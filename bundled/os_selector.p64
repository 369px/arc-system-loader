picotron cartridge // www.picotron.net
version 2

:: .info.pod
b64$LS1bW3BvZCxhdXRob3I9ImxleGFsb2ZmbGUiLGNyZWF0ZWQ9IjIwMjQtMDQtMzAgMTk6MDk6
MzUiLGljb249dXNlcmRhdGEoInU4IiwxNiwxNiwiMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMTAxMDEwMTAxMDEwMTAxMDEwMDAwMDAwMDAwMDAwMTA3MDcwNzA3MDcwNzA3
MDcwNzAxMDAwMDAwMDAwMTA3MGQwZDBkMGQwZDBkMGQwZDBkMDcwMTAwMDAwMTA3MGQwZDA3MDcw
NzA3MDcwNzBkMGQwZDA3MDEwMDAxMDcwZDBkMDcwNzA3MDcwNzA3MDcwZDBkMDcwMTAwMDEwNzBk
MGQwZDBkMGQwZDA3MGQwNzBkMGQwNzAxMDAwMTA3MGQwZDA3MDcwNzBkMDcwNzA3MGQwZDA3MDEw
MDAxMDcwZDBkMDcwZDA3MGQwZDBkMGQwZDBkMDcwMTAwMDEwNzBkMGQwNzA3MDcwNzA3MDcwNzBk
MGQwNzAxMDAwMTA3MGQwZDBkMDcwNzA3MDcwNzA3MGQwZDA3MDEwMDAxMDYwNzBkMGQwZDBkMGQw
ZDBkMGQwZDA3MDYwMTAwMDEwNjA2MDcwNzA3MDcwNzA3MDcwNzA3MDYwNjAxMDAwMDAxMDYwNjA2
MDYwNjA2MDYwNjA2MDYwNjAxMDAwMDAwMDAwMTA2MDYwNjA2MDYwNjA2MDYwNjAxMDAwMDAwMDAw
MDAwMDEwMTAxMDEwMTAxMDEwMTAxMDAwMDAwMDAiKSxtb2RpZmllZD0iMjAyNC0wNy0wNiAxMTo0
ODozNiIsbm90ZXM9IihjKSAyMDIyLTI0IExleGFsb2ZmbGUgR2FtZXMgTExQXG4iLHN0b3JlZD0i
MjAyNC0wMy0zMCAxNTozNjo0MyIsdGl0bGU9IlBpY290cm9uIFdvcmtzdGF0aW9uIE9TIix2ZXJz
aW9uPSIwLjEuMGciXV1sejQABAAAAAMAAAAwbmls
:: apps/
:: apps/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA0LTMwIDE5OjA5OjMzIixtb2RpZmllZD0iMjAyNC0w
Ny0wNiAxMTo0ODozNiJdXWx6NAAEAAAAAwAAADBuaWw=
:: apps/procman.lua
--[[pod_format="raw",created="2024-28-16 08:28:46",modified="2024-28-16 08:28:46",revision=0]]

last_update_t = 0
plist = {}

window(200,160)

function generate_gui()
	
	local item_h = 12

	gui = create_gui()
	local w,h = get_display():width(), get_display():height()
--	w -= 20 h -= 20

	container = gui:attach{x = 0, y = 0, width = w, height = h,
		draw = function(self)
			rectfill(0,0,self.width-1,self.height-1,7)
		end
	}
	content  = container:attach{
		x = 0, y = 0, width = w, height = #plist * item_h,

		draw = function(self, msg)
			for i=1,#plist do
				print(string.format("%4d %-20s %0.3f", plist[i].id, plist[i].name, plist[i].cpu), 2, (i-1)*item_h+2, 5)
			end			
		end,
		
	}

	function content:mousewheel(msg)
		if (key("ctrl")) then
			self.x += msg.wheel_y * 16 
		else
			self.y += msg.wheel_y * 16
		end

	end

	
	container:attach_scrollbars()

end


function _init()

	generate_gui()

end

function _update()

	local x,y,b = mouse()

	local last_num = #plist
	plist = fetch"/ram/system/processes.pod"


	if (b == 0) then -- to do: allow regenerating gui while dragging an element (scrollbar in this case)
		if (last_num ~= #plist) generate_gui()
		--if (t() - last_update_t >= 0.25) generate_gui()	last_update_t = t()
	end

	gui:update_all()
	

	
end

function _draw()
	gui:draw_all()

end

on_event("request_resize", function(msg)
	generate_gui()
end)




:: apps/terminal.lua
--[[pod_format="raw",author="zep",created="2023-10-07 14:33:59",icon=userdata("u8",16,16,"00000001010101010101010101000000000001070707070707070707070100000001070d0d0d0d0d0d0d0d0d0d07010001070d0d0d0d0d0d0d0d0d0d0d0d070101070d0d0d0d07070d0d0d0d0d0d070101070d0d0d0d0d07070d0d0d0d0d070101070d0d0d0d0d0d07070d0d0d0d070101070d0d0d0d0d0d07070d0d0d0d070101070d0d0d0d0d07070d0d0d0d0d070101070d0d0d0d07070d0d0d0d0d0d070101070d0d0d0d0d0d0d0d0d0d0d0d07010106070d0d0d0d0d0d0d0d0d0d07060101060607070707070707070707060601000106060606060606060606060601000000010606060606060606060601000000000001010101010101010101000000"),modified="2024-04-23 11:46:40",notes="",revision=145,stored="2024-03-09 10:31:21",title="Terminal",version=""]]
--[[

	terminal.lua
	(c) Lexaloffle Games LLP

	-- ** terminal is also an application launcher. manages cproj / decides permissions **

	-- to consider: line entry in terminal can be a bitmap


]]


-- set preferred window size unless about to corun a program (which should be the one to create the window w/ size, icon)
-- this window size might be overwritten by env().window_attribs
if (not env().corun_program) then
	window{
		width=320,
		height=160,
		icon = userdata"[gfx]0907000707000000070000777777777770000077770000077770000077777777777[/gfx]"
	}
end



if (pwd() == "/system/apps") cd("/") -- start in root instead of location of terminal.lua


-- print to self, not to terminal that launched it!
-- env().print_to_proc_id = pid()


--- *** NO GLOBALS ***   --   don't want to collide with co-running program

local cmd=""

--local line={"picotron 0.0.1","(c) lexaloffle games 2020~2022 ",""}
local line={}
local lineh={}
local history={}
local history_pos = 1
local scroll_y = 0
local char_h = peek(0x4002)
local char_w = peek(0x4000)
local cursor_pos = 0
local disp_w, disp_h = 0, 0
local back_page = userdata("u8", 480, 270)
local last_total_text_h = 0
local max_lines = 64 -- to do: increase w/ more efficient rendering (cache variable line offsets)
local left_margin = 2

local terminal_draw 
local terminal_update

local cproj_draw, cproj_update


-- to do: perhaps cproj can be any program; -> should be "corunning_prog"
-- (or two separate concepts if need)
local running_cproj = false
local last_pauseable = -1

local _has_focus = true
on_event("gained_focus", function() _has_focus = true end)
on_event("lost_focus", function() _has_focus = false end)


--corunning coroutines

local coco = {}


function _init()
end

-- to do: string format for custom prompts?
-- for now, create a return value so that can use sedit
local function get_prompt()
	local result = "\f6"..pwd().."\f7> "
	return result -- custom prompt goes here
end


local function run_cproj_callback(func, label)
	if (type(func) ~= "function") then return end

	-- run as a coroutine (separate lua_State) so that errors don't bring terminal itself down

	coco[func] = coco[func] or cocreate(func)

	local res, err = coresume(coco[func])
	

	--if (res == 3) running_cproj = false -- 

	if (err) then
		set_draw_target() -- prevent drawing error to back page or whatever the program is drawing to
		add_line("\feRUNTIME ERROR: [callback] "..tostr(label))
		add_line(err)

		send_message(3, {event="report_error", content = "*runtime error"})
		send_message(3, {event="report_error", content = err})
		send_message(3, {event="report_error", content = debug.traceback()})

		running_cproj = false

		-- nothing haltable (esc should go straight back into code editor)
		send_message(3, {event="set_haltable_proc_id", haltable_proc_id = nil})

	end

	if (costatus(coco[func]) == "dead") coco[func] = nil


end




local function suspend_cproj()

	if (not running_cproj) return

	-- kill all audio channels
	note()

	-- copy whatever is on screen
	blit(get_display(), back_page)
	
	-- consume keypresses
	readtext(true)

	running_cproj = false

	scroll_y = 0
--	show_last_line()

	-- back to last directory that user chose
	local pwd = fetch("/ram/system/pwd.pod")
	if (pwd) then cd(pwd) end

	-- stop playing any sound  // to do: need to pause mixer so that it is resumable 
	-- play_note(0,-1,0,0,0, 0)

end



local function get_file_extension(s)

	if (type(s) ~= "string") return nil
	return s:ext()

end


local function try_multiple_extensions(prog_name)
--	printh(" - - - - trying multiple entensions for: "..tostr(prog_name))

	if (type(prog_name) ~= "string") return nil

	local res =
		--(fstat(prog_name) and prog_name and get_file_extension(prog_name)) or  --  needs extension because don't want regular folder to match
		(fstat(prog_name) and prog_name:ext() and prog_name) or  --  needs extension because don't want regular folder to match
		(fstat(prog_name..".lua") and prog_name..".lua") or
		(fstat(prog_name..".p64") and prog_name..".p64") or -- only .p64 carts can be run without specifying extension (would be overkill; reduce ambiguity)
		nil
	--printh(" - - - - - - - - -")
	return res

end


--[[
	find a program 

	look in /system/util, /system/apps, /appdata/system/util and finally current path

	to do: some kind of customisable $PATH? would be nice to avoid the need for that
]]
local function resolve_program_path(prog_name)

	local prog_name_0 = prog_name

	-- /appdata/system/util/ can be used to extend built-in apps (same pattern as other collections)
	-- update: not true, other collections (wallpapers) are replaced rather than extended by /appdata

	return
		try_multiple_extensions("/system/util/"..prog_name) or
		try_multiple_extensions("/system/apps/"..prog_name) or
		try_multiple_extensions("/appdata/system/util/"..prog_name) or
		try_multiple_extensions(prog_name) -- 0.1.0c: moved last 

end


-- assume is cproj for now
local function run_program_inside_terminal(prog_name)

	local prog_str = fetch(prog_name)

	if (not prog_str) then
		printh("** could not run "..prog_name.." **")
		return
	end

	coco = {}

	terminal_draw = _draw
	terminal_update = _update

	_draw,_update,_init = nil,nil,nil


	-- to do: need to preprocess in the same way as create_process()
	-- but don't need to inject libraries / head / mainloop (use terminal's and manage mainloop from terminal)
	local f, err = load(prog_str, "@"..prog_name, "t", _ENV)


--	printh(":: run_program_inside_terminal: "..tostr(prog_name))

	
	if (f) then

		run_cproj_callback(f, prog_name) -- to do: fix runtime error causes message written to back page
		--run_cproj_callback(_init, "_init") -- gets run from foot

		-- record callbacks and revert to terminal ones
		cproj_draw = _draw
		cproj_update = _update

		running_cproj = true

	else
		send_message(3, {event="report_error", content = "*syntax error"})
		send_message(3, {event="report_error", content = tostr(err)})

		--add_line("\fesyntax error")
		add_line("\fe"..err)
		printh(err)
		suspend_cproj()
	end

	_draw = terminal_draw
	_update = terminal_update



end


--[[

	run_program_in_new_process()

	initial pwd is always program path (even for stand-alone .lua scripts), so if planning to run
	from a different directory (e.g. /system/util), program needs to start with cd(env().path)

]]
local function run_program_in_new_process(prog_name, argv)

	local proc_id = create_process(
		prog_name, 
		{
			print_to_proc_id = pid(),  -- tell new process where to print to               
			argv = argv,
			path = pwd(), -- used by commandline programs -- cd(env().path)
			window_attribs = {show_in_workspace = true}
		}
	)

end


--[[

	run_terminal_command

	try in order:

		1. built-in commands (cd / exit etc) that can not be replaced by lua or program names
		2. programs          // can't have spaces in them
		3. lua command

	note: running a program might be in the form of a legal lua statement, but if the program
		doesn't exist, then the lua statement is never executed. e.g.

		ls = 3 -- runs list with args {"=","3"}
		xx = 3 -- assigns 3 to xx (assuming there is no program called xx)

]]

local function run_terminal_command(cmd)

	local prog_name = resolve_program_path(split(cmd," ",false)[1])

--	printh("run_terminal_command program: "..tostr(prog_name))

	local argv = split(cmd," ",false)

	-- 0-based so that 1 is first argument!
	for i=1,#argv+1 do
		argv[i-1] = argv[i]
	end

	-----
	
	if (argv[0] == "cd") then

		local result = cd(argv[1])
		if (result) then add_line(result) end -- result is an error message

	elseif (cmd == "exit") then

		exit(0)
		
	elseif (cmd == "cls") then

		set_draw_target(back_page)
		cls()
		set_draw_target()
		scroll_y = last_total_text_h

	elseif (cmd == "reset") then

		reset()

	elseif (cmd == "resume") then

		running_cproj = true
		send_message(3, {event="set_haltable_proc_id", haltable_proc_id = pid()})

	elseif (prog_name) then

		run_program_in_new_process(prog_name, argv) -- could do filename expansion etc. for arguments

	else
		-- last: try lua

		local f, err = load(cmd, nil, "t", _ENV)

		if (f) then
		
			-- run loaded lua as a coroutine
			local cor = cocreate(f)

			repeat
				set_draw_target(back_page)
				_is_terminal_command = true -- temporary hack so that print() goes to terminal. e.g. pset(100,100,8)?pget(100,100)

				local res,err = coresume(cor)
				
				set_draw_target() 
				_is_terminal_command = false
				
				if (err) then
					add_line("\feRUNTIME ERROR")
					add_line(err)
					
				end
			until (costatus ~= "running")
		else

			-- try to differenciate between syntax error /command not found

			local near_msg = "syntax error near"
			if (near_msg == sub(err, 5, 5 + #near_msg - 1)) then
				-- caused by e.g.: "foo" or "foo -a" or "foo a.png" when foo doesn't resolve to a program
				add_line "command not found"
			else
				add_line(err)
			end

		end

	end

end


-- scroll down only if needed
local function show_last_line()

	-- need to print same as will be printed so that wrapping behaves the same

	local hh = 0
	for i=1,#lineh do
		hh += lineh[i]
	end
	last_total_text_h = hh

--	last_total_text_h = #line * char_h -- assumes constant line height

	scroll_y = mid(scroll_y, last_total_text_h - disp_h + 18, last_total_text_h + char_h - 18)

end



local function clamp_scroll()

	local x, y = 0, 0
	for i=1,#line do
		x, y = print(line[i], 1000, y, 7)
	end
	last_total_text_h = y

	scroll_y = mid(0, scroll_y, last_total_text_h - (disp_h - 10 - char_h))
end



--local  -- to do: where is this being called from?
function add_line(s)
	s = tostr(s)
	if (not s) then return end

	if (#line > max_lines) then
		deli(line, 1)		
		deli(lineh, 1)
	end
	
	local xx,yy = print(s, 0, 1000, 7)
	add(line,  s)
	add(lineh, (yy or 1012) - 1000)

	show_last_line()
end


-- ** incredibly inefficient! to do: need to replace with string matching
local function find_common_prefix(s0, s1)

	if (type(s0) ~= "string") then return nil end
	if (type(s1) ~= "string") then return nil end

	if (s0 == s1) then return s0 end

	local len = 0
	while(sub(s0,1,len+1) == sub(s1,1,len+1)) do
		len = len + 1
		--printh(len)
	end

	return sub(s0,1,len)
end

--[[
	
	tab_complete_filename
	
]]
local function tab_complete_filename()

	if (cmd == "") then return end

	-- get string
	local args = split(cmd, " \"", false)  -- also split on " to allow tab-completing filenames inside strings
	local prefix = args[#args] or ""

	-- construct path prefix  -- everything (canonical path) except the filename
	local prefix = fullpath(prefix)
	if (not prefix) return -- bad path
	local pathseg = split(prefix,"/",false)
	local path_part = ""
	for i=1,#pathseg-1 do
		path_part = path_part .. "/" .. pathseg[i]
	end
	if (path_part == "") then path_part = "/" end -- canonical filename special case

	prefix = (pathseg and pathseg[#pathseg]) or "/"


	-- printh("@@@ path part: "..path_part.." pwd:"..pwd())
	local files = ls(path_part)

	if (not files) return

	-- find matches

	local segment = nil
	local matches = 0
	local single_filename = nil

	for i=1,#files do
		--printh(prefix.." :: "..files[i])
		if (sub(files[i], 1, #prefix) == prefix) then
			matches = matches + 1
			local candidate = sub(files[i], #prefix + 1) -- remainder

			-- set segment to starting sequence common to candidate and segment
			segment = segment and find_common_prefix(candidate, segment) or candidate
			single_filename = path_part.."/"..files[i] -- used when single match is found
		end
	end

	if (segment) then
		cmd = cmd .. segment
		cursor_pos = cursor_pos + #segment
	end

	-- show files if >= 2
	if (matches > 1) then
		add_line("-- "..matches.." matching files --")
		for i=1,#files do
			if (sub(files[i], 1, #prefix) == prefix) then
				add_line(files[i])
			end
		end
	elseif single_filename and fstat(single_filename) == "folder" then
		-- trailing slash when a single match is a folder
		-- for folders with an extension, need to already match the full name;
		--> press tab once for foo.p64 and once more for foo.p64/)
		-- the vast majority of the time, user wants to refer to the cart itself
		if not single_filename:ext() or prefix == sub(cmd,-#prefix) 
		then
			cmd ..= "/"
			cursor_pos += 1
		end
	end

end


local tv_frames = 
{	[0] =
	userdata"[gfx]0907000707000000070000777777777770000077770070077770000077777777777[/gfx]",
	userdata"[gfx]0907000707000000070000777777777770070077770707077770070077777777777[/gfx]",
	userdata"[gfx]0907000707000000070000777777777770707077770000077770707077777777777[/gfx]",
}

function _update()

	-- app is pauseable when and only when running_cproj is true and fullscreen

	if (get_display()) then
		local w,h = get_display():attribs()
		local pauseable1 = running_cproj and w == 480 and h == 270
		if (last_pauseable ~= pauseable1) then
			last_pauseable = pauseable1
			window{pauseable = last_pauseable}
		end
	end

	if (running_cproj and not cproj_update and not cproj_draw) then
		suspend_cproj()
	end

	-- while co-running program, use that update instead 
	if (running_cproj) then
		run_cproj_callback(cproj_update, "_update")
--		window{ icon = tv_frames[((t()*10)\1)%3] }
		return
	end


	if (key("ctrl")) then

		if keyp("l") then
			set_draw_target(back_page)
			cls()
			set_draw_target()
			scroll_y = last_total_text_h + 5
		end

		if keyp("v") then

			local str = get_clipboard()
			cmd = sub(cmd, 1, cursor_pos) .. str .. sub(cmd, cursor_pos+1)
			cursor_pos = cursor_pos + #str

		end

		if keyp("c") then

			set_clipboard(cmd)
			
		end

		if keyp("x") then

			set_clipboard(cmd)
			cmd = ""
			cursor_pos = 0
			
		end

		if (keyp("e")) cursor_pos = #cmd

		-- clear text intput queue; don't let anything else pass through
		-- readtext(true) -- 0.1.0f: wrong! ctrl sometimes used for text entry (altgr), and anyway ctrl-* shouldn't ever produce textinput event
	end


	while (peektext()) do
		local k = readtext()

		-- insert at cursor

		cmd = sub(cmd, 1, cursor_pos) .. k .. sub(cmd, cursor_pos+1)

		cursor_pos = cursor_pos + 1
	end

	if (keyp("tab")) then
		tab_complete_filename();
	end

	if (keyp("up")) then
		history[history_pos] = cmd
		history_pos = mid(1, history_pos-1, #history	)
		cmd = history[history_pos]
		cursor_pos = #cmd
	end

	if (keyp("down")) then
		history[history_pos] = cmd
		history_pos = mid(1, history_pos+1, #history)
		cmd = history[history_pos]
		cursor_pos = #cmd
	end

	if (keyp("left")) then
		cursor_pos = mid(0, cursor_pos - 1, #cmd)
	end

	if (keyp("right")) then
		cursor_pos = mid(0, cursor_pos + 1, #cmd)
	end

	if (keyp("home") or (key("ctrl") and keyp("a"))) cursor_pos = 0
	if (keyp("end")) cursor_pos = #cmd


	if (keyp("enter")) then

		add_line(get_prompt()..cmd)

		-- execute the command

		run_terminal_command(cmd)
		show_last_line()


		if (history[#history] == "") then 
			history[#history] = cmd
		else
			add(history, cmd)
			store("/ram/system/history.pod", history)
			store("/ram/system/pwd.pod", pwd()) 
		end

		history_pos = #history+1

		
		cmd = ""
		cursor_pos = #cmd -- cursor at end of command

	end

	if (keyp("backspace") and #cmd > 0) then
		cmd = sub(cmd, 1, max(0,cursor_pos-1))..sub(cmd, cursor_pos+1)
		cursor_pos = mid(0, cursor_pos - 1, #cmd)
	end

	if (keyp("delete") or (key("ctrl") and keyp("d"))) then
		cmd = sub(cmd, 1, max(0,cursor_pos))..sub(cmd, cursor_pos+2)
	end


end


function _draw()

	local disp = get_display()
	disp_w, disp_h = disp:width(), disp:height()

--	printh("terminal draw "..pod{disp_w, disp_h})

	if (running_cproj) then
		run_cproj_callback(cproj_draw, "_draw")
	else
		camera()
		clip()
	end

	--set_draw_target() -- commented to make debugging easier

	if (not running_cproj) then
		cls()
		blit(back_page, nil, 0, 0, 0, 0, 480, 270)
	end


	-- experiment: run painto / dots3d in terminal
--[[
	if (running_proc_id) then
		_blit_process_video(running_proc_id, 0, 0)
	end
]]


	--scroll_y = mid(0, scroll_y, #line * char_h - disp_h)

	

	--printh("disp_h: "..disp_h.." scroll_y: "..scroll_y.." max: "..(#line * char_h - disp_h))

	local function draw_text_masked(str, x, y, col)

		-- to do: how to allow colour codes?

		for yy=y-1,y+1 do
 			for xx=x-1,x+1 do
				print(str,xx, yy, 32)
			end
		end

		return print(str, x, y, col)
	end

	if (not running_cproj) then
		
		local x = left_margin
		local y = 7 - scroll_y

		local y0 = y

		-- to do: could cache wrapped strings
		-- and/or add a picotron-specific p8scii address for rhs wrap
		--local wrap_prefix = "\006r"..chr(ord("a") + max(6, disp_w \ 4 - 10))
		local wrap_prefix = ""
		
		poke(0x5f36, (@0x5f36) | 0x80) -- turn on wrap

		for i=1,#line do
			_, y = print(line[i], x, y, 7)
		end

		last_total_text_h = y - y0

		-- poke(0x5f36, (@0x5f36) | 0x80) -- turn on wrap

		camera()
		print(wrap_prefix..get_prompt()..cmd.."\0", x, y, 7)

		print(wrap_prefix..get_prompt()..sub(cmd,1,cursor_pos).."\0", x, y, 7)

		local cx, cy = peek4(0x54f0, 2)
		if (cx > disp_w - peek(0x4000)) cx,cy = peek4(0x54f8), cy + peek(0x4002) -- where next character is (probably) going to be after warpping

		-- show cursor when window is active
		if (_has_focus) then
			if (time()%1 < .5) then
				rectfill(cx, cy, cx+char_w-1, cy+char_h-4, 14)
			end
		end

	end

end

on_event("print", function(msg)


	add_line(msg.content)	

end)



-- window manager can tell guest program to halt
-- (usually by pressing escape)
on_event("halt", function(msg)
	if (running_cproj) then
		suspend_cproj()
		
	end
end)



scroll_y = 0

-- happens when open terminal with ctrl-r
if (env().corun_program) then
	run_program_inside_terminal(env().corun_program)

	local history1 = fetch("/ram/system/history.pod")
	if (type(history1) == "table") history = history1
	history_pos = #history + 1

	scroll_y = 0
end


-- process events like this because corunning program might have own handlers
-- (only one handler per event -- see event.lua)
-- update: have multiple events per subscriber now; can keep _subscribe_to_events out of userspace (extraneous)
--[[
subscribe_to_events(function(msg)

	-- ignore all events while running cproj
	if (running_cproj) then return end

	if (msg.event == "mousewheel") then
		scroll_y = scroll_y - msg.wheel_y * char_h * 2
	end

end)

]]

on_event("mousewheel", function(msg)
	scroll_y = scroll_y - msg.wheel_y * char_h * 2
end)


on_event("reload_src", function(msg)

	-- security: only accept from window manager
	if (msg._from ~= 3) then
		return
	end

	local prog_name = msg.working_file -- env().corun_program
	local prog_str = fetch(prog_name)

	local f = load(prog_str, "@"..prog_name, "t", _ENV)

	if (f) then
		f()
	else
		-- to do: how to return error?
	end


end)


on_event("resize", function(msg)
	show_last_line()
end)

:: apps/test.lua
function _init()
    start = time()
end

function _draw()
    cls(5)
    print("Hello world", 0, 0, 7)
end

function _update()
    if time() - start > 10 then
        store_metadata("/systems", {pass=true, system="picotron"})
        send_message(2, {event="reboot"})
        exit()
    end
end
:: demos/
:: demos/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA0LTMwIDE5OjA5OjMzIixtb2RpZmllZD0iMjAyNC0w
Ny0wNiAxMTo0ODozNiJdXWx6NAAEAAAAAwAAADBuaWw=
:: fonts/
:: fonts/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA0LTMwIDE5OjA5OjMzIixtb2RpZmllZD0iMjAyNC0w
Ny0wNiAxMTo0ODozNiJdXWx6NAAEAAAAAwAAADBuaWw=
:: fonts/lil.font
b64$LS1bW3BvZF1ddXNlcmRhdGEoInU4IiwyMDQ4LCJoZXg6MDUwYTBiMDAwMDAzMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDEwMDAwMDAwMDAwMDA3MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwNzAwMDEw
MDAwMDAwMDExMDAwMDAwMDAwMDAwMDAwMDA3MDAwMTcwMDAwMDAwMDEwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDNmM2YzZjNmM2YzZjNmMDAwMDAwM2YzZjNmMDAwMDAwMDAwMDNmMzMzZjAwMDAwMDAw
MDAzMzBjMzMwMDAwMDAwMDAwMzMwMDMzMDAwMDAwMDAwMDMzMzMzMzAwMDAwMDAwMzAzYzNmM2Mz
MDAwMDAwMDAzMGYzZjBmMDMwMDAwM2UwNjA2MDYwNjAwMDAwMDAwMDAzMDMwMzAzMDNlMDA2MzM2
MWMzZTA4M2UwODAwMDAwMDAwMTgwMDAwMDAwMDAwMDAwMDAwMDAwYzE4MDAwMDAwMDAwMDAwMGMw
YzAwMDAwMDBhMGEwMDAwMDAwMDAwMDQwYTA0MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDIwMjAy
MDIwMjAwMDIwMDA1MDUwMDAwMDAwMDAwMDAwMDAwMGExZjBhMWYwYTAwMDAwNDBlMDEwNjA4MDcw
NDAwMDAwOTA0MDIwOTAwMDAwMDAyMDUwMjBiMDUwYTAwMDQwNDAwMDAwMDAwMDAwMDA0MDIwMjAy
MDIwMjAyMDQwMjA0MDQwNDA0MDQwNDAyMDAwMDA1MDIwNzAyMDUwMDAwMDAwMDA0MGUwNDAwMDAw
MDAwMDAwMDAwMDAwNDAyMDAwMDAwMDAwZjAwMDAwMDAwMDAwMDAwMDAwMDAyMDAwMDA0MDQwMjAy
MDEwMTAwMDYwOTBkMGIwOTA5MDYwMDA0MDYwNDA0MDQwNDBlMDAwNjA5MDgwNDAyMDEwZjAwMDYw
OTA4MDYwODA5MDYwMDA0MDYwNTA1MGYwNDA0MDAwZjAxMDEwNzA4MDgwNzAwMDYwMTAxMDcwOTA5
MDYwMDBmMDgwODA0MDIwMjAyMDAwNjA5MDkwNjA5MDkwNjAwMDYwOTA5MGUwODA4MDYwMDAwMDAw
MDAyMDAwMjAwMDAwMDAwMDAwNDAwMDQwMjAwMDAwMDA0MDIwMTAyMDQwMDAwMDAwMDBmMDAwZjAw
MDAwMDAwMDIwNDA4MDQwMjAwMDYwOTA4MDQwMjAwMDIwMDAwMGUwOTBkMGQwMTBlMDAwNjA5MDkw
ZjA5MDkwOTAwMDcwOTA5MDcwOTA5MDcwMDA2MDkwMTAxMDEwOTA2MDAwNzA5MDkwOTA5MDkwNzAw
MGYwMTAxMDcwMTAxMGYwMDBmMDEwMTA3MDEwMTAxMDAwZTAxMDEwZDA5MDkwZTAwMDkwOTA5MGYw
OTA5MDkwMDA3MDIwMjAyMDIwMjA3MDAwZTA4MDgwODA4MDkwNjAwMDkwOTA1MDMwNTA5MDkwMDAx
MDEwMTAxMDEwMTBmMDAxMTFiMTUxNTExMTExMTAwMDkwYjBkMDkwOTA5MDkwMDA2MDkwOTA5MDkw
OTA2MDAwNzA5MDkwNzAxMDEwMTAwMDYwOTA5MDkwOTBiMDYwYzA3MDkwOTA3MDkwOTA5MDAwNjA5
MDEwNjA4MDkwNjAwMWYwNDA0MDQwNDA0MDQwMDA5MDkwOTA5MDkwOTBlMDAwOTA5MDkwOTA5MDUw
MzAwMTExMTExMTUxNTFiMTEwMDA5MDkwOTA2MDkwOTA5MDAwOTA5MDkwZTA4MDgwNzAwMGYwODA0
MDIwMTAxMGYwMDA3MDEwMTAxMDEwMTAxMDcwMDAxMDEwMjAyMDQwNDAwMGUwODA4MDgwODA4MDgw
ZTAyMDUwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwZjAwMDIwNDAwMDAwMDAwMDAwMDAwMDAwNjA4
MGUwOTBlMDAwMTAxMDcwOTA5MDkwNzAwMDAwMDBlMDEwMTAxMGUwMDA4MDgwZTA5MDkwOTBlMDAw
MDAwMDYwOTBmMDEwZTAwMGMwMjAyMGYwMjAyMDIwMDAwMDAwZTA5MDkwZTA4MDYwMTAxMDcwOTA5
MDkwOTAwMDIwMDAzMDIwMjAyMDcwMDA4MDAwYzA4MDgwODA5MDYwMTAxMDkwNTAzMDUwOTAwMDMw
MjAyMDIwMjAyMDYwMDAwMDAwYjE1MTUxMTExMDAwMDAwMDcwOTA5MDkwOTAwMDAwMDA2MDkwOTA5
MDYwMDAwMDAwNzA5MDkwNzAxMDEwMDAwMGUwOTA5MGUwODA4MDAwMDBkMDMwMTAxMDEwMDAwMDAw
ZTAxMDYwODA3MDAwMjAyMGYwMjAyMDIwYzAwMDAwMDA5MDkwOTA5MGUwMDAwMDAwOTA5MDkwNTAz
MDAwMDAwMTExMTE1MTUwYTAwMDAwMDA5MDkwNjA5MDkwMDAwMDAwOTA5MDkwZTA4MDYwMDAwMGYw
ODA2MDEwZjAwMDYwMjAyMDEwMjAyMDIwNjAwMDIwMjAyMDAwMjAyMDIwNjA0MDQwODA0MDQwNDA2
MDAwYTA1MDAwMDAwMDAwMDAwMDMwMzBjMGMwMDAwMDA3ZjdmN2Y3ZjdmN2Y3ZjAwNTUyYTU1MmE1
NTJhNTUwMDQxNjM3ZjVkNWQ3NzNlMDAzZTYzNjM3NzNlNDEzZTAwMTE0NDExNDQxMTQ0MTEwMDA0
MGM3YzNlMWYxODEwMDAxYzI2NWY1ZjdmM2UxYzAwMjI3NzdmN2YzZTFjMDgwMDJhMWMzNjc3MzYx
YzJhMDAxYzFjM2U1ZDFjMTQxNDAwMDgxYzNlN2YzZTJhM2EwMDNlNjc2MzY3M2U0MTNlMDAzZTdm
NWQ1ZDdmNjMzZTAwMTg3ODA4MDgwODBmMDcwMDNlNjM2YjYzM2U0MTNlMDAwODE0MmE1ZDJhMTQw
ODAwMDAwMDAwNTUwMDAwMDAwMDNlNzM2MzczM2U0MTNlMDAwODFjN2YxYzM2MjIwMDAwN2YyMjE0
MDgxNDIyN2YwMDNlNzc2MzYzM2U0MTNlMDAwMDBhMDQwMDUwMjAwMDAwMTEyYTQ0MDAxMTJhNDQw
MDNlNmI3NzZiM2U0MTNlMDA3ZjAwN2YwMDdmMDA3ZjAwNTU1NTU1NTU1NTU1NTUwMDAwN2U0MjUy
NGE0MjdlMDAwMDdlNDI1MjRhNDI3ZTAwMDA3ZTQyNTI0YTQyN2UwMDAwN2U0MjUyNGE0MjdlMDAw
MDdlNDI1MjRhNDI3ZTAwMDA3ZTQyNTI0YTQyN2UwMDAwN2U0MjUyNGE0MjdlMDAwMDdlNDI1MjRh
NDI3ZTAwMDA3ZTQyNTI0YTQyN2UwMDAwN2U0MjUyNGE0MjdlMDAwMDdlNDI1MjRhNDI3ZTAwMDA3
ZTQyNTI0YTQyN2UwMDAwN2U0MjUyNGE0MjdlMDAwMDdlNDI1MjRhNDI3ZTAwMDA3ZTQyNTI0YTQy
N2UwMDAwN2U0MjUyNGE0MjdlMDAwMDdlNDI1MjRhNDI3ZTAwMDA3ZTQyNTI0YTQyN2UwMDAwN2U0
MjUyNGE0MjdlMDAwMDdlNDI1MjRhNDI3ZTAwMDA3ZTQyNTI0YTQyN2UwMDAwN2U0MjUyNGE0Mjdl
MDAwMDdlNDI1MjRhNDI3ZTAwMDA3ZTQyNTI0YTQyN2UwMDAwN2U0MjUyNGE0MjdlMDAwMDdlNDI1
MjRhNDI3ZTAwMDA3ZTQyNTI0YTQyN2UwMDAwN2U0MjUyNGE0MjdlMDAwMDdlNDI1MjRhNDI3ZTAw
MDA3ZTQyNTI0YTQyN2UwMDAwN2U0MjUyNGE0MjdlMDAwMDdlNDI1MjRhNDI3ZTAwMDA3ZTQyNTI0
YTQyN2UwMDAwN2U0MjUyNGE0MjdlMDAwMDdlNDI1MjRhNDI3ZTAwMDA3ZTQyNTI0YTQyN2UwMDAw
N2U0MjUyNGE0MjdlMDAwMDdlNDI1MjRhNDI3ZTAwMDA3ZTQyNTI0YTQyN2UwMDAwN2U0MjUyNGE0
MjdlMDAwMDdlNDI1MjRhNDI3ZTAwMDA3ZTQyNTI0YTQyN2UwMDAwN2U0MjUyNGE0MjdlMDAwMDdl
NDI1MjRhNDI3ZTAwMDA3ZTQyNTI0YTQyN2UwMDAwN2U0MjUyNGE0MjdlMDAwMDdlNDI1MjRhNDI3
ZTAwMDA3ZTQyNTI0YTQyN2UwMDAwN2U0MjUyNGE0MjdlMDAwMDdlNDI1MjRhNDI3ZTAwMDA3ZTQy
NTI0YTQyN2UwMDAwN2U0MjUyNGE0MjdlMDAwMDdlNDI1MjRhNDI3ZTAwMDA3ZTQyNTI0YTQyN2Uw
MDAwN2U0MjUyNGE0MjdlMDAwMDdlNDI1MjRhNDI3ZTAwMDA3ZTQyNTI0YTQyN2UwMDAwN2U0MjUy
NGE0MjdlMDAwMDdlNDI1MjRhNDI3ZTAwMDA3ZTQyNTI0YTQyN2UwMDAwN2U0MjUyNGE0MjdlMDAw
MDdlNDI1MjRhNDI3ZTAwMDA3ZTQyNTI0YTQyN2UwMDAwN2U0MjUyNGE0MjdlMDAwMDdlNDI1MjRh
NDI3ZTAwMDA3ZTQyNTI0YTQyN2UwMDAwN2U0MjUyNGE0MjdlMDAwMDdlNDI1MjRhNDI3ZTAwMDA3
ZTQyNTI0YTQyN2UwMDAwN2U0MjUyNGE0MjdlMDAwMDdlNDI1MjRhNDI3ZTAwMDA3ZTQyNTI0YTQy
N2UwMDAwN2U0MjUyNGE0MjdlMDAwMDdlNDI1MjRhNDI3ZTAwMDA3ZTQyNTI0YTQyN2UwMDAwN2U0
MjUyNGE0MjdlMDAwMDdlNDI1MjRhNDI3ZTAwMDA3ZTQyNTI0YTQyN2UwMDAwN2U0MjUyNGE0Mjdl
MDAwMDdlNDI1MjRhNDI3ZTAwMDA3ZTQyNTI0YTQyN2UwMDAwN2U0MjUyNGE0MjdlMDAwMDdlNDI1
MjRhNDI3ZTAwMDA3ZTQyNTI0YTQyN2UwMDAwN2U0MjUyNGE0MjdlMDAwMDdlNDI1MjRhNDI3ZTAw
MDA3ZTQyNTI0YTQyN2UwMDAwN2U0MjUyNGE0MjdlMDAwMDdlNDI1MjRhNDI3ZTAwMDA3ZTQyNTI0
YTQyN2UwMDAwN2U0MjUyNGE0MjdlMDAwMDdlNDI1MjRhNDI3ZTAwMDA3ZTQyNTI0YTQyN2UwMDAw
N2U0MjUyNGE0MjdlMDAwMDdlNDI1MjRhNDI3ZTAwMDA3ZTQyNTI0YTQyN2UwMDAwN2U0MjUyNGE0
MjdlMDAwMDdlNDI1MjRhNDI3ZTAwMDA3ZTQyNTI0YTQyN2UwMDAwN2U0MjUyNGE0MjdlMDAwMDdl
NDI1MjRhNDI3ZTAwMDA3ZTQyNTI0YTQyN2UwMCIpDQoNCg==
:: fonts/lil_mono.font
b64$LS1bW3BvZF1ddXNlcmRhdGEoInU4IiwyMDQ4LCJoZXg6MDUwYjBiMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDNmM2YzZjNmM2YzZjNmMDAwMDAwM2YzZjNmMDAwMDAwMDAwMDNmMzMzZjAwMDAwMDAw
MDAzMzBjMzMwMDAwMDAwMDAwMzMwMDMzMDAwMDAwMDAwMDMzMzMzMzAwMDAwMDAwMzAzYzNmM2Mz
MDAwMDAwMDAzMGYzZjBmMDMwMDAwM2UwNjA2MDYwNjAwMDAwMDAwMDAzMDMwMzAzMDNlMDA2MzM2
MWMzZTA4M2UwODAwMDAwMDAwMTgwMDAwMDAwMDAwMDAwMDAwMDAwYzE4MDAwMDAwMDAwMDAwMGMw
YzAwMDAwMDBhMGEwMDAwMDAwMDAwMDQwYTA0MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDIwMjAy
MDIwMjAwMDIwMDA1MDUwMDAwMDAwMDAwMDAwMDAwMGEwZjBhMGYwYTAwMDAwNDBlMDEwNjA4MDcw
NDAwMDAwOTA0MDIwOTAwMDAwMDAyMDUwMjBiMDUwYTAwMDQwNDAwMDAwMDAwMDAwMDA0MDIwMjAy
MDIwMjAyMDQwMjA0MDQwNDA0MDQwNDAyMDAwMDA1MDIwNzAyMDUwMDAwMDAwMDA0MGUwNDAwMDAw
MDAwMDAwMDAwMDAwNDAyMDAwMDAwMDAwZjAwMDAwMDAwMDAwMDAwMDAwMDAyMDAwMDA0MDQwMjAy
MDEwMTAwMDYwOTBkMGIwOTA5MDYwMDA0MDYwNDA0MDQwNDBlMDAwNjA5MDgwNDAyMDEwZjAwMDYw
OTA4MDYwODA5MDYwMDA0MDYwNTA1MGYwNDA0MDAwZjAxMDEwNzA4MDgwNzAwMDYwMTAxMDcwOTA5
MDYwMDBmMDgwODA0MDIwMjAyMDAwNjA5MDkwNjA5MDkwNjAwMDYwOTA5MGUwODA4MDYwMDAwMDAw
MDAyMDAwMjAwMDAwMDAwMDAwNDAwMDQwMjAwMDAwMDA0MDIwMTAyMDQwMDAwMDAwMDBmMDAwZjAw
MDAwMDAwMDIwNDA4MDQwMjAwMDYwOTA4MDQwMjAwMDIwMDAwMGUwOTBkMGQwMTBlMDAwNjA5MDkw
ZjA5MDkwOTAwMDcwOTA5MDcwOTA5MDcwMDA2MDkwMTAxMDEwOTA2MDAwNzA5MDkwOTA5MDkwNzAw
MGYwMTAxMDcwMTAxMGYwMDBmMDEwMTA3MDEwMTAxMDAwZTAxMDEwZDA5MDkwZTAwMDkwOTA5MGYw
OTA5MDkwMDA3MDIwMjAyMDIwMjA3MDAwZTA4MDgwODA4MDkwNjAwMDkwOTA1MDMwNTA5MDkwMDAx
MDEwMTAxMDEwMTBmMDAwOTBmMGYwOTA5MDkwOTAwMDkwYjBkMDkwOTA5MDkwMDA2MDkwOTA5MDkw
OTA2MDAwNzA5MDkwNzAxMDEwMTAwMDYwOTA5MDkwOTBiMDYwYzA3MDkwOTA3MDkwOTA5MDAwNjA5
MDEwNjA4MDkwNjAwMGYwNDA0MDQwNDA0MDQwMDA5MDkwOTA5MDkwOTBlMDAwOTA5MDkwOTA5MDUw
MzAwMDkwOTA5MDkwZjBmMDkwMDA5MDkwOTA2MDkwOTA5MDAwOTA5MDkwZTA4MDgwNzAwMGYwODA0
MDIwMTAxMGYwMDA3MDEwMTAxMDEwMTAxMDcwMDAxMDEwMjAyMDQwNDAwMGUwODA4MDgwODA4MDgw
ZTAyMDUwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwZjAwMDIwNDAwMDAwMDAwMDAwMDAwMDAwNjA4
MGUwOTBlMDAwMTAxMDcwOTA5MDkwNzAwMDAwMDBlMDEwMTAxMGUwMDA4MDgwZTA5MDkwOTBlMDAw
MDAwMDYwOTBmMDEwZTAwMGMwMjAyMGYwMjAyMDIwMDAwMDAwZTA5MDkwZTA4MDYwMTAxMDcwOTA5
MDkwOTAwMDQwMDA2MDQwNDA0MGUwMDA4MDAwYzA4MDgwODA5MDYwMTAxMDkwNTAzMDUwOTAwMDYw
NDA0MDQwNDA0MGMwMDAwMDAwZjBmMDkwOTA5MDAwMDAwMDcwOTA5MDkwOTAwMDAwMDA2MDkwOTA5
MDYwMDAwMDAwNzA5MDkwNzAxMDEwMDAwMGUwOTA5MGUwODA4MDAwMDBkMDMwMTAxMDEwMDAwMDAw
ZTAxMDYwODA3MDAwMjAyMGYwMjAyMDIwYzAwMDAwMDA5MDkwOTA5MGUwMDAwMDAwOTA5MDkwNTAz
MDAwMDAwMDkwOTA5MGYwZjAwMDAwMDA5MDkwNjA5MDkwMDAwMDAwOTA5MDkwZTA4MDYwMDAwMGYw
ODA2MDEwZjAwMDYwMjAyMDEwMjAyMDIwNjAwMDIwMjAyMDAwMjAyMDIwNjA0MDQwODA0MDQwNDA2
MDAwYTA1MDAwMDAwMDAwMDAwMDMwMzBjMGMwMDAwMDA3ZjdmN2Y3ZjdmN2Y3ZjAwNTUyYTU1MmE1
NTJhNTUwMDQxNjM3ZjVkNWQ3NzNlMDAzZTYzNjM3NzNlNDEzZTAwMTE0NDExNDQxMTQ0MTEwMDA0
MGM3YzNlMWYxODEwMDAxYzI2NWY1ZjdmM2UxYzAwMjI3NzdmN2YzZTFjMDgwMDJhMWMzNjc3MzYx
YzJhMDAxYzFjM2U1ZDFjMTQxNDAwMDgxYzNlN2YzZTJhM2EwMDNlNjc2MzY3M2U0MTNlMDAzZTdm
NWQ1ZDdmNjMzZTAwMTg3ODA4MDgwODBmMDcwMDNlNjM2YjYzM2U0MTNlMDAwODE0MmE1ZDJhMTQw
ODAwMDAwMDAwNTUwMDAwMDAwMDNlNzM2MzczM2U0MTNlMDAwODFjN2YxYzM2MjIwMDAwN2YyMjE0
MDgxNDIyN2YwMDNlNzc2MzYzM2U0MTNlMDAwMDBhMDQwMDUwMjAwMDAwMTEyYTQ0MDAxMTJhNDQw
MDNlNmI3NzZiM2U0MTNlMDA3ZjAwN2YwMDdmMDA3ZjAwNTU1NTU1NTU1NTU1NTUwMDAwN2U0MjUy
NGE0MjdlMDAwMDdlNDI1MjRhNDI3ZTAwMDA3ZTQyNTI0YTQyN2UwMDAwN2U0MjUyNGE0MjdlMDAw
MDdlNDI1MjRhNDI3ZTAwMDA3ZTQyNTI0YTQyN2UwMDAwN2U0MjUyNGE0MjdlMDAwMDdlNDI1MjRh
NDI3ZTAwMDA3ZTQyNTI0YTQyN2UwMDAwN2U0MjUyNGE0MjdlMDAwMDdlNDI1MjRhNDI3ZTAwMDA3
ZTQyNTI0YTQyN2UwMDAwN2U0MjUyNGE0MjdlMDAwMDdlNDI1MjRhNDI3ZTAwMDA3ZTQyNTI0YTQy
N2UwMDAwN2U0MjUyNGE0MjdlMDAwMDdlNDI1MjRhNDI3ZTAwMDA3ZTQyNTI0YTQyN2UwMDAwN2U0
MjUyNGE0MjdlMDAwMDdlNDI1MjRhNDI3ZTAwMDA3ZTQyNTI0YTQyN2UwMDAwN2U0MjUyNGE0Mjdl
MDAwMDdlNDI1MjRhNDI3ZTAwMDA3ZTQyNTI0YTQyN2UwMDAwN2U0MjUyNGE0MjdlMDAwMDdlNDI1
MjRhNDI3ZTAwMDA3ZTQyNTI0YTQyN2UwMDAwN2U0MjUyNGE0MjdlMDAwMDdlNDI1MjRhNDI3ZTAw
MDA3ZTQyNTI0YTQyN2UwMDAwN2U0MjUyNGE0MjdlMDAwMDdlNDI1MjRhNDI3ZTAwMDA3ZTQyNTI0
YTQyN2UwMDAwN2U0MjUyNGE0MjdlMDAwMDdlNDI1MjRhNDI3ZTAwMDA3ZTQyNTI0YTQyN2UwMDAw
N2U0MjUyNGE0MjdlMDAwMDdlNDI1MjRhNDI3ZTAwMDA3ZTQyNTI0YTQyN2UwMDAwN2U0MjUyNGE0
MjdlMDAwMDdlNDI1MjRhNDI3ZTAwMDA3ZTQyNTI0YTQyN2UwMDAwN2U0MjUyNGE0MjdlMDAwMDdl
NDI1MjRhNDI3ZTAwMDA3ZTQyNTI0YTQyN2UwMDAwN2U0MjUyNGE0MjdlMDAwMDdlNDI1MjRhNDI3
ZTAwMDA3ZTQyNTI0YTQyN2UwMDAwN2U0MjUyNGE0MjdlMDAwMDdlNDI1MjRhNDI3ZTAwMDA3ZTQy
NTI0YTQyN2UwMDAwN2U0MjUyNGE0MjdlMDAwMDdlNDI1MjRhNDI3ZTAwMDA3ZTQyNTI0YTQyN2Uw
MDAwN2U0MjUyNGE0MjdlMDAwMDdlNDI1MjRhNDI3ZTAwMDA3ZTQyNTI0YTQyN2UwMDAwN2U0MjUy
NGE0MjdlMDAwMDdlNDI1MjRhNDI3ZTAwMDA3ZTQyNTI0YTQyN2UwMDAwN2U0MjUyNGE0MjdlMDAw
MDdlNDI1MjRhNDI3ZTAwMDA3ZTQyNTI0YTQyN2UwMDAwN2U0MjUyNGE0MjdlMDAwMDdlNDI1MjRh
NDI3ZTAwMDA3ZTQyNTI0YTQyN2UwMDAwN2U0MjUyNGE0MjdlMDAwMDdlNDI1MjRhNDI3ZTAwMDA3
ZTQyNTI0YTQyN2UwMDAwN2U0MjUyNGE0MjdlMDAwMDdlNDI1MjRhNDI3ZTAwMDA3ZTQyNTI0YTQy
N2UwMDAwN2U0MjUyNGE0MjdlMDAwMDdlNDI1MjRhNDI3ZTAwMDA3ZTQyNTI0YTQyN2UwMDAwN2U0
MjUyNGE0MjdlMDAwMDdlNDI1MjRhNDI3ZTAwMDA3ZTQyNTI0YTQyN2UwMDAwN2U0MjUyNGE0Mjdl
MDAwMDdlNDI1MjRhNDI3ZTAwMDA3ZTQyNTI0YTQyN2UwMDAwN2U0MjUyNGE0MjdlMDAwMDdlNDI1
MjRhNDI3ZTAwMDA3ZTQyNTI0YTQyN2UwMDAwN2U0MjUyNGE0MjdlMDAwMDdlNDI1MjRhNDI3ZTAw
MDA3ZTQyNTI0YTQyN2UwMDAwN2U0MjUyNGE0MjdlMDAwMDdlNDI1MjRhNDI3ZTAwMDA3ZTQyNTI0
YTQyN2UwMDAwN2U0MjUyNGE0MjdlMDAwMDdlNDI1MjRhNDI3ZTAwMDA3ZTQyNTI0YTQyN2UwMDAw
N2U0MjUyNGE0MjdlMDAwMDdlNDI1MjRhNDI3ZTAwMDA3ZTQyNTI0YTQyN2UwMDAwN2U0MjUyNGE0
MjdlMDAwMDdlNDI1MjRhNDI3ZTAwMDA3ZTQyNTI0YTQyN2UwMDAwN2U0MjUyNGE0MjdlMDAwMDdl
NDI1MjRhNDI3ZTAwMDA3ZTQyNTI0YTQyN2UwMCIpDQo=
:: fonts/p8.font
b64$LS1bW3BvZF1ddXNlcmRhdGEoInU4IiwyMDQ4LCJoZXg6MDQwODA2MDAwMDAzMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDA3MDcwNzA3MDcwMDAwMDAwMDA3MDcwNzAwMDAwMDAwMDAwNzA1MDcwMDAwMDAwMDAw
MDUwMjA1MDAwMDAwMDAwMDA1MDAwNTAwMDAwMDAwMDAwNTA1MDUwMDAwMDAwMDA0MDYwNzA2MDQw
MDAwMDAwMTAzMDcwMzAxMDAwMDAwMDcwMTAxMDEwMDAwMDAwMDAwMDQwNDA0MDcwMDAwMDAwNTA3
MDIwNzAyMDAwMDAwMDAwMDAyMDAwMDAwMDAwMDAwMDAwMDAxMDIwMDAwMDAwMDAwMDAwMzAzMDAw
MDAwMDUwNTAwMDAwMDAwMDAwMDAyMDUwMjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDIwMjAy
MDAwMjAwMDAwMDA1MDUwMDAwMDAwMDAwMDAwNTA3MDUwNzA1MDAwMDAwMDcwMzA2MDcwMjAwMDAw
MDA1MDQwMjAxMDUwMDAwMDAwMzAzMDYwNTA3MDAwMDAwMDIwMTAwMDAwMDAwMDAwMDAyMDEwMTAx
MDIwMDAwMDAwMjA0MDQwNDAyMDAwMDAwMDUwMjA3MDIwNTAwMDAwMDAwMDIwNzAyMDAwMDAwMDAw
MDAwMDAwMjAxMDAwMDAwMDAwMDA3MDAwMDAwMDAwMDAwMDAwMDAwMDIwMDAwMDAwNDAyMDIwMjAx
MDAwMDAwMDcwNTA1MDUwNzAwMDAwMDAzMDIwMjAyMDcwMDAwMDAwNzA0MDcwMTA3MDAwMDAwMDcw
NDA2MDQwNzAwMDAwMDA1MDUwNzA0MDQwMDAwMDAwNzAxMDcwNDA3MDAwMDAwMDEwMTA3MDUwNzAw
MDAwMDA3MDQwNDA0MDQwMDAwMDAwNzA1MDcwNTA3MDAwMDAwMDcwNTA3MDQwNDAwMDAwMDAwMDIw
MDAyMDAwMDAwMDAwMDAyMDAwMjAxMDAwMDAwMDQwMjAxMDIwNDAwMDAwMDAwMDcwMDA3MDAwMDAw
MDAwMTAyMDQwMjAxMDAwMDAwMDcwNDA2MDAwMjAwMDAwMDAyMDUwNTAxMDYwMDAwMDAwMDA2MDUw
NzA1MDAwMDAwMDAwMzAzMDUwNzAwMDAwMDAwMDYwMTAxMDYwMDAwMDAwMDAzMDUwNTAzMDAwMDAw
MDAwNzAzMDEwNjAwMDAwMDAwMDcwMzAxMDEwMDAwMDAwMDA2MDEwNTA3MDAwMDAwMDAwNTA1MDcw
NTAwMDAwMDAwMDcwMjAyMDcwMDAwMDAwMDA3MDIwMjAzMDAwMDAwMDAwNTAzMDUwNTAwMDAwMDAw
MDEwMTAxMDYwMDAwMDAwMDA3MDcwNTA1MDAwMDAwMDAwMzA1MDUwNTAwMDAwMDAwMDYwNTA1MDMw
MDAwMDAwMDA2MDUwNzAxMDAwMDAwMDAwMjA1MDMwNjAwMDAwMDAwMDMwNTAzMDUwMDAwMDAwMDA2
MDEwNDAzMDAwMDAwMDAwNzAyMDIwMjAwMDAwMDAwMDUwNTA1MDYwMDAwMDAwMDA1MDUwNzAyMDAw
MDAwMDAwNTA1MDcwNzAwMDAwMDAwMDUwMjAyMDUwMDAwMDAwMDA1MDcwNDAzMDAwMDAwMDAwNzA0
MDEwNzAwMDAwMDAzMDEwMTAxMDMwMDAwMDAwMTAyMDIwMjA0MDAwMDAwMDYwNDA0MDQwNjAwMDAw
MDAyMDUwMDAwMDAwMDAwMDAwMDAwMDAwMDA3MDAwMDAwMDIwNDAwMDAwMDAwMDAwMDA3MDUwNzA1
MDUwMDAwMDAwNzA1MDMwNTA3MDAwMDAwMDYwMTAxMDEwNjAwMDAwMDAzMDUwNTA1MDcwMDAwMDAw
NzAxMDMwMTA3MDAwMDAwMDcwMTAzMDEwMTAwMDAwMDA2MDEwMTA1MDcwMDAwMDAwNTA1MDcwNTA1
MDAwMDAwMDcwMjAyMDIwNzAwMDAwMDA3MDIwMjAyMDMwMDAwMDAwNTA1MDMwNTA1MDAwMDAwMDEw
MTAxMDEwNzAwMDAwMDA3MDcwNTA1MDUwMDAwMDAwMzA1MDUwNTA1MDAwMDAwMDYwNTA1MDUwMzAw
MDAwMDA3MDUwNzAxMDEwMDAwMDAwMjA1MDUwMzA2MDAwMDAwMDcwNTAzMDUwNTAwMDAwMDA2MDEw
NzA0MDMwMDAwMDAwNzAyMDIwMjAyMDAwMDAwMDUwNTA1MDUwNjAwMDAwMDA1MDUwNTA3MDIwMDAw
MDAwNTA1MDUwNzA3MDAwMDAwMDUwNTAyMDUwNTAwMDAwMDA1MDUwNzA0MDcwMDAwMDAwNzA0MDIw
MTA3MDAwMDAwMDYwMjAzMDIwNjAwMDAwMDAyMDIwMjAyMDIwMDAwMDAwMzAyMDYwMjAzMDAwMDAw
MDAwNDA3MDEwMDAwMDAwMDAwMDIwNTAyMDAwMDAwMDA3ZjdmN2Y3ZjdmMDAwMDAwNTUyYTU1MmE1
NTAwMDAwMDQxN2Y1ZDVkM2UwMDAwMDAzZTYzNjM3NzNlMDAwMDAwMTE0NDExNDQxMTAwMDAwMDA0
M2MxYzFlMTAwMDAwMDAxYzJlM2UzZTFjMDAwMDAwMzYzZTNlMWMwODAwMDAwMDFjMzY3NzM2MWMw
MDAwMDAxYzFjM2UxYzE0MDAwMDAwMWMzZTdmMmEzYTAwMDAwMDNlNjc2MzY3M2UwMDAwMDA3ZjVk
N2Y0MTdmMDAwMDAwMzgwODA4MGUwZTAwMDAwMDNlNjM2YjYzM2UwMDAwMDAwODFjM2UxYzA4MDAw
MDAwMDAwMDU1MDAwMDAwMDAwMDNlNzM2MzczM2UwMDAwMDAwODFjN2YzZTIyMDAwMDAwM2UxYzA4
MWMzZTAwMDAwMDNlNzc2MzYzM2UwMDAwMDAwMDA1NTIyMDAwMDAwMDAwMDAxMTJhNDQwMDAwMDAw
MDNlNmI3NzZiM2UwMDAwMDA3ZjAwN2YwMDdmMDAwMDAwNTU1NTU1NTU1NTAwMDAwMDBlMDQxZTJk
MjYwMDAwMDAxMTIxMjEyNTAyMDAwMDAwMGMxZTIwMjAxYzAwMDAwMDA4MWUwODI0MWEwMDAwMDA0
ZTA0M2U0NTI2MDAwMDAwMjI1ZjEyMTIwYTAwMDAwMDFlMDgzYzExMDYwMDAwMDAxMDBjMDIwYzEw
MDAwMDAwMjI3YTIyMjIxMjAwMDAwMDFlMjAwMDAyM2MwMDAwMDAwODNjMTAwMjBjMDAwMDAwMDIw
MjAyMjIxYzAwMDAwMDA4M2UwODBjMDgwMDAwMDAxMjNmMTIwMjFjMDAwMDAwM2MxMDdlMDQzODAw
MDAwMDAyMDczMjAyMzIwMDAwMDAwZjAyMGUxMDFjMDAwMDAwM2U0MDQwMjAxODAwMDAwMDNlMTAw
ODA4MTAwMDAwMDAwODM4MDQwMjNjMDAwMDAwMzIwNzEyNzgxODAwMDAwMDdhNDIwMjBhNzIwMDAw
MDAwOTNlNGI2ZDY2MDAwMDAwMWEyNzIyNzMzMjAwMDAwMDNjNGE0OTQ5NDYwMDAwMDAxMjNhMTIz
YTFhMDAwMDAwMjM2MjIyMjIxYzAwMDAwMDBjMDAwODJhNGQwMDAwMDAwMDBjMTIyMTQwMDAwMDAw
N2Q3OTExM2Q1ZDAwMDAwMDNlM2MwODFlMmUwMDAwMDAwNjI0N2UyNjEwMDAwMDAwMjQ0ZTA0NDYz
YzAwMDAwMDBhM2M1YTQ2MzAwMDAwMDAxZTA0MWU0NDM4MDAwMDAwMTQzZTI0MDgwODAwMDAwMDNh
NTY1MjMwMDgwMDAwMDAwNDFjMDQxZTA2MDAwMDAwMDgwMjNlMjAxYzAwMDAwMDIyMjIyNjIwMTgw
MDAwMDAzZTE4MjQ3MjMwMDAwMDAwMDQzNjJjMjY2NDAwMDAwMDNlMTgyNDQyMzAwMDAwMDAxYTI3
MjIyMzEyMDAwMDAwMGU2NDFjMjg3ODAwMDAwMDA0MDIwNjJiMTkwMDAwMDAwMDAwMGUxMDA4MDAw
MDAwMDAwYTFmMTIwNDAwMDAwMDAwMDQwZjE1MGQwMDAwMDAwMDA0MGMwNjBlMDAwMDAwM2UyMDE0
MDQwMjAwMDAwMDMwMDgwZTA4MDgwMDAwMDAwODNlMjIyMDE4MDAwMDAwM2UwODA4MDgzZTAwMDAw
MDEwN2UxODE0MTIwMDAwMDAwNDNlMjQyMjMyMDAwMDAwMDgzZTA4M2UwODAwMDAwMDNjMjQyMjEw
MDgwMDAwMDAwNDdjMTIxMDA4MDAwMDAwM2UyMDIwMjAzZTAwMDAwMDI0N2UyNDIwMTAwMDAwMDAw
NjIwMjYxMDBjMDAwMDAwM2UyMDEwMTgyNjAwMDAwMDA0M2UyNDA0MzgwMDAwMDAyMjI0MjAxMDBj
MDAwMDAwM2UyMjJkMzAwYzAwMDAwMDFjMDgzZTA4MDQwMDAwMDAyYTJhMjAxMDBjMDAwMDAwMWMw
MDNlMDgwNDAwMDAwMDA0MDQxYzI0MDQwMDAwMDAwODNlMDgwODA0MDAwMDAwMDAxYzAwMDAzZTAw
MDAwMDNlMjAyODEwMmMwMDAwMDAwODNlMzA1ZTA4MDAwMDAwMjAyMDIwMTAwZTAwMDAwMDEwMjQy
NDQ0NDIwMDAwMDAwMjFlMDIwMjFjMDAwMDAwM2UyMDIwMTAwYzAwMDAwMDBjMTIyMTQwMDAwMDAw
MDAwODNlMDgyYTJhMDAwMDAwM2UyMDE0MDgxMDAwMDAwMDNjMDAzZTAwMWUwMDAwMDAwODA0MjQ0
MjdlMDAwMDAwNDAyODEwNjgwNjAwMDAwMDFlMDQxZTA0M2MwMDAwMDAwNDNlMjQwNDA0MDAwMDAw
MWMxMDEwMTAzZTAwMDAwMDFlMTAxZTEwMWUwMDAwMDAzZTAwM2UyMDE4MDAwMDAwMjQyNDI0MjAx
MDAwMDAwMDE0MTQxNDU0MzIwMDAwMDAwMjAyMjIxMjBlMDAwMDAwM2UyMjIyMjIzZTAwMDAwMDNl
MjIyMDEwMGMwMDAwMDAzZTIwM2MyMDE4MDAwMDAwMDYyMDIwMTAwZTAwMDAwMDAwMTUxMDA4MDYw
MDAwMDAwMDA0MWUxNDA0MDAwMDAwMDAwMDBjMDgxZTAwMDAwMDAwMWMxODEwMWMwMDAwMDAwODA0
NjMxMDA4MDAwMDAwMDgxMDYzMDQwODAwMDAwMCIpDQoNCg==
:: lib/
:: lib/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA0LTMwIDE5OjA5OjMzIixtb2RpZmllZD0iMjAyNC0w
Ny0wNiAxMTo0ODozNiJdXWx6NAAEAAAAAwAAADBuaWw=
:: lib/api.lua
--[[pod_format="raw",created="2024-03-24 14:56:58",modified="2024-03-24 14:56:58",revision=0]]


local _fcopy = _fcopy
local _fdelete = _fdelete


-- some of these should be moved into c

function all(c) if (c == nil or #c == 0) then return function() end end
 	local i=1
 	local li=nil
 	return function()
 		if (c[i] == li) then i=i+1 end
 		while(c[i]==nil and i <= #c) do i=i+1 end
 		li=c[i]
 		return li
 	end
end


function foreach(c,_f)
	for i in all(c) do _f(i) end 
end


function sub(str, ...)
	if (type(str) ~= "string") then return end -- pico-8 behaviour
	return string.sub(str, ...)
end



-- pico-8 compatibility (but as_hex works differently; no fractional part)
-- weird to have 2 slightly different ways to write the same thing, but tostr(foo,1) is too handy for getting hex numbers
--> jettison tostring, tonumber for now! can add back later if need

local _tonumber = tonumber
local _tostring = tostring

function tostr(val, as_hex)
	if (as_hex) then
		return string.format("0x%x", val)
	else
		return _tostring(val)
	end
end

-- pico-8 compatibility
function tonum(...)
	return _tonumber(...)
end


function abs(a)
	if (type(a) != "number") a = 0
	return a >= 0 and a or -a
end

function sgn(a)
	if (type(a) != "number") a = 0
	return a >= 0 and 1 or -1
end

function max(a,b)
	if (type(a) != "number") a = 0
	if (type(b) != "number") b = 0
	return a > b and a or b
end

function min(a,b)
	if (type(a) != "number") a = 0
	if (type(b) != "number") b = 0
	return a < b and a or b
end

unpack = table.unpack
pack = table.pack

function mid(a,b,c)
	b = b or 0
	c = c or 0
	if a < b then
		return a < c and min(b,c) or min(a,b)
	else
		return b < c and min(a,c) or min(a,b)
	end
end

-- keep local copies so that they can be used internally, even if rm and/or rm are renamed in userland
local _cp = nil
local _rm = nil

_rm = function(f0, flags, depth)

	flags = flags or 0x0
	depth = depth or 0

	local attribs, size, origin = fstat(f0)

	if (not attribs) then
		-- does not exist
		return
	end

	if (attribs == "folder") then

		-- folder: first delete each entry using this function
		if (not origin) then -- dont recurse into origin!
			local l = ls(f0)
			for k,fn in pairs(l) do
				_rm(f0.."/"..fn, flags, depth+1)
			end
		end
		-- remove metadata (not listed)
		_rm(f0.."/.info.pod", flags, depth)

		-- flag 0x1: remove everything except the folder itself (used by cp when copying folder -> folder)
		-- for two reasons:

		-- leave top level folder empty but stripped of metadata; used by cp to preserve .p64 that are folders on host
		if (flags & 0x1 > 0 and depth == 0) then
			return
		end

	end


	-- delete single file / now-empty folder
	return _fdelete(f0)
end

function rm(f0)
	return _rm(f0, 0, 0)
end




--[[	
	cp(src, dest)
	if dest exists, is deleted!  (cp util / filenav copy operations can do safety)

]]
function _cp(f0, f1, moving)

	f0 = fullpath(f0)
	f1 = fullpath(f1)

	if (not f0)   return "could not resolve source path"
	if (not f1)   return "could not resolve destination path"
	if (f0 == f1) return "can not copy over self"

	local f0_type = fstat(f0)
	local f1_type = fstat(f1)

	if (not f0_type) then
		-- print(tostr(f0).." does not exist") 
		return
	end

	-- explicitly delete in case is a folder -- want to make sure contents are removed
	-- to do: should be an internal detail of delete_path()?
	-- 0.1.0e: 0x1 to keep dest as a folder when copying a folder over a folder
	-- (e.g. dest.p64/ is a folder on host; preferable to keep it that way for some workflows)
	if (f1_type) _rm(f1, f0_type == "folder" and 0x1 or 0x0) 

	-- folder: recurse
	if (f0_type == "folder") then

		-- 0.1.0c: can not copy inside itself   "cp /ram/cart /ram/cart/foo" or "cp /ram/cart/foo /ram/cart" 
		local minlen = min(#f0, #f1)
		if (sub(f1, 1, minlen) == sub(f0, 1, minlen)) then
			return "can not copy folder inside self" -- 2 different meanings!
		end

		-- get a cleared out root folder with empty metadata
		-- (this allows host folders to stay as folders even when named with .p64 extension -- some people use that workflow)
		mkdir(f1)

		-- copy each item (could also be a folder)

		local l = ls(f0)
		for k,fn in pairs(l) do
			local res = _cp(f0.."/"..fn, f1.."/"..fn, moving)
			if (res) return res
		end

		-- copy metadata over if it exists (ls does not return dotfiles)
		-- 0.1.0f: also set initial modified / created values 

		local meta = fetch_metadata(f0) or {}

		-- also set date [and created when not being used by mv())
		meta.modified = date()
		if (not moving) meta.created = meta.created or meta.modified -- don't want to clobber .created when moving

		-- store it back at target location
		store_metadata(f1, meta)

		return
	end

	-- binary copy single file
	_fcopy(f0, f1)

end

--[[

	placeholder mv
	to do: safety! efficiency! errors! semantics!

	currently moving a mount copies it into a regular file and removes the mount;
	should be possible to rename/move mounts around?
	
]]
function mv(src, dest)

	if (fullpath(src) == fullpath(dest)) return
	local res = _cp(src, dest, true)
	if (res) return res -- copy failed -- return before removing original!
	_rm(src)
end

function cp(src, dest)
	_cp(src, dest) -- don't expose the moving parameter; is an internal detail
end




:: lib/app_menu.lua
--[[

	menuitem{
		id = 3,                   -- unique identifier. integer ids are used to sort items (otherwise in order added)
		label = "Foo",            -- user-facing label
		shortcut = "CTRL-O",      -- drawn right justified in menu
		greyed = false,           -- greyed out item (use for ---)
		action = function(b) end  -- callback on select -- b is the button pressed (left / right)
	}

]]

local _menu = {}

function menuitem(m, a, b)

	-- legacy pico-8 calling format
	if (a) then
		m = {
			id = m, -- integer position
			label = a,
			action = b
		}
	end

	_menu[m.id] = m

	send_message(3, {event = "app_menu_item", attribs = m})

end


-- default hooks
on_event("menu_action", function(msg)
	local item = _menu[msg.id]
	if (item and item.action) then
		item.action(msg.b)
	end
end)


:: lib/events.lua
--[[

	events.lua
	part of head.lua

]]

do

	local _read_message = _read_message


	local message_hooks = {}
	local message_subscriber = {}
	local mouse_x = 0
	local mouse_y = 0
	local mouse_b = 0
	local wheel_x = 0
	local wheel_y = 0
	local locked_dx = 0
	local locked_dy = 0



	local ident = math.random()

	local key_state={}
	local last_key_state={}
	local repeat_key_press_t={}

	local frame_keypressed_result={}
	local scancode_blocked = {} -- deleteme -- not used or needed   //  update: maybe do? ancient sticky keys problem

	function mouse()
		return mouse_x, mouse_y, mouse_b, wheel_x, wheel_y -- wheel
	end

	--[[
		do_lock bits
			0x1 enable mouse (P8)       //  ignored; always enabled!
			0x2 mouse_btn    (P8)       //  mouse buttons trigger player buttons (not implemented)
			0x4 mouse lock   (P8)       //  lock cursor to picotron host window when set
			0x8 auto-unlock on mouseup  //  common pattern for dials (observed by gui.lua)
	]]
	function mouselock(do_lock, event_sensitivity, move_sensitivity)
		if (event_sensitivity) poke(0x5f28, mid(0,event_sensitivity*64, 255)) -- controls scale of deltas (64 == 1 per picotron pixel)
		if (move_sensitivity)  poke(0x5f29, mid(0,move_sensitivity *64, 255)) -- controls speed of cursor while locked (64 == 1 per host pixel)
		if (type(do_lock) == "number") poke(0x5f2d, do_lock)
		if (do_lock == true)  poke(0x5f2d, peek(0x5f2d) | 0x4)  -- don't alter flags, just set the lock bit
		if (do_lock == false) poke(0x5f2d, peek(0x5f2d) & ~0x4) -- likewise
		return locked_dx, locked_dy -- wheel, locked is since last frame
	end



	--[[

		// 3 levels of keyboard mapping:

		1. raw key names  //  key("a")
	
			"a" means the key to the right of capslock
			defaults to US layout, patched by /appdata/system/scancodes.pod
			example: tracker music input -- layout should physically match a piano

		2. mapped key names  // key("a")

			"a" means the key with "a" written on it
			e.g. the key to the right of tab on a typical azerty keyboard
			defaults to OS mapping, patched by /appdata/system/keycodes.pod
			example: key"f" to flip sprite horiontally should respond to the key with "f" written on it

		3. text entry  // readtext()

			"a" is a unicode string triggered by pressing a when shift is not held (-> SDL_TEXTINPUT event)
			ctrl-a or enter does not trigger a textinput event; need to read with mapped key names using key() + keyp()
			defaults to host OS keyboard layout and text entry method; not configurable inside Picotron [yet?]
	]]
	

	-- physical key names
	-- include everything from sdl -- might want to make a POS terminal; but later could define a "commonly supported" subset
	local scancode_name = {
	"", "", "", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", 
	"m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "1", "2", 
	"3", "4", "5", "6", "7", "8", "9", "0", "enter", "escape", "backspace", "tab", "space", "-", "=", "[", 
	"]", "\\", "#", ";", "'", "`", ",", ".", "/", "capslock", "f1", "f2", "f3", "f4", "f5", "f6", 
	"f7", "f8", "f9", "f10", "f11", "f12", "printscreen", "scrolllock", "pause", "insert", "home", "pageup", "delete", "end", "pagedown", "right", 
	"left", "down", "up", "numlock", "kp /", "kp *", "kp -", "kp +", "kp enter", "kp 1", "kp 2", "kp 3", "kp 4", "kp 5", "kp 6", "kp 7", 
	"kp 8", "kp 9", "kp 0", "kp .", "<", "menu0", "", "kp =", "", "", "", "", "", "", "", "f20", 
	"f21", "f22", "f23", "f24", "execute", "help", "menu1", "select", "stop0", "again", "undo", "", "", "", "find", "", 
	"", "", "", "", "", "kp ,", "kp = (as400)", "", "", "", "", "", "", "", "", "", 
	"", "", "", "", "", "", "", "", "", "alterase", "right alt", "stop1", "clear", "prior", "return", "separator", 
	"out", "oper", "clear / again", "crsel", "exsel", "", "", "", "", "", "", "", "", "", "", "", 
	"kp 00", "kp 000", "thousandsseparator", "decimalseparator", "currencyunit", "currencysubunit", "kp (", "kp )", "kp {", "kp }", "kp tab", 
		"kp backspace", "kp a", "kp b", "kp c", "kp d", 
	"kp e", "kp f", "kp xor", "kp ^", "kp %", "kp <", "kp >", "kp &", "kp &&", "kp |", "kp ||", "kp :", "kp #", "kp space", "kp @", "kp !", 
	"kp memstore", "kp memrecall", "kp memclear", "kp memadd", "kp memsubtract", "kp memmultiply", "kp memdivide", "kp +/-", "kp clear", 
		"kp clearentry", "kp binary", "kp octal", "kp decimal", "kp hexadecimal", "", "", 
	"lctrl", "lshift", "lalt", "lcommand", "rctrl", "rshift", "ralt", "rcommand"
	}



	local raw_name_to_scancode = {}

	for i=1,#scancode_name do
		local name = scancode_name[i]
		if (name ~= "") raw_name_to_scancode[name] = i
	end

	-- patch with /settings/scancodes
	-- e.g. store("/appdata/system/scancodes.pod", {lctrl=57}) to use capslock as lctrl

	local patch_scancodes = fetch"/appdata/system/scancodes.pod"
	if type(patch_scancodes) == "table" then
		for k,v in pairs(patch_scancodes) do
			raw_name_to_scancode[k] = v
		end
	end

	-------------------------------------------------------------------------
	--	name_to_scancodes:  default host OS default mapping
	--  each entry is a table of one or more scancodes that trigger it
	-------------------------------------------------------------------------

	local name_to_scancodes = {}

	for i=1,255 do
		local mapped_name = stat(302, i)
		if (mapped_name and mapped_name ~= "") then
			-- temporary hack -- convert from SDL names (should happen at lower level)
			mapped_name = mapped_name:lower()
			if (mapped_name:sub(1,7) == "keypad ") mapped_name = "kp "..mapped_name:sub(8)
			if (mapped_name:sub(1,5) == "left ") mapped_name = "l"..mapped_name:sub(6)
			if (mapped_name:sub(1,6) == "right ") mapped_name = "r"..mapped_name:sub(7)
			if (mapped_name == "return") mapped_name = "enter"
			if (mapped_name == "lgui") mapped_name = "lcommand"
			if (mapped_name == "rgui") mapped_name = "rcommand"
			if (mapped_name == "loption") mapped_name = "lalt"
			if (mapped_name == "roption") mapped_name = "ralt"

--			printh("mapping "..mapped_name.." to "..i.."    // ".._get_key_from_scancode(i))

			if (not name_to_scancodes[mapped_name]) name_to_scancodes[mapped_name] = {}

			add(name_to_scancodes[mapped_name], i)

		end
	end


	-- raw  scancode names that are not mapped to anything -> dummy scancode (simplify logic)
	for i=1,#scancode_name do
		if (scancode_name[i] ~= "") then
			if (raw_name_to_scancode[scancode_name[i]] == nil) raw_name_to_scancode[scancode_name[i]] = -i
		end
	end

	
	-- patch keycodes (can also overwrite multi-keys like ctrl)

	local patch_keycodes = fetch"/appdata/system/keycodes.pod"
	if type(patch_keycodes) == "table" then
		for k,v in pairs(patch_keycodes) do
			-- /replace/ existing table; can use keycodes.pod to turn off mappings
			if (type(v) == "table") then
				name_to_scancodes[k] = v
			else
				name_to_scancodes[k] = {raw_name_to_scancode[v] or v} -- can use raw name or scancode directly.
			end
			--printh("mapping keycode "..k.." to "..pod(name_to_scancodes[k]))
		end
	end

	-- scancodes map to themselves unless explicitly remapped
	-- (avoids an extra "or scancode" in get_scancode)

	for i=0,511 do
		name_to_scancodes[i]    = name_to_scancodes[i] or {i}
		raw_name_to_scancode[i] = raw_name_to_scancode[i] or i
	end

	-- faster lookup for lctrl, rctrl, lalt, ralt wm filtering combinations
	local lctrl = (name_to_scancodes.lctrl and name_to_scancodes.lctrl[1]) or -1
	local rctrl = (name_to_scancodes.rctrl and name_to_scancodes.rctrl[1]) or -1
	local lalt =  (name_to_scancodes.lalt  and name_to_scancodes.lalt[1])  or -1
	local ralt =  (name_to_scancodes.ralt  and name_to_scancodes.ralt[1])  or -1


	-- alternative names
	-- (if the name being aliased is unmapped, then inherit its dummy mapping)

	name_to_scancodes["del"]      = name_to_scancodes["delete"] -- 0.1.0b used del
	name_to_scancodes["return"]   = name_to_scancodes["enter"]   
	name_to_scancodes["+"]        = name_to_scancodes["="]
	name_to_scancodes["~"]        = name_to_scancodes["`"]
	name_to_scancodes["<"]        = name_to_scancodes[","]
	name_to_scancodes[">"]        = name_to_scancodes["."]


	-- super-keys that are triggered by a bunch of other keys
	-- common to want to test for "any ctrl" (+ picotron includes apple command keys as ctrl)

	function create_meta_key(k)
		local result = {}
		for i=1,#k do	
			local t2 = name_to_scancodes[k[i]]
			if (t2) then -- key might not be mapped to anything (ref: rctrl on robot)
				for j=1,#t2 do
					add(result, t2[j])
				end
			end
		end
		--printh("@@@ "..pod(k).."  -->  "..pod(result))
		return result
	end

	name_to_scancodes["ctrl"]  = create_meta_key{"lctrl",  "rctrl",  "lcommand", "rcommand"}
	name_to_scancodes["alt"]   = create_meta_key{"lalt",   "ralt"}
	name_to_scancodes["shift"] = create_meta_key{"lshift", "rshift"}
	name_to_scancodes["menu"]  = create_meta_key{"menu0",  "menu1"}
	name_to_scancodes["stop"]  = create_meta_key{"stop0",  "stop1"}


	-- is allowed to return a table of scancodes that a key is mapped to
	local function get_scancode(scancode, raw)
		local scancode = (raw and raw_name_to_scancode or name_to_scancodes)[scancode]
		--[[
		if (scancode_blocked[scancode]) then
			-- unblock when not down. to do: could do this proactively and not just when queried 
			if (key_state[scancode] != 1) scancode_blocked[scancode] = nil 
			return 0 
		end
		]]
		return scancode
	end

	--[[

		keyp(scancode, raw)

			raw means: use US layout; same physical layout regardless of locale.
			use for things like music keyboard layout in tracker

			otherwise: map via appdata/system/scancodes.pod (should be "kbd_layout.pod"?)

		-- frame_keypressed_result is determined before each call to _update()
		--  (e.g. ctrl-r shouldn't leave a keypress of 'r' to be picked up by tracker. consumed by window manager)

	]]

	function keyp(scancode, raw, depth)

--		if (scancode == "escape") printh("get_scancode(\"escape\"): "..get_scancode(escape))

		scancode = get_scancode(scancode, raw)

		if (type(scancode) == "table") then			
			
			if (#scancode == 1) then
				-- common case: just process that single scancode
				scancode = scancode[1]
			else
				if (depth == 1) return false -- eh?
				local res = false
				for i=1,#scancode do res = res or keyp(scancode[i], raw, 1) end
				return res
			end
		end

		-- keep returning same result until end of frame
		if (frame_keypressed_result[scancode]) return frame_keypressed_result[scancode]

		-- first press
		if (key_state[scancode] and not last_key_state[scancode]) then
			repeat_key_press_t[scancode] = time() + 0.5
			frame_keypressed_result[scancode] = true
			return true
		end

		-- repeat
		if (key_state[scancode] and repeat_key_press_t[scancode] and time() > repeat_key_press_t[scancode]) then
			repeat_key_press_t[scancode] = time() + 0.04
			frame_keypressed_result[scancode] = true
			return true
		end

		return false
	end
	
	
	function key(scancode, raw)

		scancode = get_scancode(scancode, raw)

		if (type(scancode) == "table") then
			local res = false
			for i=1,#scancode do 
				if (key_state[scancode[i]]) return true
			end
			return false
		end

		return key_state[scancode]
	end



	-- clear state until end of frame
	-- (mapped keys only -- can't be used with raw scancodes)
	function clear_key(scancode)

		scancode = get_scancode(scancode)

		if (type(scancode) == "table") then
			for i=1,#scancode do clear_key(scancode[i]) end
			return
		end

		frame_keypressed_result[scancode] = nil
		key_state[scancode] = nil
	end

	
	local text_queue={}

	function readtext(clear_remaining)
		local ret=text_queue[1]

		for i=1,#text_queue do -- to do: use table operation
			text_queue[i] = text_queue[i+1] -- includes last nil
		end

		if (clear_remaining) text_queue = {}
		return ret
	end

	function peektext(i)
		return text_queue[i or 1]
	end

	-- when window gains or loses focus
	local function reset_kbd_state()
		--printh("resetting kbd")
		text_queue={}
		key_state={}
		last_key_state={}

		-- block all keys
		--[[
			scancode_blocked = {}
			for k,v in pairs(name_to_scancode) do
				scancode_blocked[v] = true
			end
		]]

	end


--[[
	deleteme -- don't need. app can just listen to gained/lost focus themselves. 
	local _window_has_focus = false

	function window_has_focus()
		return _window_has_focus
	end
]]
	
	local future_messages = {}

	--[[
		called once before each _update
	]]
	
	function _process_event_messages()

		frame_keypressed_result = {}

		wheel_x, wheel_y, locked_dx, locked_dy = 0, 0, 0, 0


--[[		for i=0,511 do
			last_key_state[i] = key_state[i]
		end
]]

		last_key_state = unpod(pod(key_state))

		local future_index = 1

		repeat
			
			local msg = _read_message()

			if (msg and msg._delay) msg._open_t = time() + msg._delay

			-- future messages: when _open_t is specified, open message at that time

			if (not msg and future_index <= #future_messages) then
				-- look for next future message that is ready to be received
				while (future_index <= #future_messages and future_messages[future_index]._open_t >= time()) do
					future_index += 1
				end
				msg = deli(future_messages, future_index)
			elseif (msg and msg._open_t and time() < msg._open_t) then
				-- don't process yet! put in queue of future messages
				add(future_messages, msg)
				msg = nil
			end

			
			if (msg) then

			--	printh(ser(msg))

				local blocked_by_hook = false

				if (message_hooks[msg.event]) then
					for i = 1, #message_hooks[msg.event] do
						blocked_by_hook = blocked_by_hook or message_hooks[msg.event][i](msg)
					end
				end

				if (not blocked_by_hook) then
					for i=1,#message_subscriber do
						blocked_by_hook = message_subscriber[i](msg)
						if (blocked_by_hook) then break end
					end

				end

				if (not blocked_by_hook) then

					-- 2. system

					if (msg.event == "mouse") then

						mouse_x = msg.mx
						mouse_y = msg.my
						mouse_b = msg.mb
						
					end

					if (msg.event == "mousewheel") then
						wheel_x += msg.wheel_x or 0
						wheel_y += msg.wheel_y or 0

					end

					if (msg.event == "mouselockedmove") then
						locked_dx += msg.locked_dx or 0
						locked_dy += msg.locked_dy or 0
					end

					if (msg.event == "keydown") then


						local accept = true

						if (pid() > 3) then
							if (key_state[lctrl] or key_state[rctrl]) then
								-- to do (efficiency) maintain a reverse lookup of keys to filter when ctrl is held
								if (msg.scancode == name_to_scancodes["s"][1]) accept = false
								if (msg.scancode == name_to_scancodes["6"][1]) accept = false
								if (msg.scancode == name_to_scancodes["7"][1]) accept = false
								if (msg.scancode == name_to_scancodes["0"][1]) accept = false
								if (msg.scancode == name_to_scancodes["tab"][1]) accept = false

							end

							if (key_state[lalt] or key_state[ralt]) then
								if (msg.scancode == name_to_scancodes["left"][1]) accept = false
								if (msg.scancode == name_to_scancodes["right"][1]) accept = false
								if (msg.scancode == name_to_scancodes["enter"][1]) accept = false
							end
						end

						if (accept) key_state[msg.scancode] = 1
						--printh("@@ keydown scancode: "..msg.scancode)
					end

					if (msg.event == "keyup") then
						key_state[msg.scancode] = nil
					end

					if (msg.event == "textinput" and #text_queue < 1024) then
						if not(key"ctrl") then -- block some stray ctrl+ combinations getting through. e.g. ctrl+1
							text_queue[#text_queue+1] = msg.text;
						end
					end

					if (msg.event == "gained_focus") then
						--_window_has_focus = true -- deleteme
						reset_kbd_state()
					end

					if (msg.event == "lost_focus") then
						--_window_has_focus = false -- deleteme
						reset_kbd_state()
					end

					if (msg.event == "gained_visibility") then
						poke(0x547f, peek(0x547f) | 0x1)
					end

					if (msg.event == "lost_visibility") then
						if (pid() > 3) poke(0x547f, peek(0x547f) & ~0x1) -- safety: only userland processes can lose visibility
					end

					if (msg.event == "resize") then
						-- throw out old display and create new one. can adjust a single dimension
						if (get_display()) then
							-- sometimes want to use resize message to also adjust window position so that
							-- e.g. width and x visibly change at the same frame to avoid jitter (ref: window resizing widget)
							window{width = msg.width, height = msg.height, x = msg.x, y = msg.y}
						end
					end

				end
			end

		until not msg

		-- 0.1.0g: disable control keys when alt is held
		-- don't want ALTgr + 7 to count as ctrl + 7 (some hosts consider ctrl + alt to be held when ALTgr is held)
		if (key_state[lalt] or key_state[ralt]) then
			key_state[lctrl] = nil
			key_state[rctrl] = nil
		end


	end


	-----
	-- only one hook per event. simplifies logic.

	function on_event(event, f)
		if (not message_hooks[event]) message_hooks[event] = {}
		add(message_hooks[event], f)
	end

	-- kernel space for now -- used by wm (jettisoned)
	function _subscribe_to_events(f)
		add(message_subscriber, f)
	end

end



:: lib/foot.lua
--[[pod_format="raw",created="2024-03-11 18:02:01",modified="2024-04-23 11:47:10",revision=5]]
--[[
	foot.lua
]]

-- init first; might set window inside _init
-- only problem: no visual feedback while _init does a lot of work. maybe need to spin the picotron button gfx!
if (_init) then _init() end


--[[
	every program runs in headless until window() called, either
		- explicitly by program
		- automatically, when _draw exists (but window doesn't) just before entering main loop

	handle the second case here
]]


if (_draw and not get_display()) then

	-- create window (use fullscreen by default unless overridden by env().window_attribs)
	window()

end

if (pid() > 3) then
	on_event("pause",       function() poke(0x547f, peek(0x547f) |  0x4) end)
	on_event("unpause",     function() poke(0x547f, peek(0x547f) & ~0x4) end)
	on_event("toggle_mute", function() poke(0x547f, peek(0x547f) ^^ 0x8) end)
end

-- mainloop
-- only loop if there is a _draw or _update
-- logic here applies to window manager too!

-- printh("entering mainloop at cpu:"..stat(1))

while (_draw or _update) do


	-- called once before every _update()  --  otherwise keyp() returns true for multiple _update calls
	_process_event_messages()


	if (peek(0x547f) & 0x4) > 0 and pid() > 3 then

		-- paused: nothing left to do this frame
		-- still need to process buttons though
		_update_buttons()
		flip(0x3)

	else

		-- set a hold_frame flag here and unset after mainloop completes (in flip) 
		-- window manager can decide to discard half-drawn frame. --> PICO-8 semantics
		-- moved to start of mainloop so that _update() can also be halfway through
		-- drawing something (perhaps to a different target) without it being exposed

		poke(0x547f, peek(0x547f) | 0x2)

		-- to do: process can be run in background when not visible
		-- @0x547f:0x1 currently means "window is visible", and apps only run when visible

		if (peek(0x547f) & 0x1) > 0 then

			-- always exactly one call to _update_buttons() before each _update() when it is defined (allows keyp to work)
			-- when _update is not defined, still call once per draw.
			_update_buttons()

			if (_update) then
				_update()

				local fps = stat(7)
				if (fps < 60) _process_event_messages() _update_buttons() _update()
				if (fps < 30) _process_event_messages() _update_buttons() _update()

				-- below 20fps, just start running slower. It might be that _update is slow, not _draw.
			end
		end


		if (_draw and (peek(0x547f) & 0x1) > 0) then

			_draw()

			flip() -- unsets 0x547f:0x2
		else
			-- safety: draw next frame. // to do: why is this ever 0 for kernel processes? didn't received gained_visibility message?
			if (pid() <= 3) poke(0x547f, peek(0x547f) | 0x1)

			flip() -- no more computation this frame, and show whatever is in video memory
		end
	end

end

:: lib/gui.lua
--[[

	gui.lua

	standard gui library
	// "standard" means included by head.lua

	super-minimal -- similar to codo gui.  ** well-defined and freeze early

	goal: scrollbox full of buttons and input boxes
	-> need attributes like clip_to_parent clip_to_self
		// or perhaps: stack of draw states? push_draw_state(). and/or push_clip()
		// needs to also apply when determining pointer element though. overcomplicated.
		// update: not that complicated! implemented in playground 10

	events:
		click, doubleclick, drag, release
		tap // on release when mouse hasn't moved
		mousewheel

]]


do
	local GuiElement={} -- helper class; never used externally

	local next_id = 0

	-- used for setting from draw call tree
	local mouse_cursor_gfx = nil 
	local last_mouse_cursor_gfx = nil 

	
	function GuiElement:new(el)
		el = el or {}
		setmetatable(el, self)
		self.__index = self

		el.id = next_id -- for debugging
		next_id = next_id + 1

		-- time of creation
		-- sometimes don't want to interact with newly created elements
		el.t0 = time()

		-- commented: too confusing to have a default position / size when accidentally not specified on creation 
		-- to do: only useful if make crashes inside gui.lua more readable though!
--[[
		el.x = el.x or 43
		el.y = el.y or 43
		el.width = el.width or 43
		el.height = el.height or 43
]]

		el.z  = el.z or 0
		el.sx = el.x or 0 -- will be calculated on update
		el.sy = el.y or 0

		if (el.clip_to_parent == nil) then
			el.clip_to_parent = true
		end

		el.child = el.child or {}

		return el
	end

	-- child can be null to create new element
	function GuiElement:attach(child)
		child = child or {}		
		child = GuiElement:new(child)
		child.parent = self
		child.head = self.head or self -- also updated in update_absolute_position (ref: wm manually reattaches subtrees, messing up head)

		-- calculate relative size immediately -- might be used while calculating other elements
		if (child.width_rel)  child.width  = self.width  * child.width_rel  + (child.width_add  and child.width_add  or 0) 
		if (child.height_rel) child.height = self.height * child.height_rel + (child.height_add and child.height_add or 0)

		return add(self.child, child)

	end

	function GuiElement:has_keyboard_focus()
		-- to do: assert(typeof(this)=="table");   might accidentally self.has_keyboard_focus() instead of self:has_keyboard_focus()
		return self.head.keyboard_focus_el == self
	end

	function GuiElement:set_keyboard_focus(val)
		-- to do: assert(typeof(this)=="table");   might accidentally self.set_keyboard_focus() instead of self:set_keyboard_focus()
		if (val == true) then
			self.head.keyboard_focus_el = self
		elseif (self.head.keyboard_focus_el == self) then
			-- only set to nil if was this element (don't clobber a different element's focus)
			self.head.keyboard_focus_el = nil
		end

	end


	--[[

		g = create_gui()
		p = g:attach_pulldown({x = ..})
		p:attach_pulldown_item("Hey", func)

	]]
	function GuiElement:attach_pulldown(el)

		local p = self:attach(el)

		function p:draw(ev)

			local flat_top = false -- when false, can generalise to dismissable dialogue. probably too leaky though.
			local x0 = 1
			local y0 = flat_top and -1 or 1
			local x1 = el.width-2
			local y1 = el.height-2
			
			rectfill(x0,y0, x1,y1, 7)

			local border_col = 1
			
			line(x0+1, y1+1, x1-1, y1+1, border_col)
			line(x0-1, y0+1, x0-1, y1-1, border_col)
			line(x1+1, y0+1, x1+1, y1-1, border_col)
			if (not flat_top) then
				-- top border and corners
				line(x0+1, y0-1, x1-1, y0-1, border_col)
				pset(x0,y0,border_col)
				pset(x1,y0,border_col)
			end
			-- bottom corners
			pset(x0,y1,border_col)
			pset(x1,y1,border_col)

		end

		-- no items yet
		p.item_y = 4
		p.item_h = 12
		p.height = 10 -- extra 2px at the bottom feels better
		
		return p
	end

	function GuiElement:attach_pulldown_item(el)

		local item = unpod(pod(el)) -- copy attributes

		-- need to copy function separately
		item.action     = el.action

		-- default attrib values
		item.label      = item.label or "???"
		item.x          = item.x or 1
		item.y          = item.y or self.item_y
		item.width      = item.width or self.width-2  -- (-2 to fit inside 1px black border)
		item.height     = item.height or self.item_h


		item.draw = function(self, ev)
			if (ev.has_pointer and not self.divider) rectfill(0,0,self.width-1, self.height-1, 13)
			if (self.divider) then
				line(4,4, self.width-5, 4, 6)
			else
				local xx = 6
				local yy = 3
				if (self.icon) then
					pal(7,1)
					spr(self.icon, xx, 3)
					pal(7,7) -- hrrrm
					xx += 14
				end

				print(self.label, xx, yy, 1)

				if (self.shortcut) then
					local ww = print(self.shortcut, 0,-1000)
					-- to do: adapt greyed out colour (make pulldown themeable)
					print("\f6"..self.shortcut, self.width - ww - 6, yy)
				end
			end
		end
		
		-- run and close
		item.tap = function(self)
			if (self.action) then
				self.action()
				if not self.stay_open then
					if (self.onclose) then self.onclose() end
					del(self.parent.parent.child, self.parent) -- close
				end
			end
			return true
		end

		local item_h = self.item_h
		if (el.divider) item_h -= 4 -- line break is shorter
		self.item_y += item_h
		self.height += item_h

		return self:attach(item)
	end

	--[[
		attach_field  //  ** placeholder

		needs a get() and set() callback

		** maybe fields are always too specialised; leave up to client
		   but nice to have a drop-in starting point if can make it general enough
	]]
	function GuiElement:attach_field(el)
		local el = self:attach(el)

		function el:draw()
			str = type(self.get == "function") and self:get() or "---"
			if (self:has_keyboard_focus()) str = self.str
			local ww,hh = print(str,0,-1000)
			rectfill(0,0,self.width-1,self.height-1, self:has_keyboard_focus() and 8 or 0)
			print(str,self.width-ww-1,1,6)
			if (self.label) then
				clip()
				local ww = print(self.label,0,-1000)
				print(self.label, -ww, 1, 13)
			end
		end

		function el:click()
			self:set_keyboard_focus(true)
			readtext(true)
			self.str = "" -- starting editing new string
		end


		function el:update()
			if (self:has_keyboard_focus()) then

				while (peektext()) do
					self.str = self.str .. readtext()
				end

				if (keyp("backspace")) self.str = sub(self.str,1,-2)

				if (keyp("enter")) then
					if (type(self.set) == "function") self:set(self.str)
					self:set_keyboard_focus(false)
				end

			end
		end


		return el
	end


	--[[
		attach_scrollbars() // to do: horizontal bar (or generalise to 2d)

		assume that self is a container element, where 
			child[1] is the element to be scrolled
			child[2] is the scrollbar

		example:

		g = create_gui()
		my_container = g:attach(my_container_attribs)
		my_container:attach(my_contents)
		my_container:attach_scrollbars()

		to allow mousewheel scrolling, still need to process messages from contents:

			function contents:mousewheel(msg)
				self.y += msg.wheel_y * 32 -- scroll speed is arbitrary
			end

			** to do: mousewheel event should propagate up to parent though (if not defined)
	]]

	function GuiElement:attach_scrollbars(attribs)

		--if no children, attach to parent! to do: standardise
		local container = self

		local bar_w = 8

		local attribs = attribs or {} -- to do: should use usual pattern where (duck-type) extend from el

		local scrollbar = {
			x = 0, justify = "right",
			y = 1,                             -- 1px boundary at top
			width = bar_w,
			height = container.height-1,       -- allow for 1px boundary at top
			height_rel = 1.0, height_add = -1, -- 1 pixel less than container's height
			autohide = attribs.autohide,
			bar_y = 0,
			bar_h = 0,
			cursor = "grab",

			update = function(self, msg)
				local container = self.parent
				local contents  = container.child[1]
				local h0 = self.height
				local h1 = contents.height
				local bar_h = max(9, h0 / h1 * h0)\1  -- bar height; minimum 9 pixels
				local emp_h = h0 - bar_h - 1          -- empty height (-1 for 1px boundary at bottom)
				local max_y = max(0, contents.height - container.height)


				-- clamp only if contents has a specially named callback
				-- update: don't need to be responsible for that here; deleteme
				--[[
					if (contents.clamp_scrolling) then
						contents:clamp_scrolling()
					end
				]]

				self.scroll_spd = max_y / emp_h
				self.bar_y = flr(- emp_h * contents.y / max_y)
				self.bar_h = bar_h
				

				if (self.autohide) then
					self.hidden = contents.height <= container.height
				end
			end,
			
			draw = function(self, msg)
				local bgcol = 13
				local fgcol = 6

				-- allow for 1px boundary at top; draw 1px outside of self at top
				clip()
				
				rectfill(0,-1,self.width-1, self.height-1, bgcol | (fgcol << 8)) 
				rectfill(1,self.bar_y,self.width-2,self.bar_y + self.bar_h-1, fgcol)

				-- lil grip thing; needs a mid UI colour though?
				--if (msg.has_pointer) then
					local yy = self.bar_y + self.bar_h/2
					line(2, yy-1, self.width-3, yy-1, bgcol)
					line(2, yy+1, self.width-3, yy+1, bgcol)
				--end

				-- rounded?
				-- [[
				pset(1,self.bar_y,bgcol)
				pset(self.width-2, self.bar_y,bgcol)
				pset(1,self.bar_y + self.bar_h-1,bgcol)
				pset(self.width-2, self.bar_y + self.bar_h-1,bgcol)
				--]]

			end,
			drag = function(self, msg)
				local content = self.parent.child[1]
				content.y -= msg.dy * self.scroll_spd
				-- clamp
				content.y = mid(0, content.y, -max(0, content.height - container.height))

			end,
			click = function(self, msg)
				local content = self.parent.child[1]
				
				-- click above / below to pageup / pagedown
				if (msg.my < self.bar_y) content.y += self.parent.height
				if (msg.my > self.bar_y + self.bar_h) content.y -= self.parent.height
			end
		}

		-- standard mousewheel support when attach scroll bar
		-- speed: 32 pixels // to do: maybe should be a system setting?
		function container:mousewheel(msg)
			local content = self.child[1]
			if (not content) return

			if (key("ctrl")) then
				content.x += msg.wheel_y * 32 
			else
				content.y += msg.wheel_y * 32 
			end

			-- clamp
			content.y = mid(0, content.y, -max(0, content.height - container.height))
			
		end

		return container:attach(scrollbar)

	end


	function GuiElement:attach_button(el)
		el.label = el.label or "[label]"
		el.width = el.width or #el.label * 5 + 10 -- to do: calculate width with current font
		el.height = el.height or 14
		el.cursor = "pointer"

		local b = self:attach(el)

		function b:draw(msg)
			local bgcol = el.bgcol or 0x0706
			local fgcol = el.fgcol or 0x0e01
			if (msg.has_pointer) then
				bgcol >>= 8 
				fgcol >>= 8
			end

			local yy = 0
			if (msg.mb > 0 and msg.has_pointer) yy = yy + 1

			rectfill(0, yy + 1, self.width-1, yy + self.height-3, bgcol)
			rectfill(1, yy + 0, self.width-2, yy + self.height-2, bgcol)

			print(self.label, self.width/2 - #self.label * 2.5, 3 + yy, fgcol)
		end

		return b

	end


	function GuiElement:attach_text_editor(...)

		-- lazily load the text editor
		if (not attach_text_editor) include("/system/lib/gui_ed.lua")

		return attach_text_editor(self, ...)
	end


	function GuiElement:detach(el)
		if (not el) then
			-- can just detach()
			return del(self.parent.child, self)
		end
		return del(self.child, el)
	end

	-- bring as far foward as will go before find an element with higher z
	function GuiElement:bring_to_front()
		p = self.parent
		if (not p) then return end

		for i=1,#p.child-1 do
			if (p.child[i] == self and p.child[i].z >= p.child[i+1].z) then
				p.child[i],p.child[i+1] = p.child[i+1],p.child[i]
			end
		end
	end

	-- push as far back as will go before find an element with lower z
	function GuiElement:push_to_back()
		p = self.parent
		if (not p) then return end

		for i=#p.child,2,-1 do
			
			if (p.child[i] == self and p.child[i].z <= p.child[i-1].z) then
				p.child[i],p.child[i-1] = p.child[i-1],p.child[i]
			end
		end
	end

	-- event propagates to children only when specified with msg.propagate_to_children (used for draw, update)
	-- normally don't want to propagate -- e.g. just click on pointer element

	function GuiElement:event(msg)

		if (not msg) then return end

		-- this helper is not scoped to a particular Gui -- need to pass in pointer_element via head
	
		if (self.head.pointer_element == self) then
			local mx, my, mb = mouse()
			msg.has_pointer = (mx >= self.sx and my >= self.sy and mx < self.sx + self.width and my < self.sy + self.height)
			if (self.cursor) mouse_cursor_gfx = self.cursor
		else
			msg.has_pointer = nil
		end

		local fin = false
		local cl,ct,cw,ch,cc

		-- call event handler if it exists
		if (type(self[msg.event]) == "function") then

			if (self.hidden and msg.event ~= "update") then
				-- no callbacks (except update is still called ~ might want to control if self is hidden! (scrollbars))
				fin = true
			else

				if (msg.event == "draw") then
					-- draw is special: optionally clip children and set camera position
					-- [experimental: also, can skip if outside]

					cl,ct,cw,ch,cc = clip(self.sx, self.sy, self.width, self.height, self.clip_to_parent)

					camera(-self.sx, -self.sy)

					--[[
						-- commented. works, but is too complex and spooky if it goes wrong
						-- when efficiency is needed, implement custom layer that handles longs lists etc (ref:filenav)
						if (self.clip_to_parent and cc) then
							-- clipped out -- can skip. and don't bother drawing children (implied clip_to_parent)
							fin = true
						else
							fin = self[msg.event](self, msg)
						end
					]]

					-- 0.1.0c: mosue position should be relative to element
					local mx, my, mb = mouse()
					msg.mx, msg.my = mx - self.sx, my - self.sy

					fin = self.draw(self, msg)

				else

					fin = self[msg.event](self, msg)
				end
			end

		end

		if (not fin) then

			if (msg.propagate_to_children) then

				-- propagate to children (have to explicitly set in message)
				-- used for draw, update

				for i=1,#self.child do
					local c = self.child[i]
					if (c and c.event) then 
						c:event(msg)
					end
				end
			else

				-- default: propagate to parents   //   e.g. can mousewheel anywhere in scrollbox to scroll 
				-- block this by returning true from callback

				if (self.parent) self.parent:event(msg)

			end


		end

		-- restore clipping, camera state if needed
		if (cl) then
			clip(cl,ct,cw,ch)
			camera() -- to do: backup and restore
		end

	end


	-- Gui: class factory, extends GuiElement
	-- was Gui, now create_gui (consistent with create_undo_stack)

	function create_gui(head_el)

		head_el = head_el or {}

		head_el.head = head_el
		
		head_el.x = head_el.x or 0
		head_el.y = head_el.y or 0
		head_el.z = head_el.z or 0

		-- by default, occupy entire display adaptively
		if (not head_el.width)  head_el.width_rel  = 1.0
		if (not head_el.height) head_el.height_rel = 1.0

		head_el.width = head_el.width or 480
		head_el.height = head_el.height or 270

		local gui = GuiElement:new(head_el)

		local mx, my, mb, wheel_x, wheel_y = 0,0,0,0,0
		local last_mx, last_my, last_mb = 0,0,0
		local dx, dy = 0
		local start_mx, start_my,start_el = 0,0
		local drag_t = 0
		local dragging_el = nil

		-- don't pay attention to mouse button until it is first recorded as not pressed
		-- avoids complications when e.g. button is held on creation (generating click event)
		local block_mb = true

		-- to do: shouldn't need this? can use has_pointer()?
		function gui:get_pointer_element()
			return gui.pointer_element
		end

		function gui:get_keyboard_focus_element()
			return gui.keyboard_focus_el
		end

--[[
		-- commented; don't really want to have brittle iterator code in the window manager during dev
		-- breaks easily while experimenting with cpu model -> can't debug from inside
		-- (and turns out, don't really need this)
		function iter(tree)

			local function traverse(node)
				coroutine.yield(node)
				for i=1,#node.child do
				    traverse(node.child[i])
				end
			end

			local c = coroutine.create(function() traverse(tree) end)
		 
			return function()
				local _, value  = coresume(c) -- wrapped version needed in order to reconstruct call tree
--				local _, value  = coroutine.resume(c)
				return value
			end
		end
]]

		
		local function update_absolute_position(el)

				local px = el.parent.sx or 0
				local py = el.parent.sy or 0

				-- hack: update head so that tree structure can change (should that be allowed? wm does it!)
				el.head = el.parent.head or el

				-- relative size
				if (el.width_rel)  el.width  = el.parent.width  * el.width_rel  + (el.width_add or 0)
				if (el.height_rel) el.height = el.parent.height * el.height_rel + (el.height_add or 0)

				-- to do: (optimisation) table of functions
				if (el.justify == "right")  then px = px + el.parent.width - el.width end
				if (el.justify == "center") then px = px + el.parent.width/2 - el.width/2 end

				if (el.vjustify == "bottom") then py = py + el.parent.height - el.height end
				if (el.vjustify == "center") then py = py + el.parent.height/2 - el.height/2 end

				el.sx = (px + (el.x or 0)) \ 1
				el.sy = (py + (el.y or 0)) \ 1

				for i=1, #el.child do
					update_absolute_position(el.child[i])
				end

		end


		local function update_absolute_positions()

			-- dummy parent to reduce logic in update_absolute_position()

			gui.parent = {
				x=0, y=0,
				width = get_display():width(),
				height = get_display():height()
			}

			update_absolute_position(head_el) -- head_el /is/ the gui

			gui.parent = nil

		end


		local function el_at_xy_recursive(el, px0, py0, px1, py1, x, y, depth)

			-- was needed due to superyield L->top borking bug -- can guarantee now?
			--[[
			if (not el or not el.sx or not el.sy) then printh("*** bad el in el_at_xy_recursive") return end
			if (depth > 64) then printh("*** max depth el_at_xy_recursive") return end
			]]

			-- ghost is drawn but can't interact
			if (el.hidden or el.ghost) return nil

			local best_el = nil

			local sx0, sy0 = el.sx, el.sy
			local sx1 = el.sx + el.width
			local sy1 = el.sy + el.height

			-- clip by parent -- events should also be clipped when not visibly interacting

			if (el.clip_to_parent) then
				sx0 = mid(px0, sx0, px1)
				sy0 = mid(py0, sy0, py1)
				sx1 = mid(px0, sx1, px1)
				sy1 = mid(py0, sy1, py1)
			end

			--printh("el_at_xy_recursive "..pod{tostr(el), {x, y}, {sx0, sy0, sx1, sy1}})

			if (x >= sx0 and x < sx1 and y >= sy0 and y < sy1) then
				-- last element in tree (so prefers leaf nodes). matches visual order

				if (not el.test_point or el:test_point(x - el.sx, y - el.sy)) then
					best_el = el
				end
				
				--printh("best_el: "..pod(tostr(el), {el.sx,el.sy,el.width,el.height}))
			end

			for i=1, #el.child do
				best_el = el_at_xy_recursive(el.child[i], el.sx, el.sy, sx1, sy1, x, y, depth + 1) or best_el
			end

			return best_el
		
		end



		-- to do: element can have collision test called when inside bounding rectangle
		-- x, y are relative to TLC of gui
		function gui:el_at_xy(x, y)
			local el = nil

			-- don't interact with gui a moment after it was created; avoid complex edge cases
			-- e.g. dragging while regenerate gui -> don't want to immediately pick up whatever
			-- is under the cursor. (confusing)
			--if (time() < gui.t0 + 0.2) return false
			-- 0.1.0c: commente; pushes complexity to other places! e.g. drop file into newly opened window

			--el = el_at_xy_recursive(gui, gui.x, gui.y, gui.x + gui.width, gui.y + gui.height, x, y)

			el = el_at_xy_recursive(gui, 0, 0, 480, 270, x, y ,0)
			
			--printh("--> el_at_xy: "..tostr(el).."  //  "..pod{el.sx,el.sy,el.width,el.height})
			return el

		end


		function gui:el_at_pointer(x,y)
			printh("** FIXME: el_at_pointer -> el_at_xy")
			return gui:el_at_xy(x,y)
		end

		-- sometimes want to make an element that isn't attached [yet]
		-- e.g. scroll box contents
		function gui:new(el)
			return GuiElement:new(el)
		end

		

		--[[
					0x5480 ~ 0x5bff     (64) indexed display palette
					0x54c0 ~ 0x553f     (128) picotron misc draw state
		]]
		local draw_state = userdata("i64", 24) -- 192 bytes

		function gui:draw_all()

			update_absolute_positions()

			local el=self
			local msg = el and { mx = mx - el.sx, my = my - el.sy, mb = mb} or {}

			msg.event = "draw"
			msg.propagate_to_children = true

			-- should gui be responsible for preserving draw state?
			set(draw_state, 0, peek8(0x5480, 24))

--			local cx, cy, cw, ch = clip()
			clip()


			-- use false instead of nil so that can send it via a message
			-- means "no cursor found by gui draw tree"
			mouse_cursor_gfx = false 

			self:event(msg)

			-- send message to wm when cursor changed
			if (pid() > 3) then
				if (last_mouse_cursor_gfx != mouse_cursor_gfx) window{cursor = mouse_cursor_gfx}
				last_mouse_cursor_gfx = mouse_cursor_gfx
			end

			gui.mouse_cursor_gfx = mouse_cursor_gfx -- could be false; means no cursor 

--			clip(cx, cy, cw, ch) -- restore
			poke8(0x5480, get(draw_state)) -- restore whole draw state

		end


		-- update_all mean update the whole gui tree -- is typically called onced from _update
		function gui:update_all()

			last_mx, last_my, last_mb = mx, my, mb

			mx, my, mb, wheel_x, wheel_y = mouse() -- screen space

			dx = mx - last_mx
			dy = my - last_my

			if (block_mb and mb == 0) block_mb = false
			if (block_mb) then
				-- consider mouse state to be junk when mb hasn't been 0 yet
				mx,my,mb = 0,0,0
			end

			update_absolute_positions()

			-- if dragging something, always pay attention only to that
			-- (even if drag outside of that element)

			local el = dragging_el or gui:el_at_xy(mx, my)

			-- can be nil
			gui.pointer_element = el 


			-- check for hidden parent
			
			local el2 = el
			while (el2) do
				if (el2.hidden) el = nil -- found; don't send any messages
				el2 = el2.parent
			end

			----------------- standard messages: only send to element at pointer -----------------------

			-- construct generic message with state information
			local msg = el and {
				mx = mx - el.sx, 
				my = my - el.sy, 
				mb=mb, dx=dx, dy=dy
			} or {}


			

			
			local do_double_click = false
			local do_double_tap = false
			-- mouse buttons needs to match: clicking left and then right quickly should not trigger double click/tap
			if (el and last_mb == 0 and mb > 0 and (el.last_click_t and time() - el.last_click_t < 0.4) and mb == el.last_click_mb) then
				do_double_click = true
				-- (send message at end)
			end


			-- click
			-- two click messages for every double click -- because might only care about rapid clicks and not double clicks
			if (el and last_mb == 0 and mb > 0) then
				-- mousedown (and not second click in a double click): send click and start drag
				start_mx = mx
				start_my = my
				start_el = el -- to do: use this to discard some interactions that should start and end on the same element (no gui refresh midway)
				drag_t = time()
				dragging_el = el	
				-- commented: need to explicitly set, so that it is possible to know if there 	
				-- is an element that is actively consuming keyboard input via gui:get_keyboard_focus_element
				--gui.keyboard_focus_el = el 
				el.last_click_t = time()
				el.last_click_mb = mb

				msg.event="click" el:event(msg)
			end

			-- mouseup: send release and possibly tap
			if (el and last_mb > 0 and mb == 0) then

				-- tap if mouse position hasn't moved more than 4 pixels
				local dx = start_mx - mx
				local dy = start_my - my

				-- only tap when close to position-at-mousedown within one second, and element existed for 200ms or more
				-- ref: filenav doubleclick to enter folder -> don't want tap on newly created interface
				if (dx*dx + dy*dy < 4*4 and time() < drag_t + 1.0 and t() > el.t0 + 0.2) then

					msg.event="tap" msg.last_mb = last_mb el:event(msg)

					-- also send a doubletap if second tap (using same mouse button)
					if (el.last_tap_t and time() - el.last_tap_t < 0.4 and last_mb == el.last_tap_mb) then
						do_double_tap = true
					else
						el.last_tap_t = time()
						el.last_tap_mb = last_mb
					end

				end

				-- common to want to know where drag started from
				msg.mx0 = start_mx - el.sx
				msg.my0 = start_my - el.sy

				-- release
				msg.event="release" el:event(msg)
			end

			-- hover. maybe don't need?
			if (el and mb == 0) then
				msg.event="hover" el:event(msg)
			end

			-- drag
			if (dragging_el) then

				-- if (last_mb > 0 and mb > 0) then -- only start dragging the frame after mouse button becomes active
				if (mb > 0) then  -- what's wrong with dragging from first frame? need that interactivity! e.g. pick up colour in sprite editor
					msg.event="drag" 
					-- common to want to know where drag started from
					msg.mx0 = start_mx - el.sx
					msg.my0 = start_my - el.sy

					-- locked pointer? use that for dx, dy. ref: instrument designer envelope knob
					if (peek(0x5f2d) & 0x4) > 0 then
						local locked_dx, locked_dy = mouselock()
						msg.dx = locked_dx
						msg.dy = locked_dy
					end

					dragging_el:event(msg)
					--printh("dragging_el: "..tostr(dragging_el))
				elseif (mb == 0) then            -- .. but stop dragging immediately when mouse button released

					dragging_el = nil

					-- auto unlock mouse on release
					if ((peek(0x5f2d) & 0x8) > 0) poke(0x5f2d, peek(0x5f2d) & ~0x4)
				end
			end

			-- doubleclick sent after click / drag (e.g. in text editor, don't want to deselect what the double click selected)
			if (do_double_click) then
				msg.event="doubleclick" el:event(msg)
				el.last_click_t = 0
			end

			-- doubletap message comes after second tap message
			if (do_double_tap) then
				msg.event="doubletap" el:event(msg)
			end

			-- mousewheel event
			
			if (el and (wheel_x ~= 0 or wheel_y ~= 0)) then
				msg.wheel_x = wheel_x
				msg.wheel_y = wheel_y
				msg.event="mousewheel" el:event(msg)
			end
	
			----------------- send update message to gui tree -----------------------

			msg.event="update" msg.propagate_to_children = true self:event(msg)


		end


		return gui
	end

end

:: lib/gui_ed.lua
--[[pod_format="raw",created="2024-03-13 18:17:04",modified="2024-04-05 01:40:13",revision=4]]
--[[

	/dev/ed/gui_ed.lua

	text editor widget

	good for ~128k

]]

local _has_focus = true
on_event("gained_focus", function() _has_focus = true end)
on_event("lost_focus", function() _has_focus = false end)


local function apply_markup(l)

	-- require space; better to be strict
	if (sub(l,1,2) == "# ") then
		--return "\14\06t\06w"..sub(l,3)
		-- return "\^t\^w"..sub(l,3).."\^g\-h"..sub(l,3) -- haha
		return "------------------------------------\n  "..sub(l, 3).."\n------------------------------------\n"
	end

	if (sub(l,1,3) == "## ") then
		return ":: "..sub(l, 4).."\n"
	end

	if (sub(l,1,3) == "```") then

	end

	-- no markup; need to let "]]" pass through!
	return l
end


local search_box_height = 18
local search_box_width  = 240

function close_search_pane(container)
	
	if (not container.search_box) return

	window{capture_escapes = false}
	container.search_box:detach()

	container.search_box = false

end



function open_search_pane(container, search_func)

	-- already open
	if (container.search_box) return

--	printh("opening search pane from container: "..tostr(container))

	local search_box = container.parent:attach({
		x = container.x + container.width - search_box_width - 8, y = container.y, 
		width = search_box_width, height = search_box_height
	})

	function search_box:draw()
		rectfill(0,0,self.width,self.height,6)
		line(0,self.height-1,self.width,self.height-1,13)
		print("Find:",8,6, 5)
	end

	local search_field = search_box:attach_text_editor({
		x=34, y=3, width=search_box_width - 48, height=12, block_scrolling = true, max_lines = 1,
		key_callback = {enter = function () search_func(1) close_search_pane(container) end }
	})

	search_field:set_text({container.last_search_str or ""})
	search_field:select_all()
	search_field:set_keyboard_focus(true) -- to do: perhaps should allow search_field:set_keyboard_focus()

	container.search_box = search_box
	container.search_field = search_field

	window{capture_escapes = true}

end

-- attach_text_editor
-- returns the content -- all exposed methods (incl :attach_scrollbars!) and attributes can be stored there  
function attach_text_editor(g, parent)

	
	local container = g:attach(parent)
	local content                -- referenced by container:draw
	local undo_stack



	local char_w = peek(0x4000) -- only used for cursor
	local char_h = peek(0x4002)

	
	local cursor_y0 = -1
	local cursor_y1 = 7

	local cur_x, cur_y = 1, 1

	local hydrated = {}
	local hydrate_y = 1

	local margin_left = 0
	local margin_top  = 3


	local sel = {{line=0, char=0}, {line=0, char=-1}, {line=0, char=0}}





	-- note: need a draw function so that parent clipping is set!

	function container:draw()
		-- default container draw: clear to blue
		-- perhaps could be optional though if caller wants to manage background (e.g. live coding w/ code shown on top of output)
		rectfill(0,0,self.width-1, self.height-1, content.bgcol)

		-- print("\^w\^t ***"..tostring(cur_y), 10,10,8)

		-- show keyboard focus state (debug, but maybe useful in future)
		-- have blinking cursor!
		--[[
		if (content:has_keyboard_focus() and self.max_lines == 1) then
			rect(0, 0, self.width-1, self.height-1, 10)
		end
		]]

	end
	
	-- returns true when call back exists AND callback doesn't opt to pass-through
	local function key_pressed_callback(k)
		if (type(content.key_callback[k]) == "function") then
			return not content.key_callback[k](k, text)
		end
		return false
	end


	
	-- make the scrollable thing
	-- start same height as container

	content = container:attach({x=0,y=0,width=container.width, height=container.height})

	-- copy attributes passed to container
	-- stored in content so that caller can deal only with return value of attach_code_editor (content, not container) 
	-- don't do an pairs() copy because don't want to copy over internal values
	
	content.show_line_numbers   = container.show_line_numbers
	content.embed_pods          = container.embed_pods
	content.syntax_highlighting = container.syntax_highlighting
	content.markup              = container.markup
	content.max_lines           = container.max_lines
	content.has_search          = container.has_search
	content.bgcol               = container.bgcol or 1
	content.fgcol               = container.fgcol or 6
	content.block_scrolling     = container.block_scrolling
	content.key_callback        = container.key_callback or {}

	---
	local text = {""}

	local num = rnd(20)
	local x = container.x or 0
	local y = container.y or 0
	local width = container.width or 200
	local height = container.height or 100
	

-- colour when editing a line
	local editing_line_col = content.bgcol == 1 and 9 or 5


	------------------------------------------------------------------------------------

	local function set_selection(tbl)
		sel = tbl
		-- starting point (for adjusting with shift+click / shift+navigate)
		if (not sel[3]) then
			sel[3] = unpod(pod(sel[1]))
		end
	end


	local function get_sx_for_cur_x(str, pos)
		if (pos < 1) then return 0 end
		local s = sub(str, 1, pos)
		return print(s, 0, -100)
	end

	-- don't care about x for now
	local function find_cur_y_for_click(my)

		local yy = margin_top

		for i = 1, #text do			
			yy += (hydrated[i] and hydrated[i].draw_h) or char_h
			if (my < yy) return i
		end

		return #text

	end

	
	local function find_x_for_cur_x(cur_x, str)
		if (not str) return 0
		return print(sub(str, 1, cur_x - 1), 0, -1000)
	end

	-- assumes tabs rendered relative to home_x ------
	local function find_cur_x_for_click(cx, str)
		if (not str) return 0

		if (#str == 0) then return 1 end

		-- printh("find_cur_x_for_click: "..cx)
		
		for i=1,#str do
			local xx = print(sub(str, 1, i), 0, -1000)
			if (xx and xx >= cx) then return i end
		end
		return #str+1
	end

	------------------------------------------------------------------------------------

	function content:set_text(t)
		if (type(t) == "string") t = split(t,"\n",false)

		text = t 

		-- behave as if editing a new file
		-- (can't undo across set_texts)
		cur_y = 1
		hydrated = {}
		undo_stack:reset()
	end

	function content:get_text() return text end

	function content:select_all()
		set_selection{{line=1, char=1}, {line=#text, char=#text[#text]}}
	end

	function content:search_box_is_open()
		return container.search_box
	end

	

	local identcol = {}
	local reserved = {"and", "break", "do", "else", "elseif", "end", "for", "function", "if", "in", "local", "not", "or", "repeat", "return", "then", "until", "while"}
	local reserved_val = {"true", "false", "nil"}
	local api_name = {
		"camera", "clip", "cls", "color", "pal", "palt",
		"fillp", "flip", "line", "rect", "rectfill",
		"oval", "ovalfill", "circ", "circfill",
		"pget", "pset", "print", "printh", "cursor",
		"map", "tline", "spr", "sspr",

		"peek", "peek2", "peek4", "poke", "poke2", "poke4",
		"memset", "memcpy",

		"sub", "chr", "ord", "split", "tostr", "tonum",	
		"add", "del", "deli", "all", "foreach", "pairs",
		
		"reset", "yield", "time", "stat",
		"btn", "btnp",

		"cos", "sin", "atan2", "sqrt", "srand", "rnd",
		"max", "min", "mid", "flr", "ceil", "sgn", "abs"
	}
	for i=1,#reserved do
		identcol[reserved[i]] = "e"
	end
	for i=1,#api_name do
		identcol[api_name[i]] = "b"
	end
	for i=1,#reserved_val do
		identcol[reserved_val[i]] = "c"
	end

	local multi_catcol ={[3] = "d", [4] = "c"} -- multiline categories take priority
	local catcol={[0]="7","6","c","d", "c", "7"}

	local function highlight_line(line, token_state)

		if (not line) return

		if (not content.syntax_highlighting) return line

		local pos = 1
		local out = ""
		
		while (pos <= #line) do
			local str, pos1, cat
			str, pos1, cat, token_state = tokenoid(line, pos, token_state)
			
			if (not str) then return out end
			local colstr = multi_catcol[cat] or identcol[str] or catcol[cat] or ""
			out = out .. "\f" .. colstr .. str
			pos = pos1
		end

		return out,token_state
	end

	------------------------------------------------------------------------------------

	-- hydrate can invalidate total height
	local total_height = nil

	--[[
		hydrate()
		applies syntax hydrateing, pod embedding, pn markup 
		to do: handle markup. need 2 standard banks of fonts

		renderable   -- the thing to render (could be a userdata)
		draw_h       -- height of the item
		text_src     -- invalid when no longer matches (need to recalcuate)
		token_state0 -- state of tokenoidizer ad start of line (should match previous line when valid)
		token_state  -- state of tokenoidizer (optional) after line

	]]
--	local function hydrate(line, token_state)

	local function hydrate(i, from)

		if (i > #text) return -- safety

		-- no need
		if (
			hydrated[i] and 
			hydrated[i].text_src == text[i] and
			(i == 1 or (hydrated[i-1] and hydrated[i-1].token_state == hydrated[i].token_state0))
		) 
		then
			return
		end

		-- always invalidate total height when something is hydrated
		total_height = nil

		-- make sure previous line is hydrated
		if (i > 1) then
			hydrate(i-1, i)
			-- safety
			if (not hydrated[i-1]) return
		end


		--[[
			-- debug: show reason hydration is happening

			local reason = "unknown reason"
			if (not hydrated[i]) then reason = "not hydrated yet"
			elseif (hydrated[i].text_src != text[i]) then reason = "text_src changed"
			elseif (not hydrated[i-1]) then reason = "previous lie not hydrated"
			elseif (hydrated[i-1].token_state != hydrated[i].token_state0) then reason = "previous token_state doesn't match"
			end

			printh("hydrating: "..i.."   (from: "..(from or "")..") because "..reason)
		]]

		local token_state = i > 1 and hydrated[i-1].token_state or 0
		local line = text[i]

		local item = {
			text_src = line,
			token_state = token_state,
			token_state0 = (i == 1 or not hydrated[i-1]) and 0 or hydrated[i-1].token_state,
			-- draw_y includes the top margin
			draw_y = i > 1 and (hydrated[i-1].draw_y + hydrated[i-1].draw_h) or margin_top
		}

		hydrated[i] = item

		-- pod
		if (content.embed_pods and sub(line,1,7) == "--[[pod") then
			item.renderable = unpod(line)
			if (type(item.renderable) == "userdata") then
				item.draw_h = item.renderable:height() + 4 -- give 4 pixels margin below image
				return
			else
				item.renderable = line
			end
		end
		
		-- marked up line
		if (content.markup and (not content.syntax_highlighting or (token_state >> 8) == 3)) then

			-- when syntax highlight is on, only apply markup when inside a comment!
			-- for multiline string: (token_state >> 8) == 3
			
			local marked_up_line = apply_markup(line)
			local x1, y1 = print(marked_up_line, 0, -1000)

			if (token_state >= 256) marked_up_line = "\fd"..marked_up_line -- commented markup should still be commented colour

			-- still need to do highlighting to close comment block. consider: "# foo ]]"
			-- (alternative strategy: apply_markup() can return nil)
			if (content.syntax_highlighting) _, item.token_state = highlight_line(line, token_state)

			item.has_markup = true
			item.renderable = marked_up_line
			item.draw_h = y1 + 1000
			return
		
		end

		-- syntax highlighted line

		item.renderable, item.token_state = highlight_line(line, token_state)
		item.token_state = item.token_state or 0

		local x1, y1 = print(item.renderable, 0, -1000)
		if (y1) item.draw_h = y1 + 1000
	end
	

		
	



	-- visible_x / visible_y: minimum distance from cusor to edge
	-- e.g. when searching, want to see above and below
	-- with 12px minimum edge disance, means can also drag-scroll-select more easily
	local function show_cursor(visible_x, visible_y)

		visible_x = visible_x or 12
		visible_y = visible_y or 12

		hydrate(cur_y) -- might cause a delay while hydrating a bunch of earlier lines

		if (not hydrated[cur_y]) return -- to do: how/when does this happen?

		local xx = find_x_for_cur_x(cur_x, text[cur_y]) -- raw text
		local yy = hydrated[cur_y].draw_y

		if (not xx or not yy) return

		content.y = mid (-(yy - visible_y), content.y, -(yy - (container.height - margin_top) + char_h + 4 + visible_y))
		content.x = mid (-(xx - visible_x), content.x, -(xx - (container.width - margin_left) + char_w + 8 + visible_x))

		--printh(xx)

		content.clamp_scrolling()

	end

	local function center_cursor(q)

		visible_x = 12
		visible_y = 12

		-- dupe
		hydrate(cur_y) -- might cause a delay while hydrating a bunch of earlier lines
		if (not hydrated[cur_y]) printh("couldn't center 1") return -- to do: how/when does this happen?
		local xx = find_x_for_cur_x(cur_x, text[cur_y]) -- raw text
		local yy = hydrated[cur_y].draw_y
		if (not xx or not yy) printh("couldn't center 2") return

		content.y = -yy + container.height * (1-q)
		content.x = 0 ---yy + container.height/2

		content.clamp_scrolling()

	end



	-- safety; shouldn't happen
	local function contain_cursor()
		if (not text or #text == 0) text = {""}
		cur_y = mid(1, cur_y, #text)
		cur_x = mid(1, cur_x, #text[cur_y] + 1)
	end

	local function is_something_selected()
		return sel[2].line > sel[1].line or (sel[2].line == sel[1].line and sel[2].char >= sel[1].char)
	end
	
	-- scrollbars calls this if it exists  -- UPDATE: nope; scrollbars not resposible for clamping at all
	-- just always clamp internally. (so clamp_scrolling is not a special name here)
	function content:clamp_scrolling()
		local max_y = max(0, content.height - container.height)
		content.y = mid(0, content.y, -max_y)
		content.x = min(0, content.x)

		if (content.block_scrolling) then
			content.x = 0
			content.y = 0
		end
	end

	function content:draw()

		-- rhs: clip at container (hack so that don't need to calculate content width)
		poke2(0x552c, container.sx + container.width)

		-- draw tabs relative to home
		poke(0x4005, (@0x4005) | 0x2)

		-- line number background
		if (self.show_line_numbers) then
			rectfill(0, 0, 26, self.height, 16)
		end
		
		local x = margin_left
		local y = margin_top 
		local inside_comment = false
		local something_selected = is_something_selected()

		local start_i = mid(1, find_cur_y_for_click(0 - content.y),       #text)
		local end_i   = mid(1, find_cur_y_for_click(container.height - content.y),  #text)

		-- draw_y includes the top margin
		y = (hydrated[start_i] and hydrated[start_i].draw_y or margin_top)

		for i= start_i, end_i do

			-- draw selection
			-- to do: how to display \n?
			if (sel and i >= sel[1].line and i <= sel[2].line) then
				
				local c0 = i > sel[1].line and 1 or sel[1].char
				local c1 = i < sel[2].line and #text[i] or sel[2].char
				if (c1 >= c0 or (text[i]=="" and sel[1].line ~= sel[2].line)) then -- c1==c0 means single character selected   except "" (means \n)
					local sx0 = margin_left + get_sx_for_cur_x(text[i], c0-1)
					local sx1 = margin_left + get_sx_for_cur_x(text[i], c1)-1
					rectfill(sx0, y + cursor_y0, sx1, y + cursor_y1, 10)
				end
			end


			-- =====================================================
			-- print line
			-- =====================================================

			local y0 = y

			-- print line number on left
		
			--clip()
			if (self.parent.show_line_numbers) then
				print(string.format("%4d",i), 3, y, 1)
			end

			-- validate line to print; might propagate backwards
			hydrate(i)

			-- safety
			if (not hydrated[i]) return -- nothing much can do

			local y1 = 0

			-- record where it was drawn (used for cursor_y -> line_index lookup)
			hydrated[i].draw_x = x
			hydrated[i].draw_y = y

			if (cur_y == i or (sel[1].line <= i and sel[2].line >= i)) then

				-- cursor is over, or selection covers that line
				--> show raw text (but still with syntax highlighting when enabled)

				local token_state = hydrated[i-1] and hydrated[i-1].token_state or 0

				-- highlight text outside of a comment (when it doesn't have any markup)
				-- i.e. regular code should still be highlighted as usual when the cursor is over it
--[[
				local highlighted_line = 
					(content.syntax_highlighting and type(hydrated[i].renderable) == "string" and not hydrated[i].has_markup) and
					highlight_line(text[i], token_state) or text[i]
				_,y1 = print(highlighted_line, x, y, editing_line_col)
]]

				if (type(hydrated[i].renderable) == "userdata" or hydrated[i].has_markup) then
					-- show true form
					_,y1 = print(text[i], x, y, editing_line_col)
				else
					-- show as usual (just highlighting)
					_,y1 = print(hydrated[i].renderable, x, y, content.fgcol)
				end

			else

				if (type(hydrated[i].renderable) == "userdata") then
					-- embedded pod; only happens when content.embed_pods is true					
					spr(hydrated[i].renderable, x, y)
				else
					-- text [with markup]
					_,y1 = print(hydrated[i].renderable, x, y, content.fgcol)
				end

			end

			-- move cursor down
			-- if hydrated height is greater, use that -- so that page doesn't jump around when cursor goes on/off
			y = max(y1, hydrated[i].draw_h and (y + hydrated[i].draw_h) or 0)

			-- cursor: when no selection and has focus
			if (content:has_keyboard_focus() and _has_focus and i == cur_y and not something_selected and t()%0.5 < 0.25) then
				local sx = x
				local sy = y0
				if (cur_x > 1) then
					local substr = sub(text[i], 1, cur_x-1)
					sx = print(substr,x,-100)
				end
				
				rectfill(sx, sy + cursor_y0, sx+char_w-1, sy+cursor_y1, 14)

			end
			
		end

	end



	local function insert_string(orig, pos, str)
		if (not orig or not pos or not str) return
		str = tostr(str)
		return sub(orig, 1, pos-1) .. tostr(str) .. sub(orig, pos)
	end

	local function insert_multiline_string(str, y, x)

		if (type(str) ~= "string") return

		local lines = split(str, "\n", false) -- false for no mixed types (numbers also returned as strings)

		if (#lines == 1) then
			-- printh("just one line")
			text[y] = insert_string(text[y], x, str)
			cur_x += #str
			return
		end

		-- 1. split -- same as pressing enter

		local nl = #lines - 1

		-- printh("inserting "..nl.." lines")

		for i=#text + nl, cur_y + 1, -1 do
			text[i] = text[i - nl]
		end

		
		text[cur_y + nl] = lines[#lines] .. sub(text[cur_y], cur_x)
		text[cur_y] = sub(text[cur_y], 1, cur_x-1) .. lines[1]

		for i=2, #lines-1 do
			text[cur_y + i - 1] = lines[i]
		end

		cur_y += nl
		cur_x = #lines[#lines] + 1

		hydrate_y = y

	end

	local function delete_string(orig, pos0, pos1)
		return sub(orig, 1, pos0-1) .. sub(orig, pos1+1)
	end
	local function insert_line(pos, str)
		for i=#text+1, pos+1, -1 do
			text[i] = text[i-1]
		end
		text[pos] =  str or ""
	end
	local function delete_line(pos)
		local n = #text
		for i=pos,n do
			text[i] = text[i+1] -- last one will be nil
		end
	end
	local function delete_char()
		if (cur_x == 1) then
			-- join w/ previous line
			if (cur_y > 1) then
				cur_x = #text[cur_y-1] + 1
				text[cur_y-1] = text[cur_y-1] .. text[cur_y]
				delete_line(cur_y)
				cur_y = cur_y - 1
			end
		else
			text[cur_y] = delete_string(text[cur_y], cur_x-1, cur_x-1)
			cur_x = cur_x - 1
		end
	end

	

	local function deselect()
		set_selection{{line=0, char=0}, {line=0, char=-1}}
	end

	local function get_selected_text()

		local str = ""

		if (not is_something_selected()) return ""

		if (sel[1].line == sel[2].line) then
			return sub(text[sel[1].line], sel[1].char, sel[2].char)
		end

		str ..= (sub(text[sel[1].line], sel[1].char) or "") .. "\n"
		for i = sel[1].line + 1, sel[2].line - 1 do
			str ..= text[i] .. "\n"
		end
		str ..= (sub(text[sel[2].line], 1, sel[2].char) or "")

		return str

	end



	local function delete_selected()

		if (not is_something_selected()) then return end

		local l0 = sel[1].line + 1
		local l1 = sel[2].line

		cur_x = sel[1].char
		cur_y = sel[1].line

		-- perfectly delete from start of line0 to end of line1 --> don't keep first line
		if (sel[1].char == 1 and sel[2].char == #text[sel[2].line]) then
			l0 = sel[1].line
		end

		-- 1. join start of line0 and end of line1
		text[sel[1].line] = (sub(text[sel[1].line], 1, sel[1].char - 1) or "") .. (sub(text[sel[2].line], sel[2].char + 1) or "")
		
		-- 2. remove anything inbetween

		local n = l1 - l0 + 1 -- number of lines to delete

		if (n > 0) then
			for i = l0, #text do
				text[i] = text[i + n]
			end
		end
		
		deselect()

		if (#text == 0) then
			text = {""}
		end

	end




	local function extend_selection_to_cursor()

		sel[2] = {line = cur_y, char = cur_x}
		
		-- copy initalial position (might swap)
		sel[1].line, sel[1].char = sel[3].line, sel[3].char
		
		-- swap so that start is always first
		if (sel[2].line < sel[1].line or
			(sel[2].line == sel[1].line and sel[2].char < sel[1].char))
		then
			sel[1].line, sel[2].line = sel[2].line, sel[1].line
			sel[1].char, sel[2].char = sel[2].char, sel[1].char
		end

		-- half open
		sel[2].char = sel[2].char - 1
		if (sel[2].char < 1 and sel[2].line > 1) then
			sel[2].line -= 1
			sel[2].char = #text[sel[2].line]
		end

	end

	function content:get_cursor()
		return cur_x, cur_y
	end


	function content:set_cursor(x,y)
		if (not x and not y) then
			-- set based on mouse
			local mx, my = mouse()
			-- printh(string.format("mx %d my %d", mx, my))
			mx -= container.sx
			my -= container.sy
			-- printh(string.format(" --> mx %d my %d", mx, my))
			local cy = find_cur_y_for_click(my)
			cur_y = mid(1, cy, #text)
			cur_x = find_cur_x_for_click(mx - margin_left, text[cur_y])
			deselect()
			show_cursor()
			return
		end

		if (x) cur_x = x
		if (y) cur_y = y

		show_cursor() -- always show
	end

	function content:center_cursor(...)
		-- experimental; disable for now
		--center_cursor(...)
	end


	------------------------------------------------------------------------------------------------
	-- update
	------------------------------------------------------------------------------------------------

	
	local function get_total_height()

		-- current total is valid
		if (total_height) return total_height

		-- re-calculate (only happens after something was hydrated)
		total_height = 0
		for i=1,#text do
			total_height += (hydrated[i] and hydrated[i].draw_h) or char_h
		end

		return total_height
	end

	-- deleteme -- hydration should be 100% lazy
	local function hydrate_all()
		for i=1,#text do
			hydrate(i)
		end
	end


	----------------------------------------------------------------------------------------------------------------

	local function checkpoint()
		--printh("@ checkpoint")
		undo_stack:checkpoint()
	end

	local last_line_y = -1
	local function backup_line_edit()
		-- to do: should be whitespace check
		if (cur_y ~= last_line_y or ((sub(text[cur_y],cur_x-1,cur_x-1) == " ") != (sub(text[cur_y],cur_x,cur_x) == " "))) then
			checkpoint()
		end
		last_line_y = cur_y
	end



	local function strchr(s, c)
		return string.find (s, c, 1, true)
	end

	local function get_char_cat(c)
		if (strchr("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_", c)) return 1
		if (ord(c) >= 128 or ord(c) < 0) return 1

		-- pico-8 0.2.4d: added some operators for pico-8 help system
		if (strchr("@%$", c)) return 3
		if (strchr("#^?", c)) return 4
		if (strchr("(){}[]<>", c)) return 5
		
		if (strchr("!@#$%^&*:;.,~=+-/\\`'\"", c)) return 2;

		return 6 -- something else. whitespace
	end

	local function select_from_double_tap(line, pos, sel)

		checkpoint()

		local cat = get_char_cat(sub(line,pos,pos))
		
		local sel0 = pos;
		local sel1 = pos;
		
		
		while (sel0 > 1 and get_char_cat(sub(line,sel0-1,sel0-1)) == cat) do
			sel0 -= 1
		end

		while (sel1 < #line and get_char_cat(sub(line,sel1+1,sel1+1)) == cat) do
			sel1 +=1
		end

		set_selection{{line=cur_y, char=sel0}, {line=cur_y, char=sel1}}

	end


	local function calculate_skip_steps(dir)
		
		local line = text[cur_y]
		
		-- normal cursor movement: one character at a time
		if not key("ctrl") then
			if (dir < 0 and (cur_y > 1 or cur_x > 1)) return -1
			if (dir > 0 and (cur_y < #text or cur_x <= #line)) return 1
			return 0;
		end

		

		local pos = cur_x
		local cat0 = 0 -- unknown starting category
		
		while ((dir < 0 and pos > 1) or (dir > 0 and pos <= #line)) do

			if (dir < 0) pos += dir
			
			-- category of current char
			cat = get_char_cat(sub(line,pos,pos));
			
			-- found a character that disagrees with starting category -> end of span
			if ((cat0 > 0) and (cat != cat0)) then
				if (dir > 0 and pos > 0) pos -= 1
				return (pos - cur_x) + 1
			end

			if (cat0 == 0 and cat != 0) then		
				cat0 = cat
			end

			if (dir > 0) pos += dir
		end

		if (dir > 0 and pos > 1) pos -= 1

		return pos - cur_x
	end



	local function indent_selection()

		checkpoint()

		if (key("shift")) then
			for i=sel[1].line,sel[2].line do
				if (ord(text[i],1) == 9) then
					text[i] = sub(text[i],2)
					if (i == sel[1].line) sel[1].char -= 1
					if (i == sel[2].line) sel[2].char -= 1
				end
			end
		else

			for i=sel[1].line,sel[2].line do
				text[i] = "\009"..text[i]
			end
			sel[1].char += 1
			sel[2].char += 1
		end



	end

	----------------------------------------------------------------------------------------------------------------

	local function search_text(dir, needle)
		local x = cur_x
		local y = cur_y

		if (is_something_selected()) then
			x = sel[2].char
			y = sel[2].line
			-- printh("starting at "..pod(sel[2]))
		end

		local start_x = x
		local start_y = y

		local first = true
		while (first or y != start_y) do

			local x0, x1 = string.find(text[y], needle, x, true)

			if x0 then
				sel[1].line, cur_y = y,  y
				sel[1].char, cur_x = x0, x0
				sel[2] = {line = y, char = x1}
				show_cursor(50, 80)
				return
			end
			y += 1 x = 1
			if (y > #text) y = 1
			first = false
		end

		notify("could not find: "..needle)

	end



	function content:update()

		self.width = 10000 -- hack; don't need to know width [yet]. but need to catch mouse events when scrolled to the right

		if (not self.parent.show_line_numbers) then
			margin_left = 4
		else
			margin_left = 32
		end

		-- rolling hydration (semi-lazy layout evaluation; spread out computation before e.g. jump to end of file)

		for i=1,5 do
			hydrate_y = hydrate_y + 1
			if (hydrate_y > #text) hydrate_y = 1
			hydrate(hydrate_y)
		end
	


		local new_height = max(get_total_height() + 32, container.height) -- 32 px space at the bottom

		if (self.height != new_height) then
			self.height = new_height
			show_cursor()
		end


		content.clamp_scrolling()


		-- don't need to have focus -- can close from anywhere
		if (keyp("escape")) then
			if (container.search_box) then
				close_search_pane(container)
			else
				key_pressed_callback("escape")
			end
		end


		if (self:has_keyboard_focus()) then

			while peektext() do
				backup_line_edit()
				local k = readtext()

				if (type(content.key_callback[k]) == "function") then
					content.key_callback(k)
				else
				
					delete_selected()
					text[cur_y] = insert_string(text[cur_y], cur_x, k)
					cur_x = cur_x + 1
					show_cursor()
				end
			end


			-- tab
			if (keyp("tab")) then

				if key_pressed_callback("tab") then
					-- skip
				elseif (is_something_selected()) then
					indent_selection()
				else
					backup_line_edit()
					local k = "\009"
					delete_selected()
					text[cur_y] = insert_string(text[cur_y], cur_x, k)
					cur_x = cur_x + 1
					show_cursor()
				end
			end

			-- enter
			if (keyp("enter")) then

				if key_pressed_callback("enter") then
					-- skip
				else

					checkpoint()

					-- find tabs & spaces at start to match indentation
					local whitespace=""
					local pos = 1
					while (pos < #text[cur_y] and (sub(text[cur_y], pos, pos) == "\t" or sub(text[cur_y], pos, pos) == " ")) do
						whitespace ..= sub(text[cur_y], pos, pos)
						pos += 1
					end

					--split current line
					insert_line(cur_y + 1, whitespace .. sub(text[cur_y], cur_x))
					text[cur_y] = sub(text[cur_y], 1, cur_x-1)
					cur_x = 1 + #whitespace
					cur_y = cur_y + 1
					show_cursor()
				end
			end

			-- backspace
			if (keyp("backspace")) then
				backup_line_edit()
				if (is_something_selected()) then
					delete_selected()
				else
					delete_char()
				end
				show_cursor()
			end

			-- delete
			if (keyp("del")) then

				backup_line_edit()
				if (is_something_selected()) then
					delete_selected()
				elseif (cur_y < #text or cur_x <= #text[#text]) then
					-- dupe: same as pressing right and then backspace
					if (cur_x > #text[cur_y]) then
						if (cur_y < #text) then
							cur_x = 1
							cur_y = cur_y + 1				
						end
					else
						cur_x = cur_x + 1
					end
		 
					delete_char()
				end
				show_cursor()
			end


			-----------------------------------------------------
			-- cursor navigation
			-----------------------------------------------------
			local pressed_cursor_nav_key = false

			local nav_keys = {"left","right","up","down", "home","end", "pageup","pagedown"}

			for i=1,#nav_keys do
				local k = nav_keys[i]
				if keyp(k) then
					if key_pressed_callback(k) then
						-- callback called for this navigation key: ignore following logic
						clear_key(k)
					else
						pressed_cursor_nav_key = true
					end
				end
			end


			if pressed_cursor_nav_key then

				if (not is_something_selected()) then
					set_selection{{line=cur_y, char=cur_x}, {line=cur_y, char=cur_x-1}}
				end

				show_cursor()
			end


			if (keyp("left")) then
				if (cur_x < 2) then
					if (cur_y > 1) then
						cur_y = cur_y - 1				
						cur_x = #text[cur_y] + 1
					end
				else
					--cur_x = cur_x - 1
					cur_x += calculate_skip_steps(-1)
				end
				
			end
			if (keyp("right")) then
				if (cur_x > #text[cur_y]) then
					if (cur_y < #text) then
						cur_x = 1
						cur_y = cur_y + 1				
					end
				else
					cur_x += calculate_skip_steps(1)
				end
			end
			if (keyp("up") or keyp("pageup")) then
				local n = keyp("pageup") and 20 or 1
				for i=1,n do
					if (cur_y < 2) then
						cur_x = 1
					else
						local xx = find_x_for_cur_x(cur_x, text[cur_y])
						cur_y = cur_y - 1
						cur_x = xx > 0 and 1 + find_cur_x_for_click(xx, text[cur_y]) or 1
						cur_x = mid(1, cur_x, #text[cur_y] + 1)
					end
				end
				contain_cursor()
			end
			if (keyp("down") or keyp("pagedown")) then
				local n = keyp("pagedown") and 20 or 1
				for i=1,n do
					if (cur_y >= #text) then
						cur_x = #text[cur_y]+1
					else
						local xx = find_x_for_cur_x(cur_x, text[cur_y])
						cur_y = cur_y + 1
						cur_x = xx > 0 and 1 + find_cur_x_for_click(xx, text[cur_y]) or 1
						cur_x = mid(1, cur_x, #text[cur_y] + 1)
					end
				end
				contain_cursor()
			end

			if (keyp("home")) then
				if (key"ctrl") cur_y = 1
				cur_x = 1
				show_cursor()
			end

			if (keyp("end")) then
				if (key"ctrl") cur_y = #text
				cur_x = #text[cur_y]+1
				show_cursor()
			end

			
			if (pressed_cursor_nav_key) then

				-- hold shift to extend
				if (key("shift")) then
					extend_selection_to_cursor()
				else
					deselect()
				end

				-- keep cursor visible
				show_cursor()
			end


			-- ctrl-* presses

			if (key("ctrl")) then

				if keyp("x") and is_something_selected() then
					checkpoint()
					set_clipboard(get_selected_text())
					delete_selected()
				end

				if keyp("c") and is_something_selected() then
					set_clipboard(get_selected_text())
				end

				if keyp("v") then
					checkpoint()
					delete_selected()
					insert_multiline_string(get_clipboard(), cur_y, cur_x)
					show_cursor()
				end

				if keyp("z") then
					undo_stack:undo()
				end

				if keyp("y") then
					undo_stack:redo()
				end

				if keyp("a") then
					set_selection{{line=1, char=1}, {line=#text, char=#text[#text]}}
				end
				
				if keyp("f") and content.has_search then
					open_search_pane(container, function ()
						local needle = container.search_field:get_text()[1]
						container.last_search_str = needle
						search_text(1, needle)	
					end)
				end

				if keyp("g") and container.last_search_str then
					search_text(1, container.last_search_str)
				end

			end

			-- cproj file -> save every keypress!
			-- to do: "about_to_run_cproj" message on pressing ctrl-r, or something
			-- (and save when leave focus or idle)

			-- any keypress that is not shift or ctrl
			local found_keypress = false
			for i=1,255 do
				if (keyp(i) and i~= 225 and i~=57) found_keypress = true
			end


		end -- keyboard focus

		contain_cursor()

--		printh(string.format("cpu %.3f",stat(1)),440,2,7)

	end



	-- ======================================================================================================================

	----------------------------------------------------------------------------------------
	-- undo
	----------------------------------------------------------------------------------------


	-- don't want to unpod(pod(text)) because only need separate copy of string references

	local function duplicate_text_table(text)
		local t2={}
		for i=1,#text do
			t2[i] = text[i]	
		end
		return t2
	end

	undo_stack = create_undo_stack(
		function() return {
			duplicate_text_table(text),
			cur_x,
			cur_y,
			content.x,
			content.y,
			pod(sel)
		} end,

		function(s)
			text = s[1] 
			cur_x = s[2]
			cur_y = s[3]
			content.x = s[4]
			content.y = s[5]
			sel = unpod(s[6])

			show_cursor()
		end
	)

	

	-------------------------------------------------------------------------------------------------------------------------


	-- to do: how to manage scroll speed?
--[[
	function content:mousewheel(msg)
		if (key("ctrl")) then
			self.x += msg.wheel_y * 32 
		else
			self.y += msg.wheel_y * 32 
		end

	end
]]
	


	function content:click(msg)
		self:set_keyboard_focus(true)
		local cy = find_cur_y_for_click(msg.my)
		if (cy ~= cur_y) checkpoint()
		cur_y = mid(1, cy, #text)
		cur_x = find_cur_x_for_click(msg.mx - margin_left, text[cur_y])
		if (key("shift")) then
			-- add to selection
			sel[2] = {line=cur_y, char=cur_x-1}
		else
			-- no selection: start new one
			set_selection{{line=cur_y, char=cur_x}, {line=cur_y, char=cur_x-1}}
		end
		show_cursor()
	end

	function content:doubletap(msg)


		local cy = find_cur_y_for_click(msg.my)
		cur_y = mid(1, cy, #text)
		cur_x = find_cur_x_for_click(msg.mx - margin_left, text[cur_y])

--		printh("@@ content:doubletap cur_y: "..cur_y)

		select_from_double_tap(text[cur_y], cur_x, sel)

	end


	function content:drag(msg)
		-- dupe from click
		local cy = find_cur_y_for_click(msg.my)
		cur_y = mid(1, cy, #text)
		cur_x = find_cur_x_for_click(msg.mx - margin_left, text[cur_y])
		extend_selection_to_cursor()
		show_cursor()
	end

	
	-------------------------------------------------------------------------------------------------------------------------


	--[[
		allow caller to operate only only content
		ce = gui:attach_text_editor()
		ce:attach_scrollbars()  -- instead of ce.parent:attach_scrollbars()
	]]
	function content:attach_scrollbars(...)
		self.parent:attach_scrollbars(...)
	end

	
	-- container:attach_scrollbars()
	-- return container

	return content
end






:: lib/head.lua
--[[

	head.lua -- kernal space header for each process
	(c) Lexaloffle Games LLP

]]

do

local _stop = _stop
local _mkdir = _mkdir
local _print_p8scii = _print_p8scii
local _map_ram = _map_ram
local _ppeek = _ppeek
local _create_process_from_code = _create_process_from_code
local _unmap_ram = _unmap_ram
local _store_metadata = _store_metadata
local _fdelete = _fdelete
local _apply_system_settings = _apply_system_settings
local _get_process_display_size = _get_process_display_size
local _run_process_slice = _run_process_slice
local _fetch_local = _fetch_local
local _get_clipboard_text = _get_clipboard_text
local _blit_process_video = _blit_process_video
local _set_clipboard_text = _set_clipboard_text
local _req_clipboard_text = _req_clipboard_text
local _set_spr = _set_spr
local _ppeek4 = _ppeek4
local _fetch_metadata = _fetch_metadata
local _store_local = _store_local
local _set_draw_target = _set_draw_target
local _get_process_list = _get_process_list
local _pod = _pod
local _kill_process = _kill_process
local _read_message = _read_message
local _fcopy = _fcopy
local _draw_map = _draw_map
local _halt = _halt

local _fetch_local = _fetch_local
local _fetch_remote = _fetch_remote
local _fetch_anywhen = _fetch_anywhen
local _fetch_remote_result = _fetch_remote_result
local _store_local = _store_local
local _signal = _signal


function reset()

	-- reset palette (including scanline palette selection, rgb palette)

	pal()

	-- line drawing state

	memset(0x551f, 0, 9)

	-- bitplane masks

	poke(0x5508, 0x3f) -- read mask    //  masks raw draw colour (8-bit sprite pixel or parameter)
	poke(0x5509, 0x3f) -- write mask   //  determines which bits to write to
	poke(0x550a, 0x3f) -- target mask  //  (sprites)  applies to colour table lookup & selection
	poke(0x550b, 0x00) -- target mask  //  (shapes)   applies to colour table lookup & selection

	-- draw colour

	color(6)

	-- fill pattern 0x5500

	fillp()

	-- fonts (reset really does reset everthing!)

	poke(0x5f56, 0x40) -- primary font
	poke(0x5f57, 0x56) -- secondary font
	poke(0x4000,get(fetch"/system/fonts/lil.font"))
	poke(0x5600,get(fetch"/system/fonts/p8.font"))

	-- set tab width to be a multiple of char width

	poke(0x5606, (@0x5600) * 4)
	poke(0x5605, 0x2)             -- apply tabs relative to home

	-- mouselock event sensitivity, move sensitivity (64 means x1.0)
	poke(0x5f28, 64)
	poke(0x5f29, 64)


end


local function init_runtime_state()

	-- experiment: always start with a display
	-- should be able to start drawing stuff in _init!
	-- extra 128k per process, but not many headless processes
--[[
	_disp = userdata("u8", 480, 270)
	memmap(0x10000, _disp)
	set_draw_target() -- reset target to display\
	poke2(0x5478, 480, 270)
	poke (0x547c, 0)  -- video mode
]]

	-- runtime state
	srand()

	-- default map
	memmap(0x100000, userdata("i16", 32, 32))

	-- reset() does most of the work but doesn't reset entire runtime state (maybe it should?)
	reset()

end


local function get_short_prog_name(p)
	if (not p) then return "no_prog_name" end
	--p = split0(p, "/")
	p = split(p, "/", false)
	p = p[#p]
	--p = split0(p, ".")[1]
	p = split(p, ".", false)[1]
	return p
end

function create_process(prog_name, env_patch, do_debug)

	prog_name = fullpath(prog_name)

	-- .p64 files: find boot file in root of .p64 (and thus set default path there too)
	local boot_file = prog_name
	if  string.sub(prog_name,-4) == ".p64"     or 
		string.sub(prog_name,-8) == ".p64.rom" or
		string.sub(prog_name,-8) == ".p64.png"
	then
		boot_file ..= "/main.lua"

		-- only check runtime on carts; not stored on lua files
		local meta = fetch_metadata(prog_name)
		if (meta and type(meta.runtime) == "number" and meta.runtime > stat(5)) then
			notify("** warning: running cartridge with future runtime version **")
		end
	end

--	printh("create_process "..prog_name.." ("..boot_file..") env: "..pod(env_patch))

	--===== construct new environment table if needed ======

--	local new_env = env() and unpod(pod(env())) or {}
	local new_env = {} -- don't inherit anything! env means "launch parameters"

	-- default path is same directory as boot file
	local segs = split(boot_file,"/",false)
	local program_path = string.sub(boot_file, 1, -#segs[#segs] - 2)


	-- deleteme
--	new_env.pwd = string.sub(boot_file, 1, -#segs[#segs] - 2)

	-- add new attributes from env_patch (note: can copy trees)
	if (env_patch) then
		for k,v in pairs(env_patch) do
			new_env[k] = v
		end
	end


	-- when corunning, start in folder of corun program
	-- needs to happen here so that load_resources has the correct path
	-- to do: shouldn't terminal be able to have its own resources / includes?
	if (new_env.corun_program) then
		local ppath = fullpath(new_env.corun_program)
		local segs = split(ppath,"/",false)
		program_path = string.sub(ppath, 1, -#segs[#segs] - 2)
	end


	
	-- add system env info


	new_env.prog_name = prog_name
	new_env.title = get_short_prog_name(prog_name)
	new_env.parent_pid = pid()
	new_env.argv = new_env.argv or {} -- guaranteed to exist at least as an empty table

	local str = [[
		
		do
			local head_code = load(fetch("/system/lib/head.lua", "@/system/lib/head.lua", "t", _ENV))
			if (not head_code) then printh"*** ERROR: could not load head. borked file system / out of pfile slots? ***" end
			head_code()
		end

		include("/system/lib/legacy.lua")
		include("/system/lib/api.lua")
		include("/system/lib/events.lua")
		include("/system/lib/gui.lua")
		include("/system/lib/app_menu.lua")
		include("/system/lib/wrangle.lua")

		include("/system/lib/jettison.lua")
		
		
		-- pass along environment. env() return value is read-only-ish
		
		function env() 
			return ]]..pod(new_env,0x0)..[[
		end
		
		-- always start in program path
		cd("]]..program_path..[[")

		-- autoload resources (must be after setting pwd)
		include("/system/lib/resources.lua")

		-- to do: preprocess_file() here // update: no need!
		include("]]..boot_file..[[")

		-- footer; includes mainloop
		include("/system/lib/foot.lua")

	]]

	-- printh("create_process with env: "..pod(env))

	local proc_id = _create_process_from_code(str, get_short_prog_name(prog_name))

	
	if (not proc_id) then
		
		return nil
	end

--	printh("$ created process "..proc_id..": "..prog_name.." ppath:"..program_path)

	if (env_patch and env_patch.window_attribs and env_patch.window_attribs.pwc_output) then
		store("/ram/system/pop.pod", proc_id) -- present output process
	end

	return proc_id

end

-- manage process-level data: dispay, env

	-- hidden from userland program
	local _disp = nil
	local _target = nil

	-- default to display
	function set_draw_target(d)
		d = d or _disp

		--printh("setting draw target to:"..tostr(d))
		local ret = _target
		_target = d
		_set_draw_target(d)

		-- map to 0x60000 automatically? nope -- user should decide to do this / wrap set_draw_target()
		-- and in most cases, target is _disp and drawing straight to 0x10000 anyway.
		-- let window manager handle frame holding

		-- but.. want to poke(0x10000, 8) in terminal / when running on top of terminal.
		-- maybe "draw_target" /is/ "display". np if wm is holding frames.
		-- up to user to set_draw_target() before end of _draw()
		-- (or happens automatically in mainloop)

		if (d ~= nil) then
			memmap(0x10000, d)
		end

		return ret

	end

	function get_draw_target()
		return _target
	end

	-- used to have a set_display to match, but only need get_display(). (keep name though; display() feels too ambiguous)
	function get_display()
		return _disp
	end

	-- starting environment: none; overwritten by injected process code
	function env() return {} end

	---------------------------------------------------------------------------------------------------

	local first_set_window_call = true

	local function set_window_1(attribs)

		-- to do: shouldn't be needed by window manager itself (?)
		-- to what extent should the wm be considered a visual application that happens to be running in kernel?
		-- if (pid() <= 3) return

		attribs = attribs or {}


		-- on first call, observe attributes from env().window_attribs
		-- they **overwrite** any same key attributes passed to set_window
		-- (includes pwc_output set by window manager)

		if (first_set_window_call) then

			first_set_window_call = false
		
			if type(env().window_attribs) == "table" then
				for k,v in pairs(env().window_attribs) do
					attribs[k] = v
				end
			end

			-- set the program this window was created with (for workspace matching)

			attribs.prog = env().prog_name
			
			-- first call: decide on an initial window size so that can immediately create display

			-- default size: fullscreen (dimensions set below)
			if not attribs.tabbed and (not attribs.width or not attribs.height) then
				attribs.fullscreen = true
			end

			-- not fullscreen, tabbed or desktop, and (explicitly or implicitly) moveable -> assume regular moveable desktop window
			if (not attribs.fullscreen and not attribs.tabbed and not attribs.wallpaper and
				(attribs.moveable == nil or attribs.moveable == true)) 
			then
				if (attribs.has_frame  == nil) attribs.has_frame  = true
				if (attribs.moveable   == nil) attribs.moveable   = true
				if (attribs.resizeable == nil) attribs.resizeable = true
			end


			-- wallpaper has a default z of -1000
			if (attribs.wallpaper) then
				attribs.z = attribs.z or -1000 -- filenav is -999
			end


		end

		-- video mode implies fullscreen

		if (attribs.video_mode) then
			attribs.fullscreen = true
		end


		-- setting fullscreen implies a size and position

		if attribs.fullscreen then
			attribs.width = 480
			attribs.height = 270
			attribs.x = 0
			attribs.y = 0
		end

		-- setting tabbed implies a size and position  // but might be altered by wm

		if attribs.tabbed then
			attribs.fullscreen = nil
			attribs.width = 480
			attribs.height = 248+11
			attribs.x = 0
			attribs.y = 11
		end

		-- setting new display size
		if attribs.width and attribs.height then

			local scale = 1
			if (attribs.video_mode == 3) scale = 2 -- 240x135
			if (attribs.video_mode == 4) scale = 3 -- 160x90
			local new_display_w = attribs.width  / scale
			local new_display_h = attribs.height / scale


			local w,h = -1,-1
			if (get_display()) then
				w = get_display():width()
				h = get_display():height()
			end

			-- create new bitmap when display size changes
			if (w != new_display_w or h != new_display_h) then
				-- this used to call set_display(); moved inline as it should only ever happen here

				_disp = userdata("u8", new_display_w, new_display_h)
				memmap(0x10000, _disp)
				set_draw_target() -- reset target to display

				-- set display attributes in ram
				poke2(0x5478, new_display_w)
				poke2(0x547a, new_display_h)

				poke (0x547c, attribs.video_mode or 0)

				poke(0x547f, peek(0x547f) & ~0x2) -- safety: clear hold_frame bit
				-- 0x547d is blitting mask; keep previous value
			end
		end

		send_message(3, {event="set_window", attribs = attribs})

	end

	-- set preferred size; wm can still override
	function window(w, h, attribs)

		-- this function wrangles parameters;
		-- set_window_1 doesn't do any further transformation / validation on parameters

		if (type(w) == "table") then
			attribs = w
			w,h = nil,nil

			-- special case: adjust position by dx, dy
			-- discard other 
			if (attribs.dx or attribs.dy) then
				send_message(3, {event="move_window", dx=attribs.dx, dy=attribs.dy})
				return
			end

		end

		attribs = attribs or {}
		attribs.width = attribs.width or w
		attribs.height = attribs.height or h

		return set_window_1(attribs)
	end
	
------- standard library   -----  (see also api.lua for temporary api implementation for functions that should be rewritten in C)

--  deleteme
--	load_54 = load
--	loadstring = load
--	load = load_object -- to do: don't use load for anything -- too ambiguous and confusing! just "fetch" 


	-- to do: remove use of _get_system_global when these values are standardized
--[[
	local sys_global = {
		pm_proc_id = 2,
		wm_proc_id = 3,
		cart_path = "/ram/cart"
	}
	function _get_system_global(k)
		if (sys_global[k]) return sys_global[k]
		printh("**** _get_system_global failed for key: "..k)
	end
]]

	-- fullscreen videomode with no cursor
	function vid(mode)
		window{
			video_mode = mode,
			cursor = 0
		}
	end

	-- immediately close program & window
	function exit(exit_code)
		if (env().immortal) return
		
		--send_message(pid(), {event="halt"})
		send_message(2, {event="kill_process", proc_id=pid()})
		_halt() -- stop executing immediately
	end

	-- stop executing in a resumable way 
	-- use for debugging via terminal: stop when something of interest happens and then inspect state
	function stop(txt, ...)
		if (txt) print(txt, ...)

		send_message(pid(), {event="halt"}) -- same as pressing escape; goes to terminal
		yield() -- get out of terminal callback (only works if not inside a coroutine ** and doesn't resume at that point **)
	end

	-- any process can kill any other process!
	-- deleteme -- send a message to process manager instead. process manager might want to decline.
	--[[
	function kill_process(proc_id, exit_code)
		send_message(2, {event="kill_process", proc_id=proc_id, exit_code = exit_code})
	end
	]]

	-- 
	function get_clipboard()
		_req_clipboard_text()

		-- ** commented; can't support get_clipboard on web yet
		--flip() -- wait at least one frame (even on binary platforms -- just how it be)

		-- wait up to 10 frames for the browser to separately process ctrl-v (setting codo_textarea contents) 
		for i=1,10 do
			
			local ret = _get_clipboard_text()
			if (ret) then return ret end
			flip()
		end

		return nil -- could not fetch
	end

	function set_clipboard(...)
		return _set_clipboard_text(...)
	end

	-- generate metadata string in plain text pod format
	local function generate_meta_str(meta_p)

		-- use a copy so that can remove pod_format without sideffect
		local meta = unpod(pod(meta_p)) or {}

		local meta_str = "--[["

		if (meta.pod_format and type(meta.pod_format) == "string") then
			meta_str ..= "pod_format=\""..meta.pod_format.."\""
			meta.pod_format = nil -- don't write twice
		elseif (meta.pod_type and type(meta.pod_type) == "string") then
			meta_str ..= "pod_type=\""..meta.pod_type.."\""
			meta.pod_type = nil -- don't write twice
		else
			meta_str ..= "pod"
		end

		local meta_str1 = _pod(meta, 0x0) -- 0x0: metadata always plain text. want to read it!

		if (meta_str1 and #meta_str1 > 2) then
			meta_str1 = sub(meta_str1, 2, #meta_str1-1) -- remove {}
			meta_str ..= ","
			meta_str ..= meta_str1
		end

		meta_str..="]]"

		return meta_str

	end


	function pod(obj, flags, meta)

		-- safety: fail if there are multiple references to the same table
		-- to do: allow this but write a reference marker in C code? maybe don't need to support that!
		local encountered = {}
		local function check(n)
			local res = false
			if (encountered[n]) return true
			encountered[n] = true
			for k,v in pairs(n) do
				if (type(v) == "table") res = res or check(v)
			end
			return res
		end
		if (type(obj) == "table" and check(obj)) then
			-- table is not a tree
			return nil, "error: multiple references to same table"
		end

		if (meta) then
			local meta_str = generate_meta_str(meta)
			return _pod(obj, flags, meta_str) -- new meaning of 3rd parameter!
		end

		return _pod(obj, flags)
	end

	
	local function fix_metadata_dates(result)
		if (result) then
			
			-- time string generation bug that happened 2023-10! (to do: fix files in /system)
			if (type(result.modified) == "string" and tonumber(result.modified:sub(6,7)) > 12) then
				result.modified = result.modified:sub(1,5).."10"..result.modified:sub(8)
			end
			if (type(result.created) == "string" and tonumber(result.created:sub(6,7)) > 12) then
				result.created = result.created:sub(1,5).."10"..result.created:sub(8)
			end

			-- use legacy value .stored if .modified was not set
			if (not result.modified) result.modified = result.stored

		end
	end



	-- fetch and store can be passed locations instead of filenames

	function fetch(location, do_yield, ...)
		local filename, hash_part = table.unpack(split(location, "#", false))

		-- anywhen: used for testing rollback (please don't use this for anything important yet!)
		-- fetch("anywhen://foo.txt@2024-04-05_13:02:27"
		-- to do: allow fetch("foo.txt@2024-04-05_13:02:27") -- shorthand for anywhen://..
		if (string.sub(location, 1, 10) == "anywhen://") then
			local ret, meta = _fetch_anywhen(filename:sub(10)) -- include second '/' to give absolute path 
			return ret, meta, hash_part
		end


		--[[
			remote fetches are logically the same as local ones -- they block the thread
			but.. can be put into a coroutine and polled
		]]
		if (string.sub(location, 1, 8) == "https://" or string.sub(location, 1, 7) == "http://" ) then
			-- blocking call: download

			-- printh("[fetch] calling _fetch_remote: "..filename)
			local job_id, err = _fetch_remote(filename, ...)
			-- printh("[fetch] job id: "..job_id)

			if (err) return nil, err

			local tt = time()

			while time() < tt + 10 do -- to do: configurable timeout.

				-- printh("[fetch] about to fetch result for job id "..job_id)

				local result, meta, hash_part, err = _fetch_remote_result(job_id)

				-- printh("[fetch] result: "..type(result))

				if (result or err) then
					--printh("[fetch remote] returned an obj type: "..type(result).."  // err: "..tostring(err))
					--printh("[fetch remote] err: "..pod(err))
					return result, meta, hash_part, err
				end

				flip(0x1)
				yield() -- allow pollable pattern from program.  to do: review cpu hogging

			end
			return nil, nil, nil, "timeout"

		else
			-- local file
			local ret, meta = _fetch_local(filename, do_yield, ...)
			fix_metadata_dates(meta)
			return ret, meta, hash_part  -- no error
		end
	end

	function mkdir(p)
		if (fstat(p)) return -- is already a file or directory
		local ret = _mkdir(p)
		store_metadata(p, {created = date(), modified = date()}) -- 0.1.0f: replaced stored with modified; not useful as a separate concept
		return ret
	end


	function store(location, obj, meta)

		-- treat web as read-only!
		if (string.sub(location, 1, 8) == "https://") then
			return nil
		end

		-- special case: can write raw .p64 / .p64.rom / .p64.png binary data out to host file without mounting it
		local ext = location:ext()

		if (type(obj) == "string" and (ext == "p64" or ext == "p64.rom" or ext == "p64.png")) then
			rm(location:path()) -- unmount existing cartridge // to do: be more efficient
			return _store_local(location, obj)
		end

		-- ignore location string
		local filename = split(location, "#", false)[1]
		
		-- grab old metadata
		local old_meta = fetch_metadata(filename)
		
		if (type(old_meta) == "table") then
			if (type(meta) == "table") then			
				-- merge with existing metadata.   // to do: how to remove an item?			
				for k,v in pairs(meta) do
					old_meta[k] = v
				end
			end
			meta = old_meta
		end

		if (type(meta) != "table") meta = {}
		if (not meta.created) meta.created = date()
		if (not meta.revision or type(meta.revision) ~= "number") meta.revision = -1
		meta.revision += 1   -- starts at 0
		meta.modified = date()

		-- use pod_format=="raw" if is just a string
		-- (_store_local()  will see this and use the host-friendly file format)

		if (type(obj) == "string") then
			meta.pod_format = "raw"
		else
			-- default pod format otherwise
			-- (remove pod_format="raw", otherwise the pod data will be read in as a string!)
			meta.pod_format = nil 
		end


		local meta_str = generate_meta_str(meta)

		-- /ram/system/settings.pod is special
		if (fullpath(filename) == "/ram/system/settings.pod") then
			-- printh("setting fullscreen: "..tostr(obj.fullscreen))
			_apply_system_settings(obj)
		end

		-- printh("storing meta_str: "..meta_str)

		local result, err_str = _store_local(filename, obj, meta_str)
		
		-- dev: assume no error for now! return stored metadata
		-- return meta -- 0.1.0f: removed; was for debugging
		return nil

	end

	
	
	function fetch_metadata(filename)
		local result = _fetch_metadata(fstat(filename) == "folder" and filename.."/.info.pod" or filename)
		fix_metadata_dates(result)
		return result
	end

	function store_metadata(filename, meta)

		local old_meta = fetch_metadata(filename)
		
		if (type(old_meta) == "table") then
			if (type(meta) == "table") then			
				-- merge with existing metadata.   // to do: how to remove an item? maybe can't! just recreate from scratch if really needed.
				for k,v in pairs(meta) do
					old_meta[k] = v
				end
			end
			meta = old_meta
		end

		if (type(meta) != "table") meta = {}
		meta.modified = date() -- 0.1.0f: was ".stored", but nicer just to have a single, more general "file was modified" value.


		local meta_str = generate_meta_str(meta)

		if (fstat(filename) == "folder") then
			-- directory
			-- printh("writing meta_str to directory: "..meta_str)
			local info_filename = filename.."/.info.pod" 
--			if fstat(info_filename) then
			if false then

				-- modify existing file metadata
				_store_metadata(info_filename, meta_str)
				
			else
				-- create new .info.pod file containing only metadata + content of nil
				_store_local(info_filename, nil, meta_str) 
			end
		else
			_store_metadata(filename, meta_str)
		end
	end


	local _printh = _printh
	local _tostring  = tostring
	function printh(str)
		_printh(string.format("[%03d] %s", pid(), _tostring(str)))
	end

	

	function print(str, x, y, col)

		if (y or (get_display() and not _is_terminal_command)) then
			return _print_p8scii(str, x, y, col)
		end

		-- when print_to_proc_id is not set, send to self (e.g. printing to terminal)
		send_message(env().print_to_proc_id or pid(), {event="print",content=tostr(str)})
		
	end


	sub = string.sub

	-- get filename extension
	-- include double extensions; .p64.png is treated differently from .png
	-- "" is also a legit extension distinct from no extension ("wut." vs "wut")

	function string:ext()
		local loc = split(self,"#",false)[1]
		-- max extension length: 16
		for i = 1,16 do
			if (string.sub(loc,-i,-i) == ".") then
				-- try to find double ext first e.g. .p8.png  but not .info.pod
				for j = i+1,16 do
					if (string.sub(loc,-j,-j) == "/") return string.sub(loc, -i + 1) -- path separator -> return just the single segment
					if (string.sub(loc,-j,-j) == "." and #loc > j) return string.sub(loc, -j + 1)
				end
				return string.sub(loc, -i + 1)
			end
		end
		return nil -- "no extension"
	end

	function string:path()
		return split(self,"#")[1]
	end

	function string:hloc()
		return split(self,"#")[2]
	end

	function string:basename()
		local segs = split(self:path(),"/")
		return segs[#segs]
	end

	function string:dirname()
		local segs = split(self:path(),"/")
		return self:sub(1,-#segs[#segs]-2)
	end

	-- PICO-8 style string indexing;  ("abcde")[2] --> "b"  
	-- to do: implement in lvm.c?
	local string_mt_index=getmetatable('').__index
	getmetatable('').__index = function(str,i) 
		return string_mt_index[i] or _strindex(str,i)
	end

--[[
	local string_mt = getmetatable("")

	setmetatable(string_mt.__index, {__index = function(a,b) return pod{a,b} end})
]]

--	setmetatable(string_mt.__index, {__index = function(a,b) return a end})

--[[
	function string:__index()
		return "zxc"
	end
]]

--	local string_mt = getmetatable("")
--	string_mt.__index.__index = function() return "#" end

--	setmetatable(getmetatable("").__index, {__index=function(s, i) return pod(i) end})

	--[[
		** experimental -- perhaps a bad idea **  

		//  goal: want a simple, transparent, commonly used path for including code

		include is similar to require() but searches:
			1. current path (libraries bundled with program)
			2. /system/lib  (common libraries -- dunno what that would be though! font should be standard)
				// maybe should use pico-8 style #include so can manage .p64.png packaging automatically
				// could just rewrite #include filename as include "filename" in preprocessor! 

		** "include" is a bad name -- included code has scope and can't read parent locals

		related reading: Lua Module Function Critiqued // old module system deprecated in 5.2 in favor of require()
			// avoids multiple module authors writing to the same global environment

			http://lua-users.org/wiki/LuaModuleFunctionCritiqued
			https://web.archive.org/web/20170703165506/https://lua-users.org/wiki/LuaModuleFunctionCritiqued

	]]

	function include(filename)
		local filename = fullpath(filename)
		local src = fetch(filename)

		if (type(src) ~= "string") then 
			notify("could not include "..filename)
			stop()
			return
		end

		local pwd0 = pwd()
		
		-- https://www.lua.org/manual/5.4/manual.html#pdf-load
		-- chunk name (for error reporting), mode ("t" for text only -- no binary chunk loading), _ENV upvalue
		-- @ is a special character that tells debugger the string is a filename
		local func,err = load(src, "@"..filename, "t", _ENV)

		-- syntax error while loading
		if (not func) then 
			-- printh("** syntax error in "..filename..": "..tostr(err))
			--notify("syntax error in "..filename.."\n"..tostr(err))
			send_message(3, {event="report_error", content = "*syntax error"})
			send_message(3, {event="report_error", content = tostr(err)})

			stop()
			return
		end

--[[
		-- method 1. run as a coroutine
		--local res, err = coresume(cocreate(func))

		-- method 2: pcall
		--local res, err = pcall(func)

		if (not res) then
			notify(debug.traceback())
			notify(err) -- will show the filename the runtime error ocurred in			
			--notify(":: runtime error in "..filename)
			stop()
		end
		return res, err
]]

		-- call directly; allows complete stacktrace -- runtime error can be handled in general case
		
		-- hrrm
		-- if (filename:sub(1,12) ~= "/system/lib/") cd(filename:dirname())
			func()
		--cd(pwd0)

		return true -- ok, no error including
	end
	
	-- only for holding reference
	local userdata_ref = {}
	local _current_map = nil

	function memmap(addr, a, offset, len)

		if (_map_ram(addr, a, offset, len)) then
			if (a) then
				userdata_ref[a] = a
				if (addr == 0x100000) _current_map = a
			end
		end

	end

	-- unmap by array
	-- removes all pages mapped to somewhere inside that array.
	-- ** this is the only way to free mapped userdata, even if there are no remaining mapped pages **

	function unmap(a)
		if (type(a) == "userdata") then
				-- remove c-side pointer references
			if _unmap_ram(a) then
				-- _unmap_ram refused to unmap because used in base ram
				return
			end
			
			 -- can release reference and be garbage collected 	
			userdata_ref[a] = nil              
		end

	end


--------------------------------------------------------------------------------------------------------------------------------
--    Sprite Registry
--------------------------------------------------------------------------------------------------------------------------------

	-- sprites are owned by head -- process can assume exists
	local _spr = {} 

	-- add or remove a sprite at index
	-- flags stored at 0xc000 (16k)
	function set_spr(index, s, flags_val)
		index &= 0x3fff
		_spr[index] = s    -- reference held by head
		_set_spr(index, s) -- notify process
		if (flags_val) poke(0xc000 + index, flags_val)
	end

	function get_spr(index)
		return _spr[flr(index) & 0x3fff]
	end


	function map(ud, b, ...)
		
		if (type(ud) == "userdata") then
			-- userdata is first parameter -- use that and set current map
			_draw_map(ud, b, ...)
		else
			-- pico-8 syntax
			_draw_map(_current_map, ud, b, ...)
		end
	end

	
	

--------------------------------------------------------------------------------------------------------------------------------
--    Undo
--------------------------------------------------------------------------------------------------------------------------------

function create_undo_stack(...)

	if (not UNDO) then
		include("/system/lib/undo.lua")
	end
	return UNDO:new(...)
end

--------------------------------------------------------------------------------------------------------------------------------
--    Theme
--------------------------------------------------------------------------------------------------------------------------------

local theme_dat = nil
local theme_t   = -1
function theme(which)

	-- reload up to 5 times a second 
	-- is a tiny file and in ram, so not worth introducing a push scheme. just poll
	-- to do: checking metadata / attributes to see if it has changed? not worth it ~ just reload!
	if (not theme_dat or time() > theme_t + 0.2) then
		theme_t = time()
		theme_dat = fetch"/ram/shared/theme.pod"
		if (not theme_dat) then
			local sdat = fetch"/appdata/system/settings.pod"
			if (not sdat) sdat = fetch"/system/misc/default_settings.pod"
			if (sdat and sdat.theme) theme_dat = fetch(sdat.theme) -- if there is a theme file set in settings, use that
			if (not theme_dat) theme_dat = fetch"/appdata/system/theme.pod" or fetch"/system/themes/classic.theme"
			store("/ram/shared/theme.pod", theme_dat)
		end
	end

	return theme_dat[which]
end


--------------------------------------------------------------------------------------------------------------------------------
--    Coroutines
--------------------------------------------------------------------------------------------------------------------------------


yield = coroutine.yield
cocreate = coroutine.create
costatus = coroutine.status

local _coresume = coroutine.resume -- used internally

-- move to local; only used here
local _yielded_to_escape_slice = __yielded_to_escape_slice
__yielded_to_escape_slice = nil

--[[

	coresume wrapper needed to preserve and restore call stack
	when interuppting program due to cpu / memory limits

]]

function coresume(c,...)
	
	_yielded_to_escape_slice(0)
	local r0,r1 =_coresume(c,...)
	--printh("coresume() -> _yielded_to_escape_slice():"..tostr(_yielded_to_escape_slice()))
	while (_yielded_to_escape_slice() and costatus(c) == "suspended") do
		_yielded_to_escape_slice(0)
		r0,r1 = _coresume(c,...)
	end
	_yielded_to_escape_slice(0)
	return r0,r1
end


--------------------------------------------------------------------------------------------------------------------------------

--[[
	
	notify("syntax error: ...", "error")
	-> shows up in /ram/log/error, as a tab in infobar (shown in code editor workspace)
	
	can also use logger.p64 to view / manage logs
	how to do realtime feed with atomic file access? perhaps via messages to logger? [sent by program manager]

]]
function notify(msg_str)

	-- notify user and add to infobar history
	send_message(3, {event="user_notification", content = msg_str})

	-- logged by window manager
	-- send_message(3, {event="log", content = msg_str})
	
	-- printh("@notify: "..msg_str.."\n")
end



-- notifications

init_runtime_state()


end




:: lib/jettison.lua
--[[pod_format="raw",created="2023-14-26 21:14:41",modified="2023-14-26 21:14:41",revision=0]]
--------------------------------------------------------------------------------------------------------------------------------

-- **** jettison kernel functions before entering userland code
--[[

if (pid() > 3) then
	printh("----- globals at boot ------")
	local str = ""
	for k,v in pairs(_G) do
		if (sub(k,1,1) == "_" and #k > 3) then
			--str..= "local "..k.." = "..tostr(k).."\n"
			str..= k.." = nil\n"
		else
			-- keep
			--str..= k.."\n"
		end
	end
	printh(str)
end

]]

if (pid() > 3) then

	_draw_map = nil
	_fcopy = nil
	_store_metadata = nil
	_fdelete = nil
	_mkdir = nil
	_get_process_display_size = nil
	_kill_process = nil
	_get_clipboard_text = nil
	_apply_system_settings = nil
	_pod = nil
	_map_ram = nil
	_halt = nil
	_set_draw_target = nil
	_store = nil
	_set_spr = nil
	_open_host_path = nil
	_print_p8scii = nil
	_fetch_metadata = nil
	_get_process_list = nil
	_read_message = nil
	_unmap_ram = nil
	_ppeek4 = nil
	_ppeek = nil
	_blit_process_video = nil
	_req_clipboard_text = nil
	_set_clipboard_text = nil
	_fetch = nil
	_fetch_remote_result = nil
	_create_process_from_code = nil
	_run_process_slice = nil
	
	_subscribe_to_events = nil -- events.lua, only used by wm
	_superyield = nil

	-- commented: even pico-8 has tostring! is slightly different
	-- tostring = nil
	-- tonumber = nil

	_fetch_local = nil
	_fetch_remote = nil
	_fetch_anywhen = nil
	_store_local = nil
	_signal = nil
	_printh = nil


	-- needed by foot
	-- _process_event_messages = nil  
	-- _update_buttons = nil



end

--[[
if (pid() > 3) then
	printh("----- candidates for jettison ------")
	local str = ""
	for k,v in pairs(_G) do
		if (sub(k,1,1) == "_" and #k > 3) then
			str..= k.." = nil\n"
		end
	end
	printh(str)
end
]]


:: lib/legacy.lua
--[[

	deprecated

]]

if (false) then

	function notify_user(...)
		printh("*** DELETEME (LEGACY): notify_user")
		return notify(...)
	end

	function log(...)
		printh("*** DELETEME (LEGACY): log")
		return notify(...)
	end


	function print_p8scii(...)
		printh("*** DELETEME (LEGACY): print_p8scii")
		return print(...)
	end

	function set_window_title(title, description, location)
		printh("*** DELETEME (LEGACY): set_window_title")
		window{title = title, description = description, location = location}
	end

	function set_window_icon(icon)
		printh("*** DELETEME (LEGACY): set_window_icon")
		window{icon = icon}
	end


	function set_window(...)
		printh("*** DELETEME (LEGACY): set_window")
		return window(...)
	end

	function create_window(...)
		printh("*** DELETEME (LEGACY): create_window")
		return window(...)
	end

	function create_tab(location)
		printh("*** DELETEME (LEGACY): create_tab")
		window{tabbed   = true}
	end

	function Gui(...)
		printh("*** DELETEME (LEGACY): Gui")
		return create_gui(...)
	end


	--[[
	get_key_pressed = keyp
	get_key_state = key
	]]

end


:: lib/resources.lua
--[[pod_format="raw",created="2024-03-21 06:13:04",modified="2024-03-21 06:13:04",revision=0]]
--[[

	resources.lua

	on program boot, load everything in gfx/[0..9].gfx

	later: maybe also sfx

]]


local function _autoload_resources()

	--printh("autoloading..")
	
	local gfx_files = ls("gfx")
	if (not gfx_files or #gfx_files == 0) then return end

	for i=1,#gfx_files do
		local fn=gfx_files[i]
		local num = tonum(string.sub(fn,1,1))
		fn = "gfx/"..fn
		if (num and num >= 0 and num <= 63) then

			--printh("fetchin' "..fn)
			local gfx_dat = fetch(fn)
			if (type(gfx_dat) == "userdata") then
				local w,h = fstat(gfx_dat)

				w = w // 16
				h = h // 16

				--printh("cel w "..w)

				-- load sprite bank from gfx_dat
				for y=0,15 do
					for x=0,15 do
						local sprite = userdata("u8",w,h)
						blit(gfx_dat, sprite, x*w, y*h, 0, 0, w, h)

						--printh("## found "..found.." pixels")

						--set(sprite,2,2,14) -- test pixel
						set_spr(x + y * 16 + num * 256, sprite); --> hrrm
					end
				end

			elseif (type(gfx_dat == "table") and gfx_dat[0] and gfx_dat[0].bmp) then

				-- format saved by sprite editor
				-- sprite flags are written to 0xc000 + index

				for i=0,#gfx_dat do
					set_spr(num * 256 + i, gfx_dat[i].bmp, gfx_dat[i].flags or 0)
				end
			end

		end
	end


	-- load default map layer if there is one (for PICO-8 style map())
	-- map0.map for dev legacy -- should use 0.map
	local mm = fetch("map/0.map") or fetch("map/map0.map")


	-- dev legacy
	if (mm and mm.layer) then
		if (mm.layer[0] and mm.layer[0].bmp) memmap(0x100000, mm.layer[0].bmp)
	end

	-- 0.1 version: layers are in file root
	if (mm) then
		if (mm[1] and mm[1].bmp) memmap(0x100000, mm[1].bmp)
	end

	-- set starting tile size to size of sprite 0 (has authority; observed by map editor too)
	if (get_spr(0)) then
		local w, h = get_spr():attribs()
		poke(0x550e, w, h)
	else
		poke(0x550e, 16, 16)
	end

	-- load default sound bank (256k from 0x30000)
	local ss = fetch("sfx/0.sfx")
	if type(ss) == "userdata" then
		for i=0,0x3ff do
			poke(0x30000+i*0x100, get(ss,i*0x100,0x100))
		end
	end

end


-- only autoload in the context of running cproj or a .p64?
-- update: can autoload when running a .lua file -- can run main.lua from commandline

--if pwd() == "/ram/cart" or sub(pwd(),-4) == ".p64" then -- update: wrong now anyway
	if (_autoload_resources) then
		_autoload_resources()
	end
--end 



:: lib/undo.lua
--[[

	undo.lua

	// loaded dynamically in head.lua

	my_stack = create_undo_stack(mysave, myload, pod_flags, item)
	
		function mysave()   -- return program state
		function myload(s)  -- load s into program state
		pod_flags           -- pod format for pod() -- default to 0
		item                -- extra info that the caller can use (usually to identify which item)

]]


local Undo = {}

function Undo:reset()

	self.prev_state_str = nil
	self.next_state_str = nil

	self.undo_stack = {}
	self.redo_stack = {}

	self:checkpoint()

end

function Undo:undo()

	if (#self.undo_stack < 1) return false -- nothing to undo

	-- 0. assymetrical case for undo (and not redo): if there is no next state (redo stack is empty), make a new one
	if (not self.next_state_str) self.next_state_str = pod(self.save_state(self.item), self.pod_flags)

	-- 1. add patch to get from prev -> next on redo stack
	local patch = create_delta(self.prev_state_str, self.next_state_str)
	add(self.redo_stack, patch)

	-- 2. grab older state from undo stack
	self.next_state_str = self.prev_state_str
	self.prev_state_str = apply_delta(self.prev_state_str, deli(self.undo_stack))
	self.load_state(unpod(self.next_state_str), self.item)

	return true
end

function Undo:redo()

	if (#self.redo_stack < 1) return false -- nothing to redo
	
	-- 1. add patch to get from next -> prev on undo stack
	local patch = create_delta(self.next_state_str, self.prev_state_str)
	add(self.undo_stack, patch)

	-- 2. grab newer state from redo stack
	self.prev_state_str = self.next_state_str
	self.next_state_str = apply_delta(self.next_state_str, deli(self.redo_stack))
	self.load_state(unpod(self.next_state_str), self.item)

	return true
end



function Undo:checkpoint()

	local s0 = pod(self.save_state(self.item), self.pod_flags)
	local s1 = self.prev_state_str

	if (s0 == s1 and #self.undo_stack > 0) return false -- no change

	-- delta allowed to be nil 
	local delta = create_delta(s0, s1)

	add(self.undo_stack, delta)
	self.prev_state_str = s0
	self.next_state_str = nil
	self.redo_stack = {}
	return true
end



function Undo:new(save_state, load_state, pod_flags, item)

	local u = {
		save_state = save_state,
		load_state = load_state,
		pod_flags  = pod_flags or 0,
		item = item
	}

	setmetatable(u, self)
	self.__index = self

	u:reset()
	
	return u
end

-- export class used by head
UNDO = Undo


:: lib/wrangle.lua
--[[pod_format="raw",created="2024-03-12 18:17:15",modified="2024-03-12 18:18:07",revision=1]]
--[[

	wrangle.lua

	not designed to be customisible; aim to take care of 90% of cases with a minimal replacement for boilerplate.
	to customise: copy and modify (internals will not change [much] after 0.1)

	wrangle_working_file(save_state, load_state, untitled_filename)

	user supplies two callbacks, similar to create_undo_stack():

		save_state()          -- should return data (and optionally metadata)
		load_state(dat, meta) -- takes data and restores program state

]]


local current_filename

-- last known metadata on disk for a given filename
-- can use to check if contents of file has changed due to another process
local last_known_filename  = nil
local last_known_meta      = nil

-- set when contents is found to be stale due to external changes
-- ( --> stop auto-saving)
local stale_filename       = nil


function pwf()
	return current_filename
end





local function update_menu_items()
	
	-- don't need -- can do file open, CTRL-I to get file info
	-- also: can hover over tab to see filename
	-- ** maybe: right click on tab gives a different tab-specific menu
	--    at the moment it is only really useful for "close tab", and maybe confusing that there is the same menu twice
--[[
	menuitem{
		id = "file_info",
		label = "\^:1f3171414141417f About "..current_filename:basename(),
		action = function() create_process("/system/apps/about.p64", {argv={current_filename}, window_attribs={workspace = "current"}}) end
	}
	-- \^:1c367f7777361c00  -- i in circle
]]


	--** fundamental problem (maybe wrangler could tackle):
	--** when edit metadata, doesn't feel like anything changes on disk until save it
	--** But then Save As, what happens? Should wrangler store current metadata and pass it on?
--[[
	menuitem{
		id = "file_info",
		label = "\^:1c367f7777361c00 File Metadata",
		action = function() create_process("/system/apps/about.p64", {argv={current_filename}, window_attribs={workspace = "current"}}) end
	}
]]

	menuitem{
		id = "open_file",
		label = "\^:7f4141417f616500 Open File",
		shortcut = "CTRL-O",
		action = function()
			local segs = split(current_filename,"/",false)
			local path = string.sub(current_filename, 1, -#segs[#segs] - 2) -- same folder as current file
			--create_process("/system/apps/filenav.p64", {path = path, window_attribs= {workspace = "current", autoclose=true}})
			create_process("/system/apps/filenav.p64", {path = path, open_with = env().prog_name, window_attribs= {workspace = "current", autoclose=true}})
		end
	}

	-- save file doesn't go through filenav -- can send straight to even handler installed by wrangle.lua
	if (current_filename:sub(1,10) == "/ram/cart/") then
		menuitem{
			id = "save_file",
			label = "\f6\^:7f4141417f616500 Save File (auto)",
			shortcut = "CTRL-S", -- ctrl-s is handled by window manager
			action = function() send_message(pid(), {event = "save_file"}) return true end -- still save just in case!
		}
	else
		menuitem{
			id = "save_file",
			label = "\^:7f4141417f616500 Save File",
			shortcut = "CTRL-S", -- ctrl-s is handled by window manager
			action = function() send_message(pid(), {event = "save_file"}) end
		}
	end

	menuitem{
		id = "save_file_as",
		label = "\^:7f4141417f616500 Save File As",

		action = function() 
			local segs = split(current_filename,"/",false)
			local path = string.sub(current_filename, 1, -#segs[#segs] - 2) -- same folder as current file
			create_process("/system/apps/filenav.p64", 
				{path=path, intention="save_file_as", use_ext = current_filename:ext(), window_attribs={workspace = "current", autoclose=true}})
		end
	}

end




local function set_current_filename(fn)
	fn = fullpath(fn) -- nil for bad filenames
	if (not fn) return false
	current_filename = fn
	stale_filename = nil
	window{
		title = current_filename:basename(),
		location = current_filename, 
		unique_location = true
	}
	update_menu_items() -- (auto) shown on /ram/cart files
	return true -- could set
end




function wrangle_working_file(save_state, load_state, untitled_filename, get_hlocation, set_hlocation)

	local w = {
		save = function(w)
			-- printh("## save "..current_filename)
			local content, meta = save_state()
			if (not meta) meta = {}

			local meta1 = store(current_filename, content, meta)

			-- use callback to modify current_filename with new location suffix (e.g. foo.lua#23 line number changes)

			if (get_hlocation) then
				w.update_hloc(w, get_hlocation())
			end


			last_known_filename = current_filename
			last_known_meta = unpod(pod(meta1))

		end,

		load = function(w)
			local content, meta, hloc = fetch(current_filename)

			load_state(content, meta)
			if (set_hlocation) set_hlocation(hloc)

			last_known_filename = current_filename
			last_known_meta = unpod(pod(meta))

			return content, meta
		end,


		update_hloc = function(w, newloc)

			newloc = tostring(newloc) -- could be a number
			if (type(newloc) ~= "string") return

			local old_filename = current_filename
			current_filename = split(current_filename, "#", false)[1].."#"..newloc
			if (current_filename ~= old_filename) then
				-- tell wm new location
				--printh("telling wm new location: "..current_filename)
				window{location = current_filename}

				if (set_hlocation) set_hlocation(newloc) -- callback that e.g. changes cursor position
			end

		end


	}

	untitled_filename = untitled_filename or "untitled.pod"
	
	
	-- derive current_file
	
	cd(env().path)

	current_filename = (env().argv and env().argv[1]) or untitled_filename
	current_filename = fullpath(current_filename)


	-- load (or create) current working file
	-- to do: what happens if it is a folder?
	if (fstat(current_filename)) then
		-- to do: check error
		w:load()
	else
		w:load() -- initialise state
		w:save() -- create
	end

	
	-- tell window manager working file
	-- ** [currently] needs to happen after creating window **

	window{
		title = current_filename:basename(),
		location = current_filename, 
		unique_location = true
	}



	------ install events ------

	-- invoked directly from app menu, and by wm when about to run / save cartridge
	on_event("save_file", function(msg)
		-- can optionally 
		if (msg.filename) then
			current_filename = msg.filename
		end

		-- refuse to save over external changes. to do: nicer way to handle this
		if (stale_filename == current_filename) then
			notify(stale_filename..": skipped saving over external changes")
			return
		end

		w:save()
		
		-- show message only when NOT auto-saving /ram/cart files
		if (sub(current_filename, 1, 10) ~= "/ram/cart/") then

			if (fullpath(current_filename):sub(1,8) == "/system/") then
				notify("saved "..current_filename.." ** warning: changes to /system/ not written to disk **")
			else
				notify("saved "..current_filename)

			end
		end

	end)

	-- invoked by filenav intention
	on_event("open_file", function(msg)
		set_current_filename(msg.filename)
		w:load()
	end)

	on_event("jump_to_hloc", function(msg)
		local newloc_str = msg.hloc and "#"..msg.hloc or ""

		if (w.set_hlocation) w:set_hlocation(newloc)
		local old_filename = current_filename
		current_filename = split(current_filename, "#", false)[1]..newloc_str
		if (current_filename ~= old_filename) then
			-- tell wm new location
--			printh("request setting window location: "..current_filename)
			window{location = current_filename}
		end

	end)

	-- invoked by filenav intention
	on_event("save_file_as", function(msg)
		
		if (set_current_filename(msg.filename)) then

			-- 0.1.0c: automatically add extension if none is given
			if (not current_filename:ext() and untitled_filename:ext()) then
				set_current_filename(current_filename.."."..untitled_filename:ext())
			end

			w:save()			
			notify("saved as "..current_filename) -- show message even if cart file
		end
		
	end)


	-- autosave cart file when lose focus

	on_event("lost_focus", function(msg)
		if (sub(current_filename, 1, 10) == "/ram/cart/") then
			w:save()
		end
	end)

	
	--[[
		when gaining focus, check that file being edited has a newer version on disk
		if so, warn that external changes are detected (user might want to reload)
	]]
	on_event("gained_focus", function(msg)
	
		if split(last_known_filename,"#",false)[1] == split(current_filename,"#",false)[1] then
			local md1 = fetch_metadata(current_filename)
			if (md1) then
--				printh("revision on disk:"..(md1.revision or -1).."   last_known_meta: "..pod(last_known_meta))
				if (last_known_meta and last_known_meta.revision < md1.revision) then
					-- to do: how to disable autosave / 
					stale_filename = current_filename
					--notify("warning: external changes detected -- this version is stale")
					notify("warning: external changes detected")
				end
			end
		end
	end)

	update_menu_items()

	return w
end







:: misc/
:: misc/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA0LTMwIDE5OjA5OjMzIixtb2RpZmllZD0iMjAyNC0w
Ny0wNiAxMTo0ODozNiJdXWx6NAAEAAAAAwAAADBuaWw=
:: misc/boot.sfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTE0IDEyOjM3OjA5Iixtb2RpZmllZD0iMjAyNC0w
My0xNCAxMjozNzowOSIscmV2aXNpb249MF1dbHo0AGkBAAAQBwAA8CdweHUAAygAAAMABA9AEAIO
AAGgASACoA4ADxAADfDKAQIDBAUGBwEP-5AICQoLDwwPDQ8ODw8QAPAADQ8RDxIPEw8UDxUPFg8X
EwDxAQ8YDxkPGg8bDxwPHQ8eDx8UAPEAIA8hDyIPIw8kDyUPJg8nFADxACgPKQ8qDysPLA8tDy4P
LxQA8QAwDzEPMg8zDzQPNQ82DzcUAP8FOA85DzoPOw88Dz0PPg8-AQ--8P8BAOvwI1oBEAYPIBAB
IAEgAfAAAhACDBABIA8hIAEwD0Dwww8oD--wxg-4Cg--D4AP9w8NAfAJMQAXLzEAIw8rMgBwEAIA
DyyQARMABEUA-REAAhAPj5ABCQIQDxogDfAHCCAPeSAPZvBvDwzwHwTwl1oAHwyKAAsPMADqH-8B
ANz-GPgPQAAIQA9BDzoPPw9GD03--ytB-is-MA3_K-BwD0AADUD_sPBwAwgA-9wf-wEAl1D-----
Hw==
:: misc/cursors.gfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTA3IDA4OjQ3OjEyIixtb2RpZmllZD0iMjAyNC0w
My0wOCAxNjoyMjowMCIscmV2aXNpb249MzBdXWx6NABMAQAALzMAAPMUe1swXT17Ym1wPXB4dQBD
IBAQBPDwLGZsYWdzPTAscGFuX3gIANt5PTAsem9vbT0xMX0sMgD-DWgB0AEHAcABFwGwAScBoAE3
AZABFxGwEQcB8BRNAB4RSE0A-wewASABkAEHIAcBkAEgAbABBwHQAfA3TQAeMTYBAD0AUQcRkAEH
AgATgAgA-wdwEUcBYAEHAUcBcAFXAYABNwGgMfAmYQAeN1ZBkFEAAEsAD08AKhNYSgFfBxEAAZCq
AAkfBKUBIQ9XAEEPLgIfMSNBoCYCIQcRmgFhAaARAAEH_AAxABGgEgAAOgIBJAA-QfAjXwAeEShf
AAJDAABNABGQWQAzUBEADAATB3sAAV8AHyjwAB8PMgD---------------------------------
------------------------------8UUD0xMX19
:: misc/default_settings.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDIzLTA5LTA0IDA3OjA5OjM4Iixtb2RpZmllZD0iMjAyNC0w
My0xNCAwNDoxMTo0NiIscmV2aXNpb249NDYwNV1dbHo0AAkBAABxAQAA9BR7YmF0dGVyeV9zYXZl
cj1mYWxzZSxiZWphbmdsZV9jdXJzbxYA5GZsb3BweV93aW5kb3dzFQDzCnVsbHNjcmVlbj10cnVl
LG11dGVfYXVkaW8hAOJuZXR3b3JrX2FjY2VzcyUA0nBpeGVsX3BlcmZlY3QTAONyc2hpZnRfbWFn
bmlmeTwADxQAAmRwYXJrbGWAAGxzcXVpc2iWAHpzdHJldGNoDgAzX3RvJwAEGACUd2FwX3N0ZXJl
rQDTc3lzdGVtX3ZvbHVtZRQAgnRoZW1lPSIvHAARLw8AcXMvYXF1YS4MALYiLHdhbGxwYXBlciYA
BRMA8AJzL3BhdGNod29yay5wNjQifQ==
:: misc/drive.loc
b64$LS1bW3BvZCxhdXRob3I9IiIsY3JlYXRlZD0iMjAyMy00NC0wNSAxNTo0NDozNyIsaWNvbj11
c2VyZGF0YSgidTgiLDE2LDE2LCIwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMDAwMDAwMTA3MDcwNzA3MDcwNzA3MDcwNzA3MDcwNzAx
MDAwMTA3MDcwNzA3MDcwNzA3MDcwNzA3MDcwNzA3MDcwMTAxMDcwNzA3MDcwNzA3MDcwNzA3MDcw
NzA3MDcwNzAxMDEwNzA3MDcwNzA3MDcwNzA3MDcwNzA3MDcwNzA3MDEwMTA3MDcwNzA3MDcwNzA3
MDcwNzA3MDcwNzA3MDcwMTAxMDcwNzA3MDcwNzA3MDcwNzA3MDcwNzA3MDcwNzAxMDEwNzA3MDcw
NzA3MDcwNzA3MDcwNzA3MDcwNzA3MDEwMTA3MDcwNzA3MDcwNzA3MDcwNzA3MDcwNzA3MDcwMTAx
MDYwNzA3MDcwNzA3MDcwNzA3MDcwNzA3MDcwNjAxMDEwNjA2MDYwNjA2MDYwNjA2MDYwNjA2MDYw
NjA2MDEwMTA2MDYwZDBkMDYwNjA2MDYwNjA2MDYwNjA2MDYwMTAwMDEwNjA2MDYwNjA2MDYwNjA2
MDYwNjA2MDYwMTAwMDAwMDAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMCIpLG5vdGVzPSJTaG9ydGN1dCB0byAvIixyZXZpc2lvbj0xLHN0
b3JlZD0iMjAyNC0wMy0xNCAwNDoxNjowMSIsdGl0bGU9IlBpY290cm9uIERyaXZlIix2ZXJzaW9u
PSIiXV1sejQADwAAAA4AAADge2xvY2F0aW9uPSIvIn0=
:: misc/p64_cart.png
b64$iVBORw0KGgoAAAANSUhEUgAAAgAAAAGACAYAAADbINq-AAAKO0lEQVR4Ae3dPW6bB77F4b8P
uIdk3iWkchYwgIsAt6F2YAOuorsBNW4MN9N4A1epDNg7iJoLTBFgFjCpsgTOZBW6d5BREHlkfdmk
RJ7naSSS7wf1I6HTPplbWJbl-DbHAQAPb7PZ3Ljv1x5g_AFgf202m0-u-JUvfDz86-WRigCwJ87O
frz0eLPZ-MfeX3rC8APA4Tg7_-HS481m8-vu56oT1usj4w8Ae_66Pc-FL8uynF8cDAAcjottv9j6
mZnIAgB9MjOzLMv5zMx6faQIABygi42-2PxIAgB9sizL_czMen2kBgAcsIutX5blPHIAQJ9IAAB9
Vtu8_OnbN3c6-vjktU8EAHYgEgBAn9VjejOnb9-MzMzxyet7nfcpF9e77XE3Xfe2x933-jcdt6v3
AbDvnr94eavjPrx-9yDH3-T8NsXXAwD6rLZ58eOT1zMz87f-_p8rX--lu19-__UvP-3289WzO13-
9O2bK_-38fM3vX7x-E3X3dX9b3vefd-HTde-_HnT_wJ47D68f3fl889fvPys87-U8Q8pvh4A0Ge1
zYufvn3z799_vfT8N3-96vKBr5594fsdlo--ruOT1765ALfw-MXLrZz-4f27rRz-qeO2Ib4eANBn
tZO7-OWn336_enbp6W-__tWlx3-_3--_rNscn7w_yA-p4u86ffvm0s9D-XsBtuXD_3f3ev35i5d3
uv59j7-4edP7-BLi6wAAfVY7ucurZ5ce-vLdr1cf992bmZk5Pnm9lbdx_va363-q_U-d9_PzPve4
bXss7wPgsXn_4uWVz394-_7a1z-3_o9RfB0AoM_TZVnOZ2bW66Ot3eT07Zs7HX988tonAwBbcHb2
48zMRAoA6LPaxU2OT14rDQCPSCQAgD6RAAD6RAIA6BMJAKBPJACAPpEAAPpEAgDoEwkAoE8kAIA_
q-ue_MMPp_oBwAP7-vvje50X6QCgTyQAgD6RAAD6RAIA6BMJAKBPJACAPpEAAPpEAgDoEwkAoE8k
AIA_kQAA_kQCAOgTCQCgTyQAgD6RAAD6RAIA6BMJAKBPJACAPpEAAPpEAgDoEwkAoE8kAIA_kQAA
_kQCAOgTCQCgTyQAgD6RAAD6RAIA6BMJAKBPJACAPpEAAPpEAgDoEwkAoE8kAIA_kQAA_kQCAOgT
CQCgTyQAgD6RAAD6RAIA6BMJAKBPJACAPpEAAPpEAgDoEwkAoE8kAIA_kQAA_kQCAOgTCQCgTyQA
gD6RAAD6RAIA6BMJAKBPJACAPpEAAPpEAgDoEwkAoE8kAIA_kQAA_kQCAOgTCQCgTyQAgD6RAAD6
RAIA6BMJAKBPJACAPpEAAPpEAgDoEwkAoE8kAIA_kQAA_kQCAOgTCQCgTyQAgD6RAAD6RAIA6BMJ
AKBPJACAPpEAAPpEAgDoEwkAoE8kAIA_kQAA_kQCAOgTCQCgTyQAgD6RAAD6RAIA6BMJAKBPJACA
PpEAAPpEAgDoEwkAoE8kAIA_kQAA_kQCAOgTCQCgTyQAgD6RAAD6RAIA6BMJAKBPJACAPpEAAPpE
AgDoEwkAoE8kAIA_kQAA_kQCAOgTCQCgTyQAgD6RAAD6RAIA6BMJAKBPJACAPpEAAPpEAgDoEwkA
oE8kAIA_kQAA_kQCAOgTCQCgTyQAgD6RAAD6RAIA6BMJAKBPJACAPpEAAPpEAgDoEwkAoE8kAIA_
kQAA_kQCAOgTCQCgTyQAgD6RAAD6RAIA6BMJAKBPJACAPpEAAPpEAgDoEwkAoE8kAIA_kQAA_kQC
AOgTCQCgTyQAgD6RAAD6RAIA6BMJAKBPJACAPpEAAPpEAgDoEwkAoE8kAIA_kQAA_kQCAOgTCQCg
TyQAgD6RAAD6RAIA6BMJAKBPJACAPpEAAPpEAgDoEwkAoE8kAIA_kQAA_kQCAOgTCQCgTyQAgD6R
AAD6RAIA6BMJAKBPJACAPpEAAPpEAgDoEwkAoE8kAIA_kQAA_kQCAOgTCQCgTyQAgD6RAAD6RAIA
6BMJAKBPJACAPpEAAPpEAgDoEwkAoE8kAIA_kQAA_kQCAOgTCQCgTyQAgD6RAAD6RAIA6BMJAKBP
JACAPpEAAPpEAgDoEwkAoE8kAIA_kQAA_kQCAOgTCQCgTyQAgD6RAAD6RAIA6BMJAKBPJACAPpEA
APpEAgDoEwkAoE8kAIA_kQAA_kQCAOgTCQCgTyQAgD6RAAD6RAIA6BMJAKBPJACAPpEAAPpEAgDo
EwkAoE8kAIA_kQAA_kQCAOgTCQCgTyQAgD6RAAD6RAIA6BMJAKBPJACAPpEAAPpEAgDoEwkAoE8k
AIA_kQAA_kQCAOgTCQCgTyQAgD6RAAD6RAIA6BMJAKBPJACAPpEAAPpEAgDoEwkAoE8kAIA_kQAA
_kQCAOgTCQCgTyQAgD6RAAD6RAIA6BMJAKBPJACAPpEAAPpEAgDoEwkAoE8kAIA_kQAA_kQCAOgT
CQCgTyQAgD6RAAD6RAIA6BMJAKBPJACAPpEAAPpEAgDoEwkAoM-qvid_--2xegCwpyIBAPSJBADQ
JxIAQJ9IAAB9IgEA9IkEANAnEgBAn0gAAH1WEvynn3-_uwgAB_Tp029F_EgkMP4A-rf3iQQA0CcS
AECfSAAAfSIBAPRZPaY3889--uPa17-__k8_MQD4Alb7Mv4AsG9u2ravv-7Tg7237Mv4P2QkANjG
tj2k7Pv4P-bAABj-u27bLuQQxv821wGAfdq2bcuhBNpVMADY9rbtYtNyCON-l_sCwD5s27Y3LYcy
-rsKBgC72rZtbloOafxvOh8A9m3bbnP9_4jxB4C_bYtAANC3bREIAPq2LQIBQN_2rQ410MX5u4gI
gPHfp-GfmVkd8vgDwKFt23XH3EWMPwD0bVsEAoC_bYtAANC3bdlVROMPgPF-PNsW4w8AfdsWgQCg
b9tyyIGuOx8AWsd-ZibGHwD6ti0CAUDftkUgAOjbttUu4hh-AIz-49q21S7iGX8ADmn4D2HbYvwB
oG-bIhAA9G1bBAKAvm2LQADQt23ZxkVv_gOMPwDG-2G3Ldu68Kf_EOMPwL65aXv2cduyy2DGH4B9
9akN2tdty66CGX8A9t3HW7TP25aHCGb8AdhXF5u079uWh7y58QdgH_37_M-MZF8DA8Bj89jH-_zs
x99-Xxl4ADj83fvj_G82mycrHwcA7P-A32X8Z2bi4wKAw3XV_M-MRBoA6Br-mZnIAwBd4z8zE4kA
oGv8Z2YiEwB0jf-MTKQCgK7xn5mJXADQNf4zM5HssqdPvxUBwP-2gx7-mZmVr0XfFwWA7vGfmYl0
ANA1-jMzT2ZmlmU5n5lZr4-UBIADH-_ZmUgIAF3jPzPz_0nLspzPzKzXR8oCwAGP-8xMpASArvGf
mbl08rIs5zMz6-WRygBwoOM-M7O67ibr9ZHiAHBg4---_z9XXmRZlvM-Pl6vj9QHgAMZ-5mZay_0
LMu59ADwMDabzSzL8sfH1_72XdzqQsuynPsYAODhfMnx-5f-A--AE4_lscm7AAAAEHRFWHRMb2Rl
UE5HADIwMTEwMjIx41m2wQAAAABJRU5ErkJggg==
:: misc/ram_info.pod
b64$LS1bW3BvZCxhdXRob3I9IiIsY3JlYXRlZD0iMjAyNC0wNC0wMyAwMDozMToyOSIsaWNvbj11
c2VyZGF0YSgidTgiLDE2LDE2LCIwMDAwMDAwMTAxMDEwMTAxMDEwMTAxMDEwMTAwMDAwMDAwMDAw
MTA3MDcwNzA3MDcwNzA3MDcwNzA3MDEwMDAwMDAwMTA3MGQwZDBkMGQwZDBkMGQwZDBkMGQwNzAx
MDAwMTA3MGQwZDBkMGQwZDBkMGQwZDBkMGQwZDBkMDcwMTAxMDcwZDBkMDYwNjBkMDYwNjBkMDYw
NjBkMGQwNzAxMDEwNzBkMGQwNjA2MGQwNjA2MGQwNjA2MGQwZDA3MDEwMTA3MGQwZDBkMGQwZDBk
MGQwZDBkMGQwZDBkMDcwMTAxMDcwZDBkMDYwNjBkMDYwNjBkMDYwNjBkMGQwNzAxMDEwNzBkMGQw
ZDBkMGQwZDBkMGQwNjA2MGQwZDA3MDEwMTA3MGQwZDA2MDYwZDA2MDYwZDA2MDYwZDBkMDcwMTAx
MDcwZDBkMGQwZDBkMGQwZDBkMGQwZDBkMGQwNzAxMDEwNjA3MGQwZDBkMGQwZDBkMGQwZDBkMGQw
NzA2MDEwMTA2MDYwNzA3MDcwNzA3MDcwNzA3MDcwNzA2MDYwMTAwMDEwNjA2MDYwNjA2MDYwNjA2
MDYwNjA2MDYwMTAwMDAwMDAxMDYwNjA2MDYwNjA2MDYwNjA2MDYwMTAwMDAwMDAwMDAwMTAxMDEw
MTAxMDEwMTAxMDEwMTAwMDAwMCIpLG1vZGlmaWVkPSIyMDI0LTA0LTE0IDAxOjQzOjQ1Iixub3Rl
cz0iVGhpcyBmb2xkZXIgZXhpc3RzIG9ubHkgaW4gbWVtb3J5XG5hbmQgd2lsbCBkaXNhcHBlYXIg
YWZ0ZXIgc2h1dGRvd24uIixzdG9yZWQ9IjIwMjQtMDQtMDMgMDA6NTE6MTYiLHRpdGxlPSIiLHZl
cnNpb249IiJdXWx6NAAEAAAAAwAAADBuaWw=
:: misc/readme.txt
--[[pod_format="raw",created="2024-03-10 12:02:52",icon=userdata("u8",16,16,"00000101010101010101010101000000000106060606060606060606060100000107010606060606060606060606010000010106060707070707070606060100000106060607070707070707060601000107010606060606060706070606010000010106060707070607070706060100000106060607060706060606060601000107010606070707070707070606010000010106060607070707070706060100000106060606060606060606060601000107010606060606060606060601010000010101010101010101010101070100000101070707070707070707070601000000010606060606060606060601000000000001010101010101010101000000"),modified="2024-03-14 16:56:13",revision=63,stored="2024-03-10 12:03:12"]]
-==================================================-
           Getting Started with Picotron 
-==================================================-


--[[pod_type="image"]]unpod("b64:bHo0AF4HAACACwAA8RlweHUAQyDwZATw-----9Zd8FaN8A2N8DyNUI3wTQ0QDRANAA3wDQ0ACwAh8DwHABKQDQADHwAj-Q8dAII6-QzwNC3wBC0AI-0PPQA3Og0ANgCTAA3wMh0gHfACFgBF0B3ADSkAwfAKDfAwHWAd8AANYBoAEWAWAKgEHTAN8C8NoA3gFwBRQA0QDTAGAJ4gDfAXLdD9C3AfADBQDQAfAJ4WDSANwB3wBx0jABIdfgBgIA3wD-0DLwBf8AUNAA1LAABTAB0ADQAqAJ8d4B1QDRD9BRApAAEiMC0lAIANAA3ADQANUBwBIAMNKwBxUA3gHdANUCsAEp1MAAEpADEQzRAnAD3AHTAoAABTAEFNIA0wKABSDTAtMA0sADFgDTD7AAwwACSNYCwAMyBNICwANRANgCwAYEAN8AAd4AcAETrVAEAQPQAdAQFwMA2wHQAd0CgANB0AHToAXkANYB0wOACBrRAdAA1ADaBcABnAbAAt8AMvAKnwCg2QHQAtAB2wwgAAOwEREAgAYDAN8AAt8IQAAi4AImAtrgARoLYAJCANXAAAagAvAB0yAAEAHgABoQFBHQAtgFYAADkBAjYAQTAdQA0aAAA6ABFdOAASXTYAEUAUABMghgAEhgFtID0wDQBtZgAAFwEGAgAxIA1AUwAA1wARAI8BBe4BARcCSF3wAR1oABQ9ZwIYYDwCITANJwACYQAAGAEGAgATIBAAMABNIJACCZwCC10BEiCGAFJNAC3wEuUCCyEAAlAAERCEAErwEv0LIQAM2QAFSgEQPVcAL-A0TgAEAzoBL-AzTQAKAZwAEz1RAAAtAKBQDbBdwA1QLfA4TAAB5AAVPUoA8gNQDcANME1wDSAtID3wNP0MQB3YAAGHAGBQDdAdYC13AWOQHfBUDRBVASHwNQADgIANMB3QHfBSzQLwJy0ATfAKrfARDVD9BHA98AIN8FKdAA3wCw2gDfAQDVD9BmANEB0wPYAN8EgdcA0ADUAt8AoNwDYDALMA8ALwBT0gDQBtMD1QHfBGHXAtQDoAkOAN8A4dED3wAR0CsA0APTA9MF3wSB2gwQP4AQsN8AEN8CQdgC0AHYAd8FAWAOAjDcA9oA3wPK1gLQAdYCQBEAkjA9jwIB2QnZAd8DjtQB0QGACwHw1ALRAdMB0wHRB5AGA3PRAtED0kABBQYwSACA1AjUAN8B4hASAdQIQDwB0gLSAN8DYtIC0gLS4BEmAnADAwDYBVAlEdTTAdQCsAaDBN8DQ9gCMAESCLA3AgDfAlDTBNTQHVMA3wOw0AHTAtMB0wXSUAANoD8QIgDfAkDSCNIF0gDfA5LUBNQJ4CBWsAIBBN9wRA8CNNEKwCUT0QTfA4aQAHJwCQBU0wjTBN8CZd9gRKAF3wPUYAsgI9EC3gLRA98CJNFwVAAF3wO98ARC1ADTAlAABtA1AgLcAtIA8CAPcAACkAUCBd8DFtigQTQCcA4dAdMC0gLaAtIC0wHfAePgDyAwAN8Db9LWAdYC0g7SAtYB3wIRUA8wQ1DfAtDUANkC0wrTAtkA3wIQ0gLACRQA2wPeA9sA3wZQAxLfA03gMCAgAArgOB0E2gTdAN8BzPAEkQHfAyIABgIA3wAf0B-gETGQQBMvAxDc0ACAQAADcEgPAEzfAEDfAXfwRZDUAd8C9JAO8ADfAnDfAUHZBNQA3wLhsAAHATDUAtMA0AmAHwAS0NAP0pAB3wKQ3wEQ0gnRCHARIsJwACFgBAEE0gPZwAQQAd8DMsAGEN8CsN8BatBhIAfwMCnQEyIB0ACgARPRcAIgkNKgAxFR0gpwMWACoAAtUDAeEDoj2grSAd8C0N8BnMAx41IwAABAhBHXANMCcAEBi8AQYnABUgJQAyAB2Q4gQQL7cHAGYGL-A2TAACNYC9MCUAAMQALvA2TABijSANkA0gJwAB5gYfAE4ABCM9MKIIIPAxUgAB0AINnACAHQANID0QvSAUAQOPA0-wFg0w7wAGQD0QzVAsAD5gDVAsAAlYAPABjRA9ID0gDcANsA1ADVANoI0EWhH9A-AwVwABCgCAEA1gHSBNIE0IAgD1AhGwLQABbQQeMIYAQe0gXTAzAgArCQArAEmQHfAFLQCwIB0A-QwgjbBNoA0PBIKQTbANgD3wBH4A0v0C8AnN8AE98Agt8AEMCFEd8AD9AdECIPAA3gDAoA3wBR0Q-QAQHfAEcAlxXQAd8AEN4PQCIP0DfQCMMN3wB-0E8AYeAACHAAB8AhGgwAGAwA3wCP0A8AdLB2KN8ALt8DIiAAFCAAkeADN98AMeABACEgdy0A3wCG0AfRwAMG3wBCwABB4AYAPdMA3wBxEBuW3wBg1wDQBtII1wIQABXgAg8AZBAEEFDYCN2AcRDSMA8BEx-TDwBP0A8AP9CUANAP0R8FHtcB1wTUD9APABHcB9ILAD0YtdAB0gHTD9AKBd4H1OBfAGk-0X8AV9QC3wlW0g-QLwxw2QDfDUBQAS0woA8ABATfDWDSAN8Nwt8P---0c=")

Congratulations on being the new owner of your very 
own Picotron Fantasy Workstation!

This is a quick guide to get you started using
Picotron and creating your own cartridges.

** Workspaces **

Press ALT+LEFT or ALT+RIGHT to cycle through desktop
workspaces. Click and drag the toolbar to reveal a
tooltray.

On boot, /appdata/system/startup.lua is run if it
exists, and you can use that to install widgets in
the tooltray. See /system/startup.lua for an example.


** Customizing your Desktop **

You can open the system settings via the Picotron 
menu (top left) or by typing settings at the prompt.
To create your own lists of themes, wallpapers and
screensavers, create the following folders:

/appdata/system/themes
/appdata/system/wallpapers
/appdata/system/screensavers

** Creating a Program **

Picotron always has a global cartridge sitting in RAM
at /ram/cart ready to be edited. Click on the code
workspace (it looks like "()" at the top right) and
type in a program:

function _draw()
	cls(1)
	for i=1,24 do
		circ(240,135, i*t(), i)
	end
end

Now hit CTRL-R to run it. You can do this from
anywhere -- CTRL-R means: "run whatever is in
/ram/cart", and the entry point for any cart is
always main.lua.

To stop a running program, press ESC and then ESC
once more to return to the last desktop workspace.

To create a windowed program, the window size can
be set with: window(width, height), or to run at
different resolution use the vid() function:

	vid(0) 480x270
	vid(3) 240x135
	vid(4) 160x90

Some handy functions to get started:
	
	cls(col) -- clear the screen to a colour (0..63)
	circfill(x,y,radius,col) -- filled circle
	line(x0,y0,x1,y1,col) -- draw a line
	spr(index,x,y) -- draw a sprite
	map() -- draw the default map
	sfx(index) -- play a sfx
	music(index) -- play a pattern
	
Picotron programs can define a function called _draw
that is called each frame, _update that is always
called at 60fps, and _init that is called once when
the program is run.
	
** Saving a Cartridge **

From terminal, use the save command:

/>save mycart

An extension will automatically be added (.p64) and
the contents of /ram/cart will be stored in that
cartridge. Inside Picotron, cartridges are folders, so
you can open them up and look inside! But in the real
world they are stored as single .p64 or p64.png files.

** Commands **

Some handy commands:

ls			list the current directory (folder)
cd			change directory (e.g. cd /desktop)
mkdir		create a folder
folder		open the current folder in your Host OS
open		open a file with an associated editor

To create your own commands, put .p64 or .lua files
in /appdata/system/util.


** Running a Cartridge **

There are some demos in /system/demos:

> cd /system/demos
/system/demos> load carpet.p64

Cartridges are also like regular applications that can
be opened by double clicking on them, or typing their
name from the command prompt. If the cartridge
creates a new fullscreen workspace, you can close it
by pressing ESC and then right-clicking on the
workspace icon.


** GFX Editor **

The second workspace is a sprite editor. Each .gfx
file contains up to 256 sprites, and if the filename
starts with a number, it can be indexed by the map
editor.

Don't forget to save your cartridge after drawing
something -- the default filenames all point to
/ram/cart and isn't actually stored to disk until
you use the save command (or CTRL-S to save the
current cartridge)

s			select
space		pan
f/v			flip selection horizontall or vertically
cursors	move selection
ctrl-c		copy selection
ctrl-v		paste to current sprite
ctrl-b		paste big (2x2)
tab			toggle RH pane
-,+			navigate sprites
ctrl		modify some draw tools (fill)
rmb		pick up colour

Draw sprites from your program with spr(index, x, y).
0.gfx is loaded automatically.


** MAP Editor **

Changes made to /ram/cart/gfx/0.gfx automatically
show up in the map editor.

The map editor uses similar shortcuts, with a few
changes in meaning. For example, f and v also flip
selected tiles, but also set special bits on those
tiles to indicate that the tile itself should also
be drawn flipped. The map() command also observes
those bits.


** SFX Editor **

There are 3 modes to the SFX editor: an instrument
(synth patch) designer, SFX editor (for playing
sequences of notes) and a pattern editor, for
arranging SFXs into groups to play music.

Each instrument is a tree of nodes that can either
create or modify an audio signal. Please refer to the
PFX6416 design document for details:

https://www.lexaloffle.com/dl/docs/picotron_synth.html

Basic node instrument editing:

Click and drag a knob to turn it
Right mouse draw to adjust the range of a knob
Click and drag an envelope to a knob field
-> The envelope now applies to that range

Press SPACE while in the instrument editor to
kill all sound.

** Saving a PNG Cartridge **

To create a .p64.png ready to be uploaded to the
BBS, first capture a label while running it (ctrl-7)
and then save it with a .p64.png filename extension.
To print a title and author/version on the label,
type: about mycart.p64.png

** Loading a BBS Cartridge **

> load #cart_id

This loads the cart with a temporary filename in
/ram. Don't forget to save somewhere to disk if
you want to keep any changes.



** Reading Games Controllers **

Use btn(index) to read the state of game controllers:

	0,1,2,3		Stick L,R,U,D
	4,5  			Buttons: O, X
	6,7  			(reserved)
	8,9,10,11		Secondary Stick
	12,13,14,15  Buttons, SL, SR
	
A secondary stick is not guaranteed on all platforms!
It is preferable to offer an alternative control
scheme that does not require it, if possible.

Keyboard controls are currently hard-coded:

	0~5 	Cursors, Z/X
	8~11	ADWS
	12,13	F,G
	14,15	Q,E


--------------

There are still many unfinished and rough corners
but I hope you enjoy messing around with this first
version. See you on the BBS!

-- zep

:: pm/
:: pm/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA0LTMwIDE5OjA5OjMzIixtb2RpZmllZD0iMjAyNC0w
Ny0wNiAxMTo0ODozNiJdXWx6NAAEAAAAAwAAADBuaWw=
:: pm/pm.lua
--[[

	procman.lua

	Process Manager

	doesn't have much to do!
	process slices are run from the kernel mainloop

]]


function _update()

	-- to do: adjust process cpu allocations based on previous frame
	
end


on_event("kill_process", 
	function(msg)

		-- silentely refuse to kill system processes: kernel, process manager, window manager
		-- commented; fun to kill these processes! can have useful error screen when core processes have crashed

		-- if (msg.proc_id < 3) return

--		printh("killing process via message "..tostr(msg.proc_id))

		_kill_process(msg.proc_id)

	end
)

on_event("restart_process", 
	function(msg)
		_kill_process(msg.proc_id, 1)
		send_message(msg.proc_id, {event = "unpause"})
	end
)


on_event("open_host_path", 
	function(msg)
		_open_host_path(msg.path)
	end
)

-- placeholder; to do: allow communication by program name?
on_event("broadcast",
	function (msg)

		local pl = _get_process_list()

		for i=1,#pl do
			if (pl[i].id > 3) then
				send_message(pl[i].id, msg.msg)
			end
		end

	end
)

-- to do: care about who is asking!
on_event("shutdown",
	function()
		_signal(33)
	end
)

on_event("reboot",
	function()
		_signal(34)
	end
)

on_event("mount_host_desktop",
	function()
		_signal(65)
	end
)





:: screensavers/
:: screensavers/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA0LTMwIDE5OjA5OjMzIixtb2RpZmllZD0iMjAyNC0w
Ny0wNiAxMTo0ODozNiJdXWx6NAAEAAAAAwAAADBuaWw=
:: startup.lua

-- load settings
local sdat = fetch"/appdata/system/settings.pod"
if not sdat then
	-- install defaults
	sdat = fetch"/system/misc/default_settings.pod"
	store("/appdata/system/settings.pod", sdat)
end

-- newer settings that should default to a non-nil value
if (sdat.anywhen == nil) then
	sdat.anywhen = true
	store("/appdata/system/settings.pod", sdat)
end

-- present working cartridge
local num = 0
local num=0
while (fstat("/untitled"..num..".p64") and num < 64) num += 1
store("/ram/system/pwc.pod", "/untitled"..num..".p64")


-- custom startup could opt to run different window / program manager
create_process("/system/pm/pm.lua")
create_process("/system/wm/wm.lua")

------------------------------------------------------------------------------------------------
--   hold down lctrl + rctrl on boot to start with a minimal terminal setup
--   useful for recovering from borked /appdata/system/startup.lua
------------------------------------------------------------------------------------------------

-- give a guaranteed short window to skip

for i=1,20 do
	flip()
	if (stat(988) > 0) bypass = true _signal(35) 
end

if bypass then
	create_process("/system/apps/terminal.lua", 
		{
				window_attribs = {fullscreen = true, pwc_output = true, immortal = true},
				immortal   = true -- exit() is a NOP; separate from window attribute :/
		}
	)
	return
end


create_process("/system/apps/test.lua", 
	{
			window_attribs = {fullscreen = true, pwc_output = true, immortal = true},
			immortal   = true -- exit() is a NOP; separate from window attribute :/
	}
)
:: sysboot.lua
--[[
	Picotron Kernel
	Handle process creation and slice allocation
	-- should be small so that can configure to just run a single cart (update: why?)
]]


-- need to fetch early to determine fullscreen or windowed
local sdat = fetch"/appdata/system/settings.pod" or  {}
_apply_system_settings(sdat)



-- allowed to assume / and /ram is mounted before boot.lua is run
-- and that there is already /system

cp("/system/misc/ram_info.pod", "/ram/.info.pod")

mkdir("/ram/cart")
mkdir("/ram/system") -- system state (userland)
mkdir("/ram/shared") -- system state visible to sandboxed carts
mkdir("/ram/drop")   -- host files dropped into picotron -- can just leave them kicking around until reboot
--mkdir("/ram/log")    -- logs for this session -- to do

mkdir("/desktop")
-- mkdir("/apps")       -- later; could be optional!

mkdir("/appdata")
mkdir("/appdata/system")
mkdir("/appdata/system/desktop2") -- for the tooltray

--mkdir("/ram/dev") -- experimental; devices are an extraneous concept if have messages and ram file publishing


local head_func, err = load(fetch("/system/lib/head.lua"))
if (not head_func) io.write ("** could not load head ** "..err)
head_func()


-- user can extend this with /appdata/system/startup.lua (is daisy-chained)

local startup_src  = fetch("/system/startup.lua")

if (type(startup_src) ~= "string") then
	printh("** could not read startup.lua")
else
	local startup_func = load(startup_src)
	if (type(startup_func) ~= "function") then
		printh("** could not load startup.lua")
	else
		startup_func()
	end
end



function run_userland_processes(allotment)

	local pl = _get_process_list()
	local wm_proc_id = 3

	-- publish!
	store("/ram/system/processes.pod", pl)

	while(pl[1] and pl[1].id <= wm_proc_id) do
		deli(pl, 1)
	end

	--printh("---")

	local max = #pl
	local num = max
	local keep_going = true
	local remaining = allotment - stat(301)
	local slices = 0
	local safety = 0

	-- safety: might not make any progress towards zero -- e.g. if still a tiny bit of cpu left
	-- that rounds down to 0 cycles; or for some other anamolous reason a process keeps returning
	-- 0 cpu spent, but also never reaches end of frame. 

	while (keep_going and remaining > 0 and safety < 256) do
		keep_going = false
		local cpu = remaining / num
		--cpu = 0.0001 -- microslices for debugging. slow (0.0001 == only ~30 insts/ slice) but should still work!
		
		for i = 1, max do
			local p = pl[i]
			if (p) then
				--printh("  running "..p.id.." "..cpu.." slice: "..slices)
				--local completed, cpu_spent, err = _run_process_slice(p.id, p.id < 10 and 0.2 or cpu) -- debug: only microslice cproj output
				local completed, cpu_spent, err = _run_process_slice(p.id, cpu)

				if (cpu_spent) remaining -= cpu_spent

				if (completed) then
					-- completed
					-- printh("    completed "..p.name.." cpu:"..string.format("%3.3f",cpu_spent))
					pl[i] = nil
					num -= 1
				else
					-- at least one process made progress
					keep_going = true
				end

				slices += 1
			end
			
		end

		
		safety += 1

	end

	--printh("slices: "..slices)

end


-- boot sound
sfx_index = 0
sfx_delay = 1000 --1200
r = fetch"/system/misc/boot.sfx"


for i=0,0x2ff do
	poke(0x30000+i*0x100, get(r,i*0x100,0x100))
end


local total_frames = 0
local max_wm_cpu = 0.02

local wm_cpu = {}
local max_cpu_samples = 64
for i=0,max_cpu_samples-1 do wm_cpu[i] = 0 end
local wm_cpu_index = 0
local played_boot_sound = false

while (true) do -- \m/

--	printh("------------ mainloop "..total_frames.." ----------------")
	total_frames += 1

	-- use time() for better sync
	if not played_boot_sound and stat(987) >= sfx_delay then
		played_boot_sound = true
		sfx(sfx_index)
	end


	-- maybe don't need procman
	-- to do: just let any (local security context) process kill any other process
	-- can assume completes within 0.1 cpu
	_run_process_slice(2, 0.1)

	-- allocate longest time spent in wm within the last 8 frames
	local wm_cpu_max = 0.01 -- at least 1%
	for i=0,max_cpu_samples-1 do
		if (wm_cpu[i] > wm_cpu_max) wm_cpu_max = wm_cpu[i]
	end


--	printh("wm_cpu_max:"..wm_cpu_max)

--[[	printh(string.format("%3.3f %3.3f %3.3f %3.3f %3.3f %3.3f %3.3f %3.3f ",
		wm_cpu[0],wm_cpu[1],wm_cpu[2],wm_cpu[3],wm_cpu[4],wm_cpu[5],wm_cpu[6],wm_cpu[7]))
]]

	-- 0.98 to give 2% margin
	-- problem is: run_userland_processes can't guarantee to run under allotment; e.g. finish on expensive operation
	-- also allows wm to spike by 1% without causing frame overrun (e.g. when desktop apps are maxing out userland cpu)
	-- to do: perhaps could be less when desktop workspaces / more for fullscreen workspace

	local userland_cpu = 0.98 - wm_cpu_max - stat(301)
	local cpu0 = stat(301)

	run_userland_processes(userland_cpu)

	local cpu1 = stat(301)

	-- run window manager last: want to see most recent state of every program; otherwise a frame behind?
	
	-- make sure wm process completes
	local wm_slice_completed = false 
	local total_wm_cpu = 0
	while not wm_slice_completed do

		local completed, cpu_spent, err = _run_process_slice(3, 0.5)

		-- printh(" wm slice cpu: "..pod{completed, cpu_spent, err})

		if (cpu_spent) total_wm_cpu += cpu_spent

		if (err) then

			poke(0x0, 1) -- low level error code
			--printh("*** wm error: "..err)

			wm_slice_completed = true -- give up
		elseif completed then
			--printh("completed: "..cpu_spent)
			wm_cpu[wm_cpu_index] = total_wm_cpu
			wm_cpu_index = (wm_cpu_index + 1) % max_cpu_samples
			wm_slice_completed = true
			-- if (total_wm_cpu > wm_cpu_max) printh("wm cpu spike: "..total_wm_cpu.." / "..wm_cpu_max) 
		else
			-- printh("** wm slice did not complete; running again **")
			-- to do: when does this happen? genuine large spike in wm usage?
				-- or because of unexpected yields / superyields? (run_process_slice does not currently run subslices)
		end

	end

	local cpu2 = stat(301)

	-- to do: allow it to complete (assuming 1 whole frame of cpu is enough) -- don't want to discard (or show!) half-rendered frames 

--[[
	 printh(string.format("cpu0: %3.3f [userland: %3.3f/%3.3f] -> cpu1: %3.3f [wm:%3.3f/%3.3f] -> %3.3f",
			cpu0, cpu1-cpu0, userland_cpu, cpu1, cpu2-cpu1, wm_cpu_max, cpu2))
--]]

	-- return control to c program 
	-- (let emscripten mainloop function end to return control to the browser)

--	coroutine.yield()
	flip() -- reset cpu_cycles for next frame? doesn't matter now that using stat(301) though.

end

:: themes/
:: themes/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA0LTMwIDE5OjA5OjMzIixtb2RpZmllZD0iMjAyNC0w
Ny0wNiAxMTo0ODozNiJdXWx6NAAEAAAAAwAAADBuaWw=
:: themes/aqua.theme
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDIzLTU5LTAxIDIzOjU5OjI1Iixtb2RpZmllZD0iMjAyMy01
OS0wMSAyMzo1OToyNSIscmV2aXNpb249MF1dbHo0AE0BAAAJAgAAoHtkZXNrMD0xNywJAEExPTE0
CQCRX3NoYWRvdz01DgA1dG9wIwB0dG9wMT0xNgwA8ApfcGF0dGVybj1weHUAQyAMDARHEAcQBwA3
BgAwEDcABgARVxIAQQcQB5ACAAgIABWASAADcQDyATE5LGRvcl9ib3JkZXI9MjEOAHF1dHRvbj01
DQCBZnJhbWU9MTMNAHB0aXRsZT02DABKbWFudDgAAhIAAjwABxIAA0EAFTgRAAJFAJExLGljb24w
PTcIAAEKAQAJABAyKgAACQAQM0QAlHRvb2xiYXI9NwoAEDGKAAMMABcyDABWX2JhY2snABBfQgAI
HwBIaXRlbRAAgHNlbGVjdGVkdwA0d2luyQASMQ0AAsQAITEzDgACwAAhMjkNAAK8ABA3DAA0ZG93
NwAVMBAAAzoAFDgRAAM9ABQzEACQdGl0bGU9MzB9
:: themes/biz.theme
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDIzLTI2LTIyIDEwOjI2OjE2Iixtb2RpZmllZD0iMjAyMy0z
My0yMiAxMDozMzoyOCIscmV2aXNpb249NV1dbHo0ADsBAADmAQAAoHtkZXNrMD0xNywJAEExPTE0
CQCRX3NoYWRvdz01DgB0dG9wMD0xNgwARDE9MTMMAPUMX3BhdHRlcm49cHh1AEMgCAgEByAHQAcg
B-ABCQAFLAADVQDjMSxkb3JfYm9yZGVyPTIOAHF1dHRvbj01DQBRZnJhbWVlAKBvcl90aXRsZT02
DABEbWFudDgAFjARAAI7ABUxEQACPwAlMjIRAAJDAJExLGljb24wPTcIADExPTkIAEEyPTI1CQDU
Mz0xLHRvb2xiYXI9NwoAAesAAwwAFzIMAFZfYmFjaycAEF9BAAgfAEBpdGVtMgEEEAD0AHNlbGVj
dGVkPTEyLHdpbsUAEjENAAPBABEzDgADvgAROQ0AAroAEDcMADZkb3f8AAQQAAT7AAMQAAI8ABQ5
DwCQdGl0bGU9MjB9
:: themes/candy.theme
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDIzLTQxLTAxIDAzOjQxOjU4Iixtb2RpZmllZD0iMjAyMy01
OC0zMCAxODo1ODozMiIscmV2aXNpb249NV1dbHo0AFYBAAD5AQAAoHtkZXNrMD0xNywJAEExPTE0
CQCRX3NoYWRvdz01DgB0dG9wMD0yMwwABSYA9St0b3BfcGF0dGVybj1weHUAQyAMDAQAFwAXUAcQ
BxAHQAdAB1AHIAdwBwAHkAfwAQeAR3AngAcAB-AJPwADaADyADAsZG9yX2JvcmRlcj0yMQ4AcXV0
dG9uPTUNAIFmcmFtZT0xMw0AcHRpdGxlPTYMAERtYW50OAAWMBEAAjsAFTERAAI-ABYzEQACQwCh
MjAsaWNvbjA9NwgAMTE9OQgAMTI9OAgA1DM9Mix0b29sYmFyPTcKABAxhgADDAAXMgwAVl9iYWNr
JwAQX0EACB8AZWl0ZW09OA8A9ABzZWxlY3RlZD0xMix3aW7EABIxDQADwAARMw4AAr0AITI5DQAC
uQAQNwwANmRvd-sABBAAAzoAFDkRAAI9ACQxNRAAgHRpdGxlPTJ9
:: themes/cga.theme
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDIzLTM0LTIyIDEwOjM0OjQ1Iixtb2RpZmllZD0iMjAyMy01
My0zMCAxODo1Mzo1NSIscmV2aXNpb249NV1dbHo0ADgBAADnAQAAoHtkZXNrMD0xNywJAEExPTE0
CQCRX3NoYWRvdz01DgB0dG9wMD0yOAwABSYA9Q90b3BfcGF0dGVybj1weHUAQyAICAQHIAdAByAH
8AEJAAUsAANVAOMxLGRvcl9ib3JkZXI9Mg4AcXV0dG9uPTUNAIFmcmFtZT0xMw0AcHRpdGxlPTYM
AERtYW50OAAWMBEAAjsAFTERAAI-ABYzIgACQwCRMSxpY29uMD03CAAyMT0xCQAQMioAAAkA1DM9
MSx0b29sYmFyPTcKABAxhwADDAAXMgwAVl9iYWNrJwAQX0EACB8AZml0ZW09MSAAgHNlbGVjdGVk
bQA0d2luxgASMQ0AA8IAETMOAAK-ACEyOQ0AArsAEDcMADZkb3f9AAQQAAT8AAMQAAI8ACQxNBAA
gHRpdGxlPTd9
:: themes/classic.theme
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDIzLTI4LTAxIDA0OjI4OjI4Iixtb2RpZmllZD0iMjAyNC0w
My0xMCAwMTozNjowOSIscmV2aXNpb249MTVdXWx6NAA1AQAA5QEAAKB7ZGVzazA9MTcsCQBBMT0x
NAkAkV9zaGFkb3c9NQ4ARHRvcDAaAHR0b3AxPTIzDADwCl9wYXR0ZXJuPXB4dQBDIAwMBPAKF5AX
8DAFABUKJgADTwDyATMwLGRvcl9ib3JkZXI9MjEOAHF1dHRvbj01DQCBZnJhbWU9MTMNAHB0aXRs
ZT02DABKbWFudDgAAhIAAjwABhEACEAAAREAAkQAoTE4LGljb24wPTcIAEExPTMxCQAUMhoA1DM9
MSx0b29sYmFyPTcKABAxSQADDAAXMgwAVl9iYWNrJwAQX0EACB8ASGl0ZW0QAIBzZWxlY3RlZEQB
NHdpbsgAEjENAAPDABEzDgACwAAhMjkNAAK8ABA3DAA0ZG93NwAVMBAABP0AAxAACDwAABAAkHRp
dGxlPTE4fQ==
:: themes/concrete.theme
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA2LTA0IDE0OjA2OjM0Iixtb2RpZmllZD0iMjAyNC0w
My0wNyAwNjoxNzo0OSIscmV2aXNpb249Ml1dbHo0AC8BAADiAQAAoHtkZXNrMD0xNywJAEExPTE0
CQCRX3NoYWRvdz01DgB0dG9wMD0yMgwANDE9NgsA8ApfcGF0dGVybj1weHUAQyAMDATwCheQF-Aw
BQAVCiYABk4Awm9yX2JvcmRlcj0yMQ4AU3V0dG9uGwCBZnJhbWU9MTMNAFB0aXRsZWsAam9ybWFu
dDgAAhIAAjwABhEAA0AAFTkRAAJEAKExOCxpY29uMD03CAAAwAAACAAyMj0xCQDUMz0xLHRvb2xi
YXI9NwoAEDGIAAMMABcyDABWX2JhY2snABBfQQAIHwBIaXRlbRAAgHNlbGVjdGVkWwE0d2luxwAS
MQ0AA8IAETMOAAK-ACEyOQ0AArsAEDcMADRkb3c3ABUwEAAE-AADEAAD_wAFMACQdGl0bGU9MTh9
:: themes/moonlight.theme
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDIzLTU4LTAxIDAyOjU4OjMxIixtb2RpZmllZD0iMjAyNC0w
My0wNyAwNTozODowMiIscmV2aXNpb249MjddXWx6NABDAQAA6QEAAKB7ZGVzazA9MTMsCQBBMT0x
NAkAkV9zaGFkb3c9NQ4AZHRvcDA9MAsANDE9MQsA9RZfcGF0dGVybj1weHUAQyAICAQgF0AHoAcA
B1AXUAcAB6AHQBcgLQADVADyADAsZG9yX2JvcmRlcj0yMQ4AcXV0dG9uPTUNAFFmcmFtZZMAoG9y
X3RpdGxlPTYMAERtYW50OAAWMBEAAjsAFTERAAg-AAERAAJDAKExOCxpY29uMD03CABBMT0yOQkA
QTI9MTYJANQzPTAsdG9vbGJhcj03CgAQMUkAAwwAFzIMAFBfYmFja0MABBAAAEIACCAAQGl0ZW10
AAQQAIBzZWxlY3RlZG4ANHdpbsgAEjENAAPEABEzDgACwQAhMjkNAAK9ABA3DAA2ZG93-wAEEAAD
OgAUOBEACD0AABAAgHRpdGxlPTF9
:: themes/synthwave.theme
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDIzLTMxLTAxIDAzOjMxOjQ0Iixtb2RpZmllZD0iMjAyMy0z
MS0wMSAwMzozMTo0NCIscmV2aXNpb249MF1dbHo0AEEBAADoAQAAoHtkZXNrMD0xNywJAEExPTE0
CQCRX3NoYWRvdz01DgB0dG9wMD0xOAwARDE9MzAMAPURX3BhdHRlcm49cHh1AEMgCAgEEAdQJzBH
8AEHUDcgN3AoAANRAPIBMTksZG9yX2JvcmRlcj0yMQ4AcXV0dG9uPTUNAIFmcmFtZT0xMw0AcHRp
dGxlPTYMAEptYW50OAACEgACPAAHEgADQQAVOBEAAkUAkTEsaWNvbjA9NwgAQTE9MjgJABAyzQAA
CQDUMz0xLHRvb2xiYXI9NwoAEDGJAAMMABcyDABQX2JhY2tDAAQQAABCAAggAHVpdGVtPTI5EACA
c2VsZWN0ZWRuADR3aW7JABIxDQACxAAhMTMOAALAACEyOQ0AArwAEDcMADRkb3c3ABUwEAADOgAU
OBEAAz0ABRAAgHRpdGxlPTJ9
:: themes/tangerine.theme
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTAzLTEzIDA1OjU5OjU2Iixtb2RpZmllZD0iMjAyNC0w
My0xMyAwNjowNDoyOSIscmV2aXNpb249MV1dbHo0ADgBAADgAQAAoHtkZXNrMD0xNywJAEExPTE0
CQCRX3NoYWRvdz01DgBldG9wMD0xDAA1MT0yDADwCl9wYXR0ZXJuPXB4dQBDIAwMBPAKF5AX8DAF
ABUKJgADTwDzADMxLGRvcl9ib3JkZXI9Mg4AcXV0dG9uPTUNAIFmcmFtZT0xMw0AcHRpdGxlPTYM
AERtYW50OAAWMBEAAjsAFTERAAI-ABU0EAACQgCRMSxpY29uMD03CAAxMT05CABBMj0xOAkA1DM9
MSx0b29sYmFyPTcKABAxhQADDAAXMgwAVl9iYWNrJwAQX0EACB8AZWl0ZW09OQ8AgHNlbGVjdGVk
MwE0d2luwwASMQ0AA78AETMOAAK8ACEyOQ0AArkAEDcMADZkb3f6AAQQAAM6ABQ5EQACPQAFDwCQ
dGl0bGU9MTl9
:: tooltray/
:: tooltray/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA0LTMwIDE5OjA5OjMzIixtb2RpZmllZD0iMjAyNC0w
Ny0wNiAxMTo0ODozNiJdXWx6NAAEAAAAAwAAADBuaWw=
:: tooltray/clock.lua
--[[pod_format="raw",created="2024-03-10 04:01:54",revision=5]]

-- timezones not implemented yet! everything is stored/shown in GMT
show_date = false
show_local = true

function _draw()

	cls(0)
	local format = show_local and "%Y-%m-%d %H:%M:%S" or nil

	if show_date then
		print(date(format):sub(1,10),0,0,13)
	else
		print(date(format):sub(12),4,0,13)
	end

	print("\014"..(show_local and "local" or " gmt"),52,1,16)

	poke(0x547d,0xff) -- wm draw mask; colour 0 is transparent

end

function _update()
	mx,my,mb = mouse()
	if (mb > 0 and last_mb == 0) then
		if (mx > 48) then
			show_local = not show_local
		else
			show_date = not show_date
		end
	end

	last_mb = mb
end

:: tooltray/eyes.lua
--[[pod_format="raw",created="2024-03-10 04:01:54",modified="2024-03-10 04:04:33",revision=4]]

window(80,40) -- preferred size

function draw_eyeball(x, y, r)
	local mx, my, mb = mouse()

	local angle = atan2(mx - x, my - y)

	circfill(x, y, r, 7)
	circfill(x + cos(angle)*r/2, y + sin(angle)*r/2, r/2, 3)
	circfill(x + cos(angle)*r/2, y + sin(angle)*r/2, r/3, 1)
end

function _draw()

	local w, h = get_display():attribs()
	local r = min(w/2,h)

	cls(0)

	draw_eyeball(w*.25,h/2,r*.48)
	draw_eyeball(w*.75,h/2,r*.48)

	poke(0x547d,0xff) -- wm draw mask; colour 0 is transparent

end

:: util/
:: util/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA0LTMwIDE5OjA5OjMzIixtb2RpZmllZD0iMjAyNC0w
Ny0wNiAxMTo0ODozNiJdXWx6NAAEAAAAAwAAADBuaWw=
:: util/cp.lua
--[[
	cp src dest

	to do:
		-r recursive  //  cp() is currently recursive though!
		how to do interactive copying? (prompt for overwrite)
]]

cd(env().path)
local argv = env().argv

if (argv[1] == "--help") then
	?"usage: cp [options] src dest"
	?"options:"
	?"-f force overwrite of a folder"
	?"-n no clobber (do not overwrite existing files)"
	exit(0)
end


local force_folder_overwrite = false
local no_clobber = false

local files = {}

for i=1,#argv do
	local v = argv[i]
	if (sub(v,1,1) == "-") then
		if (v == "-f") force_folder_overwrite = true
		if (v == "-n") no_clobber = true
	else
		add(files, v)
	end
end

local src = files[1]
local dest = files[2]

if (not src or not dest) then
	print("usage: cp [options] src dest")
	exit(1)
end

local src_type  = fstat(src)
local dest_type = fstat(dest)


if (not src_type) then
	print("could not find "..src)
	exit(1)
end

-------

-- using . or .. always means copy inside
if (dest == "." or dest == "..") dest ..= "/"

-- when destination is a folder, put inside the folder instead of copying over it
if (dest_type == "folder" and not force_folder_overwrite) then
	if (sub(dest,-1,-1) == "/") then

		copy_inside = true -- take as an explicit indication (when copying p64)
		dest = sub(dest,1,-2) -- cut off trailing /
	
		local segs = split(fullpath(src),"/",false)
		dest = dest .. "/" .. segs[#segs]
		dest_type = fstat(dest) -- update 
	end
end

if (no_clobber and fstat(dest)) then
	print("skipping copy over existing file: "..dest)
	exit(0)
end

if dest_type == "folder" and 
	not force_folder_overwrite and not copy_inside
then

	-- refuse to copy over a folder

	print("can not copy over a folder / cartridge.")
	print("  to copy inside: cp a.p64 b.p64/")
	print("  to force overwrite: cp -f a.p64 b.p64")
	exit(1)

else

	if (fstat(dest)) then
		print("copying "..src.." \feover\f7 "..dest)
	else
		print("copying "..src.." to "..dest)
	end

	local err = cp(src, dest)
	if (err) print(err)

end




:: util/default_app.lua

local ext = env().argv[1]
local prog = env().argv[2]

if (type(ext) ~= "string" or not prog) then
	
	print("\f7usage: default_app ext path_to_program")
	print("\f6sets the default application to be used with a file extension.")
	print("\f6e.g.: default_app loop /apps/tools/loop_editor.p64")
	exit(0)
end

if (not fstat(prog)) then
	print("could not find "..prog)
end

prog = fullpath(prog)

local dat = fetch("/appdata/system/default_apps.pod")
if (type(dat) != "table") dat = {}
dat[ext] = prog
store("/appdata/system/default_apps.pod", dat)

print("set files of type \fe."..ext.."\f7 to be opened with \fe"..prog)

:: util/dir.lua
--[[pod_format="raw",created="2023-17-26 21:17:14",modified="2024-04-04 08:23:25",revision=6]]
cd(env().path)

local path0 = env().argv[1] or "."

-- to do: why is this resolving to / when directory no longer exists? maybe terminal is validating pwd?
path = fullpath(path0)

if (not path) then
	print("could not resolve path "..tostr(path0))
	exit(0)
end

local res=ls(path)

if (not res) then
	print("could not find path "..tostr(res))
	exit(0)
end


-- stat each file and show which ones are directories (except for .p64s)
for i=1,#res do

	if (string.sub(res[i],-4) ~= ".p64" and
		 string.sub(res[i],-8) ~= ".p64.rom" and
		 string.sub(res[i],-8) ~= ".p64.png"
		) then
		if (fstat(path.."/"..res[i]) == "folder") then res[i] = res[i].."/" end 
	end

end

if (res) then
	-- to do: pick cols that will fit display width
	-- easiest method: just start at and decrease until fits (or increase until doesn't fit)
	local cols = 2
	for i=1,#res,cols do
		local str=""
		for j=0, cols-1 do
			if (i+j <= #res) then
				local col = "6"
				if (sub(res[i+j],-4)==".lua") then col="c" end
				if (sub(res[i+j],-4)==".txt") then col="a" end -- documents: yellow
				if (sub(res[i+j],-4)==".pod") then col="9" end
				--if (sub(res[i+j],-4)==".png") then col="b" end -- images: green?
				--if (sub(res[i+j],-4)==".p64") then col="s" end

				if (
					string.sub(res[i+j],-4) ~= ".p64" and
					string.sub(res[i+j],-8) ~= ".p64.rom" and
					string.sub(res[i+j],-8) ~= ".p64.png"
				) then
					local attrib, size, mount_point = fstat(path.."/"..res[i+j])
					if (attrib == "folder") col = "e"
					if (mount_point) col = "b"
				end

				str = str .. "\f"..col..res[i+j]
				for k=0,(20 - #res[i+j]) do
					str = str .. " "
				end

			end
		end
		print(str)
	end
else
print("could not list")
end

:: util/edit.lua
--[[pod_format="raw",created="2024-47-08 23:47:10",modified="2024-04-05 14:04:42",revision=2]]
--[[

	edit a file

	choose an editor based on extension [and possibly content if needed]

	** never runs the file -- up to caller to manage that depending on context **

	used by:
		filenav.p64: double click on file
		load.lua: to restore workspace tabs

]]

cd(env().path)


local argv = env().argv
if (#argv < 1) then
	print("usage: edit filename")
	exit(1)
end

-- future: could be a list per extension (open a chooser widget)

local prog_for_ext = fetch("/appdata/system/default_apps.pod")

if (type(prog_for_ext) ~= "table") prog_for_ext = {}

prog_for_ext.lua   = prog_for_ext.lua   or "/system/apps/code.p64"
prog_for_ext.txt   = prog_for_ext.txt   or "/system/apps/notebook.p64"
prog_for_ext.pn    = prog_for_ext.pn    or "/system/apps/notebook.p64"
prog_for_ext.gfx   = prog_for_ext.gfx   or "/system/apps/gfx.p64"
prog_for_ext.map   = prog_for_ext.map   or "/system/apps/map.p64"
prog_for_ext.sfx   = prog_for_ext.sfx   or "/system/apps/sfx.p64"
prog_for_ext.pod   = prog_for_ext.pod   or "/system/apps/podtree.p64"
prog_for_ext.theme = prog_for_ext.theme or "/system/apps/themed.p64"


local show_in_workspace = true

for i = 1, #argv do

	if (argv[i] == "-b") then
		-- open in background
		show_in_workspace = false
	else

		filename = fullpath(argv[i])
		local prog_name = prog_for_ext[filename:ext()]


		if (fstat(filename) == "folder") then

			-- open folder / cartridge
			create_process("/system/apps/filenav.p64", 
			{
				argv = {filename},
				window_attribs = {show_in_workspace = show_in_workspace}
			})

		elseif (prog_name) then

			create_process(prog_name,
				{
					argv = {filename},
					
					window_attribs = {
						show_in_workspace = show_in_workspace,
						unique_location = true, -- to do: could be optional. wrangle also sets this.
					}
				}
			)

		else
			-- to do: use podtree (generic pod editor)
			print("no program found to open this file")

			notify("* * * file type not found * * *")
		end
	end

end

:: util/folder.lua
--[[pod_format="raw",created="2023-29-10 02:29:44",modified="2023-29-10 02:29:44",revision=0]]
cd(env().path)
local path = fullpath(env().argv[1] or ".")

if (not path) then
	print("could not resolve path")
	exit(1)
end


if (path:sub(1,5) == "/ram/" or path == "/ram") then
	print("can not open a ram folder on host")
	exit(1)
end

-- send a message to process manager
send_message(2, {event="open_host_path", path = path})

:: util/help.lua
print
"\
\fe\128 Picotron Cheatsheet\
\
\f7 ls (or dir)       \fd list files in the current folder\
\f7 cd <directory>    \fd change directory (folder)\
\f7 mkdir <directory> \fd create a directory\
\f7 load <filename>   \fd load a cartridge (.p64) into /ram/cart\
\f7 save <filename>   \fd save /ram/cart back to a .p64 file\
\f7 reset             \fd reset draw state\
\
\f7 CTRL-R            \fd run the loaded cartridge\
\f7 ESC               \fd stop program or toggle between editor and output\
\f7 CTRL-L            \fd clear the terminal\
\
\fcTo try out a demo:\
\f7$ cd /system/demos\
$ load highway\
\
\fc.. and then CTRL-R to run it\
"



:: util/info.lua
local pwc = fetch("/ram/system/pwc.pod")

mkdir("/ram/temp") -- to do: should be allowed to assume this exists?
cp("/ram/cart", "/ram/temp/cartsize.p64.rom")
kind, size = fstat("/ram/temp/cartsize.p64.rom")


print("\fecurrent cartridge: "..pwc)
if (size) print(size.." bytes")


:: util/kill.lua

-- send a message to process manager
send_message(2, {event="kill_process", proc_id = tonum(env().argv[1])})

:: util/load.lua
--[[pod_format="raw",created="2024-03-14 19:41:44",modified="2024-03-18 19:25:51",revision=2]]
--[[
	load
		copy to /ram/cart
]]

cd(env().path)

local argv = env().argv
if (#argv < 1) then
	print("\f6usage: load filename -- can be file or directory")
	exit(1)
end


filename = argv[1]


-- load an earlier version of cartridge via anywhen

if (filename:find("@")) then

	filename, when = unpack(split(filename, "@", false))
	filename = fullpath(filename)

	-- expand when into full local time string
	
	local padding = "0000-01-01 00:00:00"
		
	if (when:find(":")) then
		-- time at start: put date at start
		local now_local = date("%Y-%m-%d %H:%M:%S")
		when = now_local:sub(1,11)..when
	end

	-- pad remaining time
	when ..= padding:sub(#when + 1)

	-- convert to UTC
	when = date(nil, when, stat(87))

	--...

	local loc = "anywhen:/"..filename.."@"..when
	print("fetching: "..loc)

	local a = fetch(loc)
	if (type(a) == "string") then
		-- switcheroony
		filename = "/ram/anywhen_temp."..filename:ext()

--		print("opening as "..filename)
		rm(filename)
		store(filename, a)
	else
		print("could not locate")
		exit(0)
	end

	
end


-- bbs cart?

if (filename:sub(1,1) == "#") then
	-- print("downloading..")
	local cart_id = filename:sub(2)
	local cart_png, err = fetch("https://www.lexaloffle.com/bbs/get_cart.php?cat=8&lid="..cart_id)  -- ***** this is not a public api! [yet?] *****
	--local cart_png = fetch("http://localhost/bbs/get_cart.php?cat=8&lid="..cart_id)

	if (err) print(err)

	if (type(cart_png) == "string" and #cart_png > 0) then
		print(#cart_png.." bytes")
		rm "/ram/bbs_cart.p64.png" -- unmount. deleteme -- should be unnecessary
		store("/ram/bbs_cart.p64.png", cart_png)

		-- switcheroony
		filename = "/ram/bbs_cart.p64.png"
	else
		print("download failed")
		exit(0)
	end
end


attrib = fstat(filename)
if (attrib ~= "folder") then
	-- doesn't exist or a file --> try with .p64 extension
	filename = filename..".p64"
	if (fstat(filename) ~= "folder") then
		print("could not load")
		exit(1)
	end
end


-- remove currently loaded cartridge
rm("/ram/cart")

-- create new one
local result = cp(filename, "/ram/cart")
if (result) then
	print(result)
	exit(1)
end

-- set current project filename

store("/ram/system/pwc.pod", fullpath(filename))


-- tell window manager to clear out all workspaces
send_message(3, {event="clear_project_workspaces"})



meta = fetch_metadata("/ram/cart")

if (meta and type(meta.runtime) == "number" and meta.runtime > stat(5)) then
	print("** warning: this cart was created using a future version of picotron.")
	print("** some functionality might be broken or behave differently.")
	print("** please upgrade to the latest version of picotron.")
end


if (meta) dat = meta.workspaces

--[[ deleteme
	dat = fetch("/ram/cart".."/.workspaces.pod")
	if (not dat) printh("*** could not find\n")
]]

-- legacy location;  to do: deleteme
if (not dat) then
	dat = fetch("/ram/cart/_meta/workspaces.pod")
	if (dat) printh("** fixme: using legacy _meta/workspaces.pod")
end

-- legacy location;  to do: deleteme
if (not dat) then
	dat = fetch("/ram/cart/workspaces.pod")
	if (dat) printh("** fixme: found /workspaces.pod")
end

-- at the very least, open main.lua if it exists
if ((type(dat) ~= "table" or #dat == 0) and fstat("/ram/cart/main.lua")) then
	dat = {{location="main.lua"}} -- relative to /ram/cart/
end

if (type(dat) == "table") then

	-- open in background (don't show in workspace)
	local edit_argv = {"-b"}

	for i=1,#dat do

		local ti = dat[i]
		local location = ti.location or ti.cproj_file -- cproj_file is dev legacy
		if (location) then
			add(edit_argv, "/ram/cart/"..location)
		end
	end

	-- open all at once
	create_process("/system/util/open.lua",
		{
			argv = edit_argv,
			pwd = "/ram/cart"
		}
	)

end

print("\f6loaded "..filename.." into /ram/cart")



:: util/ls.lua
--[[pod_format="raw",created="2023-17-26 21:17:14",modified="2024-04-04 08:23:25",revision=6]]
cd(env().path)

local path0 = env().argv[1] or "."

-- to do: why is this resolving to / when directory no longer exists? maybe terminal is validating pwd?
path = fullpath(path0)

if (not path) then
	print("could not resolve path "..tostr(path0))
	exit(0)
end

local res=ls(path)

if (not res) then
	print("could not find path "..tostr(res))
	exit(0)
end


-- stat each file and show which ones are directories (except for .p64s)
for i=1,#res do

	if (string.sub(res[i],-4) ~= ".p64" and
		 string.sub(res[i],-8) ~= ".p64.rom" and
		 string.sub(res[i],-8) ~= ".p64.png"
		) then
		if (fstat(path.."/"..res[i]) == "folder") then res[i] = res[i].."/" end 
	end

end

if (res) then
	-- to do: pick cols that will fit display width
	-- easiest method: just start at and decrease until fits (or increase until doesn't fit)
	local cols = 2
	for i=1,#res,cols do
		local str=""
		for j=0, cols-1 do
			if (i+j <= #res) then
				local col = "6"
				if (sub(res[i+j],-4)==".lua") then col="c" end
				if (sub(res[i+j],-4)==".txt") then col="a" end -- documents: yellow
				if (sub(res[i+j],-4)==".pod") then col="9" end
				--if (sub(res[i+j],-4)==".png") then col="b" end -- images: green?
				--if (sub(res[i+j],-4)==".p64") then col="s" end

				if (
					string.sub(res[i+j],-4) ~= ".p64" and
					string.sub(res[i+j],-8) ~= ".p64.rom" and
					string.sub(res[i+j],-8) ~= ".p64.png"
				) then
					local attrib, size, mount_point = fstat(path.."/"..res[i+j])
					if (attrib == "folder") col = "e"
					if (mount_point) col = "b"
				end

				str = str .. "\f"..col..res[i+j]
				for k=0,(20 - #res[i+j]) do
					str = str .. " "
				end

			end
		end
		print(str)
	end
else
print("could not list")
end

:: util/mkdir.lua

cd(env().path)

if (not env().argv[1]) then
	print("usage: mkdir path")
	exit(1)
end
local path = env().argv[1]

if (fstat(path) == "folder") then
	print("directory already exists")
	exit(1)
end

if (fstat(path) == "file") then
	print("file already exists")
	exit(1)
end

err = mkdir(path)

if (err) then
	print(err)
end

:: util/mount.lua
--[[pod_format="raw",created="2023-27-22 05:27:04",modified="2023-30-22 05:30:21",revision=2]]
cd(env().path)

local target = env().argv[1]
local origin = env().argv[2]

if (not target or not origin) then
	print("mount target origin")
	exit(1)
end

if (fstat(target)) then
	print("target already exists: "..target)
	exit(1)
end

if (not fstat(origin)) then
	print("origin not found: "..origin)
	exit(1)
end

if (not fullpath(target)) then
	print("could not resolve target path")
	exit(1)
end

local kind = fstat(origin)

print("mounting "..kind.." "..origin.." at "..target)

mount(target, origin)

:: util/mv.lua
--[[
	mv src dest

	same semantics as cp except:
		1. keep original creation date
		2. remove original file
]]

cd(env().path)
local argv = env().argv

if (argv[1] == "--help") then
	?"usage: mv [options] src dest"
	?"options:"
	?"-f force overwrite of a folder"
	?"-n no clobber (do not overwrite existing files)"
	exit(0)
end


local force_folder_overwrite = false
local no_clobber = false

local files = {}

for i=1,#argv do
	local v = argv[i]
	if (sub(v,1,1) == "-") then
		if (v == "-f") force_folder_overwrite = true
		if (v == "-n") no_clobber = true
	else
		add(files, v)
	end
end

local src = files[1]
local dest = files[2]

if (not src or not dest) then
	print("usage: mv [options] src dest")
	exit(1)
end

local src_type  = fstat(src)
local dest_type = fstat(dest)


if (not src_type) then
	print("could not find "..src)
	exit(1)
end

-------

-- using . or .. always means copy inside
if (dest == "." or dest == "..") dest ..= "/"

-- when destination is a folder, put inside the folder instead of copying over it
if (dest_type == "folder" and not force_folder_overwrite) then
	if (sub(dest,-1,-1) == "/") then

		copy_inside = true -- take as an explicit indication (when copying p64)
		dest = sub(dest,1,-2) -- cut off trailing /
	
		local segs = split(fullpath(src),"/",false)
		dest = dest .. "/" .. segs[#segs]
		dest_type = fstat(dest) -- update 
	end
end

if (no_clobber and fstat(dest)) then
	print("skipping move over existing file: "..dest)
	exit(0)
end

if dest_type == "folder" and 
	not force_folder_overwrite and not copy_inside
then

	-- refuse to copy over a folder

	print("can not write over a folder / cartridge.")
	print("  to move inside: mv a.p64 b.p64/")
	print("  to force overwrite: mv -f a.p64 b.p64")
	exit(1)

else

	if (fstat(dest)) then
		print("moving "..src.." \feover\f7 "..dest)
	else
		print("moving "..src.." to "..dest)
	end

	local err = mv(src, dest)
	if (err) print(err)

end




:: util/open.lua
--[[pod_format="raw",created="2024-47-08 23:47:10",modified="2024-04-05 14:04:42",revision=2]]
--[[

	edit a file

	choose an editor based on extension [and possibly content if needed]

	** never runs the file -- up to caller to manage that depending on context **

	used by:
		filenav.p64: double click on file
		load.lua: to restore workspace tabs

]]

cd(env().path)


local argv = env().argv
if (#argv < 1) then
	print("usage: edit filename")
	exit(1)
end

-- future: could be a list per extension (open a chooser widget)

local prog_for_ext = fetch("/appdata/system/default_apps.pod")

if (type(prog_for_ext) ~= "table") prog_for_ext = {}

prog_for_ext.lua   = prog_for_ext.lua   or "/system/apps/code.p64"
prog_for_ext.txt   = prog_for_ext.txt   or "/system/apps/notebook.p64"
prog_for_ext.pn    = prog_for_ext.pn    or "/system/apps/notebook.p64"
prog_for_ext.gfx   = prog_for_ext.gfx   or "/system/apps/gfx.p64"
prog_for_ext.map   = prog_for_ext.map   or "/system/apps/map.p64"
prog_for_ext.sfx   = prog_for_ext.sfx   or "/system/apps/sfx.p64"
prog_for_ext.pod   = prog_for_ext.pod   or "/system/apps/podtree.p64"
prog_for_ext.theme = prog_for_ext.theme or "/system/apps/themed.p64"


local show_in_workspace = true

for i = 1, #argv do

	if (argv[i] == "-b") then
		-- open in background
		show_in_workspace = false
	else

		filename = fullpath(argv[i])
		local prog_name = prog_for_ext[filename:ext()]


		if (fstat(filename) == "folder") then

			-- open folder / cartridge
			create_process("/system/apps/filenav.p64", 
			{
				argv = {filename},
				window_attribs = {show_in_workspace = show_in_workspace}
			})

		elseif (prog_name) then

			create_process(prog_name,
				{
					argv = {filename},
					
					window_attribs = {
						show_in_workspace = show_in_workspace,
						unique_location = true, -- to do: could be optional. wrangle also sets this.
					}
				}
			)

		else
			-- to do: use podtree (generic pod editor)
			print("no program found to open this file")

			notify("* * * file type not found * * *")
		end
	end

end

:: util/ps.lua

local p = fetch"/ram/system/processes.pod"

for i=1,#p do

	print(string.format("%4d %-20s %0.3f", p[i].id, p[i].name, p[i].cpu))
	
end

:: util/pwc.lua

?fetch("/ram/system/pwc.pod")

:: util/pwd.lua
?env().path

:: util/reboot.lua
--[[pod_format="raw",created="2024-04-01 02:35:27",modified="2024-04-01 02:35:27",revision=0]]
send_message(2, {event="reboot"})

--[[
print("reboot is not implemented yet")
print("please toggle power manually")
]]
:: util/rm.lua
--[[
	cp src dest

	resulting file should be idential to src (can't just fetch and then store)

	to do:
		-r recursive // rm() is currently recursive by default though
		how to do interactive copying? (prompt for overwrite)
]]

cd(env().path)
local argv = env().argv

if (#argv < 1) then
	print("usage: rm filename")
	exit(1)
end

local filename = fullpath(argv[1])
if (not filename) then
	print("could not resolve path")
	exit(0)
end


local attribs, size, origin = fstat(filename)

if (attribs) then

	-- exists. to do: directories need to be empty?

	print("deleting "..filename)

	rm(filename)

else

	print("not found")

end







:: util/run.lua
--[[pod_format="raw",created="2023-00-01 20:00:59",modified="2024-04-25 01:04:50",revision=1]]

local argv = env().argv

if (#argv < 1) then
	print"hit ctrl-r!"
	exit(1)
end

--[[

cd(env().path)


show_in_workspace = true

for i = 1, #argv do

	if (argv[i] == "-b") then
		show_in_workspace = false
	else
		-- run
		
		local proc_id = create_process(
			fullpath(prog_name), 
			{
				print_to_proc_id = pid(),  -- tell new process where to print to
				argv = argv,
				path = pwd(), -- used by commandline programs -- cd(env().path)
				window_attribs = {show_in_workspace = show_in_workspace}
			}
		)
	)

	end
end

]]

:: util/save.lua
--[[pod_format="raw",created="2024-03-23 17:34:07",modified="2024-04-07 23:28:24",revision=6]]
--[[
	save

		copy from /ram/cart to present working cartridge location
		e.g.
		cp("/ram/cart", "/mycart.p64")

]]

cd(env().path)

local argv = env().argv or {}

local save_as = argv[1] or fetch("/ram/system/pwc.pod") or "/untitled.p64"
save_as = fullpath(save_as)

if (not save_as) then
	print("error: filenames can only include letters, numbers, or ._-")
	exit()
end


if (save_as:sub(1,10) == "/ram/cart/") then
	print("error: can not save the working cartridge inside itself.")
	print("try \"cd /\" first")
	exit()
end

if (save_as:sub(1,8) == "/system/") then
	print("** warning ** saving to /system will not persist to disk")
end


-- add extension when none is given (to do: how to save to a regular folder with no extension in name? maybe just don't do that?)
if (sub(save_as, -4) ~= ".p64" and sub(save_as, -8) ~= ".p64.rom" and sub(save_as, -8) ~= ".p64.png") then
	save_as ..= ".p64"
end

-- save all files and metadata
-- hack: need to wait to complete at each step. to do: need the concept of a blocking message
send_message(3, {event="save_working_cart_files"})
for i=1,12 do flip() end
send_message(3, {event="save_open_locations_metadata"})
for i=1,4 do flip() end


-- set runtime version metadata
-- when loading a cartridge, runtime should be greater or equal to this
-- (splore: refuse to run; otherwise: show a warning)

store_metadata("/ram/cart", {runtime = stat(5)})


-- copy /ram/cart to present working cartridge

pwc_meta = fetch_metadata(save_as)

local result = cp("/ram/cart", save_as, 0x1)

if (result) then
	print(result)
	exit(1)
end

-- don't want to clobber existing created timestamp; normally when copying a folder over a folder, target is considered a newly created folder
-- something similar happens inside _cp but handled separately -- don't want to clobber .created when moving via rm,cp
if (pwc_meta and pwc_meta.created) store_metadata(save_as, {created = pwc_meta.created}) 


store("/ram/system/pwc.pod", save_as)

-- temporary warning for 0.1
-- don't want /system to be write-only because want to allow things like sedit
if (save_as:sub(1,8) == "/system/") then
	notify("saved "..save_as.."    *** note: changes to /system are in ram only ***")
end


print("saved "..save_as)


:: util/shutdown.lua
send_message(2, {event="shutdown"})

:: wallpapers/
:: wallpapers/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA0LTMwIDE5OjA5OjMzIixtb2RpZmllZD0iMjAyNC0w
Ny0wNiAxMTo0ODozNiJdXWx6NAAEAAAAAwAAADBuaWw=
:: wm/
:: wm/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA0LTMwIDE5OjA5OjMzIixtb2RpZmllZD0iMjAyNC0w
Ny0wNiAxMTo0ODozNiJdXWx6NAAEAAAAAwAAADBuaWw=
:: wm/infobar.lua
--[[

	infobar.lua


	each entry can have a location tied to it (double click to open that location)
		// handy for jumping to code in stack traces

]]



local logdat={
}


local infobar_is_visible = false

local gui = create_gui()
gui.width = 480
gui.height = 270


function get_show_infobar()
	--return #logdat > 0
	return infobar_is_visible
end

function clear_infobar()
	logdat = {}
end

function hide_infobar()
	infobar_is_visible = false
end

-- dorky name because show_infobar is used in wm -- to do: delete old logic and organise names 
function open_infobar()
	infobar_is_visible = true
end


function update_infobar()
	
	gui:update_all()

end


function generate_infobar_gui()

	gui = create_gui{
		-- position,size will be adjusted by window manager
		x=0, y=0, 
		width=480, height=270,

		draw = function(self, msg)

			rectfill(0, 0, self.width, 11, 7)
			rectfill(0, 12, self.width, self.height, 16)

			-- title
			print(logdat[1], 3, 2, 1)
			circ(474, 6, 2, 1)

			-- dummy text
			local yy = 16  -- don't write on the bar -- can leave that empty! active message is drawn separtely.
			local xx = 0

			local mx, my = mouse() -- screen space; relative to head_gui
			my -= gui.y            -- ..so need to adjust manually here

			-- printh("infobar: "..pod{msg.mx, msg.my, mx, my})

			--for i=2, 30 do -- to do: why does printing nil here cause a freeze?
			for i=2, #logdat do

				if (my and my >= yy-1 and my < yy + 10) then
					rectfill(0,yy-2,480,yy+9,10)
					hover_item = i
				end
				xx, yy = print(logdat[i], 3, yy, 6)				
			end
		
		end,

		-- ** don't need update --
		--update = gui_update,

		update = function(self, msg)
			--printh("infobar gui position: "..pod{gui.x, gui.y})
			--printh("msg: "..pod(msg))
		end,


		
		tap = function(self, e)

			-- close // to do: button
			if (e.mx > 460 and e.my < 12) hide_infobar() return

			local str = logdat[hover_item]
			if (type(str) != "string") return
			local pos = 1
			while (pos < #str and (sub(str,pos,pos) == "\t" or sub(str,pos,pos) == " ")) pos += 1

			-- 
			local pos1 = pos+1
			while (pos1 < #str and sub(str,pos1,pos1) ~= ":") pos1 += 1
			if (sub(str,pos1,pos1) == ":") then
				
				-- get number
				local pos2 = pos1+1
				while (pos2 < #str and sub(str,pos2,pos2) ~=  ":") pos2 += 1
				if (sub(str,pos2,pos2) == ":") then
					create_process("/system/util/open.lua",{
						argv = {sub(str, pos, pos1-1).."#"..sub(str, pos1+1, pos2-1)}
					}
				)

				end
			end

		end,

		drag = function(self,e)
			send_message(3, {event="drag_infobar", dy=e.dy})
		end
	}

	return gui

end

function infobar_init()
	return generate_infobar_gui()
end


--[[
on_event("log", function(msg)

	if (type(msg.content) == "string") then

		local strs = split(msg.content, "\n", false)

		for i=1,#strs do

			add(logdat, strs[i], 1)
			while(#logdat > 64) deli(logdat) -- trim

		end

		printh("** log (removeme -- deprecated) "..msg.content) 
	end

	--printh("@@@@@ infobar received log: "..pod(msg))

end)
]]

local last_reported_error_t = 0

on_event("report_error", function(msg)

	if (type(msg.content) == "string") then

		-- don't reset immediately after last error (want to see the first error. e.g syntax error causes runtime error)
		if (sub(msg.content,1,1) == "*" and time() > last_reported_error_t + 1) then
			logdat = {}
			msg.content = sub(msg.content, 2)

			show_reported_error()
			last_reported_error_t = time()
		end

		local strs = split(msg.content, "\n", false)

		for i=1,#strs do
			-- maximum: 20 entries
			if (#strs[i] > 0 and #logdat < 20) add(logdat, strs[i])
		end

		--add(logdat, msg.content)
		infobar_is_visible = true
	end

end)





:: wm/sparkles.lua
--[[

	proof of concept: module that hooks into wm with update, draw callbacks

		** don't really want to invite code running in kernel though
		** and don't want to try to sandbox /within/ a lua state [yet?]

		how to specify callback draw / update order without modifying wm.lua?
		this file should return the module table, including a key that matches settings.pod item (or have own settings)
		
		// result: maybe this kind of thing should just run in a separate process as an overlay
		// expensive, but mostly used for silly things anyway? birds.p64
		// push to homogenous userland patterns as much as possible (see red notebook)

]]

local sparkle = {}

-- currently used to reset when option turned off / on
function init_sparkles()
	sparkle = {}
end


function make_sparkle(x,y)
	local mag = 0.5

	return add(sparkle, {
		x = x, y = y,
		dx = rnd(mag)-rnd(mag),
		dy = rnd(mag)-rnd(mag),
		t = 0, max_t = 40 + rnd(30),
		col = 8+rnd(8)
	})
end

local last_mx, last_my

function update_sparkles()

	local mx,my,mb = mouse()
	mx += 4 my += 4 -- fudge

	if (not last_mx) then
		last_mx, last_my = mx, my
	end

	local dx = mx - last_mx
	local dy = my - last_my

	last_mx, last_my = mx, my

	local steps = min(10, max(abs(dx), abs(dy)))

	if (steps > 1) steps \= 2 -- sparser trail is nicer

	if (steps >= 1) then
		dx /= steps
		dy /= steps
		for i=1,steps do
			make_sparkle(mx, my)
			mx += dx 
			my += dy
		end
	end

	for i=#sparkle,1,-1 do
		local s = sparkle[i]

		s.x += s.dx
		s.y += s.dy

		s.t += 1
		if (s.t >= s.max_t) del(sparkle, s)
		
	end

end

function draw_sparkles()
	for i=1,#sparkle do
		local s = sparkle[i]

		if (s.t > s.max_t - 15) then
			pset(s.x, s.y, 6)
		else
			circ(s.x, s.y, 1, s.col)
			pset(s.x, s.y, 7)
		end
	end
	
end


:: wm/toolbar.lua
--[[

	toolbar.lua

	includeable version -- run in same lua state as window manager
		// implementing as a separate process causes too much complex, fragile interaction between wm <--> toolbar

]]

do -- locals don't conflict with window manager


local toolbar = {}


local picotron_icon = userdata("[gfx]08087777770077777770000070707770777070700000777777700777777000000000[/gfx]")

local minimal = true

local gui = create_gui()

local char_w = peek(0x5600)

local tabs_container

local function has_window_menu_in_toolbar()

--	if (get_workspace().child and #get_workspace().child == 0) return false -- empty workspace
--	return get_workspace().style == "tabbed"

--[[
	-- include app menu on desktop (is always filenav menu)
	-- update: commented for now; feels messy and unclear
	-- and maybe right menu click on files would be nicer? 
	return get_workspace().style ~= "fullscreen"
]]
	-- need app menu iff have one or more tabs
	local tabs = get_workspace_tabs()
	if (tabs and #tabs > 0) return true

end


function make_window_button(parent, label, x, y, width, height, win)
	parent = parent or gui
	local b = {label=label, x=x, y=y, width=width, height=height, cursor = "pointer"}

	b.col = 2

	function b:drag(event)
		return true -- stop parent from being draggable
	end

	function b:draw(event)
		local yy = (event.mb > 0 and event.has_pointer) and 1 or 0

		pal(7, theme(parent.col_k or "toolbar_item"))
			for y=yy+2,yy+6,2 do
				line(2,y,8,y,7)
			end
		pal(7,7)

	end

	function b:tap(event)
		-- if deskop, always applies to the filenav overlay
		--toggle_app_menu(self.sx, self.sy + self.height, win)
	end

	return parent:attach(b)
end



local function make_picotron_button(parent, label, x, y, width, height)
	parent = parent or gui
	local b = {label=label, x=x, y=y, width=width, height=height}

	b.col = 2

	function b:drag(event)
		return true -- stop parent from being draggable
	end


	function b:draw(event)
		local yy = (event.mb > 0 and event.has_pointer) and 2 or 1

		pal(7, theme("toolbar_item"))
			spr(picotron_icon, 1, yy)
		pal(7,7)

	end

	function b:tap(event)
		--toggle_picotron_menu()
	end

	return parent:attach(b)
end


local function make_new_tab_button(parent, label, x, y, w, h)

	local tt = parent:attach{x=x, y=y, width=w, height=h, label=label}

	function tt:drag(event)
		return true -- stop parent from being draggable
	end

	function tt:draw(event)

		local bg_col = theme("toolbar_item") 
		local x = 1 -- self.sx 
		local y = 0 -- self.sy
		if (event.has_pointer and event.mb > 0) y+=1

		-- to do: should just draw tab sprites and recolour them
		rectfill(x,y,x+w-2,y+h-1, bg_col)
		pset(x,y,theme"toolbar_back")
		pset(x+w-2,y,theme"toolbar_back")
		line(0,y,0,y+h-1, theme"toolbar_back")

		local str = self.label
		local text_w = print(str, 0, -1000)
		print(str, x + self.width/2 - text_w\2, y+1, theme"toolbar_back")

	end



	function tt:tap(event)

		-- create new file in same folder as neighbour
		-- to do: smart naming: 0.gfx is followed by 1.gfx etc

		local awin = get_active_window()
		local loc = (awin and awin.location) or "/ram/cart/untitled.lua"
		local ext = loc:ext()
		local segs = split(loc,"/",false)
		local path = string.sub(loc, 1, -#segs[#segs] - 2)

		-- deleteme -- titled "New File", so doesn't feel right double clicking to open an existing file
		-- create_process("/system/apps/filenav.p64", {path=path, intention="new_file", window_attribs={workspace = "current", autoclose=true}})

		-- "new_tab": can either open or create a file from filenav starting state. 
		-- guess default extention by current localtion, files in same folder, or fall back to .txt.
		-- (is used by filenav when user types filename with no extension)

		local use_ext = (awin and awin.location and awin.location:ext())

		if (not use_ext) then
			local files = ls(path)
			if (files) then
				for i=1,#files do
					if (fstat(path.."/"..files[i]) == "file" and files[i]:ext()) use_ext = files[i]:ext()
				end
			end
		end

		create_process("/system/apps/filenav.p64", 
		{
			path=path, intention="new_tab", 
			use_ext=use_ext or ".txt", 
			window_attribs={workspace = "current",autoclose=true},
			open_with = get_workspace().prog,
		})

	end


	return tt

end


-- tab is functionally the same as a window frame
-- window holds any attributes of interest to drawing / updating a tab
local function make_tab_button(parent, win, x, y, w, h)

	win = win or {title="tab_error"}

--[[
	local str = win.title or "_"	
	local text_w = print(str, 0, -1000)
	printh("tab title: "..str.."   width:"..text_w)
	-- to do: width function of title (nice, but complicates drag and switch
	w = text_w + 12
]]

	local tt = parent:attach{win = win, x=x, y=y, width=w, height=h}

--	
--[[
	-- to do: update variable width tabs / regenerate gui when tab title changes
	function tt:update()

		local str = self.win.title or "_"	
		local text_w = print(str, 0, -1000)
--		printh("tab title: "..str.."   width:"..text_w)
		self.width = text_w + 12
	end
]]


	
	function tt:draw(event)

		-- to do: tool can decide what background colour is for active tab
		-- same as selected workspace colour
		local bg_col = self.win.is_active and theme("toolbar_selected") or theme("toolbar_item") -- active tab is bright
--		local bg_col = self.win.is_active and 1 or 14 -- tried to get tab to match code editor background -- confusing.


		local x = 1 -- self.sx -- now relative to gui position
		local y = 0 -- self.sy
		
		if (event.has_pointer and event.mb > 0) y+=1


		--rectfill(x,y,x+w-1,y+h-1,2)

		-- to do: should just draw tab sprites and recolour them
		rectfill(x,y,x+w-2,y+h-1, bg_col)
		pset(x,y,theme"toolbar_back")
		pset(x+w-2,y,theme"toolbar_back")
		line(0,y,0,y+h-1, theme"toolbar_back")

		local str = win.title or "no title"
		
		-- temp debug: show position in gui element list
		--[[	
		local index = -1
		for i=1,#self.parent.child do
			if (self.parent.child[i] == self) index = i
		end
		str = index..str
		]]

		
		local text_w = print(str, 0, -1000)
		--local text_w = #str * char_w
		--[[
		if (text_w > self.width and str:ext()) then
			str = sub(str,1,-(2+#str:ext()))
			text_w = print(str, 0, -1000)
		end
		]]
		print(str, x + max(3, self.width/2-text_w\2), y+1, self.win.is_active and theme"toolbar_back" or theme"toolbar_back")


	end

	function tt:tap(event)

		if (event.last_mb == 1) then -- need to use last_mb for tap because mb is always 0 by this stage

			send_message(3, {event="bring_window_to_front", proc_id = self.win.proc_id})		
			self:bring_to_front()
			--update_tab_widths(self)
		else
			-- right mouse click to bring up app menu
			toggle_app_menu(self.sx, self.sy + self.height, self.win)
		end

		-- variable widthed tabs. messy
		--[[
			-- assume bring_window_to_front will succeed. remove 1 glitch frame
			get_active_window().is_active = false
			tt.win.is_active = true 

			generate_toolbar_gui() -- need if window tabs change size according to status
		]]
	end

	function tt:drag(event)

		if (event.mx < 0 or event.mx >= self.width) then

			local tab = get_workspace_tabs()
			local index = nil
			for i=1,#tab do
				if (tab[i] == self.win) index = i
			end

			-- ** unnecessarily complex
			-- ** to do: re-work how tab ordering is stored
			--    perhaps always just operate on x,y and position in list of gui elements is immaterial

			local index0,index1,index2

			for i=1,#self.parent.child do
				if (self.parent.child[i].win == tab[index])   index0 = i
				if (self.parent.child[i].win == tab[index-1]) index1 = i
				if (self.parent.child[i].win == tab[index+1]) index2 = i
			end
			
			if event.mx < 0 and index1 and tab[index-1] and tab[index-1].label ~= "+" then
				-- switch left
				tab[index], tab[index-1] = tab[index-1], tab[index]
				self.parent.child[index0].x,  self.parent.child[index1].x  = self.parent.child[index1].x,  self.parent.child[index0].x  
				self.parent.child[index0].sx, self.parent.child[index1].sx = self.parent.child[index1].sx, self.parent.child[index0].sx
			end

			if event.mx >= self.width and index2 and tab[index+1] and tab[index+1].label ~= "+" then
				-- switch right
				tab[index], tab[index+1] = tab[index+1], tab[index]
				self.parent.child[index0].x,  self.parent.child[index2].x  = self.parent.child[index2].x,  self.parent.child[index0].x  
				self.parent.child[index0].sx, self.parent.child[index2].sx = self.parent.child[index2].sx, self.parent.child[index0].sx
			end

		end

		return true -- can't also drag toolbar when dragging tab

	end

	return tt
end


-- deleteme -- too messy!
local function make_dock_button(parent, x, y, width, height)

	parent = parent or gui
	local b = {index=index, label=label, x=x, y=y, width=width, height=height}

	b.icon0 = userdata"[gfx]08080000000000000000000700000077700007777700077777000000000000000000[/gfx]"
	b.icon1 = userdata"[gfx]08080000000000000000000000000007700000077000000000000000000000000000[/gfx]"

	function b:draw(event)
		local ws = get_workspace()
		local yy = (event.mb > 0 and event.has_pointer) and 1 or 0
		pal(7, 13)
		spr(ws.show_toolbar and b.icon1 or b.icon0, 0, yy + 1)
		pal(7,7)
		--rectfill(0,0,4,4,8)
	end

	function b:tap()
		local ws = get_workspace()
		ws.show_toolbar = not ws.show_toolbar
	end


	return parent:attach(b)
end


local function make_workspace_button(index, parent, label, x, y, width, height)
	parent = parent or gui
	local b = {index=index, label=label, x=x, y=y, width=width, height=height}

	b.icon = get_workspace_icon(index)

	function b:drag(event)
		return true -- stop parent from being draggable
	end


	function b:draw(event)
		local xx = 0 -- b.sx
		local yy = 0 -- b.sy
		if (event.mb > 0 and event.has_pointer) then 
			yy = yy + 1
		elseif get_workspace_index() == b.index and key("lalt") and (key("left") or key("right")) then
			-- show button down when used alt+l/r to switch workspace
			yy = yy + 1
		elseif get_workspace_index() == b.index then
			--yy = yy + 1
		end

		pal(7, get_workspace_index() == b.index and theme("toolbar_selected") or theme("toolbar_item"))
		
		-- live update
		local ws = get_workspace()
		if (get_workspace_index() == b.index) b.icon = ws.icon

		spr(b.icon, xx + 4, yy + 1)

		pal(7,7)

	end

	-- later: can drag workspace buttons around; so use :tap for activating
	function b:tap(event)
		if (event.last_mb == 1) then
			set_workspace(b.index)
		else
			-- printh(pod(get_workspace(b.index).attribs))

			if (not get_workspace(b.index).immortal) then
				toggle_workspace_menu(min(370, self.sx), self.sy + self.height, b.index)
			end
		end
	end
	
	return parent:attach(b)
end



local last_num = nil
local last_tabs = nil

--function update_toolbar()

local function gui_update()

	
	-- safety: make sure don't need to update gui because of changing tabs
	-- (but better to do proactively from wm.lua to avoid being one frame behind)
	if (last_tabs ~= get_workspace_tabs() or last_num ~= #get_workspace_tabs()) then
		generate_toolbar_gui()
		last_tabs = get_workspace_tabs()
		if (last_tabs) then
			last_num  = #get_workspace_tabs()
		end
	end

end



--[[
to do: dynamic tab widths
function update_tab_widths(awin)
	local xx = 0

	local tabs = tabs_container.child

	for i = 1, #tabs do
		local tt = tabs[i]
		tt.x = xx
		tt.sx = tt.parent.sx + tt.x -- update now
		tt.width = tt == awin and 64 or 48
		if (tt.label == "+") tt.width=20
		xx += tt.width
	end
end
]]

function generate_toolbar_gui()

--	printh("-- generating toolbar gui --")
	gui = create_gui{
		x=0,y=0,width=480,height=11,

		draw = function(self)
			rectfill(0, 0, self.width, self.height, theme"toolbar_back")
		end,
		update = gui_update,

		drag = function(self,e)
			-- to do: check if is active element; can remove all the children's dummy :drag() callbacks
			-- is this the right pattern for toolbar style buttons that have a container that does something?
			--send_message(3, {event="drag_toolbar", dy=e.dy})
		end
	}

	local workspace_w = min(16, 116 / get_num_workspaces())
	local x = 476 - get_num_workspaces()*workspace_w

	for i=1,get_num_workspaces() do

--		if (i == get_num_workspaces()) then x = x + 3 end -- temp formatting hack for twitter code edits code gif
		make_workspace_button(i, gui, "wbtn"..tostr(i),x,1,16,10)
		x = x + workspace_w

	end

	-- experimental: docking button
--	make_dock_button(gui, 480-12, 1, 10, 10)

	local tab = get_workspace_tabs()
	local tab_width = 50 -- overwritten below
	local tabs_container_x = has_window_menu_in_toolbar() and 35 or 20
	local xx = 0

	if (tab) then

		-- container

		tabs_container = gui:attach{
			x=tabs_container_x, y=0, width=320, height=gui.height,

			drag = function(self,msg)
				--printh("drag container "..msg.dy)
				gui.y += msg.dy
			end,

			draw = function()
				-- for cursor // to do: shouldn't need draw function
			end

		}

		for i=1,#tab do
			if tab[i] then
				if not tab[i].closing and not tab[i].hidden then

					tab_width   = min(56, 316 \ #tab) -- skinny when too many tabs. leave some space for workspaces!

					local tt = make_tab_button(tabs_container, tab[i], xx, 1, tab_width-1, 10)
					tt.index = i
					xx += tt.width
				end
			end
		end

		--update_tab_widths(get_active_window())
		

		-- new tab: default to an untitled document

		if (get_workspace().style == "tabbed") then
			
			make_new_tab_button(tabs_container, "+", xx, 1, 17, 10)
		end

	end

	make_picotron_button(gui,"picotron menu", 4,1, 10,10)


	if has_window_menu_in_toolbar() then
		make_window_button(gui, "app menu", 18, 1, 10,10, get_window_by_proc_id(get_workspace().desktop_filenav_proc_id))
	end
	
	return gui

end

function toolbar_init()
	return generate_toolbar_gui()
end



end

:: wm/wm.lua
--[[

	Picotron Window Manager
	(c) Lexaloffle Games LLP

	Warning: this is a WIP -- a lot of internals are experimental and/or will change

]]


include("/system/wm/toolbar.lua")
include("/system/wm/infobar.lua")
include("/system/wm/sparkles.lua")

local default_cursor_gfx = userdata("[gfx]10100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000001710000000000000177100000000000017771000000000001777710000000000177110000000000001171000000000000000000000000000000000000[/gfx]")


local bar_h = 12 -- same as toolbar.lua. how to sync? global data?
local tooltray_default_h = 80

local mx, my, mb, mdx, mdy

local head_gui = nil

local workspace = {} -- desktop workspace
local ws_gui = nil   -- current workspace
local tooltray_gui = nil   -- global tooltray gui
local tooltray_active_window = nil -- set to a tooltray window when has focus
local workspace_index = 1
local last_desktop_workspace = nil
local last_fullscreen_workspace = nil
local toolbar_y        = 0
local toolbar_y_target = 0
local infobar_y        = 270 --270-11
local infobar_y_target = infobar_y



function show_reported_error() -- happens when error is reported
	open_infobar()
	infobar_y_target = 200 -- not too high, want to see code
end


local last_input_activity_t = 0

-- store some things by process so that they can be manipulated before window is created
local proc_icon = {}
local proc_menu = {}

local char_w = peek(0x5600)

local prev_frame = nil

local last_mx, last_my, last_mb


function generate_head_gui()

--	printh("generate_infobar_gui "..time())
	
	head_gui = create_gui{
		x = 0, y = 0, 
		width = 480, height = 270
	}

--[[
	-- debug
	function head_gui:draw()
		cls(9)
		camera() clip()
		rectfill(0,0,1000,1000,8)
		rectfill(0,0,1000,30,10)
		for i=1,#head_gui.child do
			local c = head_gui.child[i]
			print(pod{c.sx, c.sy, c.width, c.height}, 340, 30+i*10, 7)
		end
		for i=1,#ws_gui.child do
			local c = ws_gui.child[i]
			print(pod{c.sx, c.sy, c.width, c.height}, 340, 90+i*10, 7)
		end
	end
]]

	toolbar_gui = generate_toolbar_gui()
	infobar_gui = generate_infobar_gui()

	head_gui.child = {}
	head_gui:attach(tooltray_gui)
	head_gui:attach(ws_gui)
	head_gui:attach(toolbar_gui)
	head_gui:attach(infobar_gui)

	
--[[
	--printh("@@ generate_head_gui: #ws_gui.child: "..#ws_gui.child)
	printh("@@ generate_head_gui: ws_gui "..tostr(ws_gui).."  (workspace_index: "..workspace_index..")")
	if (ws_gui and ws_gui.child) printh("  // #ws_gui.child: "..#ws_gui.child)
	if (ws_gui and ws_gui.child and ws_gui.child[1]) printh("  // ws_gui.child[1].width: "..tostr(ws_gui.child[1].width))
]]

	function head_gui:update()

		-- slide infobar / infobar to targets
		toolbar_y = (toolbar_y * 3 + toolbar_y_target) / 4
		infobar_y = (infobar_y * 3 + infobar_y_target) / 4
		
		-- move towards target a pixel so that can reach exact value. also just nicer motion (no single-pixel creep at end; small transitions are faster)

		if (toolbar_y < toolbar_y_target) then
			toolbar_y = min(toolbar_y + 1, toolbar_y_target) else
			toolbar_y = max(toolbar_y - 1, toolbar_y_target) end

		if (infobar_y < infobar_y_target) then
			infobar_y = min(infobar_y + 1, infobar_y_target) else
			infobar_y = max(infobar_y - 1, infobar_y_target) end
		

		-- tooltray visibility
		if (tooltray_is_open() ~= last_tooltray_is_open) then
			for i=1,#tooltray_gui.child do
				send_message(tooltray_gui.child[i].proc_id, {event=tooltray_is_open() and "gained_visibility" or "lost_visibility"})
			end
		end
		last_tooltray_is_open = tooltray_is_open()

		-- don't draw under toolbar (optimisation)
		tooltray_gui.height = toolbar_y - tooltray_gui.y


		-- to do: show_bars should be initial state, and then docked is optional
		local show_toolbar = ws_gui.show_toolbar 
--		local show_infobar = ws_gui.show_infobar
		local show_infobar = get_show_infobar()

		if (key("alt")) show_toolbar = true

		-- auto-showing bars using mouse position is annoying in fullscreen; just for tools / desktop
		-- fullscreen has ESC, but tools have no other way to reach toolbar (without knowing kbd shortcut)
		--if (false) then
		if (ws_gui.style ~= "fullscreen") then
			--if ((my < 2 and mb == 0) or my < toolbar_y + toolbar_gui.height) then 
			if ((my < 2 and mb == 0)) then -- don't need second test if doing ws_gui.show_toolbar = true; allows ctrl-1 to immediately hide even while mouse is at top
				show_toolbar = true
				ws_gui.show_toolbar = true -- experimental: low friction to de-fullscreenify. can turn off at system settings level
			end
			-- if ((my >= 270-2 and mb == 0) or my >= infobar_y) show_infobar = true
		end

		if (screensaver_proc_id) then
			show_toolbar, show_infobar = false, false
		end



		if (show_toolbar) then
			toolbar_y_target = -toolbar_gui.height 
		else
			-- hide [unless pulled out]
			--if (toolbar_y < 40) 
			toolbar_y_target = -toolbar_gui.height 
		end

		if (show_infobar) then
			infobar_y_target = min(infobar_y_target, 270-12)
			-- snap. assumption: never want to leave an 8px (or less) sliver visible at top
			if (infobar_y_target >= 270 - 12-8 and mb == 0) infobar_y_target = 270-12 -- can't use infobar_gui.height -- is 270, not 12!
		else
			-- hide [unless pulled out]
			--if (infobar_y > 270-40) 

			infobar_y_target = 270
		end



		-- jump when workspace changed (otherwise can see uncovered area e.g. above tabbed window)
		if (time() < head_gui.t0 + 0.2) then
			toolbar_y = toolbar_y_target
		end


		--------- apply toolbar / infobar position --------		

--		tooltray_gui.y = min(0, - tooltray_default_h / 1.5 + toolbar_y / 1.5) \ 1 -- move at different speed; feels more like a deep drawer. ottoman
--		tooltray_gui.y = toolbar_y - tooltray_default_h  -- same speed (testing concept: toolbar / tray is more of a single thing. too chunky)
		
		toolbar_gui.y  = toolbar_y \ 1
		toolbar_gui.sy = toolbar_y \ 1
		ws_gui.y       = max(0, toolbar_y \ 1) -- when toolbar is overlapping (fullscreen) and above top, workspace stops moving up at 0
		infobar_gui.y  = infobar_y \ 1
		infobar_gui.sy = infobar_gui.y

	end

end

-- new version: derive attributes from window and calling program
function create_workspace_1(proc_id, win_attribs)
	local ws = head_gui:new()
	ws.x = 0
	ws.y = 0
	ws.width = 480
	ws.height = 270
	ws.index = #workspace       -- ** should be "id"; can be out of order. to do: unique ids
	ws.icon = win_attribs.icon 
	ws.head_proc_id = proc_id
	ws.prog = win_attribs.prog
	ws.tabs = {}

	-- workspace inherits some of the attributes of window; 
	-- used when deciding which workspace to create windows in
	ws.style = "fullscreen"
	if (win_attribs.fullscreen) ws.style = "fullscreen"       -- default, but tested here for clarity
	if (win_attribs.workspace == "new") ws.style = "desktop"  -- requesting new workspace mean requesting new desktop
	if (win_attribs.tabbed) ws.style = "tabbed"               -- ignore fullscreen if it is set

	-- workspace inherits immportality
	if (win_attribs.immortal) ws.immortal = true

	-- default desktop workspace icon
	if not ws.icon then
		ws.icon = ws.style == "desktop" and 
			userdata"[gfx]08087777777777777777777777777777777700000000777777777700007700000000[/gfx]" or  -- desktop
			userdata"[gfx]09070007070000000700007777777777700000777700000777700000777777777770[/gfx]"     -- tv
	end

	-- initialise toolbar / infobar docking based on style
	ws.show_toolbar = ws.style ~= "fullscreen"
	ws.show_infobar = false

	-- opening a window into a desktop that has no underlay -> clear each frame 
	-- (harmless if false positive -- just slightly inefficient)
	if (ws.desktop and win_attribs.width < 480) then
		ws.clear_each_frame = true
	end
	
	-- ignore workspace flow while booting
	visit_workspace(ws)

	function ws:draw()
		--cls(3) -- debug: see when workspace is redrawn
		if (#self.child == 0) then
			rectfill(0,0,self.width,self.height,1)
			print("[ empty workspace ]",self.width/2-19*2.5,self.height/2,13)
		end
	end

	local pos = 1
	while (workspace[pos] and ws.head_proc_id > workspace[pos].head_proc_id) do
		pos += 1
	end

	local result = add(workspace, ws, pos)

	return result, pos
end

-- globals used by toolbar.lua

function get_workspace(index)
	if (not index) return ws_gui or {}
	return workspace[index] or {}
end

function get_num_workspaces()
	--printh("get_num_workspaces(): "..tostr(#workspace))
	return #workspace
end

function get_workspace_index()
	return workspace_index
end

function get_workspace_tabs()
	return (ws_gui and ws_gui.tabs) or {}
end

function get_workspace_icon(index)
	local icon = nil
	if (workspace[index]) then
		icon = proc_icon[workspace[index].head_proc_id]
		if (not icon and workspace[index].style == "desktop") then
			icon = userdata("[gfx]08087777777777777777777777777777777700000000777777777700007700000000[/gfx]")
		end
	end

	-- default: tv
	if (not icon) icon = userdata("[gfx]0907000707000000070000777777777770000077770000077770000077777777777[/gfx]")
	return icon
end



local last_active_win = nil


local put_x = 0
local put_y = 0



function tooltray_is_open()
	return toolbar_y > 0
end

-- used for keeping track of which workspace to toggle between (ESC) or where desktop is
-- when deciding to put new windows
function visit_workspace(ws)

	if (ws.style == "fullscreen") last_fullscreen_workspace = ws
	if (ws.style ~= "fullscreen") last_non_fullscreen_workspace = ws
	if (ws.style == "desktop") then
		last_desktop_workspace = ws
	end

end



--[[
	set_workspace(index)

	index can be the workspace value -- this is because index might change
	when creating new workspace, so sometimes references should be by value
	(last_desktop_workspace, last_fullscreen_workspace)
]]
function set_workspace(index)

	if (index == nil) return

--	printh("set_workspace "..tostring(index))

	-- find by value
	if (type(index) == "table") then		
		for i=1,#workspace do
			if (workspace[i] == index) index = i
		end
	end

	-- couldn't find; use first workspace
	if (type(index) == "table") then
		index = 1
	end

	-- hide any modal gui elements
	dismiss_modal()

	-- safety: no workspaces exists
	if (#workspace == 0) then
		return
	end

	-- loop around
	workspace_index = 1 + ((index - 1) % #workspace)

	ws_gui = workspace[workspace_index]
	
	visit_workspace(ws_gui)

	-- invalidate active window if not found
	if (ws_gui.active_window) then
		local found = 0
		for i=1,#ws_gui.child do
			if (ws_gui.child == ws_gui.active_window) found = true
		end
		if (not found) ws_gui.active_window = false
	end

	generate_head_gui()


--  deleteme: should only need to happen on save
--	save_open_locations_metadata()
	
--[[
	printh("set workspace: "..ws_gui.index)
	if (ws_gui.child) then
	for i=1,#ws_gui.child do
		printh("  "..ws_gui.child[i].proc_id)
	end
	end
]]

end

-- can return nil
function get_active_window()

	-- to do: might not need this
	if (tooltray_active_window and tooltray_is_open()) then 
		return tooltray_active_window
	end
	
	if (not ws_gui or #ws_gui.child == 0) then 
		return nil 
	end

	if (ws_gui.active_window) return ws_gui.active_window

	return ws_gui.child[#ws_gui.child]
end

function _init()

	cursor_gfx = fetch"/system/misc/cursors.gfx"

	prev_frame = userdata("u8", 480, 270)

	------------------------ separate font for window manager ------------------------


	poke(0x4000,get(fetch"/system/fonts/lil.font"))
	poke(0x5600,get(fetch"/system/fonts/p8.font"))

--	poke(0x5600,get(fetch"/system/fonts/pug.font"))

--	poke(0x4002, (@0x4002)+3)
--	poke(0x4004, 1) -- offset_y

	----------------------------------------------------------------------------------


	-- safety: window manager itself needs to be visible! (also safety in foot though)
	send_message(pid(), {event="gained_visibility"})  --  pokes 0x547f:0x1

--	open initial processes: desktop (default workspace), code, gfx, map, sfx, full-screen terminal (esc to toggle)
	
	-- ==========================================================================================================================================
	-- single global tooltray gui
	-- ==========================================================================================================================================
	-- 

	tooltray_gui = {x=0, y=0, width=480, height=270, 
		draw=function(self) 
			--[[
			rectfill(0,0,self.width,self.height, 3) -- green background for debugging
			print("tooltray:"..#self.child, 4,4, 7)
			for i=1,#self.child do
				local c = self.child[i]
				print(pod{c.x,c.y,c.width,c.height},30,12+i*10,7)
				
			end
			]]
		end
	}

	-- ==========================================================================================================================================

	-- forward (low-level) event messages to active window
	-- should be fast; everything has to go throught here

	_subscribe_to_events( 
		function(msg)
			if (ws_gui == nil) then return end

			local forward_events = {keydown=1, keyup=1, textinput=1, mousewheel=1, mouselockedmove=1, drop_items=1}
			local activity_events = {keydown=1, keyup=1, textinput=1, mousewheel=1, mouse=1}

			
			if msg.event == "keydown" then

				last_input_activity_t = time()

				-- alt + left,right,enter filtered out (used by window manager)
				-- needs to be here (and not in events.lua) because key state is reset when switching tabs

				if key("alt") then
					if (msg.scancode == 79 or msg.scancode == 80 or msg.scancode == 40) return
				end

				-- filter ctrl combinations
				if key("ctrl") then
					-- needs to be here (and not in events.lua) because key state is reset when switching tabs
					if (msg.scancode == 43) return -- tab / ctrl+shift+tab

					-- moved to events.lua so that can be mapped; especially for ctrl-s
					-- if (msg.scancode == 22) return -- ctrl+s 
					-- if (msg.scancode == 35) return -- ctrl+6 capture screenshot
					-- if (msg.scancode == 36) return -- ctrl+7 capture label
				end

			end


			if (forward_events[msg.event]) then
				local win = get_active_window()
				if (win and win.proc_id) then
					send_message(win.proc_id, msg)
				end
			end
		end
	)

	-- ==========================================================================================================================================

	-- to do: maybe no longer used / needed?
--[[
	on_event("set_workspace",
		function (msg)
			set_workspace(msg.index)
		end
	)
]]
	on_event("drag_toolbar",
		function (msg)
			--toolbar_y_target = mid(0, toolbar_y + msg.dy, tooltray_default_h) -- limiting feels bad
			toolbar_y_target = mid(0, toolbar_y + msg.dy, infobar_y-11)
			toolbar_y = toolbar_y_target
		end
	)

	on_event("drag_infobar",
		function (msg)
			infobar_y_target = mid(0, infobar_y + msg.dy, 270-11)
			infobar_y = infobar_y_target
		end
	)

	-- used by toolbar; maybe should just be a function call
	on_event("bring_window_to_front",
		function (msg)
			local win = get_window_by_proc_id(msg.proc_id)
			set_active_window(win)		
		end
	)


	on_event("reload_settings",
		function (msg)
			sdat = fetch"/appdata/system/settings.pod"
		end
	)

	sdat = fetch"/appdata/system/settings.pod"
	
	toolbar_gui = toolbar_init()
	infobar_gui = infobar_init()

	generate_head_gui()

	--_signal(36) -- finished loading core processes
	--flip()
end



function draw_window_frame(win)


	local x0 = win.x
	local y0 = win.y
	local x1 = win.x + win.width  - 1
	local y1 = win.y + win.height - 1

	
	local bar_col = theme"dormant_frame"
	local border_col = theme"dormant_border"
	local title_col = theme"dormant_title"

	-- adjust for base gui position; to do: shouldn't be necessary

	camera()
	x0 = x0 + ws_gui.sx
	y0 = y0 + ws_gui.sy
	x1 = x1 + ws_gui.sx
	y1 = y1 + ws_gui.sy

	if (get_active_window() == win) then 
		-- active window colours
		
		bar_col = theme"window_frame"
		border_col = theme"window_border"
		title_col = theme"window_title"
	end

	rectfill(x0,y0-bar_h, x1,y0-1,  bar_col)
	rectfill(x0,y0-1, x1,y0-1,  border_col)

	-- outside outline: cuts into corners by 1 pixel
	y0 = y0 - bar_h


	-- to do: need to calculate width for variable width font
	-- to do: need to calculate y offset based on font

	clip(x0+16, y0, (x1-x0)-26, y1-y0)
	print(win.title,max(x0 + 16, (x0+x1)/2 - #win.title*char_w/2), y0+2, title_col)
	clip()

	line(x0+1, y0-1, x1-1, y0-1, border_col)
	pset(x0,y0,border_col)
	pset(x1,y0,border_col)

	if not sdat.squishy_windows then

		-- sides, bottom
		line(x0+1, y1+1, x1-1, y1+1, border_col)
		line(x0-1, y0+1, x0-1, y1-1, border_col)
		line(x1+1, y0+1, x1+1, y1-1, border_col)

		-- bottom corners
		pset(x0,y1,border_col)
		pset(x1,y1,border_col)

	else

		-- partial sides
		line(x0-1, y0+1, x0-1, y0+12, border_col)
		line(x1+1, y0+1, x1+1, y0+12, border_col)
	end


	-- shadow around the side: 2px left 3px down
	-- to do: rectfill_shadow
	--[[
	-- left
	rectfill_shadow(x0-2, y0+3, x0-2, y1+1)
	rectfill_shadow(x0-3, y0+4, x0-3, y1+1)

	-- bottom
	rectfill_shadow(x0-3, y1+2, x1-1, y1+2)
	rectfill_shadow(x0-2, y1+3, x1-2, y1+3)
	rectfill_shadow(x0-1, y1+4, x1-3, y1+4)

	-- L-shaped gap bottom left
	rectfill_shadow(x0-1,y1,x0-1,y1+1)
	rectfill_shadow(x0,y1+1,x0,y1+1)

	]]


	-- solid shadow  -- niche but kinda interesting. could be a theme attribute along with square window corners.
	--[[
		color(32)
		rectfill(x0-2, y0+3, x0-2, y1+1)
		rectfill(x0-3, y0+4, x0-3, y1+1)
		rectfill(x0-3, y1+2, x1-1, y1+2)
		rectfill(x0-2, y1+3, x1-2, y1+3)
		rectfill(x0-1, y1+4, x1-3, y1+4)
		rectfill(x0-1,y1,x0-1,y1+1)
		rectfill(x0,y1+1,x0,y1+1)
	]]


end


function draw_window_paused_menu(win,sx,sy)
	
	if (not win.pmenu) return

	local ww,hh = 70, 12 + (#win.pmenu) * 6
	local x0,y0 = sx + win.width/2 - ww, sy + win.height/2 - hh
	local x1,y1 = x0 + ww*2 - 1, y0 + hh * 2 - 1

	rectfill(x0,y0,x1,y1,0)
	rect(x0+1,y0+1,x1-1,y1-1,7)


	for i=1,#win.pmenu do 
		local xx = x0 + 20
		local yy = y0 + 3 + i * 12
		local label = "??"

		if (type(win.pmenu[i].label) == "function") label = win.pmenu[i].label()
		if (type(win.pmenu[i].label) == "string")   label = win.pmenu[i].label
		print(label, xx, yy, 7)
		if (i == win.pmenu.ii) print("\^:0103070f07030100",xx-10,yy,7)
	end
end

function update_window_paused_menu(win)

	if (not win) return

	if (win.paused) then
		local buttons = btnp()
		if (win.pmenu) then

			if ((buttons & 0x73) > 0) then
				local item = win.pmenu[win.pmenu.ii]
				if (type(item.action) == "function") item.action(buttons)
			end

			if (btnp(2)) win.pmenu.ii -= 1
			if (btnp(3)) win.pmenu.ii += 1
			if (win.pmenu.ii < 1) win.pmenu.ii = #win.pmenu
			if (win.pmenu.ii > #win.pmenu) win.pmenu.ii = 1
		end

	else
		-- pause button to pause (not within first 6 frames  ~ is left over button state)
		-- to do: button blocking scheme?
		if (btnp(6) and time() > win.created_t + 0.1) then
			win.paused = true
			generate_paused_menu(win)
			send_message(win.proc_id, {event = "pause"})
		end
	end

end




function generate_paused_menu(win)
	win.pmenu = {}

	add(win.pmenu, {label = "Continue", action = function() 
		win.paused = false
		send_message(win.proc_id, {event = "unpause"})
	end})

	-- insert userland menu items
	local menu = proc_menu[win.proc_id]

	if (menu) then
		for i=1,#menu do
			add(win.pmenu,
			{
				label = menu[i].label or "??",
				action = function(b)
					send_message(win.proc_id, {event="menu_action", id=menu[i].id, b=b})
				end
			})
		end
	end

--	add(win.pmenu, {label = "Options", action = function() end}) -- later

	add(win.pmenu,{
		label  = function(self) return (_ppeek(win.proc_id, 0x547f) or 0) & 0x8 > 0 and "Sound: Off" or "Sound: On" end,
		action = function(b) send_message(win.proc_id, {event = "toggle_mute"}) end
	})

--	add(win.pmenu, {label = "Favourite"}) -- later; need to decide what this means!
	add(win.pmenu, {label = "Reset Cartridge", action = function() 
		if (haltable_proc_id == win.proc_id) then
			-- pwc: same as hitting ctrl-r (dupe)
			haltable_proc_id = create_process("/system/apps/terminal.lua",{
				corun_program = "/ram/cart/main.lua",       -- program to run // terminal.lua observes this and is also used to set pwd
				window_attribs = {
					pwc_output = true,                      -- replace existing pwc_output process			
					show_in_workspace = true,               -- immediately show running process
				}
			})
		else
			send_message(2, {event="restart_process", proc_id = win.proc_id})
			win.paused = false
			
		end

	end})

	-- to do: can the process that launched a process have a say in its pause menu?
	-- add(win.pmenu, {label = "Exit to Splore", action = function() end})

	-- useful when running locally -- often just want to close the whole workspace when done running a fullscreen cart
	if haltable_proc_id ~= win.proc_id then
		add(win.pmenu, {label = "Exit", action = function()
			if (haltable_proc_id == win.proc_id) then
				-- halt program and enable command prompt (update: never happens -- menu item is not added in that case)
				win.paused = false
				send_message(win.proc_id, {event = "unpause"})
				send_message(haltable_proc_id, {event="halt"})
				haltable_proc_id = false
			else
				if (win.fullscreen) then
					close_workspace(workspace_index) -- fullscreen: assume running as sole child in a workspace created for that purpose
					set_workspace(previous_workspace)
				else
					close_window(win, true) -- windowed programs can be pauseable too, but is not on by default
				end
			end
		end})
	end

	win.pmenu.ii = 1
	
end

	

-- doesn't kill process -- that's up to process manager
-- update: seems almost always want to kill at the same time; added as a parameter
function close_window(win, do_kill)

	if (win.immortal) return

	
	_kill_process(do_kill and win and win.proc_id)

	win = win or get_active_window() -- is the get_active_window default ever used? to do: review and remove
	if (win.closing) then return end

	-- invalidate active window
	if (win.parent.active_window == win) win.parent.active_window = nil

	-- headless process should not be hogging cpu / calling _draw
	send_message(win.proc_id, {event="lost_visibility"})

	-- send message to self to close after end of frame
	-- (otherwise can invalidate an iterator somewhere?)

	send_message(pid(), {event="close_window",proc_id = win.proc_id})
	win.closing = true

end



function generate_windat()

	local windat = {
		--{x=0,y=infobar_y,width=480,height=270-infobar_y} -- first entry is always infobar
	}

	for i=1,#ws_gui.child do
		local w2 = ws_gui.child[i]
		-- only windows that have a frame and are solid
		-- later: could send a low-res 160x90 mask including non-rectangular windows
		if (w2.has_frame and _ppeek(w2.proc_id, 0x547d) == 0 and w2 ~= win) then
			add(windat, {
				x = w2.x, y = w2.y - bar_h,
				width = w2.width, height = w2.height + bar_h
			})
		end
	end

	return windat
end


function set_active_window(win)

	if (not win) return

	-- bring to front of same-z group
	win:bring_to_front()

	-- set active window for that sub-gui
	win.parent.active_window = win

	-- give focus to / take focus from tooltray
	tooltray_active_window = (win.parent == tooltray_gui) and win or nil
end



-- new version
function create_window(target_ws, attribs)

	local win = nil

--	printh("creating window: "..pod{attribs})

	add(boot_messages, attribs.prog)

	attribs = attribs or {}

	if (not attribs.width or not attribs.height or attribs.fullscreen) then
		attribs.width = 480
		attribs.height = 270
		attribs.x = 0
		attribs.y = 0
		attribs.fullscreen = true
	end

	attribs.x = attribs.x or (attribs.tabbed and 0  or rnd(480 - attribs.width)\1)
	attribs.y = attribs.y or (attribs.tabbed and 11 or (30 + rnd(230 - attribs.height)\1))


	-- default attributes

	if (attribs.has_frame  == nil)   attribs.has_frame  = false
	if (attribs.moveable   == nil)   attribs.moveable   = true
	if (attribs.resizeable == nil)   attribs.resizeable = true
	if (attribs.fullscreen       )   attribs.width, attribs.height, attribs.x, attribs.y = 480, 270, 0, 0
	if (attribs.maximised        )   attribs.width, attribs.height, attribs.x, attribs.y = 480, 248, 0, 11

	if (attribs.pauseable == nil) attribs.pauseable = attribs.fullscreen and not attribs.desktop_filenav and not attribs.wallpaper

	win = target_ws:attach(attribs)
	
	-- position at top of same-z stack
	win:push_to_back()    -- bottom of same-z stack (push behind any foreground layers)
	win:bring_to_front()  -- bring back up to front of same-z stack

	win.send_mouse_update = true -- send mouse message on first frame
	win.created_t = time()

	win.test_point = function(self, x, y)
		-- process is using transparency on display bitmap?
		local alphabits = _ppeek(win.proc_id, 0x547e) -- INTERACT_ALPHABITS_ADDR
		if (not alphabits or alphabits == 0) return true

		if (win.interactive == false) return false -- e.g. cursor charms should never block mouse click

		-- look up the pixel
		local disp_width = _ppeek(win.proc_id, 0x5478) + (_ppeek(win.proc_id, 0x5479) << 8)
		local val = _ppeek(win.proc_id, 0x10000 + (y * disp_width) + x)

		-- considered solid when at least one of the alpha bits is set in this pixel
		return (val & alphabits ~= 0)
	end

	
	function win:draw()

		-- not visible or about to close --> skip
		if (not win.visible or win.closing) return
		--if (win.closing) return

		-- don't render on first visible frame as process :draw has likely not been called
		-- without this, get flickering when switching tabs
		-- update: this mechanism seems redundant if entire wm skipping a frame when chaning window focus (see last_draw_window)
			-- but actually prevents a different type of flicker -- e.g. switching from gfx to map editor at start.
			-- to do: investigate why; just a result of 2 frames instead of 1? need to formalise wm guarantees

		-- commented: should be doing this at the workspace level anyway; 
		-- consider stacked tabs that are drawn except for the top one on the first frame after changing workspace

		--[[
		if (not win.process_had_a_chance_to_draw) then
			win.process_had_a_chance_to_draw = true
			return
		end
		]]

		local blit_result = false
		
		if sdat.squishy_windows and win.has_frame then

			local border_col = theme(get_active_window() == win and "window_border" or "dormant_border")

			clip()
			if (not win.sxa) win.sxa = {}
			if (not win.sya) win.sya = {}
			win.sxa[0] = win.sx + 0.5
			win.sya[0] = win.sy + 0.5

			while (#win.sxa < win.height) add(win.sxa, win.sxa[#win.sxa])
			while (#win.sya < win.height) add(win.sya, win.sya[#win.sya] + 1)
			
			for yy = 1, #win.sxa do
				win.sxa[yy] = win.sxa[yy] * 0.03 + win.sxa[yy-1] * 0.97
				win.sya[yy] = win.sya[yy] * 0.03 + (win.sya[yy-1] + 1) * 0.97
				if (abs(win.sya[yy] - (win.sya[yy-1] + 1)) < 0.05) win.sya[yy] = win.sya[yy-1] + 1.0
			end

			camera()
			local yy1 = win.sya[0]
			for yy = 0, win.height-1 do
				local ht = (win.sya[yy+1] - win.sya[yy])\1 -- draw > 1px high when stretched out

				while (yy1 <= win.sya[yy]) do
					blit_result = _blit_process_video(win.proc_id, 0, yy, nil, 1 + ht, win.sxa[yy], yy1)
					pset(win.sxa[yy]-1, yy1, border_col)
					pset(win.sxa[yy]+ win.width, yy1, border_col)
					yy1 += 1
				end

			end

			-- bottom line
			local yy = win.height-1
			line(win.sxa[yy], yy1, win.sxa[yy] + win.width - 1, yy1, border_col)

		else
			-- regular rectangular blit

			blit_result = _blit_process_video(win.proc_id, 0, 0, nil, nil, win.sx, win.sy)

			-- clear squishy positions

			win.sxa = nil
			win.sya = nil

		end
		
		-- could not blit (_draw didn't complete?) 
			--> blit from desktop copy instead (when not fullscreen -- fullscreen can just do nothing!)
		-- non-rectangular windows (w/ PROCBLIT_TRANSP_ADDR set) should make sure 
		if (blit_result and not win.fullscreen) then
			blit(prev_frame, nil, win.sx, win.sy, win.sx, win.sy, win.width, win.height)
			--clip() circfill(0,0,16,8) circfill(0,0,24,7) -- debug: show that (desktop) window is frame-skipping			
		end


		-- debug: show window size
--		local ww,hh = _get_process_display_size(win.proc_id)
--		print(pod{win.width, win.height, ww, hh}, 5,15,8+rnd(16))

		-- always draw frame for now (lazy)  // to do: check visibility
		if (win.has_frame) then
			clip()
			draw_window_frame(win)
		end

		-- paused menu

		if (win.paused) then
			draw_window_paused_menu(win, win.sx, win.sy)
		end

		-- stickers
		if (type(win.stickers) == "table") then
			clip() camera()
			for i=1,#win.stickers do
				local s = win.stickers[i]
				if (type(s) == "table" and type(s.bmp) == "userdata" and s.x and s.y) then
					local ww, hh = s.bmp:attribs()
					if (s.x >= 0 and s.y >= -12 and s.x < win.width and s.y < win.height) then
						spr(s.bmp, win.sx + s.x - ww\2, win.sy + s.y - hh\2)
					else
						-- to do: fall off? sparkle puff?
						del(win.stickers, s)
					end
				end
			end
		end
		
	end


	function win:update()
		
		win.width, win.height = _get_process_display_size(win.proc_id)

		win.is_active = self == get_active_window()

		-- no process --> close
		if (win.width == 0 or win.height == 0) then
			close_window(win)
			return
		end


		-- autoclose a non-tabbed window that is covered by a tabbed window
		-- otherwise: need some way to access that window. don't want to tab it! sheesh

		if (win.autoclose and
			win.parent.child[#win.parent.child].tabbed and
			not win.tabbed and            -- also means that this window isn't the window on top, which is tabbed
			time() > win.created_t + 0.5) -- don't close in the first half a second (give a chance to get focus)
		then
			close_window(win, true)
			return
		end

		-- tabbed: adapt position and size to useable desktop space

		if (win.tabbed) then

			-- slide with toolbar (means change height every frame when transitioning)
			win.y = min(0, toolbar_gui.sy) + toolbar_gui.height
			win.sy = win.y

			if (win.height ~= 270 - win.y) then
				win.height = 270 - win.y
				send_message(win.proc_id, {event="resize", width = win.width, height = 270 - win.y})
			end
		end

	end

	

	function win:click(msg)

		set_active_window(win)

			-- context menu on mb2 (used by filenav -- need to provide nicer mechanism for generating that menu)
			if (win.has_context_menu and msg.mb == 2) then
				-- keep above 150 -- assume menu is shorter than that. to do: maybe need a keep_inside_parent attribute
				send_message(3, {event = "toggle_app_menu", _delay = 0.1 , x = win.sx + msg.mx - 70, y = min(win.sy + msg.my - 30, 150) , proc_id = win.proc_id })
				
			end

		return true -- processed
	end

	function win:drag(msg)
		-- drag event is generate by window's own gui.lua
		-- send_message(win.proc_id, msg) -- forward to window 
	end


	-- titlebar

	if (win.has_frame) then

		local bar = win:attach(
			{
				x = 0, y = -bar_h,
				width = win.width,
				height = bar_h,
				clip_to_parent = false,
				cursor = "grab", -- to do: why doesn't this work? because outside of parent?
				is_window_bar = true
			}
		)

		function bar:draw()
		end

		-- close button
		bar:attach(
			{
				cursor = "pointer",
				x = -2, justify="right",
				y = 0, vjustify="center",
				width = 7, height = 7,
				tap = function(self)
					close_window(self.parent.parent, true)
				end,
				draw = function(self, msg)
					(msg.has_pointer and circfill or circ)(self.width / 2, self.height / 2, self.width/3, 
						win.parent.active_window == win and theme("window_button") or theme("dormant_button")) 					
				end
			}
		)

		-- app menu button
		bar:attach(make_window_button(bar, "app menu", 4, 1, 10, 10 +1)) -- height +1 so that window frame border is not clobbered


		function bar:update(event)
			self.width = self.parent.width
			self.col_k = win.parent.active_window == win and "window_button" or "dormant_button"

			-- to do: also need to adjust buttons
			-- maybe positions could be right-justified? would be nice!
			-- e.g. btn.justify = "left" | "center" | "right"
		end
		

		function bar:drag(event)
			if (not win.moveable) return
			win.x += event.dx
			win.y = max(24, win.y + event.dy)
			-- let application know! app can also send message requesting move
			send_message(win.proc_id, {event="move", x = win.x, y = win.y, dx = event.dx, dy = event.dy})
		end

		function bar:click()
			if (not key("lshift")) then -- key state test, but actually quite useful! drag windows around underneath
				bar.parent:bring_to_front()
			end
			win.parent.active_window = win -- either way: this window becomes the active window
		end

		function bar:doubletap()
			-- maximise
--			win.x = 0
--			win.y = 12

			if (not win.resizeable) return

			if (win.maximised) then
				win.maximised = false
				send_message(win.proc_id, {event="resize", x = win.old_x, y = win.old_y, width = win.old_width, height = win.old_height})
			else
				win.maximised = true
				win.old_x = win.x
				win.old_y = win.y
				win.old_width = win.width
				win.old_height = win.height
				-- space to see frame
				send_message(win.proc_id, {event="resize", x = 1, y = 24, width = 478, height = 245})
			end

		end



		--[[--------------------------------------------------------------------------------------------------------------

			resize widget

			// always attach if not resizeable; window attribute can change after creation

			to do: could be a single large rectangle behind window
			(so only works when cursor is slightly outside of window)
			or -- put in front and use test_point (ha!)
		
		--------------------------------------------------------------------------------------------------------------]]--


		local function resize_click(self, event) 
			win.start_mx, win.start_my = mx, my
			win.start_w, win.start_h = win.width, win.height
			win.start_x, win.start_y = win.x, win.y
		end

		function resize_draw(self, event) 
			-- debug: view the widget // don't need to clip() because .clip_to_parent == false
			-- rect(0, 0, self.width-1, self.height-1, 5)
		end

		-- resize bottom right
		win:attach({
			width = 8, height = 8,
			clip_to_parent = false,
			cursor  = 8,

			update = function(self)
				self.x = win.width - 4
				self.y = win.height - 4
			end,
			draw  = resize_draw,
			click = resize_click,
			drag = function(self, event)
				if (win.resizeable and (event.dx ~= 0 or event.dy ~= 0)) then
					-- use window manager mx, my because using relative event.mx,event.my will jump around as window resizes
					-- hard-coded minimum window size: 64x32
					local new_width  = max(64, win.start_w + (mx - win.start_mx))
					local new_height = max(32, win.start_h + (my - win.start_my))
					send_message(win.proc_id, {event="resize", width = new_width, height = new_height})
				end
			end
		})

		-- resize bottom left
		win:attach({
			width = 8, height = 8,
			clip_to_parent = false,
			cursor  = 9,

			update = function(self)
				self.x = -4
				self.y = win.height - 4
			end,
			draw  = resize_draw,
			click = resize_click,

			drag = function(self, event) 
				if (win.resizeable and (event.dx ~= 0 or event.dy ~= 0)) then
					-- set x in same message so that visible change is simultaneously (otherwise jitters)
					local new_width  = max(64, win.start_w\1 - (mx - win.start_mx))
					local new_height = max(32, win.start_h + (my - win.start_my))
					send_message(win.proc_id, {event="resize", 
						width = new_width, 
						height = new_height, 
						x = win.start_x + (mx - win.start_mx)
				})

				end
			end
		})

--[[
		-- commented; maybe nice to have just bottom left, bottom right widgets.

		-- resize bottom
		win:attach({
			x = 4, 
			y = win.height - 4,
			width = win.width - 8,
			height = 8,
			clip_to_parent = false,
			update = function(self)
				self.y = win.height - 4
				self.width = win.width - 8
			end,
			draw  = resize_draw,
			click = resize_click,
			drag = function(self, event) 
				if (event.dx ~= 0 or event.dy ~= 0) then
					send_message(win.proc_id, {event="resize", height = win.start_h + (my - win.start_my)})
				end
			end
		})

		-- resize left
		win:attach({
			x = -4, y = 0, 
			width = 8, height = win.height  - 4,
			clip_to_parent = false,
			update = function(self)
				self.height = win.height  - 4
			end,
			draw  = resize_draw,
			click = resize_click,
			drag = function(self, event) 
				if (event.dx ~= 0 or event.dy ~= 0) then
					send_message(win.proc_id, {event="resize", 
						width = win.start_w\1 - (mx - win.start_mx)\1, 
						x = win.start_x + (mx - win.start_mx)
					})
				end
			end
		})

		-- resize right
		win:attach({
			x = win.width-4, y = 0, 
			width = 8, height = win.height  - 4,
			clip_to_parent = false,
			update = function(self)
				self.height = win.height  - 4
				self.x = win.width-4
			end,
			draw  = resize_draw,
			click = resize_click,
			drag = function(self, event) 
				if (event.dx ~= 0 or event.dy ~= 0) then
					send_message(win.proc_id, {event="resize", 
						width = win.start_w\1 + (mx - win.start_mx)\1, 
					})
				end
			end
		})
]]



	end


	-- creating a desktop wallpaper --> automatically create a filenav overlay

	if win.wallpaper and target_ws and (win.workspace == "new" or win.workspace == "tooltray") then

		local filenav_workspace = win.workspace == "tooltray" and "tooltray" or target_ws.index

		target_ws.desktop_filenav_proc_id = 
		create_process("/system/apps/filenav.p64",{
			 -- window attribs of the desktop program launching the desktop filenav
			argv = {"-desktop", win.desktop_path or "/desktop"},
			window_attribs = {
				workspace = filenav_workspace, -- same workspace as the wallpaper
				width = win.width, height = win.height,
				x = win.x, y = win.y, z = win.z + 1, -- desktop is -1000 (head.lua)
				has_frame = false,
				moveable = false,
				resizeable = false,
				desktop_filenav = true
			}
		})
	end


	
	return win	
end

--[[
	mouse_scaled()
	takes video mode into account
	to do: lower level
]]
function mouse_scaled()

	local x,y,b,dx,dy = mouse()


	local scale = 1
	local video_mode = @0x547c

	if (video_mode == 3) scale = 2
	if (video_mode == 4) scale = 3

	x \= scale
	y \= scale

	return x,y,b,dx,dy
end

local last_draw_t = 0
local smoothed_fps = 0
local show_fps = false
local last_drawn_ws = nil
local ws_gui_frames = 0

local inited_font = false

boot_messages = {}


local xodat = {26,22,19,17,15,14,12,11,10,9,8,7,6,5,5,4,3,3,2,2,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,2,2,3,3,4,5,5,6,7,8,9,10,11,12,14,15,17,19,22,26}


function _draw()

	pal(0) -- reset colourtable but leave rgb display palette alone

	-- don't draw frame when changing window or workspace; allows messages to complete and prevents flicker
	-- (e.g. switch through newly opened tabs, or gfx setting current sprite picked up by map editor)
	if (last_draw_window ~= get_active_window()) then
		last_draw_window = get_active_window()
		return
	end

	-- also skip first frame when changing workspace
	-- to do: unnecessary? prevents gfx->map flicker, but maybe just because skipping 2 frames instead of 1
	-- also: causes no visible refresh when holding alt-right/left (only see where workspace index ended up on release) -> why?
	if (last_drawn_ws ~= ws_gui) then last_drawn_ws = ws_gui return end


	-- sanity
	if (ws_gui) then
		if (ws_gui.width < 480) printh("*** ws_gui.width: "..ws_gui.width)
		if (ws_gui.height < 240) printh("*** ws_gui.height: "..ws_gui.height)
	end

	-- wm should never hold frames (or need to)
	-- if becomes relevant, then is a bug and is extremely hard to see what's going on with wm holding frames
	-- e.g. if 30fps app is showing frames every second frame, the ones wm is holding --> appears frozen
	-- better to just let the wm interface start flickering
	poke(0x547f, peek(0x547f) & ~0x2)
	
	-- workspace doesn't have a fullscreen window covering it
	-- e.g. launch filenav when there is no desktop workspace, or running web cart player
	-- ** important not to clear each frame for fullscreen apps -- otherwise get flashing when < 60fps
	-- ** note: can be fullscreen but still width < 480 (because videomode) 
	if (ws_gui and (ws_gui.clear_each_frame or (ws_gui.child[1] and ws_gui.child[1].width < 480 and not ws_gui.child[1].fullscreen))) then
		rectfill(0,0,479, 269, 0x10)
		rectfill(0,0,479,11,7) -- toolbar-ish shape for cart player
	end

	-- cls(10) -- debug

	local awin = get_active_window()


	if (not ws_gui or #workspace == 0) then
		cls()
		if (time() > 3) print("[no workspaces found] "..#workspace,20,20,13)
		if (#workspace > 0) set_workspace(1)
		return
	end


	if (screensaver_proc_id) then
		local win = get_window_by_proc_id(screensaver_proc_id)
		if (win) win:draw()
	else

		head_gui:draw_all()
	
	end

	camera()
	clip()

	-- keep a copy of window output
	-- cheap, general way to do frame holding. should cost ~2% cpu. just a 128k memcpy!
	-- can optimise later for full-screen programs that don't need cursor (just skip drawing anything)

	if (not awin or not awin.fullscreen) 
	then
		blit(nil, prev_frame)
		--prev_frame:copy(8)
	end


	-- toolbar
	if (do_draw_toolbar) then

		-- toolbar shadow
		-- doesn't work! on top of window. need stencil bit for window frame!
		-- but doesn't work visually anyway
		-- rectfill_shadow(0,ws_gui.y + 11, 480, ws_gui.y + 12) 


--		draw_toolbar()

--		line(0,11,479,11,32) -- too much

--		printh(pod(ws_gui))
--		draw_infobar()
		
	end

	-- sparkles (under mouse cursor)

	if (sdat.sparkles) draw_sparkles()


	-- draw cursor
	-- mouse cursor is visible by default
	-- use hide_cursor() to hide it

	local show_cursor = not screensaver_proc_id

	if (show_cursor) then
		mx, my, mb = mouse_scaled()

		-- show default cursor when active window doesn't have one, and not holding alt


		local gfx = cursor_gfx[1].bmp or default_cursor_gfx

--		if (head_gui.mouse_cursor_gfx) gfx = head_gui.mouse_cursor_gfx 
		
		if (awin and awin.cursor and not key("alt")) gfx = awin.cursor
		if (head_gui.mouse_cursor_gfx) gfx = head_gui.mouse_cursor_gfx -- override with wm cursor (resize window)

		if (gfx == "crosshair") gfx = 2
		if (gfx == "grab") gfx = mb == 0 and 3 or 4
		if (gfx == "pointer") gfx = mb == 0 and 5 or 6


		if (type(gfx) == "number") gfx = cursor_gfx[flr(gfx)].bmp
		if (type(gfx) != "userdata") gfx = default_cursor_gfx

		
		if (dragging_items) then

			-- dragging: override cursor gfx
			gfx = cursor_gfx[4].bmp

			-- follow: mouse
			local fx = mx - 8
			local fy = my - 8

			for i=1,#dragging_items do
				local item = dragging_items[i]
				if (not item.xo) item.xo = item.x - mx
				if (not item.yo) item.yo = item.y - my
			end

			local hover_win = head_gui:el_at_xy(mx, my)
			local keep_original_positions = not hover_win or hover_win.desktop_filenav
			for i=1,#dragging_items do
				
				local item = dragging_items[i]

				local dx,dy = fx - item.x, fy - item.y
				local aa = atan2(dx, dy)
				local tx,ty

				if (keep_original_positions) then
					tx,ty = mx + item.xo, my + item.yo
				else
					tx,ty = fx - cos(aa)*2, fy - sin(aa)*2
				end

				if (#dragging_items > 10) then
					-- catch up faster
					item.x = (item.x*2 + tx) / 3
					item.y = (item.y*2 + ty) / 3
				else
					item.x = (item.x*3 + tx) / 4
					item.y = (item.y*3 + ty) / 4
				end
	
				if (i==1) item.x, item.y = tx,ty

				-- follow: the item in front
				fx = item.x
				fy = item.y
				
			end

			-- draw with item closest to cursor on top
			for i=#dragging_items,1,-1 do
				local item = dragging_items[i]
				spr(item.icon, item.x, item.y)
			end

		end

		last_mx9, last_my9 = mx, my

		-- 
		local gfx_w, gfx_h = gfx:attribs()
		spr(gfx, mx - (gfx_w+1)\2, my - (gfx_h+1)\2)  -- +1 so exactly at center for odd-sizes bitmaps. ref: paint bucket
	end

	-- notifications  --  show for 2~3 seconds (to do: customisable)

	local notify_duration = 2
	if (user_notification_message and #user_notification_message > 15) notify_duration = 3
	if (time() < 3) notify_duration = 5 -- startup message; e.g. mended drive.loc

	if (user_notification_message and time() < user_notification_message_t + notify_duration) then
		local y = 270
		if (@0x547c == 3) y = 135
		if (@0x547c == 4) y = 90

		rectfill(0,y-11,479,y-1,32)
		print(user_notification_message, 4,y-9, 7)
	end

	

	-- fps

	if (show_fps) then
		-- has no effect if 0 is transparent! need to be able to turn blending on / off.
		-- gives programmer option of faster code path too
		rectfill(450,259,479,469,32) 
		local fps_target = (1/(time() - last_draw_t))
		smoothed_fps = (smoothed_fps * 31 + fps_target * 1) / 32
		local num_str = (smoothed_fps + 0.5) // 1
		print(tostr(num_str), 452, 261, 7)
		last_draw_t = time()
	end

	-- grab palette and video mode from active window's process (if there is one)

	if (awin) then

		-- 0.1.0c: only update when frame is not held (avoid flashing when running < 60fps)
		local val = _ppeek(awin.proc_id, 0x547f) -- might be nil if process recently ended
		if (val and val & 0x2 == 0)
		then
			--printh("@@ process palette "..time())

			-- grab the rgb display palette and video mode from that process
			-- to do: cross-process memcpy
			for i=0x5000,0x54ff,4 do
				poke4(i, _ppeek4(awin.proc_id, i))
			end
			poke(0x547c, _ppeek(awin.proc_id, 0x547c))

		else
			--printh("-- skipped resetting palette "..time())
		end

		-- copy mouselock state bits

		poke(0x5f28, _ppeek(awin.proc_id, 0x5f28))
		poke(0x5f29, _ppeek(awin.proc_id, 0x5f29))
		poke(0x5f2d, _ppeek(awin.proc_id, 0x5f2d))

	else
		--printh("** default rgb palette "..time())
		pal(2) -- otherwise use default palette
	end

	-- magnify

	if (sdat.rshift_magnify and key("rshift")) then

		local masks = peek4(0x5508); -- backup

		poke(0x5508, 0x3f, 0x3f, 0, 0) -- ignore target value; no transparency

		if (not mag_bmp) mag_bmp = userdata("u8", 64, 64)
		blit(get_display(), mag_bmp, mx-32, my-32)
		palt(0) -- nothing is transparent

		local sx,sy = mx-64, my-64
		for y=0,63 do
			local xo = xodat[y+1]
			sspr(mag_bmp, xo, y, 64-xo*2, 1, sx + xo*2, sy+y*2, 128 - xo*4, 2)
		end

		circ(mx,my,65,7) -- close enough

		circfill(mx+38,my-38,5,7) -- haha
		circfill(mx+46,my-28,3,7)

		poke4(0x5508, masks); -- restore
	end

--	print(stat(1),30,260,8)


	-- don't open on a tabbed tool (wait for desktop or terminal to be ready before displaying)
	if (ws_gui.style != "tabbed") then 
		if (not sent_presentable_signal) _signal(37) -- wm is presentable
		sent_presentable_signal = true
	end

end


--[[
	before running or saving cart, need to make sure that any changes made to location of current window is auto-saved.
	don't care about which window is active; there might have been changes in background! -> save everything
]]
function sync_working_cartridge_files()

	for i=1,#workspace do
		for j=1, #workspace[i].child do
			local win = workspace[i].child[j]
			--printh(win.proc_id..": "..(win.location or "no location"))
			if (win.location and string.sub(win.location, 1, 10) == "/ram/cart/") then
				send_message(win.proc_id, {event="save_file"})
				--printh("@@sync_working_cartridge_files: requesting save from "..win.location)
			end
		end
	end

	-- hack: wait for saves to complete. maybe sufficient!

	-- to do: could count number of requests and wait for each process to report save completed (or timeout)
	-- would normally complete in one frame. and then process the pending save_cart / run at end of _update
	-- update: no-Rube-Goldberg-machines policy

	for i=1,2 do flip() end

end

function _update()

	-- happens while loading
	if (not ws_gui) then
		--printh("no ws_gui!!")
		return
	end

	-- temporary hack: start on desktop
	if (time() == 1.5) set_workspace(5)

	if (screensaver_proc_id) then

		-- allow test to run for at least half a second before observing new input activity
		if (test_screensaver_t0 and time() < test_screensaver_t0 + 0.5) then
			last_input_activity_t = 0
		end

		-- kill when activity happened in the last second
		if (last_input_activity_t > time() - 1) then			
			_kill_process(screensaver_proc_id)
			test_screensaver_t0 = nil
			screensaver_proc_id = nil
		end
	else
		
		-- 3 minutes; to do: store in settings.pod
		if ((time() > last_input_activity_t + 180 or test_screensaver_t0) and not screensaver_proc_id) 
		then
			
			local sdat = fetch"/appdata/system/settings.pod"
			-- printh(pod(sdat))
			if (sdat and sdat.screensaver) then
				-- note: program doesn't need to know it is a screensaver; just kill process on activity event
				screensaver_proc_id = create_process(sdat.screensaver, 
					{window_attribs = {workspace="current", autoclose = true}})
				test_screensaver_t0 = time() -- abuse same mechanism to ignore interrupts for first half second
			else
				last_input_activity_t = time() -- don't check again for another 3 minutes
			end
		end
	end


	last_mx, last_my = mx, my
	mx, my, mb, mdx, mdy = mouse_scaled()

	if (mb > 0 and last_mb == 0) then
		start_mx = mx
		start_my = my
	end

	-- update visibility; send message

	local large_front_window = false
	local awin = get_active_window()


	local num_visible = 0

	for i=1,#workspace do
		local found_covering_window = false
--		for j=1,#workspace[i].child do
		for j=#workspace[i].child,1,-1 do

			local w = workspace[i].child[j]
			local was_visible = w.visible
	
			-- rough visibility test:
			-- same workspace, and either top (active) window, or there isn't a large window on top covering everything

			local visible = false
			if (i == workspace_index and (w == awin or not found_covering_window)) then
				visible = true
			end

			-- notify on change
			if (not was_visible and visible) then
				send_message(w.proc_id, {event="gained_visibility"})
			end
			if (was_visible and not visible) then
				send_message(w.proc_id, {event="lost_visibility"})
				-- don't draw on first frame when becomes visible again, because process needs
				-- a chance to :draw first (prevents flickering; showing a single stale frame)
				w.process_had_a_chance_to_draw = false 
			end

			w.visible = visible
			num_visible = num_visible + (visible and 1 or 0)

			-- (optimisation)
			-- placeholder test for window is covering everything underneath it   // 0x547d: alpha bits
			if (w.width==480 and w.y <= bar_h and w.y + w.height >= 270-bar_h and _ppeek(w.proc_id, 0x547d) == 0) then
				found_covering_window = true
				--printh("found covering window")
			end

		end
	end

	-- printh("num_visible: "..num_visible)

	-- tool tray visibility (DUPE)

	for i=1,#tooltray_gui.child do
		local w = tooltray_gui.child[i]
		local was_visible = w.visible
		local visible = tooltray_is_open()

		-- notify on change
		if (not was_visible and visible) then
			send_message(w.proc_id, {event="gained_visibility"})
		end
		if (was_visible and not visible) then
			send_message(w.proc_id, {event="lost_visibility"})
			w.process_had_a_chance_to_draw = false 
		end

		w.visible = visible
	end

	-- ctrl-q to fastquit // dangerous so needs to be turned on
	if (key("ctrl") and keyp("q")) then
		local sdat = fetch("/appdata/system/settings.pod") or {}
		if (sdat.fastquit) _signal(33)
	end

	-- alt-f4 always available (er.. does windows do that anyway?	
	if (key("alt") and keyp("f4")) then
		_signal(33)
	end


	-- :: ctrl-r  (is a window manager thing!)

	-- happens first so that there's time to send lost_focus messages to tools so they
	-- can save their files to /ram/cart before the running program picks them up
	if (key("ctrl") and keyp("r")) then

		sync_working_cartridge_files()

		clear_infobar()
		hide_infobar()

		if (key("lshift") and haltable_proc_id) then
			-- inject 
			send_message(haltable_proc_id,{event="reload_src", location = get_active_window().location})
		else
			-- launch terminal and request it to corun cproj
			-- terminal will skip creating a window and allow guest program to create it
			-- when haltable_proc_id is set, ESC means halt for that process

			-- kill previous one
			--[[
				-- deleteme -- is more correctly handled by clearing out existing pwc_output windows
				-- the first time a cart is run, there is an existing pwc_output window that is not assigned to haltable_proc_id
				
				-- printh("killing previous: "..tostring(haltable_proc_id))
				-- send_message(2, {event="kill_process", proc_id = haltable_proc_id})
			]]

			-- create new one
			haltable_proc_id = create_process("/system/apps/terminal.lua",{
				corun_program = "/ram/cart/main.lua",       -- program to run // terminal.lua observes this and is also used to set pwd
				window_attribs = {
					pwc_output = true,                      -- replace existing pwc_output process			
					show_in_workspace = true,               -- immediately show running process
				}
			})

		end

	end


	-- :: ctrl-p: open tooltray
--[[
	if (key("ctrl") and keyp("p")) then
		toolbar_y_target = tooltray_default_h
	end
]]

	-- :: ctrl-o: open file (update: and other custom shortcuts)
	-- to do: more general rules for specifying shortcuts? e.g. not ctrl-
	if (key("ctrl")) then
		local win = get_active_window()
		if (win and proc_menu[win.proc_id]) then
			local menu = proc_menu[win.proc_id]
			for i=1,#menu do
				local mi = menu[i]
				if (type(mi.shortcut) == "string") then
					local letter = string.sub(mi.shortcut, -1)
					if (ord(letter) >= ord("A") and ord(letter) <= ord("Z")) then
						letter = chr(ord(letter) - ord("A") + ord("a"))
						-- handle s separately; context sensitive
						if (letter ~= "s" and keyp(letter)) then
							send_message(win.proc_id, {event="menu_action", id = mi.id, b = 0})
						end
					end
				end
			end
		end
	end

	-- :: ctrl-s

	if (key("ctrl") and keyp("s")) then

		local win = get_active_window()

		if (win.location and sub(win.location, 1, 10) ~= "/ram/cart/") then
			-- program has set a non-cartridge working file --> don't need to do anything else
			send_message(win.proc_id, {event="save_file"})
		else
			-- otherwise, always save cartridge
			-- [currently] only way to stop this is by using wrangle_working_file() / setting a .location
			sync_working_cartridge_files()

			if (fetch("/ram/system/pwc.pod")) then
				notify("saving cartridge: "..fetch("/ram/system/pwc.pod"))
				create_process("/system/util/save.lua")
			end
		end
	end

	

	-- :: ctrl-1, ctrl-2 to toggle toolbar / infobar

	if (key("ctrl") and keyp("1")) then
		ws_gui.show_toolbar = not ws_gui.show_toolbar
		if (not ws_gui.show_toolbar) toolbar_y_target = 0 -- immediately close even when mouse cursor is over it (intention + visual feedback)

		-- should show a message near the toolbar? need a "speech bubble" concept?
--		notify(ws_gui.show_toolbar and "docked toolbar" or "auto-hide toolbar")
	end

	if (key("ctrl") and keyp("2")) ws_gui.show_infobar = not ws_gui.show_infobar


	-- audio capture
	if (key("ctrl") and keyp("0")) then
		if (not fstat("/desktop/host")) _signal(65)
		_signal(16)
	end

	-- screenshot

	if (key("ctrl") and keyp("6")) then

		local dd = get_display()
		local w,h = 480,270
		if (awin and _ppeek(awin.proc_id, 0x547c) == 3) w,h = 240,135
		if (awin and _ppeek(awin.proc_id, 0x547c) == 4) w,h = 160,90
		
		local screen = userdata("u8", 480*2,270*2)
		set_draw_target(screen)
		sspr(dd,0,0,w,h,0,0,480*2,270*2)
		set_draw_target()

		if (not fstat("/desktop/host")) _signal(65) -- /desktop/host

		local num=0
		while (fstat("/desktop/host/sshot"..num..".png") and num < 64) do
			num += 1
		end
		store("/desktop/host/sshot"..num..".png", screen)

		notify("captured screenshot to /desktop/host/sshot"..num..".png")
	end

	-- capture label

	if (key("ctrl") and keyp("7")) then

		-- to do: custom desktop location from settings?

		local dd = get_display()

		local w,h = 480,270
		if (awin and _ppeek(awin.proc_id, 0x547c) == 3) w,h = 240,135
		if (awin and _ppeek(awin.proc_id, 0x547c) == 4) w,h = 160,90

		local label = userdata("u8", 480,270)
		set_draw_target(label)
		sspr(dd,0,0,w,h,0,0,480,270)
		set_draw_target()

		store("/ram/cart/label.png", label)
		notify("captured label")
	end


	-- window focus messages

	local win = get_active_window()

	if (win and last_active_win ~= win) then
		
		if (last_active_win) then 
			send_message(last_active_win.proc_id, {event="lost_focus"})
			last_active_win.is_active = false
		end

		-- give lost_focus message a chance to be processed before next window gains focus
		flip()

		win.is_active = true
		send_message(win.proc_id, {event="gained_focus"})
		-- when a click causes focus to change, that click should register in the window's gui immediately
		-- -> need to send updated mouse state below so that click is generated in that window's events.lua
		win.send_mouse_update = true 

		last_active_win = win
	end


	-- forward (filtered, modified) events to active window
	-- vertatim forwards also happen in _subscribe_to_events
	-- only need to send low-level device data -- click,tap etc is generated from them
	
	-- modified mouse position or mouse button
	if (win and win.proc_id) then
		if (mx ~= last_mx or my ~= last_my or mb ~= last_mb or win.send_mouse_update) then

			last_input_activity_t = time()

			--printh("mouse event "..pod{proc_id = win.proc_id, mx, my, mb})

			win.send_mouse_update = nil

			-- every window can read the mouse position, but only the active window can read mouse button state.
			-- dorky iterator for ws_gui and tooltray_gui
			local pointer_el = head_gui:get_pointer_element()
			if (@0x547c > 0) pointer_el = win -- video mode set -> assume pointing at active window
			for i=1,#ws_gui.child + #tooltray_gui.child do
				local win2 = i <= #ws_gui.child and ws_gui.child[i] or tooltray_gui.child[i - #ws_gui.child]

					send_message(win2.proc_id, {event="mouse",dx = mdx, dy = mdy, mx_abs = mx, my_abs = my, mx = mx-win2.sx, my=my-win2.sy, 
						-- only active window is allowed to read mouse button (title bar / resizer widget doesn't count)
						mb = (win == win2 and win == pointer_el) and mb or 0
					})
			end

		end
		last_mx, last_my, last_mb = mx, my, mb
	end


	-- reset; so that e.g. alt + left doesn't bring up tooltray menu
	if (keyp("alt")) then
		used_alt_navigation = false
	end


	-- to do: terminal AND desktop filenav(!) should be allowed to capture enter
	-- a little different from capture_escapes ~ window can just have pauseable property (turn off to capture enter)
	-- wallpaper should never be pausible
	-- awin.fullscreen and not awin.pwc_output and not awin.desktop_filenav and not awin.wallpaper) then 

	if (awin and awin.pauseable) then

		update_window_paused_menu(awin)

	end

	if (keyp("escape")) then

		-- look for haltable process
		-- (assumes there is only one)
		local width, height = _get_process_display_size(haltable_proc_id)

		if (modal_gui) then
			dismiss_modal()
		elseif (awin and awin.paused) then
			awin.paused = false
			send_message(awin.proc_id, {event = "unpause"})
		elseif (get_active_window() and get_active_window().autoclose) then
			close_window(get_active_window(), true) -- e.g. about / settings
		elseif toolbar_y_target > 0 then
			-- close tooltray if open
			toolbar_y_target = 0
		elseif infobar_y_target < 270 then
			-- close infobar if open
			hide_infobar()
		elseif (get_active_window() and get_active_window().capture_escapes) then
			-- let active window handle it
		elseif (width and width > 0) then 
			-- stop haltable process
			send_message(haltable_proc_id, {event="halt"})
			haltable_proc_id = false
		else
			-- toggle between output / last workspace
			if (ws_gui.style == "fullscreen") then
				set_workspace(last_non_fullscreen_workspace or last_desktop_workspace)
			else
				set_workspace(last_fullscreen_workspace)
			end
		end

	end

	-- keyboard control
	if (key("alt")) then
		if (keyp("left")) then set_workspace(workspace_index - 1) used_alt_navigation = true end
		if (keyp("right")) then set_workspace(workspace_index + 1) used_alt_navigation = true end

	end

	-- toggle fullscreen

	if (key("alt") and key("enter") and not last_enter_key_state) then		
		local sdat = fetch("/appdata/system/settings.pod") or {}
		sdat.fullscreen = not sdat.fullscreen
		store("/appdata/system/settings.pod", sdat)
		store("/ram/system/settings.pod", sdat) -- special file; causes settings to be applied
		-- clear key buffer (avoid "enter" being sent to text editor)
		readtext(true)
	end
	last_enter_key_state = key("enter")



	local dtab_index = 0

	if (key("ctrl") and keyp("tab")) dtab_index = key("shift") and -1 or 1

--[[
	-- don't need yet -- no flipping through windows, and ctrl-tab is nicer for tabs.
	if (key("alt") and keyp("up")) dtab_index = -1
	if (key("alt") and keyp("down")) dtab_index = 1
]]

	if (dtab_index != 0) then
		local tab = get_workspace_tabs()

		-- to do: for windows, need to keep a list of windows in order they are visited and use that
		-- perhaps only count windows with z==0 or something? don't want desktop, filenav, birds

		-- if (#tab < 2) tab = ws_gui.child -- cycle through windows instead;  

		for i=1,#tab do
			if (tab[i].is_active) then

				j = i + (#tab + dtab_index)
				while (j > #tab) do j = j - #tab end

				set_active_window(tab[j])

			end
		end

	end

	-- to do: while dragging items, switch between active window
	-- causes gui logic complexity but is nice and should drive gui logic to be cleaner
	-- annoying case: drag files out and back in to a window -> spurious events cause selection to start
		-- maybe just up to wm to manage which events get through while dragging files
	-- update: ah.. maybe switching window focus is not desired behaviour anyway
	-- -> light provisional version: just bring to front for a little visual feedback
	if (dragging_items) then
		local win2 = head_gui:el_at_xy(mx, my)
		if (win2) then
			if (win2.is_window_bar) win2 = win2.parent
			win2:bring_to_front()
		end
	end

--[[
	if (dragging_items) then
		local win2 = head_gui:el_at_xy(mx, my)
		if (win2 and win2.is_window_bar) win2 = win2.parent
		if (win2 ~= get_active_window()) then
			set_active_window(win2)
			send_message(win2.proc_id, {event = "block_mouse_events"})  --  need to block events until mb == 0
		end
	end
]]

	-- drop

	if (mb == 0 and dragging_items) then

		-- send a message to whatever window the cursor is over
		local win2 = head_gui:el_at_xy(mx, my)

		-- titlebar counts! (can drag and drop into titlebar, put sticker on titlebar)
		if (win2 and win2.is_window_bar) win2 = win2.parent

		--printh("dropping into proc: "..tostr(win2.proc_id))
		
		if (win2 and win2.proc_id) then

			-- first, window manager might consume some of the items (stickers)
			
			for i=1,#dragging_items do
				local item = dragging_items[i]
				--printh("item: "..pod(item))
				if (item.pod_type == "sticker") then
					if (type(win2.stickers) != "table") win2.stickers = {} 
					add(win2.stickers, {
						x = mx - win2.x,
						y = my - win2.y,
						bmp =  item.icon -- lazy change of meaning; the icon /is/ the content
					})
				end
			end

			-- send to window for processing
			send_message(win2.proc_id, {event="drop_items", 
				items = dragging_items,
				from_proc_id = dragging_items_from_proc_id,
				dx = mx - start_mx, dy = my - start_my, 
				mx = mx - win2.sx, 
				my = my - win2.sy
			})
		end

		dragging_items = nil
	end


	-- update
	if (not screensaver_proc_id) then
		head_gui:update_all()
	end

	-- store state of windows data
	-- store("/ram/shared/windows.pod", generate_windat()) -- commented during dev because noisy

	if (sdat.sparkles) then
		update_sparkles()
	else
		init_sparkles() -- reset. to do: existing sparkles should be allowed to live out their life? anti-module pattern though!
	end

end


-- to do: could maintain a lookup
-- to do: tooltray_gui windows
--local 
function get_window_by_proc_id(proc_id)

	for i=1,#workspace do
		for j=1,#workspace[i].child do
			if workspace[i].child[j].proc_id == proc_id then
				return workspace[i].child[j], i
			end 
		end
	end

	if (tooltray_gui) then
		for i=1,#tooltray_gui.child do
			if (tooltray_gui.child[i].proc_id == proc_id) return tooltray_gui.child[i], -1
		end
	end

	return nil -- none
end

function remove_workspace(index)
	for i=index, #workspace do
		workspace[i] = workspace[i+1]
	end
	set_workspace(ws_gui)
end

-- close window here so that don't invalidate window iterator
on_event("close_window", 
	function(msg)

		for i=1,#workspace do
			local pos = 1
			local num = #workspace[i].child
			
			for j=1,num do
				if workspace[i].child[j].proc_id == msg.proc_id then
					-- remove from list of tabs
					del(workspace[i].tabs, workspace[i].child[j])
				else
					-- shunt -- keep only processes that don't match those to be removed
					workspace[i].child[pos] = workspace[i].child[j]					
					pos = pos + 1
				end
			end

			-- clear end
			while (pos <= num) do
				workspace[i].child[pos] = nil
				pos = pos + 1
			end
		end

		generate_head_gui()

		-- finally, kill the process
		_kill_process(msg.proc_id)

	end
)



function choose_workspace(attribs)

	if (attribs.workspace == "current") return ws_gui

	if (attribs.workspace == "tooltray") return tooltray_gui
	
	-- explicitly requested a new workspace (e.g. New Desktop from toolbar right click menu)
	if (attribs.workspace == "new") return nil

	-- by workspace id
	if (type(attribs.workspace) == "number") then
		for i=1,#workspace do
			if (workspace[i].index == attribs.workspace) return workspace[i]
		end
	end

	---- no particular workspace requested --> choose cased on attributes

	-- wallpaper should open in same workspace (when new workspace was not requested)
	if (attribs.wallpaper) return ws_gui

	-- tabbed window get workspace running same program (to do)
	if (attribs.tabbed) then

		for i=1,#workspace do
			if (workspace[i].style == "tabbed" and workspace[i].prog == attribs.prog) then
				return workspace[i]
			end
		end

		return nil
	end

	-- fullscreen window gets new workspace
	if (attribs.fullscreen) return nil

	-- otherwise: desktop app
	return last_desktop_workspace

end

on_event("app_menu_item", function(msg)
	proc_menu[msg._from] = proc_menu[msg._from] or {}
	local menu = proc_menu[msg._from]
	-- look for existing item by label
	local pos = #menu + 1 -- default: add new
	for i=1,#menu do
		if (menu[i].id == msg.attribs.id) pos = i
	end
	menu[pos] = msg.attribs
end)



on_event("set_window", function(msg)

--	printh("set_window: "..pod(msg))

	if (msg._from <= pid()) return -- safety: don't create window for window manager

	local win = get_window_by_proc_id(msg._from)
	local attribs = msg.attribs or {}
	local target_ws = nil
	local old_win = nil
	local old_location = win and win.location or nil
	

	-- creating cart output window:  replace any existing output window

	if not win and msg.attribs.pwc_output then
		for i=1,#workspace do
			for j=1,#workspace[i].child do
				if (workspace[i].child[j].pwc_output) then
					-- match: replace fullscreen output when running fullscreen program / window when running windowed
					if (attribs.fullscreen == workspace[i].child[j].fullscreen or
						not attribs.fullscreen and not workspace[i].child[j].fullscreen) then 
						old_win = workspace[i].child[j]
						close_window(old_win, true)
						_kill_process(old_win.proc_id) -- need to kill explicitly here because pwc_output window is immortal
						target_ws = workspace[i]
					end
				end
			end
		end
	end

	

	-- if no existing window, create it
	if not win then

		--printh("creating window "..pod(attribs))

		-- 1. find workspace for it
		if (not target_ws) target_ws = choose_workspace(attribs)

		-- 2. if no existing workspace, create it
		if (not target_ws) then
			target_ws = create_workspace_1(msg._from, attribs)
		end

		-- 3. create the window

		-- if tooltray, force fixed position and frameless
		if (target_ws == tooltray_gui) then
			attribs.has_frame  = false
			attribs.moveable   = false
			attribs.resizeable = false
		end

		-- use a copy of attribs -- create_window() adds gui stuff, and want to iterate over original below
		local attribs_1 = unpod(pod(attribs))
		win = create_window(target_ws, attribs_1)

		

		-- if position is specified and has frame, should stay inside
		if (attribs.has_frame) then
			if (attribs.x) attribs.x = mid(0, attribs.x, 480 - attribs.width)
			if (attribs.y) attribs.y = mid(24, attribs.y, 270 - attribs.height)
		end

		-- 4. set starting window attributes. guess a title
		win.proc_id = msg._from

		local segs1 = split(attribs.prog,"/",false) or {}
		win.title = attribs.title or segs1[#segs1] or "proc_"..msg._from

		-- 4.a: when present working cart output, replace existing window at same position
		if (old_win) then
			win.x = old_win.x
			win.y = old_win.y
		end

		-- 5. add to tabs
		if (msg.attribs.tabbed) then
			add(target_ws.tabs, win)
		end

		-- 6. show in workspace if requested
		if (msg.attribs.show_in_workspace) then
			previous_workspace = ws_gui
			set_workspace(target_ws)
			target_ws.active_window = win -- give focus immediately
		end

		-- 7. give focus immediately when requested (autoclose implies should start with focus)
		if (msg.attribs.give_focus or msg.attribs.autoclose) then
			target_ws.active_window = win -- give focus immediately
		end

		-- 8. do some validation 
		-- was removed for 0.1.0f but caused [no workspaces] bug which seems to happen frequently but couldn't reproduce yet. race condition?
		-- to do: what is actually responsible for ensuring a valid workspace? should it really happen here?
		local workspace_index1 = mid(1, workspace_index, #workspace)
		if (workspace_index ~= workspace_index1 or ws_gui ~= workspace[workspace_index1]) then
			set_workspace(workspace_index1)
		end


		generate_head_gui()

	end

	
	-- modify / set attributes
	-- these are requested by program itself, so allowed to disregard restrictions in x,y (.moveable), width,height (.resizeable)

	for k,v in pairs(attribs) do
		win[k] = v
	end

	if (attribs.icon) then
		proc_icon[msg._from] = attribs.icon

		-- to do: update workspace button icon
		if (ws_gui and ws_gui.head_proc_id == msg._from) then
			ws_gui.icon = win.icon
			--printh("updating icon "..pod(win.icon))
		end
	end


	-- when changing location or creating new window, apply unique location logic:
	-- open in existing process where possible and optionally show in workspace
	if (attribs.unique_location and old_location ~= win.location) then

		-- printh("set_window change of location: "..pod{old_location, win.location})

		-- kill self if another window open with same location ** using same program **
		for i=1,#workspace do
			for j=1, #workspace[i].child do
				local win2 = workspace[i].child[j]
				if (win2 ~= win and not win2.closing and
					type(win.location) == "string" and type(win2.location) == "string" and
					win.location:path() == win2.location:path() and  -- same location (disregarding the hloc part after the #)
					win.prog     and win.prog     == win2.prog    -- editing using same program
				) then
				
					-- kill self!  -- to do: don't create the window in the first place
					_kill_process(win.proc_id)
					win.hidden = true

					-- kill newly created workspace if created one for this
					if (target_ws and #target_ws.child == 0) then
						del(ws_gui, target_ws)
					end

					-- go to other window
					if (win.show_in_workspace) then
						set_workspace(i)
						win2:bring_to_front()
					end

					-- tell win2 about the hash location
					send_message(win2.proc_id, {event = "jump_to_hloc", hloc = win.location:hloc()})
					
					-- file wranger thing
					notify("editing "..win.location.." using existing process")

					break -- iteration invalid?
				end
			end
		end
	end

	-- create wallpaper

	if (msg.attribs.wallpaper) then
		-- kill old wallpaper
		for i=1,#target_ws.child do
			if (target_ws.child[i].wallpaper and target_ws.child[i] != win) then
				-- send_message(pid(), {event="close_window",proc_id = target_ws.child[i].proc_id}) -- kill next frame
				_kill_process(target_ws.child[i].proc_id)
				--send_message(2, {event="kill_process", proc_id=target_ws.child[i].proc_id})
			end
		end

	end

	
	-- not here -- messes up dragging
	--generate_head_gui()

end)

-- program can ask window manager to move self by dx, dy
-- useful for implementing alternative title bar (drag self)
-- to set absolute x,y: use set_window
on_event("move_window", function(msg)
	local win = get_window_by_proc_id(msg._from)

	if (msg.dx) win.x += msg.dx
	if (msg.dy) win.y += msg.dy

end)


on_event("set_haltable_proc_id",
	function(msg)
		haltable_proc_id = msg.haltable_proc_id
	end
)

-- to do: nicer name for this; "log_message"?
on_event("user_notification",
	function(msg)
		-- printh("##################### "..pod(msg))
		user_notification_message = msg.content
		user_notification_message_t = time()

		-- log it in infobar
		-- send_message(3, {event="log", content = msg.content})

	end
)

--[[
	-- used by util/save.lua
	-- brute force save of anything editing cart files
]]
on_event("save_working_cart_files",
	function(msg)
		for i=1,#workspace do
			for j=1, #workspace[i].child do
				local win = workspace[i].child[j]
				if (win.location and sub(fullpath(win.location), 1, 10) == "/ram/cart/") then
					send_message(win.proc_id, {event="save_file"})
				end
			end
		end
	end
)

on_event("save_open_locations_metadata",
	function(msg)
		save_open_locations_metadata()
	end
)





--[[
	-- used by util/load.lua
	-- close any programs that are editing carts
]]
on_event("clear_project_workspaces",
	function(msg)
		for i=1,#workspace do
			local num = #workspace[i].child
			-- close / kill all windows under that workspace
			for j=1, #workspace[i].child do
				local win = workspace[i].child[j]
				if (win.location and string.sub(fullpath(win.location), 1, 10) == "/ram/cart/") then
					close_window(workspace[i].child[j], true)
					num -= 1
				end
			end
		end
		generate_head_gui()
	end
)


on_event("dock_toolbar",
	function(msg)
		-- to do: should modify the workspace that the window belongs to
		ws_gui.show_toolbar = msg.state
	end
)


on_event("drag_items",
	function(msg)
		-- to do: should modify the workspace that the window belongs to
		dragging_items = msg.items
		if (dragging_items) then
			dragging_items_from_proc_id = msg._from
			local win = get_window_by_proc_id(msg._from)
			for i=1,#dragging_items do
				local item = dragging_items[i]
				item.x = (item.x or 0) + win.sx
				item.y = (item.y or 0) + win.sy
			end
		end
	end
)


on_event("set_wallpaper",
	function (msg)

		-- kill existing desktop process

		--local wallpaper_win = last_desktop_workspace.child[1]
		--local wallpaper_win = ws_gui.child[1]

		--_kill_process(last_desktop_workspace.child[1]) -- test

		-- works
		create_process(msg.wallpaper, {window_attribs = { wallpaper = true, workspace = "current"}})

		-- why doesn't this work?
--		create_process(msg.wallpaper, {window_attribs = { wallpaper = true, workspace = "current"}})

		
	end
)

on_event("test_screensaver",
	function(msg) 
		test_screensaver_t0 = time()
	end
)

on_event("toggle_app_menu",
	function(msg)
		toggle_app_menu(msg.x, msg.y, get_window_by_proc_id(msg.proc_id))
	end
)


function save_open_locations_metadata()
	-- store all cart file locations /ram/cart/.info.pod

	local ws_info = {}
	for i=1,#workspace do
		for j=1, #workspace[i].tabs do
			local tt = workspace[i].tabs[j]

			-- add tab if a cart file (store relative to /ram/cart/)

			if sub(fullpath(tt.location), 1, 10) == "/ram/cart/" then

				-- printh("save_open_locations_metadata location: "..pod(tt.location))

				-- is cart file
				add(ws_info,{
					workspace_index = i,                    -- probably can't use but might be handy to group files
					location = sub(tt.location, #"/ram/cart" + 2)   -- store relative to /ram/cart/ (+2 to skip the /)
				})

			end
		end
	end

	-- metadata is normally not very large
--	printh("@@ storing workspace metadata: "..pod(ws_info))
	store_metadata("/ram/cart", {workspaces = ws_info})

end


function dismiss_modal()
	if (modal_gui) modal_gui:detach()
	modal_gui = nil
end


function create_modal_gui()

	modal_gui = head_gui:attach{
		x = 0, y = 0, width = 480, height = 270,
		--tap = dismiss_modal,
		click = dismiss_modal -- immediately interact  // to do: why isn't this working?
	}

	return modal_gui
end

function close_workspace(ws_index)
	local ws = get_workspace(ws_index)

	if (ws.immortal) return

	if (ws) then
		for i=1,#ws.child do
			_kill_process(ws.child[i].proc_id)
		end
	end

	-- fix workspace index; when delete current, hop to left unless already at left-most
	if (ws_index <= workspace_index and workspace_index > 1) workspace_index -= 1

	deli(workspace, ws_index)
	set_workspace(workspace_index)
end




function toggle_workspace_menu(x, y, ws_index)

	local pulldown = create_modal_gui():attach_pulldown{
		is_app_menu = true,
		x = x, y = y,
		width = 100, 
		ws_index = ws_index,
		onclose = dismiss_modal
	}

	pulldown:attach_pulldown_item
	{
		label = "\^:1c3e6b776b3e1c00 Close Workspace", 
		cursor="pointer",
		action = function()
			close_workspace(ws_index)

		end
	}

end


function toggle_app_menu(x, y, win)

	local win = win or get_active_window()

	if (not win) return

	-- app menu is already open
	if (modal_gui and modal_gui.child[2] and modal_gui.child[2].is_app_menu) then
		modal_gui = nil
		return
	end

	-- empty workspace

	if (#ws_gui.child == 0) return


	local mm = {}

	x = mid(0,x,480-142)
	y = max(0,y)


	local pulldown = create_modal_gui():attach_pulldown{
		is_app_menu = true,
		x = x, y = y,
		width = 142, -- to do: be adaptive when drawing
		onclose = dismiss_modal
	}

	-- add about item // to do: get icon & title from .p64 when create window (can be default title too)

	-- to do: generate icon from win.icon

	add(mm, {icon = win.icon, label = "About "..win.prog:basename(), action = function() 
		create_process("/system/apps/about.p64", {prog=win.prog, window_attribs={workspace="current", autoclose = true}}) end})

	-- userland items created by menuitem()

	local menu = proc_menu[win.proc_id]

	if (menu and #menu > 0) then

		add(mm, {divider=true})

		for i=1,#menu do

			if (menu[i].label) then
				local item = menu[i]
				local pulldown_item = unpod(pod(item)) -- copy all attributes
				
				pulldown_item.action = function(b)
					send_message(win.proc_id, {event="menu_action", id=menu[i].id, b=b})
				end

				add(mm,pulldown_item)
			end
		end

	end

	-- window management items at bottom

	

	-- is a tab
	if (win.height == 270) then -- hack: window is fullscreen file navigator (desktop)
		-- no close
	elseif (win.sy < 12) then
		add(mm, {divider=true})
		add(mm, {label="\^:1c3e6b776b3e1c00 Close Tab", action = function() close_window(win, true) end})
	else
		add(mm, {divider=true})
		add(mm, {label="\^:1c3e6b776b3e1c00 Close Window", action = function() close_window(win, true) end})
	end


	for i=1,#mm do
		mm[i].cursor = "pointer"
		pulldown:attach_pulldown_item(mm[i])
	end


end

function toggle_picotron_menu()

	if (modal_gui and modal_gui.child[2] and modal_gui.child[2].is_pictron_menu) then
		modal_gui = nil
		return
	end

	
	----------------------------------------
	-- pulldown
	----------------------------------------

	-- to do: populate some of this from a configurable shortcuts list
	-- could just look for shortcuts in /appdata/system/shortcuts

	local item =
	{
		{"\^:3f7f5077057f7e00 About Picotron", function() create_process("/system/apps/about.p64", 
			{prog="/system",window_attribs={workspace="current",  autoclose = true}}) end},
		"---",

		{"\^:307f3000067f0600 System Settings",	function() create_process("/system/apps/settings.p64", 
			{prog="/system",window_attribs={workspace="current", autoclose = true}}) end},

--		{"\^:3f7f5077057f7e00 New Desktop", function() end},

--[[	
		"\^:fec7838383c7fe00\^:1f3f3f3f3f3f1f00\-f Audio",
		"\^:fec7838383c7fe00\^:1f3f3f3f3f3f1f00\-f Fullscreen",
		"\^:fec7838383c7fe00\^:1f3f3f3f3f3f1f00\-f Battery Saver",
]]

		{"\^:7f77777f777f0301 Show Messages", show_reported_error},

		"---",

--		{"\^:00387f7f7f7f7f00 Apps", function() create_process("/system/apps/filenav.p64", {argv={"/apps"}, window_attribs={show_in_workspace=true}}) end},
		{"\^:00387f7f7f7f7f00 Files", function() create_process("/system/apps/filenav.p64", {argv={"/"}, window_attribs={show_in_workspace=true}}) end},
		{"\^:7f7d7b7d7f083e00 Terminal", function() create_process("/system/apps/terminal.lua", {window_attribs={show_in_workspace=true}}) end},
--		{"\^:00387f7f7f7f7f00 Host Desktop", function() _signal(65) end},

		--[[ underlay test; -10 means always under regular windows
		{"\^:7f7d7b7d7f083e00 Terminal2", function() create_process("/system/apps/terminal.lua", 
			{window_attribs={moveable=false,width=100,height=100,x=50,y=50,z=-10}}) end},
		--]]

--[[
		-- later (using filenav intention); use load / save commands for now

		"---",
		"\^:00ff8181ffc17f00 Load Cartridge",
		-- "Save Cartridge  (Ctrl-S)",  --  can show shortcut in message bar
		"\^:00ff8181ffc17f00 Save Cartridge",
		"\^:00ff8181ffc17f00 Save Cartridge As",
		"\^:1c367f7777361c00 Cartridge Info",
]]

		"---",
		 -- pop up menu: [Shutdown] [Reboot] [Cancel] 
		 -- perhaps show unsaved changes 
		 -- (checkbox: "discard unsaved changes" ~ once checked, buttons clickable)


		{"\^:1c22494949221c00 Reboot", function() send_message(2, {event="reboot"}) end},
		{"\^:082a494141221c00 Shutdown", function() send_message(2, {event="shutdown"}) end}
	}


	local pulldown = create_modal_gui():attach_pulldown{
		is_pictron_menu = true,
		x = 4, y = toolbar_y + 11,
		width = 122,
		onclose = dismiss_modal
	}
	
	for i=1,#item do
		if item[i] == "---" then
			pulldown:attach_pulldown_item{divider=true}
		elseif (type(item[i]) == "table") then
			pulldown:attach_pulldown_item{label=item[i][1], action = item[i][2]}
		else
			pulldown:attach_pulldown_item{label=item[i]}
		end
	end
	
	
end




:: apps/filenav.p64
b64$cGljb3Ryb24gY2FydHJpZGdlIC8vIHd3dy5waWNvdHJvbi5uZXQKdmVyc2lvbiAyCgo6OiAu
aW5mby5wb2QKYjY0JExTMWJXM0J2WkN4amNtVmhkR1ZrUFNJeU1ESXpMVEV4TFRFMUlEQTNPakV4
T2pNd0lpeGhkWFJvYjNJOUlucGxjQ0lzYm05MApaWE05SWloaktTQk1aWGhoYkc5bVpteGxJRWRo
YldWeklFeE1VQ0lzYVdOdmJqMTFjMlZ5WkdGMFlTZ2lkVGdpTERFMkxERTJMQ0l3Ck1UQXhNREV3
TVRBeE1ERXdNVEF4TURFd01UQXhNREV3TVRBeE1ERXdNVEF4TUdRd1pEQTNNRGN3TnpBM01EY3dO
ekEzTURjd056QTMKTUdRd1pEQXhNREV3WkRCa01EY3dNVEEzTURjd056QTNNRGN3TnpBeE1EY3da
REJrTURFd01UQmtNR1F3TnpBeE1EY3dOekEzTURjdwpOekEzTURFd056QmtNR1F3TVRBeE1HUXda
REEzTURjd056QTNNRGN3TnpBM01EY3dOekEzTUdRd1pEQXhNREV3WkRCa01EY3dOekJrCk1EY3dO
ekEzTURjd1pEQTNNRGN3WkRCa01ERXdNVEJrTUdRd056QTNNRGN3WkRCa01HUXdaREEzTURjd056
QmtNR1F3TVRBeE1HUXcKWkRBM01EY3dOekEzTURjd056QTNNRGN3TnpBM01HUXdaREF4TURFd1pE
QmtNR1F3WkRCa01HUXdaREJrTUdRd1pEQmtNR1F3WkRCawpNREV3TVRCa01HUXdaREJrTUdRd1pE
QmtNR1F3WkRCa01HUXdaREJrTUdRd01UQXhNR1F3WkRCa01HUXdaREJrTUdRd1pEQmtNR1F3ClpE
QmtNR1F3WkRBeE1ERXdaREJrTURFd01UQXhNREV3TVRBeE1ERXdNVEF4TURFd1pEQmtNREV3TVRC
a01HUXdNVEF4TURFd01UQTMKTURjd056QTNNRGN3TVRCa01HUXdNVEF4TUdRd1pEQXhNREV3TVRB
eE1EY3dOekEzTURjd056QXhNR1F3WkRBeE1ERXdaREJrTURFdwpNVEF4TURFd056QTNNRGN3TnpB
M01ERXdaREF4TURBd01UQXhNREV3TVRBeE1ERXdNVEF4TURFd01UQXhNREV3TVRBeE1EQXdNQ0lw
CkxHMXZaR2xtYVdWa1BTSXlNREkwTFRBM0xUQTJJREV4T2pRNE9qTTJJaXh5ZFc1MGFXMWxQVFVz
YzNSdmNtVmtQU0l5TURJMExUQXoKTFRJMElERTFPak0xT2pVMklpeDBhWFJzWlQwaVVHbGpiM1J5
YjI0Z1JtbHNaU0JPWVhacFoyRjBiM0lpTEhabGNuTnBiMjQ5SWpBdQpNV1lpTEhkdmNtdHpjR0Zq
WlhNOWUzdHNiMk5oZEdsdmJqMGliV0ZwYmk1c2RXRWpNU0lzZDI5eWEzTndZV05sWDJsdVpHVjRQ
VEY5CkxIdHNiMk5oZEdsdmJqMGliM0JsYmk1c2RXRWpPQ0lzZDI5eWEzTndZV05sWDJsdVpHVjRQ
VEY5TEh0c2IyTmhkR2x2YmowaWFXNTAKWlhKbUxteDFZU014SWl4M2IzSnJjM0JoWTJWZmFXNWta
WGc5TVgwc2UyeHZZMkYwYVc5dVBTSnBiblJsYm5ScGIyNHViSFZoSXpFaQpMSGR2Y210emNHRmpa
VjlwYm1SbGVEMHhmU3g3Ykc5allYUnBiMjQ5SW1SbGMydDBiM0F1YkhWaEl6SXpPQ0lzZDI5eWEz
TndZV05sClgybHVaR1Y0UFRGOUxIdHNiMk5oZEdsdmJqMGlabWx1Wm04dWJIVmhJekVpTEhkdmNt
dHpjR0ZqWlY5cGJtUmxlRDB4ZlN4N2JHOWoKWVhScGIyNDlJbWR5YVdRdWJIVmhJekVpTEhkdmNt
dHpjR0ZqWlY5cGJtUmxlRDB4ZlN4N2JHOWpZWFJwYjI0OUlteHBjM1F1YkhWaApJekVpTEhkdmNt
dHpjR0ZqWlY5cGJtUmxlRDB4ZlN4N2JHOWpZWFJwYjI0OUltZG1lQzh3TG1kbWVDSXNkMjl5YTNO
d1lXTmxYMmx1ClpHVjRQVEo5TEh0c2IyTmhkR2x2YmowaVoyWjRMekV1WjJaNElpeDNiM0pyYzNC
aFkyVmZhVzVrWlhnOU1uMTlYVjFzZWpRQUJBQUEKQUFNQUFBQXdibWxzCjo6IGdmeC8KOjogZ2Z4
Ly5pbmZvLnBvZApiNjQkTFMxYlczQnZaQ3hqY21WaGRHVmtQU0l5TURJekxURXhMVEUxSURBM09q
RXhPak13SWl4dGIyUnBabWxsWkQwaU1qQXlOQzB3Ck55MHdOaUF4TVRvME9Eb3pOaUlzYzNSdmNt
VmtQU0l5TURJekxURXhMVEUxSURBM09qRXhPak13SWwxZGJIbzBBQVFBQUFBREFBQUEKTUc1cGJB
PT0KOjogZ2Z4L2RlbG1lLwo6OiBnZngvZGVsbWUvLmluZm8ucG9kCmI2NCRMUzFiVzNCdlpDeGpj
bVZoZEdWa1BTSXlNREl6TFRFd0xURXhJREEzT2pVME9qQTJJaXh0YjJScFptbGxaRDBpTWpBeU5D
MHcKTnkwd05pQXhNVG8wT0Rvek5pSXNjM1J2Y21Wa1BTSXlNREl6TFRVMExURXhJREEzT2pVME9q
QTJJbDFkYkhvMEFBUUFBQUFEQUFBQQpNRzVwYkE9PQo6OiBnZngvZGVsbWUyLwo6OiBnZngvZGVs
bWUyLy5pbmZvLnBvZApiNjQkTFMxYlczQnZaQ3hqY21WaGRHVmtQU0l5TURJekxUQXlMVEV4SURB
NE9qQXlPakl3SWl4dGIyUnBabWxsWkQwaU1qQXlOQzB3Ck55MHdOaUF4TVRvME9Eb3pOaUlzYzNS
dmNtVmtQU0l5TURJekxUQXlMVEV4SURBNE9qQXlPakl3SWwxZGJIbzBBQVFBQUFBREFBQUEKTUc1
cGJBPT0KOjogZ2Z4L2hhLwo6OiBnZngvaGEvLmluZm8ucG9kCmI2NCRMUzFiVzNCdlpDeGpjbVZo
ZEdWa1BTSXlNREl6TFRBNUxURXhJREE0T2pBNU9qUTBJaXh0YjJScFptbGxaRDBpTWpBeU5DMHcK
Tnkwd05pQXhNVG8wT0Rvek5pSXNjM1J2Y21Wa1BTSXlNREl6TFRBNUxURXhJREE0T2pBNU9qUTBJ
bDFkYkhvMEFBUUFBQUFEQUFBQQpNRzVwYkE9PQo6OiBnZngvenhjLwo6OiBnZngvenhjLy5pbmZv
LnBvZApiNjQkTFMxYlczQnZaQ3hqY21WaGRHVmtQU0l5TURJekxURXdMVEV4SURBM09qUXhPalF4
SWl4dGIyUnBabWxsWkQwaU1qQXlOQzB3Ck55MHdOaUF4TVRvME9Eb3pOaUlzYzNSdmNtVmtQU0l5
TURJekxUUXhMVEV4SURBM09qUXhPalF4SWwxZGJIbzBBQVFBQUFBREFBQUEKTUc1cGJBPT0KOjog
Z2Z4LzAuZ2Z4CmI2NCRMUzFiVzNCdlpDeGpjbVZoZEdWa1BTSXlNREl6TFRFd0xUSXdJREEyT2pN
NE9qVTJJaXh0YjJScFptbGxaRDBpTWpBeU5DMHcKTkMweE1TQXlNam95TmpveE15SXNjbVYyYVhO
cGIyNDlNakk0TXl4emRHOXlaV1E5SWpJd01qTXRNelF0TURrZ01UazZNelE2TlRNaQpYVjFzZWpR
QWR3UUFBSTA2QUFEekZIdGJNRjA5ZTJKdGNEMXdlSFVBUXlBUUVBVHc4Q3htYkdGbmN6MHdMSEJo
Ymw5NENBREtlVDB3CkxIcHZiMjA5T0gwc01RRHpDZ0NSVUFGM0JnRkFBWGNXQVRBQmR5WUJJQUYz
TmdFUUFiY0VBRFFYSm1jS0FDMUdSd29BQXdRQUw5RUEKZGdBYzctQUpVWUFCTFNZQkFHRXROaEhX
QWdBQlR3RUEwUURMQURnZ0p6MnpBRFUzTFVjTUFFRVhMUWNOQ0FBZ0hYY0dBQ0JkTnhvQQpJMDAz
TUFBUDFRQWhiLUVCRnBjV0VRUUFCUUxZQUlNbWdSWVJKZ0UzTVFZQVFRRUFBUllJQUM4UTBXMEFI
SkFRb1RBQnJRRVFBUWNHCkFCQVJDZ0NmdlFFQUFRY0JIVkV0RUFBSy13T2RFUkN4QndFUUVaY05B
U0FCblFGQWtTQjVBQnp5QmZBS1FaQXhIUUVBb1MwUjNSRXQKZHkwUkhaY2RCQUJYRngwbkhRY0lB
Q0dYSFNBQS13Qk5SejBSVFFjTkJ3MEhQUkhkQVFBc0FpS0FNUzBCQUpFOUVkMXpBSUZYVFJFdApa
ejBSYlZFQXNTMG5EU2M5RVMwSERRZDlGZ0FoUFZjbUFBOF9BaUg2QXFGQUFYY0dFVEFCZHhZUklB
RjNKaEVRQ1FNQTFBQVJOekFDClB5Y2RKd2dBQ0FRb0FBNUdBZ19JQUROZkZ4MFhIVGNJQUFFQndn
Sm1GdzBISFFjTkVBQU9oZ0FQRndRMEV5ME9BUVVJQUFBbkJDRkgKTFF3QUtSMEhDQUFQaEFCQklE
ZE5iQUZQTncwbkRRZ0FBeklITFNlZUFDVXRKNTRBRDRnQVFSSm4tQUVhYlFvQ1NRY05CeDBTQUNW
dApKMm9FRDRZQVFSRzNYZ0EwQngxSERBQURsZ0VldDRZQkQzd0FGQTlXQml4Z0VJRlFBWGNOclFB
UUhhMEFFQzJ0QUJZOWdRQkZBVmNXCk53WUFBbUlHV0FjV0Z3WlhDQUFuUmxkX0JqOGdzUkN6QUIy
ZkFkRUFBZGNSQjcwSEJBQUMtd2ZYRVJlR0p4RVhoaGNHRWJjR0FRQUIKdGdFZ3NmQURaQUFkandE
eEFkWVJCcjBHQkFBQy13WFdFUmFISmhFV2h4WU5FYllOQVFBQnZRRVF3V01BSDM4SWNXQVJMU2FC
SndjRgpMLUVCR0FFZ1dCRzNJZGNSQWdBaEJyZXZBSjhkbGlHMkVRRFI4QUg1QmlkVEJ3MVhEUWNN
QURNWFhSY0tBQS0tQmo4djhQQXhBSDhQCkRnSU1FdFlNQVNHSEZtOENEZ3dDRDVJQVFCRUhQUUtj
RVFCUkxVWWh4aEhXQWdBQjdnRWZBSVlBVGc4eEFCMWlFTEVnRVpjUktRUUUKQkFBUDNnUVZVQWFY
QmdFUVh3RV9FWllSTlFRUGVnQWRNeWNkRjhnRlB6Y2RGd2dBQ0FRb0FBX0dBQVFQZWdKVUw3RUdC
QUFDbGRZUgpCaGNHWFFZWEJnZ0FQelpkSm9RQ0p3OHhBSzh2QUpHZEJnc0FCQUJGRnhZSEZuQUNS
aVlIRmpjWUFDNG1OOFlIRDN3QVFsOEhGaWNXCk53Z0FDQWVrQUEtU0IwOEFaQUpmM1JFTnNRMEVB
QVlBblF0ekRhY2RFUTJYSGU0R0h5QWRBYVlQTVFELUVnX3VBWFVQaUFBUlh3Y1cKRnhaSENBQUJF
VllHQUZZR0J4WUhCaEFBRDRZQVJoTW1EZ0VGQ0FBQUVRd2hOeVlNQUNrV0J3Z0FENFFBUVNBblJt
d0JUeWNHSndZSQpBQU1DMndRa0J5WUlBQjkzaUFCRUF2Z0xLZ2RtQ2dJQWhnRUpFZ0FESUFBZmg0
WUFSQnEzZUFJUDV3VUxEMzREZmdDUUJRLWZEQlFDCjFRc2ZBc01BZjJBQ3NTQUJ0d0duRFFfTkRB
SUVsdzBQdWdBZkR6RUEtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KLS0tLS0t
LS0tLS0tLTRGUWJUMDRmWDA9Cjo6IGdmeC8xLmdmeApiNjQkTFMxYlczQnZaQ3hqY21WaGRHVmtQ
U0l5TURJekxURXdMVEV4SURBek9qRXpPakF4SWl4dGIyUnBabWxsWkQwaU1qQXlOQzB3Ck5DMHhN
U0F5TWpveU5qb3hNeUlzY21WMmFYTnBiMjQ5TkRVMlhWMXNlalFBbWdBQUFETXhBQUR6Rkh0Yk1G
MDllMkp0Y0Qxd2VIVUEKUXlBUUVBVHc4Q3htYkdGbmN6MHdMSEJoYmw5NENBRFBlVDB3TEhwdmIy
MDlPSDBzTVFBcDlRRUlDQVEzTUFjUUZ5QUhFQ2NRQnpBSApCQUF2VjVCSEFDNlBWNUFIQUFjQUJ5
QkpBQTRPOGdBUE1RRC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCi0t
LS0tLS0tLS0tLS0tLS0tLS0tLS05Q1VHMDlPSDE5Cjo6IG1hcC8KOjogbWFwLy5pbmZvLnBvZApi
NjQkTFMxYlczQnZaQ3hqY21WaGRHVmtQU0l5TURJMExUQXpMVEEzSURFd09qRXhPalUySWl4dGIy
UnBabWxsWkQwaU1qQXlOQzB3Ck55MHdOaUF4TVRvME9Eb3pOaUlzYzNSdmNtVmtQU0l5TURJMExU
QXpMVEEzSURFd09qRXhPalUySWwxZGJIbzBBQVFBQUFBREFBQUEKTUc1cGJBPT0KOjogbWFwL21h
cDAubWFwCmI2NCRMUzFiVzNCdlpDeGpjbVZoZEdWa1BTSXlNREkwTFRBekxUQTNJREV3T2pFeE9q
VTJJaXh0YjJScFptbGxaRDBpTWpBeU5DMHcKTXkwd055QXhNRG94TWpvd01TSXNjbVYyYVhOcGIy
NDlNVjFkYkhvMEFHa0FBQUNqQ0FBQThCTjdiR0Y1WlhJOWUxc3dYVDE3WW0xdwpQWFZ6WlhKa1lY
UmhLQ0pwTVRZaUxERTJBd0F2SWpBQkFQLS0tX19oSWlrc2NHRnVYM2c5TUFnQThnWjVQVEFzYzJO
aGJHVTlNU3gwCmFXeGxYMmc5TVRZS0FHOTNQVEUyZlN4TEJQLS0tLTg0VURFMmZYMTkKOjogc2Z4
Lwo6OiBzZngvLmluZm8ucG9kCmI2NCRMUzFiVzNCdlpDeGpjbVZoZEdWa1BTSXlNREkwTFRBekxU
QTNJREV3T2pFeE9qVTJJaXh0YjJScFptbGxaRDBpTWpBeU5DMHcKTnkwd05pQXhNVG8wT0Rvek5p
SXNjM1J2Y21Wa1BTSXlNREkwTFRBekxUQTNJREV3T2pFeE9qVTJJbDFkYkhvMEFBUUFBQUFEQUFB
QQpNRzVwYkE9PQo6OiBzZngvc2Z4MC5zZngKYjY0JExTMWJXM0J2WkN4amNtVmhkR1ZrUFNJeU1E
STBMVEF6TFRBM0lERXdPakV4T2pVMklpeHRiMlJwWm1sbFpEMGlNakF5TkMwdwpNeTB3TnlBeE1E
b3hNam93TVNJc2NtVjJhWE5wYjI0OU1WMWRiSG8wQUJBQkFBQlJCd0FBOENkd2VIVUFBeWdBQUFN
QUJBOUFFQUlPCkFBR2dBU0FDb0E0QUR4QUFEZkRLQVFJREJBVUdCd0VQLTVBSUNRb0xEd3dQRFE4
T0R3OFFBUEFBRFE4UkR4SVBFdzhVRHhVUEZnOFgKRXdEeEFROFlEeGtQR2c4YkR4d1BIUThlRHg4
VUFQRUFJQThoRHlJUEl3OGtEeVVQSmc4bkZBRHhBQ2dQS1E4cUR5c1BMQTh0RHk0UApMeFFBOFFB
d0R6RVBNZzh6RHpRUE5RODJEemNVQVA4Rk9BODVEem9QT3c4OER6MFBQZzgtQVEtLThQOEJBT3Yt
SjFvQkVBWVBJQkFCCklBRWdBZkFBQWhBQ0RCQUJJQThoSUFFd0QwRHd3dzhvRC0td3hnLTRDZy0t
RDRBUDl3OE5BZkFKQVJBR0REQUEtemtmLXdFQTNMLTQKRDBBQURVRC0tN0R3Y0FvQS0tOWtILThC
QUpkUS0tLS0teDg9Cjo6IGRlc2t0b3AubHVhCi0tW1twb2RfZm9ybWF0PSJyYXciLGNyZWF0ZWQ9
IjIwMjMtMTAtMDQgMTU6MTM6NDEiLG1vZGlmaWVkPSIyMDI0LTA0LTExIDIyOjI2OjEzIixyZXZp
c2lvbj0yMDkzLHN0b3JlZD0iMjAyMy0yMS0yOSAwOToyMToxOSJdXQotLSBtb2RlOiBkZXNrdG9w
CmxvY2FsIGRlc2t0b3BfaXRlbXMgPSBuaWwKbG9jYWwgZGVza3RvcF9jb250ZW50ID0gbmlsCmxv
Y2FsIHNlbApmdW5jdGlvbiBzZXRfZGVza3RvcF9pdGVtX3Bvc2l0aW9uKGZpbGVuYW1lLCB4LCB5
KQoJaWYgKG5vdCBkZXNrdG9wX2l0ZW1zW2ZpbGVuYW1lXSkgZGVza3RvcF9pdGVtc1tmaWxlbmFt
ZV0gPSB7fQoKCWlmIChub3QgeCBvciBub3QgeSkgdGhlbgoKCQktLSBmaW5kIGFuIHVudXNlZCBz
cG90CgoJCWxvY2FsIHVzZWQgPSB1c2VyZGF0YSgidTgiLDQ4LDI3KQoJCQoJCWZvciBrLGl0ZW0g
aW4gcGFpcnMoZGVza3RvcF9pdGVtcykgZG8KCQkJaWYgKGl0ZW0ueCBhbmQgaXRlbS55KSB0aGVu
CgkJCQlsb2NhbCB4eCA9IGl0ZW0ueCBcIDEwCgkJCQlsb2NhbCB5eSA9IGl0ZW0ueSBcIDEwCgkJ
CQl1c2VkOnNldCh4eCx5eSwxKQoJCQllbmQKCQllbmQKCQkKCQlmb3IgeHggPSA1LCA0NyBkbwoJ
CQkJZm9yIHl5ID0gMiwgMjIgZG8JCQkKCQkJCWlmIHVzZWQ6Z2V0KHh4LHl5KSA9PSAwIHRoZW4K
CgkJCQkJbG9jYWwgZW1wdHkgPSB0cnVlCgkJCQkJZm9yIGR4PS0zLDMgZG8KCQkJCQkJZm9yIGR5
PS0zLDMgZG8KCQkJCQkJCWlmICh1c2VkOmdldCh4eCtkeCx5eStkeSkgPiAwKSBlbXB0eSA9IGZh
bHNlCgkJCQkJCWVuZAoJCQkJCWVuZAoKCQkJCQlpZiBlbXB0eSB0aGVuCgkJCQkJCXggPSB4eCox
MCB5ID15eSoxMAoJCQkJCQlnb3RvIGZvdW5kX3Nsb3QKCQkJCQllbmQKCQkJCWVuZAoJCQllbmQK
CQllbmQKCgkJeCA9IDQwICsgcm5kKDIwMCkKCQlpZiAobm90IHkpIHkgPSA0MCArIHJuZCgyMDAp
CgoJZW5kCgoJOjpmb3VuZF9zbG90OjoKCglkZXNrdG9wX2l0ZW1zW2ZpbGVuYW1lXS54ID0geAoJ
ZGVza3RvcF9pdGVtc1tmaWxlbmFtZV0ueSA9IHkKZW5kCmZ1bmN0aW9uIGZldGNoX2Rlc2t0b3Bf
aXRlbXMoKQoJbG9jYWwgbWV0YSA9IGZldGNoX21ldGFkYXRhKGRlc2t0b3BfcGF0aCkKCWRlc2t0
b3BfaXRlbXMgPSBtZXRhIGFuZCBtZXRhLmZpbGVfaXRlbSBvciB7fQoJLS1wcmludGgoImZldGNo
ZWQgZGVza3RvcCBpdGVtczogIi4ucG9kKGRlc2t0b3BfaXRlbXMpKQplbmQKZnVuY3Rpb24gc3Rv
cmVfZGVza3RvcF9pdGVtcygpCgktLXByaW50aCgiQEAgc3RvcmVfZGVza3RvcF9pdGVtczogIi4u
cHdkKCkpCgkKCS0tIHNlY3VyaXR5OiBvbmx5IHN0b3JlIGl0ZW1zIHRoYXQgaGF2ZSBhIG1hdGNo
aW5nIGZpbGUuCgktLSAod2hlbiBkZWxldGUgYSBmaWxlLCBkb24ndCBleHBlY3QgdGhlIGZpbGVu
YW1lIHRvIGJlIGtpY2tpbmcgYXJvdW5kIGhlcmUpCglmb3Igayx2IGluIHBhaXJzKGRlc2t0b3Bf
aXRlbXMpIGRvCgkJaWYgKG5vdCBmc3RhdChrKSkgZGVza3RvcF9pdGVtc1trXSA9IG5pbAoJCQoJ
CS0tIGFsc286IHN0b3JlIGFzIGludHMKCQl2LnggXD0gMSAgdi55IFw9IDEKCQkKCWVuZAoJCglz
dG9yZV9tZXRhZGF0YShkZXNrdG9wX3BhdGgsIHtmaWxlX2l0ZW0gPSBkZXNrdG9wX2l0ZW1zfSkK
CQplbmQKZnVuY3Rpb24gc2hpZnRfc2VsZWN0ZWRfZGVza3RvcF9pdGVtcyhkeCwgZHkpCgoJZm9y
IGk9MSwjZmkgZG8KCQlsb2NhbCBlbDIgPSBmaVtpXQoJCWlmIChlbDIuZmluZm8uc2VsZWN0ZWQp
IHRoZW4KCQkJbG9jYWwgdzIgPSBlbDIud2lkdGgvMgoJCQlsb2NhbCBoMiA9IGVsMi5oZWlnaHQv
MgoJCQllbDIueCA9IG1pZCgtdzIsIGVsMi54ICsgZHgsIHcyICsgNDgwIC0gZWwyLndpZHRoKQoJ
CQllbDIueSA9IG1pZCgtaDIsIGVsMi55ICsgZHksIGgyICsgMjcwIC0gZWwyLmhlaWdodCkKCgkJ
CS0tIGNyZWF0ZSAvIHVwZGF0ZSBkZXNrdG9wIGl0ZW0gdG9vCgoJCQlkZXNrdG9wX2l0ZW1zW2Vs
Mi5maWxlbmFtZV0gPSBkZXNrdG9wX2l0ZW1zW2VsMi5maWxlbmFtZV0gb3Ige30gLS0gY3JlYXRl
IG5ldwoJCQlsb2NhbCBkaSA9IGRlc2t0b3BfaXRlbXNbZWwyLmZpbGVuYW1lXQkKCQkJZGkueCA9
IGVsMi54CgkJCWRpLnkgPSBlbDIueQoJCQoJCWVuZAoJZW5kCgkKCXN0b3JlX2Rlc2t0b3BfaXRl
bXMoKQplbmQKCmxvY2FsIGZ1bmN0aW9uIGNyZWF0ZV9maWxlX2l0ZW0ocGFyZW50LCBmZiwgeCwg
eSkKCWlmIChub3QgZmYgb3Igbm90IGZmLmZpbGVuYW1lKSByZXR1cm4KCWxvY2FsIGZpbGVuYW1l
ID0gZmYuZmlsZW5hbWUKCQoJZGVza3RvcF9pdGVtc1tmaWxlbmFtZV0gPSBkZXNrdG9wX2l0ZW1z
W2ZpbGVuYW1lXSBvciB7fQoJCglsb2NhbCBlbCA9IHsKCQl4PXgseT15LAoJCXdpZHRoPTEyOCwg
aGVpZ2h0PTQyLCAtLSBkZXNrdG9wIGl0ZW1zIGNhbiBiZSBxdWl0ZSB3aWRlCgkJZmluZm8gICAg
PSBmZiwKCQlmaWxlbmFtZSA9IGZmLmZpbGVuYW1lLAoJCS0tIGN1cnNvciA9IDUgLS0gbmVlZHMg
dG8gYmUgY29uc2lzdGVudCB3aXRoIGdyaWQgdmlldwoJfQoJCglmdW5jdGlvbiBlbDp1cGRhdGUo
bXNnKQoJCQoJCWxvY2FsIG14LG15ID0gbW91c2UoKQoJCQoJCWxvY2FsIGR4LGR5ID0gbXggLSAo
c2VsZi5zeCtzZWxmLndpZHRoLzIpLCBteSAtIChzZWxmLnN5K3NlbGYuaGVpZ2h0LzIpCgoJCS0t
IHJlc2V0IGF1dG8tb3BlbiBtZWNoYW5pc20KCQlpZiAobm90IGRyYWdnaW5nX2ZpbGVzKSB0aGVu
CgkJCXNlbGYub3BlbmVkX3doaWxlX2RyYWdnaW5nX2ZpbGVzID0gZmFsc2UKCQkJc2VsZi5ob3Zl
cl9jb3VudGVyID0gMAoJCQlyZXR1cm4KCQllbmQKCQkKCQktLSBhdXRvLW9wZW4gd2hlbiBub3Qg
c2VsZWN0ZWQgYW5kIGRyYWdnaW5nIGZpbGVzIG92ZXJoZWFkCgkJaWYgbm90IHNlbGYuZmluZm8u
c2VsZWN0ZWQgYW5kIAoJCQlkeCpkeCtkeSpkeTwyNTYgYW5kIAoJCQlub3Qgc2VsZi5vcGVuZWRf
d2hpbGVfZHJhZ2dpbmdfZmlsZXMKCQl0aGVuCgkJCXNlbGYuaG92ZXJfY291bnRlciArPSAxCgkJ
CWlmIHNlbGYuZmluZm8uYXR0cmliID09ICJmb2xkZXIiIGFuZCBzZWxmLmhvdmVyX2NvdW50ZXIg
PiAzMAoJCQl0aGVuCgkJCQlzZWxmLm9wZW5lZF93aGlsZV9kcmFnZ2luZ19maWxlcyA9IHRydWUK
CQkJCWNyZWF0ZV9wcm9jZXNzKCIvc3lzdGVtL2FwcHMvZmlsZW5hdi5wNjQiLAoJCQkJewoJCQkJ
CWFyZ3YgPSB7ZWwuZmluZm8uZnVsbHBhdGh9LCAKCQkJCQl3aW5kb3dfYXR0cmlicz17CgkJCQkJ
CWdpdmVfZm9jdXMgPSB0cnVlLAoJCQkJCQl4ID0gbWF4KC0yLCBteCAtIDgwKSwgLS0gcG9zaXRp
b24gd2luZG93IHVuZGVyIGN1cnNvcgoJCQkJCQl5ID0gbWF4KC0yLCBteSAtIDQwKSAgLS0gcmVh
ZHkgdG8gY2F0Y2ggZmlsZQoJCQkJCX0KCQkJCX0pCgkJCWVuZAoJCWVsc2UKCQkJc2VsZi5ob3Zl
cl9jb3VudGVyID0gMAoJCWVuZAoJZW5kCgkKCWZ1bmN0aW9uIGVsOmRyYWcobXNnKQoJCWRyYWdf
c2VsZWN0ZWRfZmlsZXMobXNnKQoJZW5kCgkKCWZ1bmN0aW9uIGVsOnJlbGVhc2UobXNnKQoJCWRy
YWdnaW5nX2ZpbGVzID0gbmlsCgllbmQKCQoJZnVuY3Rpb24gZWw6dGVzdF9wb2ludCh4LCB5KQoJ
CQoJCWxvY2FsIGxsID0gZWwubGFzdF9sYWJlbF9hcmVhCgkJaWYgKG5vdCBsbCkgcmV0dXJuIHRy
dWUKCQkKCQktLSBzcHJpdGUgcGl4ZWwgaXMgc2V0LCBvciBpbnNpZGUgZmlsZW5hbWUgbGFiZWwK
CQlyZXR1cm4gZ2V0KHNlbGYuZmluZm8uaWNvbiwgeCAtIGxsWzVdLCB5IC0gbGxbNl0pID4gMAoJ
CQlvciAoeCA_PSBsbFsxXSBhbmQgeSA_PSBsbFsyXSBhbmQgeCA8PSBsbFszXSBhbmQgeSA8PSBs
bFs0XSkKCWVuZAoJCgkKCWZ1bmN0aW9uIGVsOmRyYXcobXNnKQoJCWNsaXAoKSAtLSBhbGxvdyBk
ZXNrdG9wIGl0ZW1zIHRvIGJlIGRyYXduIGFueSBzaXplIChlLmcuIHN1cGVyIGxvbmcgZmlsZW5h
bWVzKQoKCQktLXJlY3QoMCwwLHNlbGYud2lkdGgtMSxzZWxmLmhlaWdodC0xLDIpIC0tIGRlYnVn
OiBzaG93IHdpZHRoCgkJcGFsKCkKCQlsb2NhbCBzcHJ4LCBzcHJ5ID0gc2VsZi53aWR0aC8yIC0g
OCwgNgoJCWxvY2FsIHNwcngwLCBzcHJ5MCA9IHNwcngsIHNwcnkKCQkKCQktLWxvY2FsIGR4LGR5
ID0gbXNnLm14IC0gKHNlbGYuc3grc2VsZi53aWR0aC8yKSwgbXNnLm15IC0gKHNlbGYuc3krc2Vs
Zi5oZWlnaHQvMikKCQktLWlmIChkeCpkeCtkeSpkeTwyNTYpIGNpcmNmaWxsKHNlbGYud2lkdGgv
MixzZWxmLmhlaWdodC8yLDE2LDEzKQoJCgkJaWYgKHNlbGYuZmluZm8uc2VsZWN0ZWQpIHRoZW4K
CQkKCQkJLS0gc2hhZG93IGNvbG91cgoJCQlsb2NhbCBzaGFkb3dfY29sID0gdGhlbWUiZGVza3Rv
cF9zaGFkb3ciCgkJCXBhbCg3LHNoYWRvd19jb2wpIHBhbCg2LHNoYWRvd19jb2wpIHBhbCgxMyxz
aGFkb3dfY29sKSBwYWwoMSxzaGFkb3dfY29sKSAKCQkJLS1maWxscCgweGYwZjApCgkJCXNwcihz
ZWxmLmZpbmZvLmljb24sc3ByeCxzcHJ5KQoJCQlwYWwoKWZpbGxwKCkKCQkJc3ByeCArPSAyCgkJ
CXNwcnkgLT0gMgoJCQkKCQkJLS0gaW52ZXJ0CgkJCS0tIHBhbCg3LDEpIHBhbCgxLDcpCgkJCS0t
cmVjdGZpbGwoMCwwLHNlbGYud2lkdGgtMSxzZWxmLmhlaWdodC0xLDEwKQoJCWVuZAoJCQoJCWlm
IChub3QgZHJhZ2dpbmdfZmlsZXMgb3Igbm90IHNlbGYuZmluZm8uc2VsZWN0ZWQpIHRoZW4KCQkJ
cGFsKDcsIHRoZW1lImljb24wIikKCQkJcGFsKDYsdGhlbWUiaWNvbjEiKQoJCQlwYWwoMTMsIHRo
ZW1lImljb24yIikKCQkJcGFsKDEsIHRoZW1lImljb24zIikKCQkJc3ByKHNlbGYuZmluZm8uaWNv
bixzcHJ4LHNwcnkpCgkJZW5kCgkJCgkJcGFsKCkKCQkKCQktLWxvY2FsIHN0ciA9ICJcMDE0Ii4u
c2VsZi5maWxlbmFtZQoJCXBva2UoMHg1ZjM2LCAweDgwKSAtLSB0dXJuIG9uIHdyYXAgdG8gY2xp
cF9yaWdodAoJCQoJCWxvY2FsIHN0ciA9IHNlbGYuZmlsZW5hbWUKCQkKCQlsb2NhbCB3dyxoaCA9
IHByaW50KHN0ciwgMCwgLTEwMDAwMDApCgkJaGggKz0gMTAwMDAwMAoKLS0JCXd3ID0gbWluKHd3
LCBzZWxmLndpZHRoLTgpIC0tIGRvbid0IGNsaXAgbGVmdCB0ZXh0LCBvbmx5IHJpZ2h0CgkJCgkJ
bG9jYWwgdzIgPSBzZWxmLndpZHRoIC8gMgoJCWxvY2FsIHl5ID0gMzAKCQkKCQljb2xvcihzZWxm
LmZpbmZvLnNlbGVjdGVkIGFuZCAxIG9yIDcpCgkJcmVjdGZpbGwodzItd3cvMi01LHl5LTQsdzIr
d3cvMiszLHl5K2hoLTEpIAoJCXJlY3RmaWxsKHcyLXd3LzItNix5eS0zLHcyK3d3LzIrNCx5eSto
aC0yKQoJCQoJCQoJCXByaW50KHN0ciwgdzIgLSB3dyAvIDIsIHl5LCBzZWxmLmZpbmZvLnNlbGVj
dGVkIGFuZCA3IG9yIDEzKQoJCQoJCS0tIGZvciB0ZXN0X3BvaW50CgkJZWwubGFzdF9sYWJlbF9h
cmVhID0ge3cyLXd3LzItNSx5eS00LHcyK3d3LzIrMyx5eStoaC0xLHNwcngwLHNwcnkwfQoJCQoJ
CS0tIGZvciBkcmFnZ2luZyBmaWxlIGljb25zCgkJc2VsZi5maW5mby54ID0gc3ByeCArIHNlbGYu
c3gKCQlzZWxmLmZpbmZvLnkgPSBzcHJ5ICsgc2VsZi5zeSAKCQkKCWVuZAoJCglmdW5jdGlvbiBl
bDpjbGljaygpCgkJCgkJZWw6YnJpbmdfdG9fZnJvbnQoKQoJCQoJCWlmIChrZXkoImN0cmwiKSkg
dGhlbgoJCQlzZWxmLmZpbmZvLnNlbGVjdGVkID0gbm90IHNlbGYuZmluZm8uc2VsZWN0ZWQKCQll
bHNlCgkJCS0tIGlmIHdhc24ndCBhbHJlYWR5IHNlbGVjdGVkLCBkZXNlbGVjdCBldmVyeXRoaW5n
IGVsc2UKCQkJaWYgKG5vdCBzZWxmLmZpbmZvLnNlbGVjdGVkKSBkZXNlbGVjdF9hbGwoKSAgc2Vs
ID0gbmlsCgkJCS0tIC4uIGJ1dCBlaXRoZXIgd2F5LCB0aGlzIG9uZSBpcyBnb2luZyB0byBiZSBz
ZWxlY3RlZAoJCQlzZWxmLmZpbmZvLnNlbGVjdGVkID0gdHJ1ZQoJCWVuZAkKCQlyZXR1cm4gdHJ1
ZQoJZW5kCgkKCWZ1bmN0aW9uIGVsOmRvdWJsZWNsaWNrKCkKCQljbGlja19vbl9maWxlKHNlbGYu
ZmlsZW5hbWUpCgllbmQKCQoJcmV0dXJuIGVsCmVuZAoKCmZ1bmN0aW9uIGdlbmVyYXRlX2ZlbHNf
ZGVza3RvcCgpCglmaSA9IHt9CgkKCS0tIGxvYWQgaXRlbSBpbmZvIG9uIGZpcnN0IGdlbmVyYXRl
CglpZiAobm90IGRlc2t0b3BfaXRlbXMpIHRoZW4KCQlmZXRjaF9kZXNrdG9wX2l0ZW1zKCkKCWVu
ZAoJLS0gYXR0YWNoIHRvIGNvbnRlbnQgaW5jYXNlIHdhbnQgdG8gaGF2ZSBzY3JvbGxhYmxlIGRl
c2t0b3AgZmlsZXMgbGF0ZXIgKD8pCgktLSBzdGFydCBhdCAxMiB0byBtYWtlIHNwYWNlIGZvciB0
aXRsZWJhcgoKCWxvY2FsIHB1dF94ID0gLTIwCglsb2NhbCBwdXRfeSA9IDIwCgoJZm9yIGk9MSwj
ZmlsZW5hbWVzIGRvCgkKCQktLSBzdGFydCBhdCByYW5kb20gcG9zaXRpb24KCQlpZiAoZGVza3Rv
cF9pdGVtc1tmaWxlbmFtZXNbaV1dID09IG5pbCkgdGhlbgoKCQkJc2V0X2Rlc2t0b3BfaXRlbV9w
b3NpdGlvbihmaWxlbmFtZXNbaV0sIG5pbCwgbmlsKQoJCQkKCQkJLS0gdGVtcG9yYXJ5IGhhY2sg
Zm9yIGRlZmF1bHQgZGVza3RvcCBpdGVtcwoJCQlsb2NhbCBmbiA9IGZpbGVuYW1lc1tpXQoJCQlp
ZiAoZm46YmFzZW5hbWUoKSA9PSAiZHJpdmUubG9jIiBvciBmbjpiYXNlbmFtZSgpID09ICJyZWFk
bWUudHh0IikgCgkJCXRoZW4KCQkJCWRlc2t0b3BfaXRlbXNbZmlsZW5hbWVzW2ldXS54ID0gcHV0
X3gKCQkJCWRlc2t0b3BfaXRlbXNbZmlsZW5hbWVzW2ldXS55ID0gcHV0X3kJCQoJCQkJcHV0X3kg
Kz0gNTAKCQkJCWlmIChwdXRfeSA_IDIzMCkgcHV0X3kgPSAyMCBwdXRfeCArPSA2NAoJCQllbmQK
CQllbmQKCQkKCQlsb2NhbCBkZXNrdG9wX2l0ZW0gPSBkZXNrdG9wX2l0ZW1zW2ZpbGVuYW1lc1tp
XV0KCQlmaVtpXSA9IGNyZWF0ZV9maWxlX2l0ZW0oZ3VpLCBmaW5mb1tmaWxlbmFtZXNbaV1dLCAK
CQkJZGVza3RvcF9pdGVtLngsCgkJCWRlc2t0b3BfaXRlbS55KQoJZW5kCgkKCWRlc2t0b3BfY29u
dGVudC5jaGlsZCA9IHt9Cglmb3IgaT0xLCNmaSBkbwoJCWZpW2ldLmN1cnNvciA9ICJwb2ludGVy
IgoJCWRlc2t0b3BfY29udGVudDphdHRhY2goZmlbaV0pCgllbmQKCQplbmQKLS0gb25seSBjYWxs
ZWQgb25jZSBvbiBzdGFydHVwIC0tIGRvbid0IG5lZWQgdG8gYmUgYWRhcHRpdmUKZnVuY3Rpb24g
Z2VuZXJhdGVfaW50ZXJmYWNlX2Rlc2t0b3AoeTAsIGFkZF9oZWlnaHQpCgkKCWxvY2FsIGl0ZW1f
dyA9IDY4Cglsb2NhbCBpdGVtX2ggPSA0MgoJbG9jYWwgaXRlbXNfeCA9IGdldF9kaXNwbGF5KCk6
d2lkdGgoKSBcIGl0ZW1fdwoJCQoJbG9jYWwgY29udGFpbmVyID0gZ3VpOmF0dGFjaHsKCQl4PTAs
IHk9eTAsCgkJd2lkdGhfcmVsICA9IDEuMCwKCQloZWlnaHRfcmVsID0gMS4wLAoJCWhlaWdodF9h
ZGQgPSAteTAgKyBhZGRfaGVpZ2h0Cgl9CgktLSBhZGQgdG8gZ3VpOyB1c2UgcmVndWxhciB1bm9w
dGltaXNlZCBndWkgc2NoZW1lCgktLSAoY291bGQgYWRkIGJ1Y2tldHMgbGF0ZXIgb3IgYmFja3Bh
Z2UgY2FjaGluZywgYnV0IHByb2JhYmx5IHVubmVjZXNzYXJ5KQoJbG9jYWwgY29udGVudCA9IGNv
bnRhaW5lcjphdHRhY2h7CgkJeD0wLHk9MCx3aWR0aF9yZWw9MS4wLGhlaWdodF9yZWw9MS4wLAoJ
CWNsaXBfdG9fcGFyZW50ID0gdHJ1ZQoJfQoJCglkZXNrdG9wX2NvbnRlbnQgPSBjb250ZW50CgkK
CWxvY2FsIGZ1bmN0aW9uIGZpX2Zvcl94eSh4LCB5KQoJCS0tIGVhcmx5IHJlamVjdCBieSByZWFk
aW5nIGRyYXduIHN0YXRlCgkJaWYgKHBnZXQoeCx5KSA9PSAwKSByZXR1cm4KCQlsb2NhbCBlbCA9
IGd1aTplbF9hdF94eSh4LHkpCgkJaWYgKGVsIGFuZCBlbC50ZXN0X3BvaW50KSByZXR1cm4gZWwg
LS0gLnRlc3RfcG9pbnQgbWVhbnMgaXMgYSBmaWxlIGVsCgllbmQKCQoJZnVuY3Rpb24gY29udGVu
dDpjbGljayhtc2cpCgkJaWYgKG5vdCBrZXkiY3RybCIpIGRlc2VsZWN0X2FsbCgpCgkJc2VsID0g
e21zZy5teCwgbXNnLm15fQoJZW5kCgkKCS0tIGNvcHkgcGFzdGVkIGZyb20gZ3JpZC5sdWEKCS0t
IGZ1ZGdlZCBzdGVwIHNpemUgYmVjYXVzZSB0ZXN0X3BvaW50IGlzIHNsb3cgKHZpYSBndWk6ZWxf
YXRfeHkpCgktLSB0byBkbzogbW9yZSBzZW5zaWJsZSBjb2xsaXNpb24gY2FsY3VsYXRpb24KCWZ1
bmN0aW9uIGNvbnRlbnQ6ZHJhZyhtc2cpCgkJaWYgKHNlbCkgdGhlbgoJCQlpZiAoYWJzKG1zZy5t
eC1zZWxbMV0pID4gNCBvciBhYnMobXNnLm15LXNlbFsyXSkgPiA0KSB0aGVuCgkJCQlzZWxbM10s
c2VsWzRdID0gbXNnLm14LCBtc2cubXkgLS0gcmVsYXRpdmUgdG8gZ3VpIGVsZW1lbnQKCQkJCS0t
IHVwZGF0ZSBzZWxlY3Rpb24KCQkJCWlmIChub3Qga2V5ImN0cmwiKSBkZXNlbGVjdF9hbGwoKQoJ
CQkJbG9jYWwgeHgwID0gbWluKHNlbFsxXSxzZWxbM10pCgkJCQlsb2NhbCB4eDEgPSBtYXgoc2Vs
WzFdLHNlbFszXSkKCQkJCWxvY2FsIHl5MCA9IG1pbihzZWxbMl0sc2VsWzRdKQoJCQkJbG9jYWwg
eXkxID0gbWF4KHNlbFsyXSxzZWxbNF0pCgoJCQkJZm9yIGk9MSwgI2ZpIGRvCgkJCQkJbG9jYWwg
aXRlbSA9IGZpW2ldCgoJCQkJCWxvY2FsIHV1MCA9IG1pZCh4eDAsIGl0ZW0ueCwgeHgxKQoJCQkJ
CWxvY2FsIHZ2MCA9IG1pZCh5eTAsIGl0ZW0ueSwgeXkxKQoJCQkJCWxvY2FsIHV1MSA9IG1pZCh4
eDAsIHV1MCArIGl0ZW0ud2lkdGgsIHh4MSkKCQkJCQlsb2NhbCB2djEgPSBtaWQoeXkwLCB2djAg
KyBpdGVtLmhlaWdodCwgeXkxKQoJCQkJCQoJCQkJCWZvciB5ID0gdnYwLCB2djEsIDQgZG8KCQkJ
CQkJZm9yIHggPSB1dTAsIHV1MSwgNCBkbwoJCQkJCQkJaWYgKGl0ZW06dGVzdF9wb2ludCh4IC0g
aXRlbS54LCB5IC0gaXRlbS55KSkgaXRlbS5maW5mby5zZWxlY3RlZCA9IHRydWUKCQkJCQkJZW5k
CgkJCQkJZW5kCgoJCQkJZW5kCgoJCQllbHNlCgkJCQlzZWxbM10sc2VsWzRdID0gbmlsLG5pbAoJ
CQllbmQKCQkJCgkJZW5kCgllbmQKCQoJZnVuY3Rpb24gY29udGVudDpyZWxlYXNlKCkKCQlzZWwg
PSBuaWwKCWVuZAoJCgktLSBkcmF3biBmaXJzdCAtLSBtYXliZSBuZWVkIHNlcGFyYXRlIGxheWVy
IGluIGNvbnRhaW5lcgoJLS0gdG8gZHJhdyBzZWxlY3Rpb24KCQoJZnVuY3Rpb24gY29udGVudDpk
cmF3KCkKCQljbHMoKSAKCQlwb2tlKDB4NTQ3ZCwweGZmKSAtLSB3bSBkcmF3IG1hc2s7IGludGVy
YWN0IG1hc2sgaXMgc3RpbGwgMAoJZW5kCgkKLS1bWwoJZnVuY3Rpb24gY29udGVudDpkcmF3Migp
CgkJaWYgKHNlbCBhbmQgI3NlbCA9PSA0KSB0aGVuCgkJCQlyZWN0KHNlbFsxXSxzZWxbMl0sc2Vs
WzNdLHNlbFs0XSwgNykKCQkJCXJlY3Qoc2VsWzFdKzEsc2VsWzJdKzEsc2VsWzNdLTEsc2VsWzRd
LTEsIDEpCgkJCWVuZAoJZW5kCl1dCgktLSBkcmF3IHNlbGVjdGlvbiBvbiB0b3AKCWNvbnRhaW5l
cjphdHRhY2h7CgkJeD0wLHk9MCx3aWR0aF9yZWw9MS4wLGhlaWdodF9yZWw9MS4wLAoJCWdob3N0
ID0gdHJ1ZSwKCQlkcmF3ID0gZnVuY3Rpb24oKQoJCQktLWNsaXAoKQoJCQlpZiAoc2VsIGFuZCAj
c2VsID09IDQpIHRoZW4KCQkJCXJlY3Qoc2VsWzFdLHNlbFsyXSxzZWxbM10sc2VsWzRdLCA3KQoJ
CQkJcmVjdChzZWxbMV0rMSxzZWxbMl0rMSxzZWxbM10tMSxzZWxbNF0tMSwgMSkKCQkJZW5kCgkJ
ZW5kCgl9Cgl1cGRhdGVfZmlsZV9pbmZvKHRydWUpCmVuZAoKCjo6IGRyb3AubHVhCi0tW1twb2Rf
Zm9ybWF0PSJyYXciLGNyZWF0ZWQ9IjIwMjMtMTktMTEgMDk6MTk6MjAiLHJldmlzaW9uPTEwNyxz
dG9yZWQ9IjIwMjMtMjEtMjkgMDk6MjE6MTkiXV0KCgpvbl9ldmVudCgiZHJvcF9pdGVtcyIsZnVu
Y3Rpb24obXNnKQoKCS0tcHJpbnRoKCJAQCBkcm9wcGVkIGl0ZW1zIGZyb20gcHJvY19pZDoiLi5t
c2cuZnJvbV9wcm9jX2lkLi4iIC8vIG1vZGU6Ii4ubW9kZSkKCQoJLS0gZHJvcCBpbnRvIHNlbGYK
CWlmIChtc2cuZnJvbV9wcm9jX2lkID09IHBpZCgpKSB0aGVuCgkJaWYgKG1vZGUgPT0gImRlc2t0
b3AiKSB0aGVuCgkJCXNoaWZ0X3NlbGVjdGVkX2Rlc2t0b3BfaXRlbXMobXNnLmR4LCBtc2cuZHkp
CgkJZW5kCgkJcmV0dXJuCgllbmQKCQoJLS0gZHJvcCBmcm9tIHNvbWV3aGVyZSBlbHNlCgkKCS0t
cHJpbnRoKCJAQCBkcm9wIGZyb20gYSBkaWZmZXJlbnQgcHJvY2VzczoiLi5wb2QobXNnKSkKCQoJ
Zm9yIGk9MSwjbXNnLml0ZW1zIGRvCgkJbG9jYWwgaXRlbSA9IG1zZy5pdGVtc1tpXQoJCWlmIChp
dGVtLnBvZF90eXBlID09ICJmaWxlX3JlZmVyZW5jZSIpIHRoZW4KCgkJCS0tIE1PVkUKCQkJLS1w
cmludGgocG9kKGl0ZW0pKQoJCQktLSBwcmludGgoIkBAIG1vdmluZyAiLi50b3N0cmluZyhpdGVt
LmZ1bGxwYXRoKS4uIiB0byAiLi5wd2QoKSkKCQkJCgkJCS0tIHRvIGRvOiBkZWZpbmUgd2hpY2gg
YXR0cmlidXRlcyBhcmUgcmVxdWllZCBmb3IgYSB3ZWxsIGZvcm1lZCBmaWxlX3JlZmVyZW5jZSBp
dGVtCgkJCS0tIHNob3VsZG4ndCBldmVyIG5lZWQgLmZpbGVuYW1lCgkJCS0tIGF2b2lkIGludHJv
ZHVjaW5nIG9wdGlvbmFsIGF0dHJpYnV0ZXMgLyBoaW50cyAtLSBlYXN5IGZvciBhbm90aGVyIGF1
dGhvciB0byBleHBlY3QgdG8gZXhpc3Qgb24gcmVjZWl2aW5nIGVuZAoKCQkJLS0gYWxsb3dlZCB0
byBvdmVyd3JpdGUgZXhpc3RpbmcgZmlsZXMgaW4gdGhpcyBjYXNlCgkJCWxvY2FsIHJlcyA9IG12
KGl0ZW0uZnVsbHBhdGgsIHB3ZCgpLi4iLyIuLml0ZW0uZnVsbHBhdGg6YmFzZW5hbWUoKSkKCQkJ
CgkJCWlmIHJlcyB0aGVuCgkJCQlub3RpZnkoImVycm9yOiAiLi50b3N0cmluZyhyZXMpKQoJCQll
bHNlaWYgKG1vZGUgPT0gImRlc2t0b3AiKSB0aGVuCQoJCQkJc2V0X2Rlc2t0b3BfaXRlbV9wb3Np
dGlvbihpdGVtLmZ1bGxwYXRoOmJhc2VuYW1lKCksIG1zZy5teCwgbXNnLm15KQoJCQllbmQKCgkJ
ZW5kCgllbmQKCQplbmQpCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoK
CgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoK
CgoKCgoKCgoKCgoKCgoKCgoKCgo6OiBmaW5mby5sdWEKLS1bW3BvZF9mb3JtYXQ9InJhdyIsY3Jl
YXRlZD0iMjAyMy0xMC0wOCAwOToyNDo1MCIsbW9kaWZpZWQ9IjIwMjQtMDQtMTEgMjI6MjY6MTMi
LHJldmlzaW9uPTIxMDUsc3RvcmVkPSIyMDIzLTIxLTI5IDA5OjIxOjE5Il1dCi0tW1sKCWZpbmZv
Lmx1YQoJCgljb2xsZWN0aW9uIG9mIGZpbGUgaW5mbyB0YWJsZXMsIGluZGVwZW5kZW50IG9mIGd1
aQoJaW5kZXhlZCBieSBmaWxlbmFtZTsgZmVsIChmaWxlIGd1aSBlbGVtZW50cykgY2FuIHBvaW50
IGF0IHRoaXMKXV0KLS0gZ2xvYmFsCmZpbmZvID0ge30KZnVuY3Rpb24gZGVzZWxlY3RfYWxsKCkK
CWZvciBrLHYgaW4gcGFpcnMoZmluZm8pIGRvCgkJdi5zZWxlY3RlZCA9IGZhbHNlCgllbmQKCXVw
ZGF0ZV9maWxlX2luZm9fbWVudV9pdGVtKCkKZW5kCgotLSBtZWFucyAic3RhcnQgZHJhZ2dpbmci
CmZ1bmN0aW9uIGRyYWdfc2VsZWN0ZWRfZmlsZXMobXNnKQoJCgl1cGRhdGVfZmlsZV9pbmZvX21l
bnVfaXRlbSgpCgkKCS0tIHNraXAgaWYgYWxyZWFkeSBkcmFnZ2luZyBmaWxlcyBvciBoYXZlbid0
IG1vdmVkIGZhcgoJLS0gZW5vdWdoIGZyb20gaW5pdGlhbCBwb2ludAoJaWYgKGRyYWdnaW5nX2Zp
bGVzKSByZXR1cm4KCWlmIChhYnMobXNnLm14IC0gbXNnLm14MCkgPCAzIGFuZCBhYnMobXNnLm15
IC0gbXNnLm15MCkgPCAzKSByZXR1cm4KCQkKCQoJZHJhZ2dpbmdfZmlsZXMgPSB7fQotLQlwcmlu
dGgoImRyYWdnaW5nIHNlbGVjdGVkIGZpbGVzIikKCglmb3Igayx2IGluIHBhaXJzKGZpbmZvKSBk
bwoJCWlmICh2LnNlbGVjdGVkKSB0aGVuCgkJCXYuZnVsbHBhdGggPSBmdWxscGF0aCh2LmZpbGVu
YW1lKQoJCQlsb2NhbCBteCxteSA9IG1vdXNlKCkKCQkJLS0gMC4xLjBjOiBzZXQgb2Zmc2V0cyBo
ZXJlICh3bSBoYW5kbGVzIHRoaXMsIGJ1dCBtb3VzZSBtb3ZlZCBieSB0aGUgdGltZSBtZXNzYWdl
IGFycml2ZXMpCgkJCXYueG8gPSB2LnggLSBteAoJCQl2LnlvID0gdi55IC0gbXkKCQkJYWRkKGRy
YWdnaW5nX2ZpbGVzLCB2KQoJCQktLXByaW50aCgiYWRkZWQgIi4udi5mdWxscGF0aC4uc3RyaW5n
LmZvcm1hdCgiICVkICVkIix2Lngsdi55KSkKCQllbmQKCWVuZAoJCgktLSBzb3J0IGJ5IGRpc3Rh
bmNlIHRvIG1vdXNlIGN1cnNvcgoJbG9jYWwgbXgsIG15ID0gbW91c2UoKQoJLS1sb2NhbCB2ID0g
ZHJhZ2dpbmdfZmlsZXNbMV0KCS0tcHJpbnRoKCJteCwgbXk6ICIuLm14Li4iICIuLm15KQoJLS1w
cmludGgoImZ4LCBmeTogIi4udi54Li4iICIuLnYueSkKCQoJZm9yIGk9MSwjZHJhZ2dpbmdfZmls
ZXMgZG8KCQlsb2NhbCB2ID0gZHJhZ2dpbmdfZmlsZXNbaV0KCQl2LmRpc3QgPSAodi54IC0gbXgp
XjIgKyAodi55IC0gbXkpXjIKCWVuZAoKLS1bWwoJLS0gbWF5YmUgY2FuJ3Qgc3VwcG9ydCBzb3J0
IHdpdGggY3VycmVudCBjcHUgbW9kZWwgKGNyb3NzZXMgYyBib3VuZGFyeSkKCXRhYmxlLnNvcnQo
ZHJhZ2dpbmdfZmlsZXMsIGZ1bmN0aW9uKG0wLCBtMSkKCQlpZiAobTAuZGlzdCA9PSBtMS5kaXN0
KSByZXR1cm4gbTAuZmlsZW5hbWUgPCBtMS5maWxlbmFtZQoJCXJldHVybiBtMC5kaXN0IDwgbTEu
ZGlzdAoJZW5kKQpdXQoKCWxvY2FsIHRibCA9IGRyYWdnaW5nX2ZpbGVzCglmb3IgcGFzcz0xLCN0
YmwgZG8KCQlmb3IgaT0xLCN0YmwtMSBkbwoJCQlpZiAodGJsW2ldLmRpc3QgPT0gdGJsW2krMV0u
ZGlzdCBhbmQgdGJsW2ldLmZpbGVuYW1lID4gdGJsW2krMV0uZmlsZW5hbWUpIG9yCgkJCQl0Ymxb
aV0uZGlzdCA_IHRibFtpKzFdLmRpc3QKCQkJdGhlbgoJCQkJdGJsW2ldLHRibFtpKzFdID0gdGJs
W2krMV0sdGJsW2ldCgkJCWVuZAoJCWVuZAoJZW5kCgkKCWlmICgjZHJhZ2dpbmdfZmlsZXMgPiAw
KSB0aGVuCgkJLS0gc2VuZCBhIG1lc3NhZ2UgdG8gd2luZG93IG1hbmFnZXIKCQlzZW5kX21lc3Nh
Z2UoMyx7CgkJCWV2ZW50ID0gImRyYWdfaXRlbXMiLAoJCQlpdGVtcwkgPSBkcmFnZ2luZ19maWxl
cwoJCX0pCgllbHNlCgkJZHJhZ2dpbmdfZmlsZXMgPSBuaWwgLS0gY2FuY2VsOyBub3RoaW5nIHRv
IGRyYWcKCWVuZAoJCQplbmQKCgoKZnVuY3Rpb24gdXBkYXRlX2ZpbGVfaW5mbyhjbGVhcikKCi0t
CXByaW50aCgidXBkYXRlX2ZpbGVfaW5mby4uIikKCgktLSBmb3IgZGVidWdnaW5nOyBjbGVhciB3
aGVuIGludGVyZmFjZSBpcyByZWdlbmVyYXRlZAoJLS0gdXBkYXRlOiB1c2VkIHRvIHVwZGF0ZSBp
Y29ucyB2aWEgZmlsZW5hdl9yZWZyZXNoIGJyb2FkY2FzdGVkIG1lc3NhZ2UKCWlmIChjbGVhcikg
dGhlbgoJCWZpbmZvID0ge30KCQlsYXN0X2ZpbGVzX3BvZCA9IG5pbAoJZW5kCgkKCXVwZGF0ZV9m
aWxlX2luZm9fbWVudV9pdGVtKCkKCQoJLS0gZmV0Y2ggY3VycmVudCBsaXN0Cglsb2NhbCBmaWxl
cyA9IGxzKHB3ZCgpKQoJCgktLSBubyBjaGFuZ2U7IG5vIG5lZWQgdG8gdXBkYXRlCglpZiAocG9k
e21vZGUscHdkKCksZmlsZXN9ID09IGxhc3RfZmlsZXNfcG9kKSB0aGVuCgkJcmV0dXJuCgllbmQK
CQoJbGFzdF9maWxlc19wb2QgPSBwb2R7bW9kZSxwd2QoKSxmaWxlc30KCQoJZmlsZW5hbWVzID0g
e30KCgktLSBzZWFyY2ggZm9yIGFkZGVkIC9jaGFuZ2VkIGZpbGVzCglsb2NhbCBmb3VuZCA9IHt9
Cglmb3IgaT0xLCNmaWxlcyBkbwoJCgkJbG9jYWwgZmlsZW5hbWUgPSBmaWxlc1tpXQoJCWZvdW5k
W2ZpbGVuYW1lXSA9IHRydWUKCQlpZiAobm90IGZpbmZvW2ZpbGVuYW1lXSkgZmluZm9bZmlsZW5h
bWVdID0ge30KCQlsb2NhbCBmID0gZmluZm9bZmlsZW5hbWVdCgkJCgkJbG9jYWwgYXR0cmliLCBz
aXplLCBtb3VudF9kZXNjID0gZnN0YXQoZmlsZW5hbWUpCgkJCgkJLS0gdXBkYXRlIC8gY3JlYXRl
IGluZm8KCQlmLnBvZF90eXBlID0gImZpbGVfcmVmZXJlbmNlIiAtLSB1c2VkIGJ5IGRyYWdnaW5n
X2l0ZW1zCgkJZi5maWxlbmFtZSA9IGZpbGVuYW1lCgkJZi5mdWxscGF0aCA9IGZ1bGxwYXRoKGZp
bGVuYW1lKQoJCWYuc2VsZWN0ZWQgPSBmLnNlbGVjdGVkIG9yIGZhbHNlCgkJZi5hdHRyaWIgICA9
IGYuYXR0cmliIG9yIGF0dHJpYgoJCWYuc2l6ZSAgICAgPSBmLnNpemUgb3Igc2l6ZQoJCWYuaWNv
biAgICAgPSBnZXRfZmlsZV9pY29uKGZpbGVuYW1lKQoKCQlhZGQoZmlsZW5hbWVzLCBmLmZpbGVu
YW1lKQoJZW5kCgkKLS1bWwoJLS0gY2xlYXIgb3V0IG1pc3NpbmcgaXRlbXMKCWZvciBrLHYgaW4g
cGFpcnMoZmluZm8pIGRvCgkJaWYgKG5vdCBmb3VuZFtrXSkgZmluZm9ba10gPSBuaWwKCWVuZApd
XQoKLS1bWwoJLS0gc3RvcmUgYXMgc29ydGVkIGxpc3QgKGZpbGVzKQoJZmlsZW5hbWVzID0ge30K
CWZvciBrLHYgaW4gcGFpcnMoZmluZm8pIGRvCgkJYWRkKGZpbGVuYW1lcywgaykKCWVuZApdXQoK
CS0tdGFibGUuc29ydChmaWxlbmFtZXMpIC0tIGNvbW1lbnRlZDsgbWF5YmUgY2FuJ3Qgc3VwcG9y
dCB0YWJsZS5zb3J0IHdpdGggY3VycmVudCBjcHUgbW9kZWwgKGNyb3NzZXMgYyBib3VuZGFyeSkK
CgktLSB1cGRhdGU6IHNvcnQgYnkgbGlzdCBvcmRlcgotLVtbCglsb2NhbCB0YmwgPSBmaWxlbmFt
ZXMKCWZvciBwYXNzPTEsI3RibCBkbwoJCWZvciBpPTEsI3RibC0xIGRvCgkJCWlmIHRibFtpXSA_
IHRibFtpKzFdIHRoZW4KCQkJCXRibFtpXSx0YmxbaSsxXSA9IHRibFtpKzFdLHRibFtpXQoJCQll
bmQKCQllbmQKCWVuZApdXQoKCS0tIHVwZGF0ZSBndWkgZWxlbWVudHMKCWlmIChtb2RlID09ICJn
cmlkIikgZ2VuZXJhdGVfZmVsc19ncmlkKCkKCWlmIChtb2RlID09ICJsaXN0IikgZ2VuZXJhdGVf
ZmVsc19saXN0KCkKCWlmIChtb2RlID09ICJkZXNrdG9wIikgZ2VuZXJhdGVfZmVsc19kZXNrdG9w
KCkKCQoJLS1wcmludGgoIj09PT09PT09PSB1cGRhdGVkX2ZpbGVfaW5mbyA9PT09PT09PT0iKQoJ
LS1wcmludGgocG9kKGZpbmZvKSkKCmVuZAoKZnVuY3Rpb24gb3Blbl9zZWxlY3RlZF9maWxlX2lu
Zm8oKQoJZm9yIGssdiBpbiBwYWlycyhmaW5mbykgZG8KCQlpZiAodi5zZWxlY3RlZCkgdGhlbgoJ
CQljcmVhdGVfcHJvY2VzcygiL3N5c3RlbS9hcHBzL2Fib3V0LnA2NCIsIAoJCQl7CgkJCQlhcmd2
PXt2LmZ1bGxwYXRofSwKCQkJCXdpbmRvd19hdHRyaWJzID0ge3dvcmtzcGFjZSA9ICJjdXJyZW50
IiwgYXV0b2Nsb3NlPXRydWV9CgkJCX0pCgkJZW5kCgllbmQKZW5kCgpmdW5jdGlvbiB1cGRhdGVf
ZmlsZV9pbmZvX21lbnVfaXRlbSgpCgktLSB1cGRhdGUgbWVudSBpdGVtCglsb2NhbCB3aGljaCA9
IG5pbAoJZm9yIGssdiBpbiBwYWlycyhmaW5mbykgZG8KCQlpZiAodi5zZWxlY3RlZCkgd2hpY2gg
PSB2LmZ1bGxwYXRoCgllbmQKCQoJaWYgKHdoaWNoKSB0aGVuCgkJCgkJbWVudWl0ZW17CgkJCWlk
PSJmaWxlX2luZm8iLAkKCQkJbGFiZWwgPSAiXF46MWMzNjdmNzc3NzM2MWMwMCBGaWxlIEluZm8i
LAoJCQlzaG9ydGN1dCA9ICJDdHJsLUkiLAoJCQlhY3Rpb24gPSBmdW5jdGlvbigpCgkJCQljcmVh
dGVfcHJvY2VzcygiL3N5c3RlbS9hcHBzL2Fib3V0LnA2NCIsIAoJCQkJCXthcmd2PXt3aGljaH0s
IHdpbmRvd19hdHRyaWJzPXt3b3Jrc3BhY2UgPSAiY3VycmVudCIsIHNob3dfaW5fd29ya3NwYWNl
PXRydWUsIGF1dG9jbG9zZT10cnVlfX0pCQkJCQoJCQllbmQKCQl9CgoJCW1lbnVpdGVtewoJCQlp
ZD0iZGVsZXRlX2ZpbGUiLAkKCQkJbGFiZWwgPSAiXF46M2U3ZjVkNWQ3NzNlMmEwMCBEZWxldGUg
RmlsZSIsCgkJCWFjdGlvbiA9IGZ1bmN0aW9uKCkKCQkJCW1rZGlyKCIvcmFtL2NvbXBvc3QiKQoJ
CQkJbG9jYWwgcmVzID0gbXYod2hpY2gsICIvcmFtL2NvbXBvc3QvIi4ud2hpY2g6YmFzZW5hbWUo
KSkKCQkJCWlmIChyZXMpIHRoZW4KCQkJCQlub3RpZnkoImVycm9yOiAiLi50b3N0cmluZyhyZXMp
KQoJCQkJZWxzZQoJCQkJCW5vdGlmeSgibW92ZWQgdG8gIi4uIi9yYW0vY29tcG9zdC8iLi53aGlj
aDpiYXNlbmFtZSgpKQoJCQkJZW5kCgkJCWVuZAoJCX0KCQkKCQktLSByZW5hbWUgCgkJaWYgKG1v
ZGUgfj0gImRlc2t0b3AiKSB0aGVuCgkJCW1lbnVpdGVtewoJCQkJaWQ9InJlbmFtZSIsCgkJCQls
YWJlbCA9ICJcXjowZjE5MzkyMTIxM2YwMDE1IFJlbmFtZSAiLi4oZnN0YXQod2hpY2gpID09ICJm
b2xkZXIiIGFuZCAiRm9sZGVyIiBvciAiRmlsZSIpLAoJCQkJYWN0aW9uID0gZnVuY3Rpb24oKQoJ
CQkJCWludGVudGlvbl9maWxlbmFtZSA9IHdoaWNoIC0tIHRoZSBmaWxlbmFtZSB0aGF0IGNhdXNl
ZCBtZW51IGl0ZW0gdG8gYmUgYWRkZWQKCQkJCQlwdXNoX2ludGVudGlvbigicmVuYW1lIikKCQkJ
CWVuZAoJCQl9CgkJZW5kCgoJCS0tIG9wZW4gaW4gaG9zdAoJCWxvY2FsIGtpbmQsIHNpemUsIG9y
aWdpbiA9IGZzdGF0KHdoaWNoKQoKCQlpZiAobm90IG9yaWdpbiBvciBvcmlnaW46c3ViKDEsNSkg
PT0gImhvc3Q6IikgdGhlbgoJCQltZW51aXRlbXsKCQkJCWlkPSJvcGVuX2hvc3RfcGF0aCIsCQot
LQkJCQlsYWJlbCA9ICJcXjowMDMwNGY0MTQxNDE3ZjAwIFZpZXcgaW4gSG9zdCBPUyIsCgkJCQls
YWJlbCA9ICJcXjowYjFiM2IwMzNmM2YzZjAwIFZpZXcgaW4gSG9zdCBPUyIsCgoJCQkJYWN0aW9u
ID0gZnVuY3Rpb24oKQoJCQkJCXNlbmRfbWVzc2FnZSgyLCB7ZXZlbnQ9Im9wZW5faG9zdF9wYXRo
IiwgcGF0aCA9IHdoaWNoLCBfZGVsYXkgPSAwLjI1fSkgLS0gZGVsYXkgc28gdGhhdCBtb3VzZSBp
c24ndCBoZWxkIHdoaWxlIG5ldyB3aW5kb3cgaXMgb3BlbmluZwoJCQkJZW5kCgkJCX0KCQllbHNl
CgkJCS0tIHJlbW92ZQoJCQltZW51aXRlbXtpZD0ib3Blbl9ob3N0X3BhdGgifQoJCWVuZAoKCWVs
c2UKCQktLSBubyBpdGVtIHNlbGVjdGVkCgoJCS0tIGNsZWFyIGVudHJpZXMKCQltZW51aXRlbXtp
ZD0iZmlsZV9pbmZvIn0KCQltZW51aXRlbXtpZD0iZGVsZXRlX2ZpbGUifQoJCW1lbnVpdGVte2lk
PSJyZW5hbWUifQoKCQktLSBvcGVuIGhvc3QgZm9sZGVyCgoJCWxvY2FsIGtpbmQsIHNpemUsIG9y
aWdpbiA9IGZzdGF0KHB3ZCgpKQoKCQlpZiAobm90IG9yaWdpbikgdGhlbiAtLSBvciBvcmlnaW46
c3ViKDEsNSkgfj0gIi9yYW0vIikgdGhlbgoJCQltZW51aXRlbXsKCQkJCWlkPSJvcGVuX2hvc3Rf
cGF0aCIsCQoJCQkJbGFiZWwgPSAiXF46MDAzMDRmNDE0MTQxN2YwMCBPcGVuIEhvc3QgT1MgRm9s
ZGVyIiwKCQkJCWFjdGlvbiA9IGZ1bmN0aW9uKCkKCQkJCQlzZW5kX21lc3NhZ2UoMiwge2V2ZW50
PSJvcGVuX2hvc3RfcGF0aCIsIHBhdGggPSBwd2QoKSwgX2RlbGF5ID0gMC4yNX0pCgkJCQllbmQK
CQkJfQoJCWVsc2UKCQkJLS0gcmVtb3ZlCgkJCW1lbnVpdGVte2lkPSJvcGVuX2hvc3RfcGF0aCJ9
CgkJZW5kCgoJZW5kCgoKCQoKCgkKZW5kCgoKCgoKCjo6IGdyaWQubHVhCi0tW1twb2RfZm9ybWF0
PSJyYXciLGNyZWF0ZWQ9IjIwMjMtMTAtMjAgMDY6Mjc6NTkiLG1vZGlmaWVkPSIyMDI0LTA0LTEx
IDIyOjI2OjEzIixyZXZpc2lvbj0yMjQwLHN0b3JlZD0iMjAyMy0yMS0yOSAwOToyMToxOSJdXQot
LSBtb2RlOiBpY29ucyBvbiBhIGdyaWQgKGRlZmF1bHQgZm9sZGVyIHZpZXc7IGlzIGN1dGVzdCBm
b3IgPCB_MTAwIGZpbGVzKQpsb2NhbCBzZWwgPSBuaWwKbG9jYWwgZnVuY3Rpb24gY3JlYXRlX2Zp
bGVfaXRlbShwYXJlbnQsIGZmLCB4LCB5KQoJaWYgKG5vdCBmZiBvciBub3QgZmYuZmlsZW5hbWUp
IHJldHVybgoJbG9jYWwgZWwgPSB7CgkJeCA9IHgsIHkgPSB5LAoJCXdpZHRoPTY0LCBoZWlnaHQ9
NDYsCgkJZmluZm8gICAgPSAgZmYsCgkJZmlsZW5hbWUgPSBmZi5maWxlbmFtZSwKCQlwYXJlbnQg
PSBwYXJlbnQsCgl9CglmdW5jdGlvbiBlbDpkcmFnKG1zZykKCQlkcmFnX3NlbGVjdGVkX2ZpbGVz
KG1zZykKCWVuZAoJZnVuY3Rpb24gZWw6cmVsZWFzZShtc2cpCgkJZHJhZ2dpbmdfZmlsZXMgPSBu
aWwKCWVuZAoJCgkKCS0tIG5lZWQgdG8gdGVzdCBpbiBjdXN0b20gY2xpY2sgZXZlbnQgYmVsb3cK
CWZ1bmN0aW9uIGVsOnRlc3RfcG9pbnQoeCwgeSkKCQkKCQlsb2NhbCBsbCA9IGVsLmxhc3RfbGFi
ZWxfYXJlYQoJCWlmIChub3QgbGwpIHJldHVybiB0cnVlCgkJCgkJLS0gc3ByaXRlIHBpeGVsIGlz
IHNldCwgb3IgaW5zaWRlIGZpbGVuYW1lIGxhYmVsCgkJcmV0dXJuIGdldChzZWxmLmZpbmZvLmlj
b24sIHggLSBsbFs1XSwgeSAtIGxsWzZdKSA_IDAKCQkJb3IgbGwgYW5kIHggPj0gbGxbMV0gYW5k
IHkgPj0gbGxbMl0gYW5kIHggPD0gbGxbM10gYW5kIHkgPD0gbGxbNF0JCgllbmQKCQoJLS0gZHJh
dyBpY29uIG9uIGdyaWQKCWZ1bmN0aW9uIGVsOmRyYXcoKQoKCQljbGlwKCkKCQkKCQlsb2NhbCBz
cHJ4LCBzcHJ5ID0gc2VsZi53aWR0aC8yIC0gOCwgNgoJCWxvY2FsIHNwcngwLCBzcHJ5MCA9IHNw
cngsIHNwcnkKCQkKCQktLSBzaGFkb3c7IGhlbHBzIHdpdGggd2hpdGUgb3V0bGluZSBvbiB3aGl0
ZSAod2hlbiBpbnZlcnRlZCkKCQlwYWwoMSw2KSBwYWwoMTMsNikgcGFsKDcsNikKCQlpZiAoc2Vs
Zi5maW5mby5zZWxlY3RlZCkgdGhlbgoJCQkgLS0gcG9wIHVwIGFuZCBzaG93IHNoYWRvdy4gdGhh
dCB3b3JrcyEKCQkJIHNwcihzZWxmLmZpbmZvLmljb24sc3ByeCxzcHJ5KQoJCQkgc3ByeCArPSAy
CgkJCSBzcHJ5IC09IDEKCQllbmQKCQlwYWwoKQoJCQoJCS0tIG5vbmUgb2YgdGhlc2Ugc29sdmUg
dGhlIHdoaXRlLW9uLXdoaXRlIHByb2JsZW0gd2VsbDsKCQktLSB1c2UgcG9wLXVwIGZvciBub3cu
IGtpbmRhIGN1dGUgYW5kIHN1Z2dlc3RzIG1vYmlsaXR5CgkJLS1bWwoJCWlmIChzZWxmLmZpbmZv
LnNlbGVjdGVkKSB0aGVuCgkJCS0tIGludmVydCBvbmx5IGNvbDAsIGNvbDIuIG5lZWRzIHNoYWRv
d3Mgd2hlbiBvbiB3aGl0ZSAoZm9sZGVyKQoJCQktLXBhbCg3LDEpIHBhbCgxLDcpCgkJCQoJCQkt
LSByb3RhdGU-IG5haAoJCQktLXBhbCgxLDEzKSBwYWwoMTMsNykgcGFsKDcsMSkKCQkJCgkJCS0t
IHJlY3RhbmdsZTogdG9vIG11Y2gsIGJ1dCBraW5kYSBpbnRlcmVzdGluZwoJCQktLXJlY3RmaWxs
KDAsMixzZWxmLndpZHRoLTEsc2VsZi5oZWlnaHQtMyw2KQoJCWVuZAoJCV1dCgkJCgkJaWYgKG5v
dCBkcmFnZ2luZ19maWxlcyBvciBub3Qgc2VsZi5maW5mby5zZWxlY3RlZCkgdGhlbgoJCQlwYWwo
NywgdGhlbWUiaWNvbjAiKQoJCQlwYWwoNix0aGVtZSJpY29uMSIpCgkJCXBhbCgxMywgdGhlbWUi
aWNvbjIiKQoJCQlwYWwoMSwgdGhlbWUiaWNvbjMiKQoJCQkKCQkJc3ByKHNlbGYuZmluZm8uaWNv
bixzcHJ4LHNwcnkpCgkJZW5kCgkJCgkJcGFsKCkKCQkKCQktLWxvY2FsIHN0ciA9ICJcMDE0Ii4u
c2VsZi5maWxlbmFtZQoJCXBva2UoMHg1ZjM2LCAweDgwKSAtLSB0dXJuIG9uIHdyYXAgdG8gY2xp
cF9yaWdodAoJCQoJCWxvY2FsIHN0ciA9IHNlbGYuZmlsZW5hbWUKCQkKCQlsb2NhbCB3dyxoaCA9
IHByaW50KHN0ciwgMCwgLTEwMDAwMDApCgkJaGggKz0gMTAwMDAwMAoJCQoJCS0td3cgPSBtaW4o
d3csIHNlbGYud2lkdGgpIC0tIGRvbid0IGNsaXAgbGVmdCB0ZXh0LCBvbmx5IHJpZ2h0CgoJCWxv
Y2FsIGR4ID0gbWluKHd3LCBzZWxmLndpZHRoKSAvIDIKCgoJCWxvY2FsIHcyID0gc2VsZi53aWR0
aC8yCgkJbG9jYWwgeXkgPSAyOAoJCQoJCWNvbG9yKHNlbGYuZmluZm8uc2VsZWN0ZWQgYW5kIDEg
b3IgNykKCQlyZWN0ZmlsbCh3Mi1keC01LHl5LTQsdzItZHgrd3crMyx5eStoaC0xKSAKCQlyZWN0
ZmlsbCh3Mi1keC02LHl5LTMsdzItZHgrd3crNCx5eStoaC0yKQoJCQoJCXByaW50KHN0ciwgdzIg
LSBkeCwgeXksIHNlbGYuZmluZm8uc2VsZWN0ZWQgYW5kIDcgb3IgMTMpCgkJCgkJLS0gZm9yIHRl
c3RfcG9pbnQKCQlzZWxmLmxhc3RfbGFiZWxfYXJlYSA9IHt3Mi1keC01LHl5LTQsdzItZHgrd3cr
Myx5eStoaC0xLHNwcngwLHNwcnkwfQoJCQoJCS0tIGZvciBkcmFnZ2luZyBmaWxlIGljb25zOyBz
ZWxmLnN4LHN5IGlzbid0IHNldAoJCXNlbGYuZmluZm8ueCA9IHNwcnggKyBzZWxmLnggKyBzZWxm
LnBhcmVudC5zeAoJCXNlbGYuZmluZm8ueSA9IHNwcnkgKyBzZWxmLnkgKyBzZWxmLnBhcmVudC5z
eQoJCQkKCQkKCWVuZAoJCglmdW5jdGlvbiBlbDpjbGljaygpCgkJaWYgKGtleSgiY3RybCIpKSB0
aGVuCgkJCXNlbGYuZmluZm8uc2VsZWN0ZWQgPSBub3Qgc2VsZi5maW5mby5zZWxlY3RlZAoJCWVs
c2UKCQkJLS0gaWYgd2Fzbid0IGFscmVhZHkgc2VsZWN0ZWQsIGRlc2VsZWN0IGV2ZXJ5dGhpbmcg
ZWxzZQoJCQlpZiAobm90IHNlbGYuZmluZm8uc2VsZWN0ZWQpIHRoZW4gCgkJCQlkZXNlbGVjdF9h
bGwoKSAgc2VsID0gbmlsCgkJCQktLSBzZXQgZmlsZSBuYXZpZ2F0b3IgdGV4dAoJCQkJbmF2dGV4
dDpzZXRfdGV4dHtmdWxscGF0aChlbC5maWxlbmFtZSl9CgkJCWVuZAoJCQktLSAuLiBidXQgZWl0
aGVyIHdheSwgdGhpcyBvbmUgaXMgZ29pbmcgdG8gYmUgc2VsZWN0ZWQKCQkJc2VsZi5maW5mby5z
ZWxlY3RlZCA9IHRydWUKCQkJCgkJZW5kCQoJCQoJCWlmIGludGVudGlvbiA9PSAic2F2ZV9maWxl
X2FzIiB0aGVuCgkJCS0tIHNldCB0ZXh0CgkJCWludGVudGlvbl90ZXh0OnNldF90ZXh0KHtlbC5m
aWxlbmFtZX0pCgkJCW5hdnRleHQ6c2V0X3RleHR7IiJ9CgkJZW5kCgllbmQKCQoJZnVuY3Rpb24g
ZWw6ZG91YmxlY2xpY2soKQoJCWNsaWNrX29uX2ZpbGUoc2VsZi5maWxlbmFtZSkKCWVuZAoJCgly
ZXR1cm4gZWwKZW5kCmZ1bmN0aW9uIGdlbmVyYXRlX2ZlbHNfZ3JpZCgpCgktLSBoYW5kbGUgZmls
ZSBpdGVtcyBsYXllciBvZiBndWkgbWFudWFsbHkgc28gY2FuIG9wdGltaXNlCgktLSAoZS5nLiBv
bmx5IGRyYXcgLyB1cGRhdGUgdmlzaWJsZSBpdGVtcykKCQkKCWxvY2FsIHh4LHl5ID0gMCwwCgls
b2NhbCBpdGVtX3cgPSA2OAoJbG9jYWwgaXRlbV9oID0gNDYKCS0tIHRvIGRvOiBzaG91bGQgYmUg
cGFyZW50Cglsb2NhbCBpdGVtc194ID0gZ2V0X2Rpc3BsYXkoKTp3aWR0aCgpIFwgaXRlbV93CgkK
CWZpID0ge30KCQoJZm9yIGk9MSwjZmlsZW5hbWVzIGRvCgkJLS0gdG8gZG86IGF1dG8tc3RhZ2dl
ciBmb3IgbG9uZyBmaWxlIG5hbWVzPyArICh4eCYxKSoxNgoJCS0tYWRkKGZpLCBjcmVhdGVfZmls
ZV9pdGVtKGNvbnRlbnQsIGZpbmZvW2ZpbGVuYW1lc1tpXV0sIDIgKyB4eCppdGVtX3csIDIgKyB5
eSppdGVtX2ggKyAoeHgmMSkqMTYpKQoJCWFkZChmaSwgY3JlYXRlX2ZpbGVfaXRlbShjb250ZW50
LCBmaW5mb1tmaWxlbmFtZXNbaV1dLCAyICsgeHgqaXRlbV93LCAyICsgeXkqaXRlbV9oKSkKCQl4
eCs9MQoJCWlmICh4eCA_PSBpdGVtc194KSB4eD0wIHl5Kz0xCgllbmQKZW5kCgoKZnVuY3Rpb24g
Z2VuZXJhdGVfaW50ZXJmYWNlX2dyaWQoeTAsIGFkZF9oZWlnaHQpCgl1cGRhdGVfZmlsZV9pbmZv
KCkKLS0JcHJpbnRoKCJAQCBnZW5lcmF0aW5nIGdyaWQgaW50ZXJmYWNlIikKCWxvY2FsIHBvaW50
ZXJfZWwgPSBuaWwKCWxvY2FsIGl0ZW1fdyA9IDY4Cglsb2NhbCBpdGVtX2ggPSA0NgoJbG9jYWwg
aXRlbXNfeCA9IDMKCWxvY2FsIGxhc3RfaXRlbXNfeAoJCgktLSBhdHRyaWJ1dGUgaGVhZGVycwoJ
LS0gY2xpY2sgZm9yIHNvcnRpbmcgYnkgdGhhdCBhdHRyaWJ1dGUKCQoJLS0gbG9jYXRpb24gaXMg
aW4gd2luZG93IHRpdGxlIQoJbG9jYWwgY29udGFpbmVyID0gZ3VpOmF0dGFjaHsKCQl4PTAseT15
MCwKCQl3aWR0aF9yZWwgPSAxLjAsCgkJaGVpZ2h0X3JlbCA9IDEuMCwKCQloZWlnaHRfYWRkID0g
LXkwICsgYWRkX2hlaWdodCwKCQkKCQl1cGRhdGUgPSBmdW5jdGlvbihzZWxmKQoJCQktLSAgcmUt
Y2FsY3VsYXRlIGl0ZW0gcG9zaXRpb25zIG9uIGNoYW5nZQoJCQlpdGVtc194ID0gc2VsZi53aWR0
aCBcIGl0ZW1fdwoJCQlpZiAoaXRlbXNfeCB_PSBsYXN0X2l0ZW1zX3gpIHRoZW4KCQkJCWdlbmVy
YXRlX2ZlbHNfZ3JpZChmaW5mbykKCQkJCWxhc3RfaXRlbXNfeCA9IGl0ZW1zX3gKCQkJZW5kCgkJ
ZW5kLAoJCQoJCS0tIG5lZWRzIHRvIGV4aXN0IGZvciBjbGlwcGluZyAuXy4KCQlkcmF3ID0gZnVu
Y3Rpb24oc2VsZikKCQllbmQKCX0KCWNvbnRlbnQgPSBjb250YWluZXI6YXR0YWNoewoJCXg9MCx5
PTAsCgkJd2lkdGhfcmVsPTEuMCwKCQloZWlnaHQ9KCgjZmlsZW5hbWVzICsgaXRlbXNfeCAtIDEp
IFwgaXRlbXNfeCkgKiBpdGVtX2gsCgkJY2xpcF90b19wYXJlbnQgPSB0cnVlCgl9CgkKCWZ1bmN0
aW9uIGNvbnRlbnQ6Y2xhbXBfc2Nyb2xsaW5nKCkKCQlsb2NhbCBtYXhfeSA9IG1heCgwLCBjb250
ZW50LmhlaWdodCAtIGNvbnRhaW5lci5oZWlnaHQpCgkJY29udGVudC55ID0gbWlkKDAsIGNvbnRl
bnQueSwgLW1heF95KQoJCWNvbnRlbnQueCA9IG1pbigwLCBjb250ZW50LngpCgllbmQKCQoJbG9j
YWwgZnVuY3Rpb24gZmlfZm9yX3h5KHgsIHkpCgkJbG9jYWwgaXRlbV94ID0geCBcIGl0ZW1fdwoJ
CWxvY2FsIGl0ZW1feSA9IHkgXCBpdGVtX2gKCQlsb2NhbCBpbmRleCA9IDEgKyBpdGVtX3ggKyBp
dGVtX3kgKiBpdGVtc194CgkJcmV0dXJuIGZpW2ZscihpbmRleCldCgllbmQKCWZ1bmN0aW9uIGNv
bnRlbnQ6dXBkYXRlKCkKCQljb250ZW50OmNsYW1wX3Njcm9sbGluZygpCgkJCgkJLS0gdXBkYXRl
IHBvaW50ZXIgZWxlbWVudAoJCWxvY2FsIG14LG15LG1iID0gbW91c2UoKQoJCQoJCWlmIChzZWxm
LnN4KSBwb2ludGVyX2VsID0gZmlfZm9yX3h5KG14IC0gc2VsZi5zeCwgbXkgLSBzZWxmLnN5KQoJ
CQoJCS0tIHRlc3QgcG9pbnQKCQlpZiAocG9pbnRlcl9lbCBhbmQgcG9pbnRlcl9lbC5wYXJlbnQp
IHRoZW4KCQkKCQkJcG9pbnRlcl9lbC5zeCA9IHBvaW50ZXJfZWwueCArIHBvaW50ZXJfZWwucGFy
ZW50LnN4CgkJCXBvaW50ZXJfZWwuc3kgPSBwb2ludGVyX2VsLnkgKyBwb2ludGVyX2VsLnBhcmVu
dC5zeQoJCQkKCQkJCgkJCXBvaW50ZXJfZWwgPSBwb2ludGVyX2VsOnRlc3RfcG9pbnQobXggLSBw
b2ludGVyX2VsLnN4LCBteSAtIHBvaW50ZXJfZWwuc3kpCgkJCQlhbmQgcG9pbnRlcl9lbCBvciBu
aWwKCQllbmQKCgkJLS0gdG8gZG86IGJldHRlciB3YXkgdG8gaGFuZGxlIHRoaXM-CgkJaWYgKHBv
aW50ZXJfZWwpIHRoZW4KCQkJd2luZG93e2N1cnNvciA9ICJwb2ludGVyIn0KCQllbHNlCgkJCXdp
bmRvd3tjdXJzb3IgPSAxfQoJCWVuZAoJCQoJCXNlbGYuaGVpZ2h0PSgoI2ZpbGVuYW1lcyArIGl0
ZW1zX3ggLSAxKSBcIGl0ZW1zX3gpICogaXRlbV9oCgkJc2VsZi5oZWlnaHQ9bWF4KHNlbGYuaGVp
Z2h0LCBzZWxmLnBhcmVudC5oZWlnaHQpIC0tIGFsbG93IHNlbGVjdCBmcm9tIGRlYWQgc3BhY2UK
CWVuZAoJLS0gCgkJCglmdW5jdGlvbiBjb250ZW50OmRyYXcoKQoJCgkJaWYgKCNmaSA9PSAwKSBy
ZXR1cm4KCQoJCS0tbG9jYWwgbWluaSA9IG1pZCgxLCAoLWNvbnRlbnQueSAgICAgICAgICAgICAg
ICAgICApIFwgaXRlbV9oICsgMSwgI2ZpKQoJCS0tbG9jYWwgbWF4aSA9IG1pZCgxLCAoLWNvbnRl
bnQueSArIGNvbnRhaW5lci5oZWlnaHQpIFwgaXRlbV9oICsgMSwgI2ZpKQoJCQoJCS0tIHRvIGRv
OiBjYWxjdWxhdGUKCQlsb2NhbCBtaW5pID0gMQoJCWxvY2FsIG1heGkgPSAjZmkKCQkKCQlmb3Ig
aT1taW5pLG1heGkgZG8KCQkJCgkJCWxvY2FsIGZmID0gZmlbaV0KCQkJbG9jYWwgc3ggPSBmZi54
ICsgY29udGVudC54IFwgMSArIGNvbnRhaW5lci54IAoJCQlsb2NhbCBzeSA9IGZmLnkgKyBjb250
ZW50LnkgXCAxICsgY29udGFpbmVyLnkgCgkJCgkJCWNhbWVyYSgtc3gsIC1zeSkKCQkJCgkJCS0t
IGNsaXBwaW5nIGhhY2s6IGRvbid0IGRyYXcgb3ZlciB0b29sYmFyIGF0IHRvcAoJCQktLWNsaXAo
c3gsIG1heChzeSwgY29udGFpbmVyLnkpLCBmZi53aWR0aCwgZmYuaGVpZ2h0KQoJCQlmZjpkcmF3
KCkKCQllbmQKCQkKCQktLWNsaXAoKQoJCQoJCS0tIGRyYXcgc2VsZWN0aW9uCgkJY2FtZXJhKC1z
ZWxmLnN4LCAtc2VsZi5zeSkKCQkKCQlpZiAoc2VsIGFuZCAjc2VsID09IDQpIHRoZW4KCQkJcmVj
dChzZWxbMV0sc2VsWzJdLHNlbFszXSxzZWxbNF0sIDcpCgkJCXJlY3Qoc2VsWzFdKzEsc2VsWzJd
KzEsc2VsWzNdLTEsc2VsWzRdLTEsIDEpCgkJZW5kCgkJCgllbmQKCQoJLS0gZm9yd2FyZCBtZXNz
YWdlcwoJLS0gdG8gZG86IGFsbG93IHN1YnNjcmliZV90b19ldmVudHMgYXQgZ3VpIGVsZW1lbnQg
bGV2ZWw-CgkKCWZ1bmN0aW9uIGNvbnRlbnQ6Y2xpY2sobXNnKQoJCWlmIChwb2ludGVyX2VsKSB0
aGVuCgkJCXBvaW50ZXJfZWw6Y2xpY2sobXNnKQoJCWVsc2UKCQkJaWYgKG5vdCBrZXkiY3RybCIp
IGRlc2VsZWN0X2FsbCgpCgkJCXNlbCA9IHttc2cubXgsIG1zZy5teX0gLS0gcmVsYXRpdmUgdG8g
Z3VpIGVsZW1lbnQKCQllbmQKCWVuZAoKCWZ1bmN0aW9uIGNvbnRlbnQ6ZHJhZyhtc2cpCgkKCQkt
LSBkcmFnZ2luZyBhIGZpbGUKCQlpZiAocG9pbnRlcl9lbCBhbmQgcG9pbnRlcl9lbC5maW5mbyBh
bmQgcG9pbnRlcl9lbC5kcmFnIGFuZAoJCQlub3Qgc2VsKSB0aGVuCgkJCXBvaW50ZXJfZWw6ZHJh
Zyhtc2cpCgkJZW5kCgkJCgkJaWYgKHNlbCkgdGhlbgoJCQlpZiAoYWJzKG1zZy5teC1zZWxbMV0p
ID4gMiBvciBhYnMobXNnLm15LXNlbFsyXSkgPiAyKSB0aGVuCgkJCQlzZWxbM10sc2VsWzRdID0g
bXNnLm14LCBtc2cubXkgLS0gcmVsYXRpdmUgdG8gZ3VpIGVsZW1lbnQKCQkJCS0tIHVwZGF0ZSBz
ZWxlY3Rpb24KCQkJCWlmIChub3Qga2V5ImN0cmwiKSBkZXNlbGVjdF9hbGwoKQoJCQkJbG9jYWwg
eHgwID0gbWluKHNlbFsxXSxzZWxbM10pCgkJCQlsb2NhbCB4eDEgPSBtYXgoc2VsWzFdLHNlbFsz
XSkKCQkJCWxvY2FsIHl5MCA9IG1pbihzZWxbMl0sc2VsWzRdKQoJCQkJbG9jYWwgeXkxID0gbWF4
KHNlbFsyXSxzZWxbNF0pCgoJCQkJLS0gdG8gZG86IG9ubHkgbmVlZCB0byB0ZXN0IHRoZSB2aXNp
YmxlIG9uZXMKCQkJCWZvciBpPTEsICNmaSBkbwoJCQkJCWxvY2FsIGl0ZW0gPSBmaVtpXQoKCQkJ
CQlsb2NhbCB1dTAgPSBtaWQoeHgwLCBpdGVtLngsIHh4MSkKCQkJCQlsb2NhbCB2djAgPSBtaWQo
eXkwLCBpdGVtLnksIHl5MSkKCQkJCQlsb2NhbCB1dTEgPSBtaWQoeHgwLCB1dTAgKyBpdGVtLndp
ZHRoLCB4eDEpCgkJCQkJbG9jYWwgdnYxID0gbWlkKHl5MCwgdnYwICsgaXRlbS5oZWlnaHQsIHl5
MSkKCQkJCQkKCQkJCQlmb3IgeSA9IHZ2MCwgdnYxLTEsIDQgZG8KCQkJCQkJZm9yIHggPSB1dTAs
IHV1MS0xLCA0IGRvCgkJCQkJCQlpZiAoaXRlbTp0ZXN0X3BvaW50KHggLSBpdGVtLngsIHkgLSBp
dGVtLnkpKSBpdGVtLmZpbmZvLnNlbGVjdGVkID0gdHJ1ZQoJCQkJCQllbmQKCQkJCQllbmQKCQkJ
CWVuZAoKCQkJZWxzZQoJCQkJc2VsWzNdLHNlbFs0XSA9IG5pbCxuaWwKCQkJZW5kCgkJCQoJCWVu
ZAoJZW5kCgkKCWZ1bmN0aW9uIGNvbnRlbnQ6cmVsZWFzZSgpCgkJc2VsID0gbmlsCgkJZHJhZ2dp
bmdfZmlsZXMgPSBuaWwgLS0gdG8gZG86IGRyb3AKCWVuZAoJCgkKCWZ1bmN0aW9uIGNvbnRlbnQ6
ZG91YmxlY2xpY2soLi4uKQoJCWlmIChwb2ludGVyX2VsKSBwb2ludGVyX2VsOmRvdWJsZWNsaWNr
KC4uLikKCWVuZAoJCgkKCQoJdXBkYXRlX2ZpbGVfaW5mbyh0cnVlKQoJY29udGFpbmVyOmF0dGFj
aF9zY3JvbGxiYXJze2F1dG9oaWRlPXRydWV9CgkKZW5kCgoKCjo6IGljb24ubHVhCi0tW1twb2Rf
Zm9ybWF0PSJyYXciLGNyZWF0ZWQ9IjIwMjMtNDAtMDUgMDc6NDA6NDIiLG1vZGlmaWVkPSIyMDIz
LTAxLTExIDEwOjAxOjAzIixyZXZpc2lvbj02MTIsc3RvcmVkPSIyMDIzLTU5LTA3IDA3OjU5OjQ0
Il1dCi0tW1sKCWljb24ubHVhCgkKCWdldCBhbiBpY29uIGZvciBhIGZpbGUgYnkgdHlwZSAvIG1l
dGFkYXRhCglnZXRfZmlsZV9pY29uKGZpbGVuYW1lKQpdXQpsb2NhbCBpbmRleF9mb3JfdHlwZSA9
IHsKCWx1YSA9IDgsCglnZnggPSA5LAoJbWFwID0gMTAsCglzZnggPSAxMSwKCXBvcyA9IDEyLAoJ
dHh0ID0gMTMsCglwNjQgPSAxNiwKCVsicDY0LnBuZyJdID0gMTYsCglbInA2NC5yb20iXSA9IDE2
LAoJbG9jID0gMywKCXBvZCA9IDEyCgkKfQoKCmZ1bmN0aW9uIGdldF9maWxlX2ljb24oZmlsZW5h
bWUpCgoJLS0gbG9vayBmb3IgaWNvbiBpbiBtZXRhZGF0YQoJbG9jYWwgbWQgPSBmZXRjaF9tZXRh
ZGF0YShmaWxlbmFtZSkKCWlmIChtZCBhbmQgbWQuaWNvbiBhbmQgbWQuaWNvbjp3aWR0aCgpID09
IDE2KSB0aGVuCgkJcmV0dXJuIG1kLmljb24KCWVuZAoJCglsb2NhbCBleHQgPSBmaWxlbmFtZTpl
eHQoKQoJCgktLSBmb2xkZXIgc3ByaXRlIGlmIGEgZm9sZGVyIChidXQgLnA2NCBkb2Vzbid0IGNv
dW50KQoKCWxvY2FsIGtpbmQsc2l6ZSxvcmlnaW4gPSBmc3RhdChmaWxlbmFtZSkKCWlmIChleHQg
fj0gInA2NCIgYW5kIGV4dCB_PSAicDY0LnJvbSIgYW5kIGV4dCB_PSAicDY0LnBuZyIgYW5kIGtp
bmQgPT0gImZvbGRlciIpCgl0aGVuCgkJaWYgKG9yaWdpbiBhbmQgb3JpZ2luOnN1YigxLDUpID09
ICJob3N0OiIpIHJldHVybiBnZXRfc3ByKDQpCgkJcmV0dXJuIGdldF9zcHIoMikKCWVuZAoJCgly
ZXR1cm4gZ2V0X3NwcihpbmRleF9mb3JfdHlwZVtleHRdIG9yIDEpCgkKZW5kCgoKCgoKCgoKCgoK
CgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoK
CgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgo6OiBpbnRl
bnRpb24ubHVhCi0tW1twb2RfZm9ybWF0PSJyYXciLGNyZWF0ZWQ9IjIwMjMtMTAtMDUgMjE6NDk6
NTEiLG1vZGlmaWVkPSIyMDI0LTA0LTExIDIyOjI2OjEzIixyZXZpc2lvbj02MDhdXQotLVtbCgoJ
aW50ZW50aW9uLmx1YQoJCglvcGVuIGZpbGVuYXYgd2l0aCBpbnRlbnRpb24gdG8gcGVyZm9ybSBz
b21lIG9wZXJhdGlvbgoJLT4gY2hhbmdlcyBzZW1hbnRpY3Mgb2YgZG91YmxlIGNsaWNrLCBhbmQg
YWRkcyBpbnRlbnRpb24gcGFuZWwgYXQgYm90dG9tCgkJZS5nLjogU2F2ZSBBcyAuLiAgIFtTYXZl
XQoJCgl1cGRhdGU6IHJldXNlIGZvciB0YXNrcyB0aGF0IG5ldmVyIGxlYXZlIGZpbGVuYXYgKG5l
dyBmb2xkZXIpCl1dCgotLWludGVudGlvbiA9ICJvcGVuIiAtLSBkZWJ1Z2dpbmcKCmxvY2FsIGlu
dGVudGlvbl9zdGFjayA9IHt9CgpmdW5jdGlvbiBwdXNoX2ludGVudGlvbihwMCxwMSkKCS0tcHJp
bnRoKCJwdXNoaW5nIGludGVudGlvbjoiLi5wb2R7cDAscDF9KQoJYWRkKGludGVudGlvbl9zdGFj
aywKCQl7CgkJCWludGVudGlvbiwKCQkJaW50ZW50aW9uX3JlcXVlc3Rlcl9wcm9jX2lkCgkJfQoJ
KQoJaW5pdF9pbnRlbnRpb24ocDAsIHAxKQoJcmVmcmVzaF9ndWkgPSB0cnVlCmVuZAoKZnVuY3Rp
b24gcG9wX2ludGVudGlvbigpCglsb2NhbCBpdGVtPWRlbGkoaW50ZW50aW9uX3N0YWNrKSBvciB7
fQoJaW5pdF9pbnRlbnRpb24oaXRlbVsxXSwgaXRlbVsyXSkKCXJlZnJlc2hfZ3VpID0gdHJ1ZQoJ
CglyZXR1cm4gaXRlbSAtLSBuZXZlciB1c2VkCmVuZAoKCmZ1bmN0aW9uIGluaXRfaW50ZW50aW9u
KHAwLCBwMSkKCgktLSBjYW4gYmUgbmlsbCAoZS5nLiBwb3AgbGFzdCBpbnRlbnRpb24gb2ZmIHN0
YWNrIHRvIHJlbW92ZSBpbnRlbnRpb24gcGFuZWwpCglpbnRlbnRpb24gPSBwMAoJaW50ZW50aW9u
X3JlcXVlc3Rlcl9wcm9jX2lkID0gcDEKCQoJaW50ZW50aW9uX2RhdCA9IHsKCQlzYXZlX2ZpbGVf
YXMgPSB7IlNhdmUgQXMiLCAiU2F2ZSJ9LCAtLSAiU2F2ZSBGaWxlIEFzIiBkb2Vzbid0IGZpdAoJ
CW9wZW5fZmlsZSAgICA9IHsiT3BlbiBGaWxlIiwgIk9wZW4ifSwKCQluZXdfZmlsZSAgICAgPSB7
Ik5ldyBGaWxlIiwgIkNyZWF0ZSJ9LAoJCW5ld19mb2xkZXIgICA9IHsiTmV3IEZvbGRlciIsICJt
a2RpciJ9LAoJCW5ld190YWIgICAgICA9IHsiTmV3IEZpbGUiLCAiQ3JlYXRlIiwgIk5ldyBUYWIi
fSwgLS0gY2FuIGVpdGhlciBvcGVuIGEgZmlsZSwgb3IgY3JlYXRlIGEgZmlsZSAgLS0_ICB3aW5k
b3cgdGl0bGUgaXMgIk5ldyBUYWIiCgkJcmVuYW1lICAgICAgID0geyJSZW5hbWUiLCAiUmVuYW1l
In0gLS0gY291bGQgYmUgZmlsZSBvciBmb2xkZXIKCX0KCglpZiBpbnRlbnRpb24gYW5kIGludGVu
dGlvbl9kYXRbaW50ZW50aW9uXSB0aGVuCgkJaW50ZW50aW9uX3RpdGxlICA9IGludGVudGlvbl9k
YXRbaW50ZW50aW9uXVsxXSAtLSB3aW5kb3cgdGl0bGUKCQlpbnRlbnRpb25fYWN0aW9uID0gaW50
ZW50aW9uX2RhdFtpbnRlbnRpb25dWzJdIC0tIGJ1dHRvbiBvbiByaWdodAoJCWludGVudGlvbl93
aW5kb3dfdGl0bGUgPSBpbnRlbnRpb25fZGF0W2ludGVudGlvbl1bM10gb3IgaW50ZW50aW9uX3Rp
dGxlCgllbmQKZW5kCgpmdW5jdGlvbiBnZW5lcmF0ZV9pbnRlbnRpb25fcGFuZWwoKQoKCWxvY2Fs
IHBhbmVsID0gZ3VpOmF0dGFjaHsKCQl4ID0gMCwgeSA9IDAsIHZqdXN0aWZ5ID0gImJvdHRvbSIs
CgkJd2lkdGhfcmVsID0gMS4wLAoJCWhlaWdodCA9IDE5LAoJfQoKCWZ1bmN0aW9uIHBhbmVsOmRy
YXcoKQoJCXJlY3RmaWxsKDAsMCxzZWxmLndpZHRoLTEsc2VsZi5oZWlnaHQtMSw2KQoJCXByaW50
KGludGVudGlvbl90aXRsZS4uIjoiLDYsNiwxMykKCWVuZAoJCglsb2NhbCB3d2EgPSA4MAoJbG9j
YWwgeHggPSAtNgoJCglpZiAoI2ludGVudGlvbl9zdGFjayA_IDEpIHRoZW4KIAkJbG9jYWwgZWwg
PSBwYW5lbDphdHRhY2hfYnV0dG9uewoJCQl4ID0geHgsIGp1c3RpZnkgPSAicmlnaHQiLCB5ID0g
MywKCQkJbGFiZWwgPSAiQ2FuY2VsIiwKCQkJYmdjb2wgPSAweDA3MDcsCgkJCWZnY29sID0gMHgw
ZTAxLAoJCQl0YXAgPSBmdW5jdGlvbigpCgkJCQlwb3BfaW50ZW50aW9uKCkKCQkJZW5kCgkJfQoJ
CXh4IC09IGVsLndpZHRoCgkJeHggLT0gNAoJCXd3YSArPSBlbC53aWR0aCs0CgllbmQKCQoJbG9j
YWwgYnRuMSA9IHBhbmVsOmF0dGFjaF9idXR0b257CgkJeCA9IHh4LCBqdXN0aWZ5ID0gInJpZ2h0
IiwgeSA9IDMsCgkJbGFiZWwgPSBpbnRlbnRpb25fYWN0aW9uLAoJCWJnY29sID0gMHgwNzA3LAoJ
CWZnY29sID0gMHgwZTAxLAoJCXRhcCA9IHByb2Nlc3NfaW50ZW50aW9uCgl9CgkKCXd3YSArPSBi
dG4xLndpZHRoCgkKCWludGVudGlvbl90ZXh0ID0gcGFuZWw6YXR0YWNoX3RleHRfZWRpdG9yewoJ
CXg9NjQseT00LAoJCXdpZHRoPTEwMCwKCQl3aWR0aF9yZWwgPSAxLjAsCgkJd2lkdGhfYWRkID0g
LSB3d2EsCgkJaGVpZ2h0PTEyLAoJCW1heF9saW5lcyA9IDEsCQoJCWtleV9jYWxsYmFjayA9IHsg
CgkJCWVudGVyID0gcHJvY2Vzc19pbnRlbnRpb24gLS0gc2FtZSBhcyBjbGlja2luZyBvbiB0aGUg
YnV0dG9uIG5leHQgdG8gaXQKCQl9Cgl9CgkKCWludGVudGlvbl90ZXh0OnNldF9rZXlib2FyZF9m
b2N1cyh0cnVlKQoKCS0taW50ZW50aW9uX3RleHQ6c2V0X3RleHR7cGF0aH0KCS0taW50ZW50aW9u
X3RleHQ6Y2xpY2soe214PTEwMDAsbXk9Mn0pCgkKZW5kCgoKZnVuY3Rpb24gcHJvY2Vzc19pbnRl
bnRpb24oKQoKCWlmIChub3QgaW50ZW50aW9uX3RleHQpIHJldHVybgoKCWxvY2FsIGZpbGVuYW1l
ID0gZnVsbHBhdGgoaW50ZW50aW9uX3RleHQ6Z2V0X3RleHQoKVsxXSkKCglpZiAobm90IGZpbGVu
YW1lKSB0aGVuCgkJbm90aWZ5KCJjb3VsZCBub3QgcmVzb2x2ZTsgZmlsZW5hbWVzIG11c3QgY29u
dGFpbiBvbmx5IGEuLnosMC4uOSxfLS4iKQoJCXJldHVybgoJZW5kCgkKCS0tIHByaW50aCgicHJv
Y2VzcyBpbnRlbnRpb246ICIuLnBvZHtpbnRlbnRpb24sZmlsZW5hbWV9KQoJCgktLSBzYWZldHk6
IGNhbid0IG9wZXJhdGUgb24gYSBmb2xkZXIKCS0tW1sKCWlmIChmc3RhdChmaWxlbmFtZSkgPT0g
ImZvbGRlciIpIHRoZW4KCQlub3RpZnkoImNvdWxkIG5vdCBwcm9jZXNzOiAiLi5pbnRlbnRpb24p
CgkJcmV0dXJuCgllbmQKCV1dCgkKCS0tIG5ld19maWxlIGlzIHByb2Nlc3NlZCBieSBvcGVuLmx1
YQoJLS0gKiogbmV2ZXIgcHJvY2Vzc2VkIGJ5IHJlcXVlc3RlciAqKgoJaWYgKGludGVudGlvbiA9
PSAibmV3X2ZpbGUiIG9yIGludGVudGlvbiA9PSAibmV3X3RhYiIpIHRoZW4KCQlpZiAobm90IGZp
bGVuYW1lOmV4dCgpIGFuZCBlbnYoKS51c2VfZXh0KSBmaWxlbmFtZS4uPSIuIi4uZW52KCkudXNl
X2V4dAoJCWNyZWF0ZV9wcm9jZXNzKGVudigpLm9wZW5fd2l0aCBhbmQgZW52KCkub3Blbl93aXRo
IG9yICIvc3lzdGVtL3V0aWwvb3Blbi5sdWEiLAoJCQl7IGFyZ3YgPSB7ZmlsZW5hbWV9IH0pCgkJ
cG9wX2ludGVudGlvbigpCgkJcmV0dXJuCgllbmQKCQoJLS0gbmV3X2ZvbGRlciBhbHdheXMgaW50
ZXJuYWwKCWlmIChpbnRlbnRpb24gPT0gIm5ld19mb2xkZXIiKSB0aGVuCgkJbWtkaXIoZmlsZW5h
bWUpCgkJcG9wX2ludGVudGlvbigpCgkJcmV0dXJuCgllbmQKCQoJaWYgKGludGVudGlvbiA9PSAi
cmVuYW1lIikgdGhlbgoJCS0tIHByaW50aCgicmVuYW1lOiAiLi5pbnRlbnRpb25fZmlsZW5hbWUu
LiIgdG86ICIuLmZpbGVuYW1lKQoJCWlmIChmc3RhdChmaWxlbmFtZSkpIHRoZW4KCQkJbm90aWZ5
KCJjYW4gbm90IHJlbmFtZSB0byBhbiBleGlzdGluZyBmaWxlIikKCQllbHNlCgkJCWxvY2FsIHJl
cyA9IG12KGludGVudGlvbl9maWxlbmFtZSwgZmlsZW5hbWUpCgkJCWlmIChyZXMpIG5vdGlmeSgi
ZXJyb3I6ICIuLnJlcykKCQllbmQKCgkJcG9wX2ludGVudGlvbigpCgkJcmV0dXJuCgllbmQKCQoJ
LS0gaW50ZW50aW9uIGNhbWUgZnJvbSBleHRlcm5hbCByZXF1ZXN0ZXIKCS0tIGUuZy4gc2F2ZSwg
c2F2ZSBhcwoJaWYgKGludGVudGlvbl9yZXF1ZXN0ZXJfcHJvY19pZCkgdGhlbgoJCS0tIHByaW50
aCgic2VuZGluZyBpbnRlbnRpb24gdG86ICIuLmludGVudGlvbl9yZXF1ZXN0ZXJfcHJvY19pZCkK
CQlzZW5kX21lc3NhZ2UoaW50ZW50aW9uX3JlcXVlc3Rlcl9wcm9jX2lkLCAtLSBlbnYoKS5wYXJl
bnRfcGlkLCAKCQkJe2V2ZW50PWludGVudGlvbiwgZmlsZW5hbWU9ZmlsZW5hbWV9KQoJCWV4aXQo
KQoJCXJldHVybgoJZW5kCQoKZW5kCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoK
CgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgo6OiBpbnRl
cmYubHVhCi0tW1twb2RfZm9ybWF0PSJyYXciLGNyZWF0ZWQ9IjIwMjMtMTEtMjAgMDg6MTE6Mzki
LG1vZGlmaWVkPSIyMDI0LTA0LTExIDIyOjI2OjEzIixyZXZpc2lvbj0yOTE1LHN0b3JlZD0iMjAy
My0yMS0yOSAwOToyMToxOSJdXQotLSBpbnRlcmZhY2UKCi0tIHNob3J0Y3V0Ci0tIGRvbid0IG5l
ZWQgZGVza3RvcCAoanVzdCB1c2UgZGVza3RvcCEpIG9yIGZhdm91cml0ZXMgKHRvbyBtYW55IGNv
bmNlcHRzKQpzaG9ydGN1dHMgPQp7CgktLSAiZmF2cyIgdG8gYXZvaWQgZGVjaWRpbmcgd2hpY2gg
c3BlbGxpbmcgdG8gdXNlCgl7Ii9yYW0vY2FydCIsdXNlcmRhdGEiW2dmeF0wODA4Nzc3Nzc3Nzc3
MDAwMDAwNzcwMDAwMDA3NzAwMDAwMDc3Nzc3Nzc3NzcwMDAwMDc3Nzc3Nzc3NzAwMDAwMDAwMFsv
Z2Z4XSJ9LAoJLS17Ii9kZXNrdG9wIiwgdXNlcmRhdGEiW2dmeF0wODA4Nzc3Nzc3NzcwMDAwMDAw
MDc3Nzc3Nzc3NzA3Nzc3Nzc3Nzc3Nzc3NzcwNzc3Nzc3Nzc3Nzc3NzcwMDAwMDAwMFsvZ2Z4XSJ9
LAoJLS17Ii9hcHBkYXRhL2ZpbGVuYXYvZmF2cyIsdXNlcmRhdGEiW2dmeF0wODA4MDAwMDAwMDAw
NzcwNzcwMDc3Nzc3NzcwNzc3Nzc3NzAwNzc3NzcwMDAwNzc3MDAwMDAwNzAwMDAwMDAwMDAwMFsv
Z2Z4XSJ9LAoJeyIvIix1c2VyZGF0YSJbZ2Z4XTA4MDgwMDAwMDAwMDAwMDAwNzcwMDAwMDc3MDAw
MDA3NzAwMDAwNzcwMDAwMDc3MDAwMDA3NzAwMDAwMDAwMDAwMDAwWy9nZnhdIn0sCn0KYnV0dG9u
X2dmeCA9CnsKCXVwZGlyID0gdXNlcmRhdGEiW2dmeF0wODA4MDAwMDAwMDAwMDc3MDAwMDA3Nzc3
MDAwNzc3Nzc3MDAwMDc3MDAwMDAwNzcwMDAwMDA3Nzc3MDAwMDAwMDAwMFsvZ2Z4XSIsCglsaXN0
ICA9IHVzZXJkYXRhIltnZnhdMDgwODc3NzcwNzcwMDAwMDAwMDA3Nzc3MDc3MDAwMDAwMDAwNzc3
NzA3NzAwMDAwMDAwMDc3NzcwNzcwMDAwMDAwMDBbL2dmeF0iLAoJZ3JpZCAgPSB1c2VyZGF0YSJb
Z2Z4XTA4MDg3NzcwNzc3MDc3NzA3NzcwNzc3MDc3NzAwMDAwMDAwMDc3NzA3NzcwNzc3MDc3NzA3
NzcwNzc3MDAwMDAwMDAwWy9nZnhdIiwKfQpmdW5jdGlvbiBnZW5lcmF0ZV90b29sYmFyKCkKCWxv
Y2FsIHNob3J0Y3V0X3cgPSAxNgoJbG9jYWwgc2hvcnRjdXRzX3cgPSBzaG9ydGN1dF93ICogI3No
b3J0Y3V0cyArIDgKCQoJdG9vbGJhciA9IGd1aTphdHRhY2h7CgkJeCA9IDAsIHkgPSAwLAoJCXdp
ZHRoX3JlbCA9IDEuMCwKCQloZWlnaHQgPSAxNgoJfQoJCglmdW5jdGlvbiB0b29sYmFyOmRyYXco
KQoJCXJlY3RmaWxsKDAsMCwxMDAwLHNlbGYuaGVpZ2h0LDYpCgllbmQKCQoJLS0gbmF2YmFyCgkt
LSB0byBkbzogcHV0IHVwX2ZvbGRlciBidXR0b24gb24gbGVmdD8gbWF5YmUgbm90IQoJbmF2dGV4
dCA9IHRvb2xiYXI6YXR0YWNoX3RleHRfZWRpdG9yewoJCXg9MzQseT0yLAoJCXdpZHRoPTEwMCwK
CQl3aWR0aF9yZWwgPSAxLjAsCgkJd2lkdGhfYWRkID0gLXNob3J0Y3V0c193IC0gMzQsCgkJaGVp
Z2h0PTEyLAoJCW1heF9saW5lcyA9IDEsCQoJCWtleV9jYWxsYmFjayA9IHsgCgkJCgkJCWVudGVy
ID0gZnVuY3Rpb24gKCkgCgkJCQkKCQkJCWxvY2FsIHBhdGggPSBuYXZ0ZXh0OmdldF90ZXh0KClb
MV0KCQkJCWxvY2FsIGF0dHJpYnMgPSBmc3RhdChwYXRoKQoKCQkJCS0tIHByaW50aCgicHJlc3Nl
ZCBlbnRlciAiLi5wb2R7bmF2dGV4dDpnZXRfdGV4dCgpWzFdLCBwYXRoLCBhdHRyaWJzfSkKCQkJ
CQoJCQkJaWYgYXR0cmlicyA9PSAiZm9sZGVyIiB0aGVuCgkJCQkJY2QocGF0aCkKCQkJCWVsc2Vp
ZiBpbnRlbnRpb24gdGhlbgoJCQkJCXByb2Nlc3NfaW50ZW50aW9uKCkKCQkJCWVsc2VpZiAoYXR0
cmlicyA9PSAiZmlsZSIpIHRoZW4KCQkJCQktLSBvcGVuIGl0OyBzYW1lIGFzIGRvdWJsZSBjbGlj
a2luZyBvbiBpdAoJCQkJCWNsaWNrX29uX2ZpbGUocGF0aCkKCQkJCWVsc2UKCQkJCQktLSBjcmVh
dGUgZmlsZT8KCQkJCQktLT4gdG8gZG86IHN3aXRjaCB0byBOZXcgRmlsZSBpbnRlbnRpb24KCQkJ
CQkJLS0gKHVzZWQgY2FuIGNhbmNlbCBpZiBpdCB3YXMgYSB0eXBvKQoJCQkJZW5kCgkJCQkJCgkJ
CQlyZWZyZXNoX2d1aSA9IHRydWUKCQkJCQoJCQllbmQsCgkJCQoJCQl0YWIgPSBmdW5jdGlvbiAo
KQoJCQkJbG9jYWwgcGF0aCA9IG5hdnRleHQ6Z2V0X3RleHQoKVsxXQoJCQkJcGF0aCA9IHRhYl9j
b21wbGV0ZV9maWxlbmFtZShwYXRoKQoJCQkJCgkJCQluYXZ0ZXh0OnNldF90ZXh0e3BhdGh9CgkJ
CQktLSBoYWNreSB3YXkgdG8gcHV0IHRoZSBtb3VzZSBjdXJzb3IgYXQgdGhlIGVuZAoJCQkJbmF2
dGV4dDpjbGljayh7bXg9MTAwMCxteT0yfSkKCQkJCQoJCQllbmQKCQkKCQl9Cgl9CgkKCQoJbG9j
YWwgcGF0aCA9IHB3ZCgpCglpZiAoc3RyaW5nLnN1YihwYXRoLC0xKSAhPSAiLyIpIHBhdGggPSBw
YXRoLi4iLyIKCW5hdnRleHQ6c2V0X3RleHR7cGF0aH0KCW5hdnRleHQ6c2V0X2tleWJvYXJkX2Zv
Y3VzKHRydWUpCgktLSBoYWNreSB3YXkgdG8gcHV0IHRoZSBtb3VzZSBjdXJzb3IgYXQgdGhlIGVu
ZAoJbmF2dGV4dDpjbGljayh7bXg9MTAwMCxteT0yfSkKCQoJLS0gc2hvcnRjdXQgYnV0dG9ucwoJ
Cglmb3IgaT0xLCNzaG9ydGN1dHMgZG8KCQl0b29sYmFyOmF0dGFjaHsKCQkJY3Vyc29yID0gInBv
aW50ZXIiLAoJCQktLXggPSBnZXRfZGlzcGxheSgpOndpZHRoKCktc2hvcnRjdXRzX3cgKyA1ICsg
KGktMSkgKiBzaG9ydGN1dF93LAoJCQl4ID0gLXNob3J0Y3V0c193ICsgNSArIGkgKiBzaG9ydGN1
dF93LAoJCQlqdXN0aWZ5ID0gInJpZ2h0IiwKCQkJeSA9IDMsCgkJCXdpZHRoPXNob3J0Y3V0X3cs
CgkJCWhlaWdodD0xMCwKCQkJbG9jYXRpb249c2hvcnRjdXRzW2ldWzFdLAoJCQlpY29uPXNob3J0
Y3V0c1tpXVsyXSwKCQkJZHJhdyA9IGZ1bmN0aW9uKHNlbGYpCgkJCQktLXJlY3RmaWxsKDAsMCxz
ZWxmLndpZHRoLTEsc2VsZi5oZWlnaHQtMSw3KQoJCQkJcGFsKDcsc2VsZi5sb2NhdGlvbj09cHdk
KCkgYW5kIDcgb3IgMTMpCgkJCQlzcHIoc2VsZi5pY29uLHNlbGYud2lkdGgvMi1zZWxmLmljb246
d2lkdGgoKS8yLDEpCgkJCQlwYWwoNyw3KQoJCQllbmQsCgkJCXRhcCA9IGZ1bmN0aW9uKHNlbGYp
CgkJCQljZChzZWxmLmxvY2F0aW9uKQoJCQkJcmVmcmVzaF9ndWkgPSB0cnVlCgkJCWVuZAoJCX0K
CWVuZAoJCgktLSB1cGRpciBidXR0b24KCQoJdG9vbGJhcjphdHRhY2h7CgkJCWN1cnNvciA9ICJw
b2ludGVyIiwKCQkJeCA9IDE2LHkgPSAzLHdpZHRoPXNob3J0Y3V0X3csaGVpZ2h0PTEwLAoJCQlp
Y29uPWJ1dHRvbl9nZngudXBkaXIsCgkJCWRyYXcgPSBmdW5jdGlvbihzZWxmKQoJCQkJcGFsKDcs
MTMpIC0tcHdkKCkgPT0gIi8iIGFuZCA2IG9yIDEzKQoJCQkJc3ByKHNlbGYuaWNvbixzZWxmLndp
ZHRoLzItc2VsZi5pY29uOndpZHRoKCkvMiwxKQoJCQkJcGFsKDcsNykKCQkJZW5kLAoJCQl0YXAg
PSBmdW5jdGlvbihzZWxmKQoJCQkJY2QoIi4uIikKCQkJCXJlZnJlc2hfZ3VpID0gdHJ1ZQoJCQll
bmQKCQl9CgkJCgktLSB0b2dnbGUgdmlldyBtb2RlCgkKCXRvb2xiYXI6YXR0YWNoewoJCQljdXJz
b3IgPSAicG9pbnRlciIsCgkJCXggPSAyLHkgPSAzLHdpZHRoPXNob3J0Y3V0X3csaGVpZ2h0PTEw
LAoJCQlkcmF3ID0gZnVuY3Rpb24oc2VsZikKCQkJCWxvY2FsIGljb24gPSBtb2RlID09ICJsaXN0
IiBhbmQgYnV0dG9uX2dmeC5saXN0IG9yIGJ1dHRvbl9nZnguZ3JpZAoJCQkJcGFsKDcsMTMpCgkJ
CQlzcHIoaWNvbixzZWxmLndpZHRoLzItaWNvbjp3aWR0aCgpLzIsMSkKCQkJCXBhbCg3LDcpCgkJ
CWVuZCwKCQkJdGFwID0gZnVuY3Rpb24oc2VsZikKCQkJCW1vZGUgPSAobW9kZSA9PSAiZ3JpZCIp
IGFuZCAibGlzdCIgb3IgImdyaWQiCgkJCQlyZWZyZXNoX2d1aSA9IHRydWUKCQkJZW5kCgkJfQoJ
CgkKZW5kCgoKZnVuY3Rpb24gZ2VuZXJhdGVfaW50ZXJmYWNlKCkKCglsb2NhbCBzY3JvbGxfeSA9
IGNvbnRlbnQgYW5kIGNvbnRlbnQueQoJbG9jYWwgdGV4dDAgPSBuYXZ0ZXh0IGFuZCBuYXZ0ZXh0
OmdldF90ZXh0KCkKCQoJZ3VpX3csIGd1aV9oID0gZ2V0X2Rpc3BsYXkoKTp3aWR0aCgpLCBnZXRf
ZGlzcGxheSgpOmhlaWdodCgpCgkKCS0tIHNob3cgcGF0aCB3aGVuIG5vdCBpbiBpbnRlbnRpb24g
bW9kZQoJaWYgKG5vdCBpbnRlbnRpb24pIHRoZW4KCQl3aW5kb3d7dGl0bGUgPSBwd2QoKX0KCWVu
ZAoJCglndWkgPSBjcmVhdGVfZ3VpKCkKCQoJLS0gdG8gZG86IHNvcnQgZmlsZXMJCglsb2NhbCBm
aWxlcyA9IGxzKHB3ZCgpKQoJCgktLSBwcmludGgoImdlbmVyYXRlX2ludGVyZmFjZSgpIikKCQoJ
bG9jYWwgYWRkX2hlaWdodCA9IGludGVudGlvbiBhbmQgLTE5IG9yIDAKCgktLSB0byBkbzogZ2Vu
ZXJhdGUgaW50ZXJmYWNlIGJhc2VkIG9uIG1vZGUKCWlmIChtb2RlID09ICJsaXN0IikgICAgZ2Vu
ZXJhdGVfaW50ZXJmYWNlX2xpc3QoMTYsIGFkZF9oZWlnaHQpCglpZiAobW9kZSA9PSAiZ3JpZCIp
ICAgIGdlbmVyYXRlX2ludGVyZmFjZV9ncmlkKDE2LCBhZGRfaGVpZ2h0KQoJaWYgKG1vZGUgPT0g
ImRlc2t0b3AiKSBnZW5lcmF0ZV9pbnRlcmZhY2VfZGVza3RvcCgwLCBhZGRfaGVpZ2h0KQoJCglp
ZiAobW9kZSAhPSAiZGVza3RvcCIpIHRoZW4KCQlnZW5lcmF0ZV90b29sYmFyKCkKCWVuZAoJCglp
ZiAoaW50ZW50aW9uKSBnZW5lcmF0ZV9pbnRlbnRpb25fcGFuZWwoKQoJCgktLSByZXN0b3JlIHNv
bWUgc3RhdGUKCWlmIChjb250ZW50IGFuZCBzY3JvbGxfeSkgY29udGVudC55ID0gc2Nyb2xsX3kK
CWlmIChjb250ZW50IGFuZCB0ZXh0KSAgICAgbmF2dGV4dDpzZXRfdGV4dCh0ZXh0MCkKCQoJCmVu
ZAoKCgoKCjo6IGxpc3QubHVhCi0tW1twb2RfZm9ybWF0PSJyYXciLGNyZWF0ZWQ9IjIwMjMtMTAt
MjAgMDY6Mjc6NDIiLG1vZGlmaWVkPSIyMDI0LTA0LTExIDIyOjI2OjEzIixyZXZpc2lvbj0yNTY2
LHN0b3JlZD0iMjAyMy0yMS0yOSAwOToyMToxOSJdXQotLSBtb2RlOiBsaXN0CmxvY2FsIGl0ZW1f
aCA9IDEyCmxvY2FsIGZ1bmN0aW9uIGNyZWF0ZV9maWxlX2l0ZW0ocGFyZW50LCBmZiwgeCwgeSkK
CWlmIChub3QgZmYgb3Igbm90IGZmLmZpbGVuYW1lKSByZXR1cm4KCWxvY2FsIGVsID0gewoJCXgg
PSB4LCB5ID0geSx3aWR0aD00ODAsCgkJd2lkdGhfcmVsID0gMS4wLCBoZWlnaHQ9MTIsCgkJZmlu
Zm8gICAgPSAgZmYsCgkJZmlsZW5hbWUgPSBmZi5maWxlbmFtZSwKCX0KCQoJZnVuY3Rpb24gZWw6
ZHJhdygpCgkJaWYgKHNlbGYuZmluZm8uc2VsZWN0ZWQpIHRoZW4KCQkJcmVjdGZpbGwoMCwwLHNl
bGYud2lkdGgtMSxzZWxmLmhlaWdodC0xLDEwKQoJCWVuZAoJCQoJCWxpbmUoMCxzZWxmLmhlaWdo
dC0xLHNlbGYud2lkdGgtMSxzZWxmLmhlaWdodC0xLDYpCgkJCgkJcHJpbnQoc2VsZi5maWxlbmFt
ZSw0LDIsMSkKCQktLXByaW50KHNlbGYuYXR0cmliLDEyMCwyLDEpCgkJcHJpbnQoc2VsZi5maW5m
by5zaXplLDE0MCwyLDEpCgkJcHJpbnQoIjIwMjMtMDctMTkiLDIwMCwyLDEpCgkJCgllbmQKCQoJ
ZnVuY3Rpb24gZWw6dGFwKCkKCQlpZiAoa2V5KCJjdHJsIikpIHRoZW4KCQkJc2VsZi5maW5mby5z
ZWxlY3RlZCA9IG5vdCBzZWxmLmZpbmZvLnNlbGVjdGVkCgkJZWxzZQoJCQlkZXNlbGVjdF9hbGwo
KQoJCQlzZWxmLmZpbmZvLnNlbGVjdGVkID0gdHJ1ZQoJCQktLSBzZXQKCQkJbmF2dGV4dDpzZXRf
dGV4dHtmdWxscGF0aChlbC5maWxlbmFtZSl9CgkJZW5kCQoJCWlmIGludGVudGlvbiA9PSAic2F2
ZV9maWxlX2FzIiB0aGVuCgkJCS0tIHNldCB0ZXh0CgkJCWludGVudGlvbl90ZXh0OnNldF90ZXh0
KHtlbC5maWxlbmFtZX0pCgkJCW5hdnRleHQ6c2V0X3RleHR7IiJ9CgkJZW5kCgllbmQKCQoJZnVu
Y3Rpb24gZWw6ZG91YmxlY2xpY2soKQoJCWNsaWNrX29uX2ZpbGUoc2VsZi5maWxlbmFtZSkKCWVu
ZAoJCglyZXR1cm4gZWwKZW5kCmZ1bmN0aW9uIGdlbmVyYXRlX2ZlbHNfbGlzdCgpCgktLSBoYW5k
bGUgZmlsZSBpdGVtcyBsYXllciBvZiBndWkgbWFudWFsbHkgc28gY2FuIG9wdGltaXNlCgktLSAo
ZS5nLiBvbmx5IGRyYXcgLyB1cGRhdGUgdmlzaWJsZSBpdGVtcykKCQkKCWxvY2FsIHh4LHl5ID0g
MCwwCglsb2NhbCBpdGVtX3cgPSA2OAoJLS0gdG8gZG86IHNob3VsZCBiZSBwYXJlbnQKCWxvY2Fs
IGl0ZW1zX3ggPSBnZXRfZGlzcGxheSgpOndpZHRoKCkgXCBpdGVtX3cKCQoJZmkgPSB7fQoJCglm
b3IgaT0xLCNmaWxlbmFtZXMgZG8KCQlhZGQoZmksIGNyZWF0ZV9maWxlX2l0ZW0oY29udGVudCwg
ZmluZm9bZmlsZW5hbWVzW2ldXSwgMCwgKGktMSkqaXRlbV9oKSkKCWVuZAplbmQKZnVuY3Rpb24g
Z2VuZXJhdGVfaW50ZXJmYWNlX2xpc3QoeTAsIGFkZF9oZWlnaHQpCgl1cGRhdGVfZmlsZV9pbmZv
KCkKCQoJbG9jYWwgcG9pbnRlcl9lbCA9IG5pbAoJCgktLSBhdHRyaWJ1dGUgaGVhZGVycwoJLS0g
Y2xpY2sgZm9yIHNvcnRpbmcgYnkgdGhhdCBhdHRyaWJ1dGUKCQoJZ3VpOmF0dGFjaHsKCQl4PTAs
eT15MCx3aWR0aF9yZWw9MS4wLGhlaWdodD0xMiwKCQlkcmF3PWZ1bmN0aW9uKHNlbGYpCgkJCXJl
Y3RmaWxsKDAsMCxzZWxmLndpZHRoLTEsc2VsZi5oZWlnaHQtMSwgNikKCQkJcHJpbnQoImZpbGVu
YW1lIiwgNCwgMiwgMTMpCgkJCXByaW50KCJzaXplIiwgMTQwLDIsMTMpCgkJCXByaW50KCJtb2Rp
ZmllZCIsMjAwLDIsMTMpCgkJZW5kCgl9CgkKCS0tIGxvY2F0aW9uIGlzIGluIHdpbmRvdyB0aXRs
ZSEKCWxvY2FsIGNvbnRhaW5lciA9IGd1aTphdHRhY2h7CgkJeD0wLHk9eTArMTIsCgkJd2lkdGhf
cmVsID0gMS4wLAoJCWhlaWdodF9yZWwgPSAxLjAsCgkJaGVpZ2h0X2FkZCA9IC0oeTArMTIpICsg
YWRkX2hlaWdodCwKCX0KCWxvY2FsIGNvbnRlbnQgPSBjb250YWluZXI6YXR0YWNoewoJCXg9MCx5
PTAsCgkJd2lkdGhfcmVsPTEuMCwKCQloZWlnaHQ9I2ZpbGVuYW1lcyAqIGl0ZW1faCwKCQljbGlw
X3RvX3BhcmVudCA9IHRydWUKCX0KCQoJZnVuY3Rpb24gY29udGVudDpjbGFtcF9zY3JvbGxpbmco
KQoJCWxvY2FsIG1heF95ID0gbWF4KDAsIGNvbnRlbnQuaGVpZ2h0IC0gY29udGFpbmVyLmhlaWdo
dCkKCQljb250ZW50LnkgPSBtaWQoMCwgY29udGVudC55LCAtbWF4X3kpCgkJY29udGVudC54ID0g
bWluKDAsIGNvbnRlbnQueCkKCWVuZAoJZnVuY3Rpb24gY29udGVudDp1cGRhdGUoKQoJCWNvbnRl
bnQ6Y2xhbXBfc2Nyb2xsaW5nKCkKCQkKCQktLSB1cGRhdGUgcG9pbnRlciBlbGVtZW50CgkJbG9j
YWwgbXgsbXksbWIgPSBtb3VzZSgpCgkJbG9jYWwgaW5kZXggPSAxICsgKG15IC0gc2VsZi5zeSkg
XCBpdGVtX2gKCQlpbmRleCA9IG1pZCgxLCBpbmRleCwgI2ZpKQoJCXBvaW50ZXJfZWwgPSBmaVtm
bHIoaW5kZXgpXQoJCQoJCXNlbGYuaGVpZ2h0ID0gI2ZpbGVuYW1lcyAqIGl0ZW1faAoJCQoJZW5k
CgktLSAKCQkJCglmdW5jdGlvbiBjb250ZW50OmRyYXcoKQoJCgkJaWYgKCNmaSA9PSAwKSByZXR1
cm4KCQoJCWxvY2FsIG1pbmkgPSBtaWQoMSwgKC1jb250ZW50LnkgICAgICAgICAgICAgICAgICAg
KSBcIGl0ZW1faCArIDEsICNmaSkKCQlsb2NhbCBtYXhpID0gbWlkKDEsICgtY29udGVudC55ICsg
Y29udGFpbmVyLmhlaWdodCkgXCBpdGVtX2ggKyAxLCAjZmkpCgkJZm9yIGk9bWluaSxtYXhpIGRv
CgkJCQoJCQlsb2NhbCBmZiA9IGZpW2ldCgkJCWxvY2FsIHN4ID0gZmYueCArIGNvbnRlbnQueCBc
IDEgKyBjb250YWluZXIueCAKCQkJbG9jYWwgc3kgPSBmZi55ICsgY29udGVudC55IFwgMSArIGNv
bnRhaW5lci55IAoJCQoJCQljYW1lcmEoLXN4LCAtc3kpCgkJCQoJCQktLSBjbGlwcGluZyBoYWNr
OiBkb24ndCBkcmF3IG92ZXIgdG9vbGJhciBhdCB0b3AKCQkJY2xpcChzeCwgbWF4KHN5LCBjb250
YWluZXIueSksIGZmLndpZHRoLCBmZi5oZWlnaHQpCgkJCWZmOmRyYXcoKQoJCWVuZAoJCQoJCWNs
aXAoKQoJZW5kCgkKCS0tIGZvcndhcmQgbWVzc2FnZXMKCS0tIHRvIGRvOiBhbGxvdyBzdWJzY3Jp
YmVfdG9fZXZlbnRzIGF0IGd1aSBlbGVtZW50IGxldmVsPwoJCglmdW5jdGlvbiBjb250ZW50OnRh
cCguLi4pCgkJcG9pbnRlcl9lbDp0YXAoLi4uKQoJZW5kCglmdW5jdGlvbiBjb250ZW50OmRvdWJs
ZWNsaWNrKC4uLikKCQlwb2ludGVyX2VsOmRvdWJsZWNsaWNrKC4uLikKCWVuZAoJCgl1cGRhdGVf
ZmlsZV9pbmZvKHRydWUpCgljb250YWluZXI6YXR0YWNoX3Njcm9sbGJhcnN7YXV0b2hpZGU9dHJ1
ZX0KCQplbmQKCgoKCjo6IG1haW4ubHVhCi0tW1twb2RfZm9ybWF0PSJyYXciLGNyZWF0ZWQ9IjIw
MjMtMTAtMjAgMDY6MjQ6MTMiLG1vZGlmaWVkPSIyMDI0LTA0LTExIDIyOjI2OjEzIixyZXZpc2lv
bj0yODI0LHN0b3JlZD0iMjAyMy0yMS0yOSAwOToyMToxOSJdXQotLVtbCglmZjogdGhlbWUgLyBh
cHAgbWVudSBpbnRlZ3JhdGlvbgpdXQppbmNsdWRlICJpY29uLmx1YSIKaW5jbHVkZSAibGlzdC5s
dWEiCmluY2x1ZGUgImdyaWQubHVhIgppbmNsdWRlICJkZXNrdG9wLmx1YSIKaW5jbHVkZSAib3Bl
bi5sdWEiCmluY2x1ZGUgImludGVyZi5sdWEiCmluY2x1ZGUgInRhYmNvbXAubHVhIgppbmNsdWRl
ICJmaW5mby5sdWEiCmluY2x1ZGUgImRyb3AubHVhIgppbmNsdWRlICJpbnRlbnRpb24ubHVhIgot
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLQoKZnVuY3Rpb24gX2luaXQoKQoKLS0JcHJpbnRoKCJAQCBm
aWxlbmF2IF9pbml0IGNkIGVudigpLnBhdGg6ICIuLnRvc3RyKGVudigpLnBhdGgpKQoJY2QoZW52
KCkucGF0aCkKCQoJcHVzaF9pbnRlbnRpb24oZW52KCkuaW50ZW50aW9uIG9yIGludGVudGlvbiwg
ZW52KCkuaW50ZW50aW9uIGFuZCBlbnYoKS5wYXJlbnRfcGlkKQoJCgoJcG9rZSgweDQwMDAsZ2V0
KGZldGNoIi9zeXN0ZW0vZm9udHMvbGlsLmZvbnQiKSkKCXBva2UoMHg1NjAwLGdldChmZXRjaCIv
c3lzdGVtL2ZvbnRzL3A4LmZvbnQiKSkKCQoJd2luZG93ewoJCXdpZHRoID0gMjcyLCBoZWlnaHQg
PSAxNjAsCgkJdGl0bGUgPSBpbnRlbnRpb25fd2luZG93X3RpdGxlIG9yIGludGVudGlvbl90aXRs
ZSwKCQloYXNfY29udGV4dF9tZW51ID0gdHJ1ZSAtLSBtYjIgdG8gb3BlbiBhcHAgbWVudSAvLyB0
byBkbzogaW5kaWNhdGUgd2hpY2ggaXRlbXMgYXJlIGZvciBjb250ZXh0IG1lbnUKCX0KCS0tIG1v
ZGU6IGxpc3QsIGdyaWQsIGRlc2t0b3AKCW1vZGUgPSAiZ3JpZCIKCS0tbW9kZSA9ICJkZXNrdG9w
IgoJCglkZXNrdG9wX3BhdGggPSAiL2Rlc2t0b3AiCglpZiAoZW52KCkuYXJndiBhbmQgZW52KCku
YXJndlsxXSA9PSAiLWRlc2t0b3AiKSB0aGVuCgkJbW9kZSA9ICJkZXNrdG9wIgoJCS0taWYgKGVu
digpLmRlc2t0b3BfcGF0aCkgZGVza3RvcF9wYXRoID0gZW52KCkuZGVza3RvcF9wYXRoCQoJCWlm
IChlbnYoKS5hcmd2WzJdKSBkZXNrdG9wX3BhdGggPSBlbnYoKS5hcmd2WzJdCgkJY2QoZGVza3Rv
cF9wYXRoKSAtLSBwYXRoIG5ldmVyIGNoYW5nZXMgYWZ0ZXIgdGhpcyBpbiBkZXNrdG9wIG1vZGUK
CWVuZAoJCglpZiAoZW52KCkuYXJndiBhbmQgZW52KCkuYXJndlsxXSkgdGhlbgoJCWxvY2FsIGZm
PWVudigpLmFyZ3ZbMV0KCQlpZiAoZnN0YXQoZmYpID09ICJmb2xkZXIiKSBjZChmZikKCWVuZAoJ
CgoJbWVudWl0ZW17CgkJaWQgPSAibmV3X2ZpbGUiLAoJCQoJCWxhYmVsID0gIlxeOjBmMTkzOTIx
MjEyMTNmMDAgTmV3IEZpbGUiLAoJCQoJCWFjdGlvbiA9IGZ1bmN0aW9uKCkKCQkJcHVzaF9pbnRl
bnRpb24oIm5ld19maWxlIikKCQllbmQKCX0KCQoJbWVudWl0ZW17CgkJaWQgPSAibmV3X2ZvbGRl
ciIsCgkJbGFiZWwgPSAiXF46MDAzODdmN2Y3ZjdmN2YwMCBOZXcgRm9sZGVyIiwKCgkJYWN0aW9u
ID0gZnVuY3Rpb24oKQoJCQlwdXNoX2ludGVudGlvbigibmV3X2ZvbGRlciIpCgkJZW5kCgl9CgoK
CS0tIFJlbmFtZSBGaWxlLCBGaWxlIEluZm86IGFkZGVkIGJ5IHVwZGF0ZV9maWxlX2luZm9fbWVu
dV9pdGVtKCkKCQoJCgoJCgktLXByaW50aCgiPT09PT0gZmlsZW5hdjogIi4ucHdkKCkuLiIgPT09
PT0iKQoJCglnZW5lcmF0ZV9pbnRlcmZhY2UoKQplbmQKZnVuY3Rpb24gX2RyYXcoKQoJbG9jYWwg
dDA9c3RhdCgxKQoJCgljbHMoNykKCWd1aTpkcmF3X2FsbCgpCgljbGlwKCkKCQoJLS0gZnBzCglp
ZiAoZmFsc2UpIHRoZW4KCQlyZWN0ZmlsbChnZXRfZGlzcGxheSgpOndpZHRoKCktMzIsMCwxMDAw
MCwxMiwxKQoJCXByaW50KChzdGF0KDEpLXQwKVwwLjAxLGdldF9kaXNwbGF5KCk6d2lkdGgoKS0z
MCwxMiw4KQoJZW5kCgotLQlwcmludChkcmFnZ2luZ19maWxlcyB_PSBuaWwgYW5kICJkcmFnZ2lu
ZyIgb3IgIi0tLSIsMiwyMCw3KQoKZW5kCmxvY2FsIGxhc3RfcG9sbF90ID0gMApmdW5jdGlvbiBf
dXBkYXRlKCkKCi0tW1sgZG9uJ3QgbmVlZCAtLSBpcyBpbnZva2VkIGJ5IGFwcCBtZW51IHNob3J0
Y3V0CglpZiAoa2V5ImN0cmwiKSB0aGVuCgkJaWYgKGtleXAiaSIpIG9wZW5fc2VsZWN0ZWRfZmls
ZV9pbmZvKCkKCWVuZAotLV1dCgkKCWlmIHJlZnJlc2hfZ3VpIHRoZW4KCQktLWlmIChtb2RlICE9
ICJkZXNrdG9wIikgLS0gMC4xLjBjOiBjb21tZW50ZWQgfiBnZW5lcmF0ZSBpbnRlcmZhY2UgZXZl
biBvbiBkZXNrdG9wIChhbGxvdyBmaWxlIG9wcykKCQlnZW5lcmF0ZV9pbnRlcmZhY2UoKQoJCXJl
ZnJlc2hfZ3VpID0gZmFsc2UKCWVuZAoJCgktLSB0byBkbzogY291bGQgYmUgZXZlcnkgNCBzZWNv
bmRzCgktLSArIHVwZGF0ZSBpbW1lZGlhdGVseSB3aGVuIGdhaW5pbmcgZm9jdXMgb3Igc29tZSBm
aWxlIGFjdGl2aXR5IGRldGVjdGVkIAoJLS0gKGdsb2JhbCB0aW1lc3RhbXAgb2YgbGFzdCBjaGFu
Z2UgaW4gL3JhbS9zeXN0ZW0-KQoJaWYgKHRpbWUoKSA_IGxhc3RfcG9sbF90ICsgMS4wKSB0aGVu
CgkJdXBkYXRlX2ZpbGVfaW5mbygpCgkJbGFzdF9wb2xsX3QgPSB0aW1lKCkKCWVuZAoJCglndWk6
dXBkYXRlX2FsbCgpCgplbmQKb25fZXZlbnQoImdhaW5lZF92aXNpYmlsaXR5IiwgZnVuY3Rpb24o
KQoJaWYgKG1vZGUgPT0gImRlc2t0b3AiKSBmZXRjaF9kZXNrdG9wX2l0ZW1zKCkKZW5kKQotLVtb
Ci0tIG5vcGUgfiB0b28gc2xvdwpvbl9ldmVudCgibG9zdF92aXNpYmlsaXR5IiwgZnVuY3Rpb24o
KQoJaWYgKG1vZGUgPT0gImRlc2t0b3AiKSBzdG9yZV9kZXNrdG9wX2l0ZW1zKCkKZW5kKQpdXQoK
b25fZXZlbnQoImZpbGVuYXZfcmVmcmVzaCIsIGZ1bmN0aW9uKCkKCS0tIHByaW50aCgiQEAgcmVm
cmVzaGluZyBmaWxlbmF2ICoqIikKCXVwZGF0ZV9maWxlX2luZm8odHJ1ZSkgLS0gaW52YWxpZGF0
ZSBjYWNoZQoJLS1yZWZyZXNoX2d1aSA9IHRydWUKZW5kKQoKCgoKCgo6OiBvcGVuLmx1YQotLVtb
cG9kX2Zvcm1hdD0icmF3IixjcmVhdGVkPSIyMDIzLTEwLTA0IDEyOjQ2OjE2Iixtb2RpZmllZD0i
MjAyNC0wNC0xMSAyMjoyNjoxMyIscmV2aXNpb249MjQ1OCxzdG9yZWQ9IjIwMjMtMjEtMjkgMDk6
MjE6MTkiXV0KCgkKCWZ1bmN0aW9uIGNsaWNrX29uX2ZpbGUoZmlsZW5hbWUsIGFjdGlvbiwgYXJn
dikKCQkKCQktLXByaW50aCgib3BlbmluZzogIi4udG9zdHIoZmlsZW5hbWUpKQoJCQoJCS0taWYg
KG5vdCBpbnRlbnRpb24gYW5kIHN0cmluZy5zdWIoZmlsZW5hbWUsLTQpID09ICIubG9jIikgdGhl
bgoJCWlmIChzdHJpbmcuc3ViKGZpbGVuYW1lLC00KSA9PSAiLmxvYyIpIC0tIDAuMS4wYzogYWx3
YXlzIG9wZW4gYXMgaWYgZm9sZGVyCgkJdGhlbgoJCQlsb2NhbCBkYXQgPSBmZXRjaChmaWxlbmFt
ZSkKCQkJLS0gc3dpdGNoZXJvb255CgkJCS0tIHRvIGRvOiAqKiBsb29wIGRhbmdlciEgKioKCQkJ
aWYgKGRhdCBhbmQgZGF0LmxvY2F0aW9uKSB0aGVuCgkJCQlmaWxlbmFtZSA9IGZ1bGxwYXRoKGRh
dC5sb2NhdGlvbikgLS0gZGF0LmxvY2F0aW9uIGNhbiBiZSByZWxhdGl2ZQoJCQkJY2xpY2tfb25f
ZmlsZShmaWxlbmFtZSwgZGF0LmFjdGlvbiwgZGF0LmFyZ3YpCgkJCWVsc2UKCQkJCW5vdGlmeSgi
bm90IGEgdmFsaWQgbG9jYXRpb24gZmlsZSIpCgkJCWVuZAoJCWVsc2VpZiBub3QgaW50ZW50aW9u
IGFuZCAoCgkJCQlzdHJpbmcuc3ViKGZpbGVuYW1lLC00KSA9PSAiLnA2NCIgb3IKCQkJCXN0cmlu
Zy5zdWIoZmlsZW5hbWUsLTgpID09ICIucDY0LnJvbSIgb3IKCQkJCXN0cmluZy5zdWIoZmlsZW5h
bWUsLTgpID09ICIucDY0LnBuZyIgb3IKCQkJCWFjdGlvbiA9PSAicnVuIgoJCQkpCgkJCS0tIG9y
IHN0cmluZy5zdWIoZmlsZW5hbWUsLTQpID09ICIubHVhIiAtLSBuYWgsIHVzdWFsbHkgd2FudCB0
byBlZGl0CgkJdGhlbgoJCQktLSBjYXJ0cmlkZ2UgLS0_IHJ1biBpdCEKCQkJCgkJCWNyZWF0ZV9w
cm9jZXNzKGZpbGVuYW1lLAoJCQkJdW5wb2QoYXJndikgb3IKCQkJCXt3aW5kb3dfYXR0cmlicz17
c2hvd19pbl93b3Jrc3BhY2U9dHJ1ZX19CgkJCSkKCQkKCQllbHNlCgkJCS0tIHRvIGRvOiBjb3Vs
ZCBncmFiIGZyb20gZmlsZSBpdGVtCgkJCQoJCQlpZiAoZnN0YXQoZmlsZW5hbWUpID09ICJmb2xk
ZXIiKSB0aGVuCgkJCQktLSBkaXJlY3RvcnkKCQkJCWlmIChtb2RlID09ICJkZXNrdG9wIiBvciBr
ZXkoInNoaWZ0IikpIHRoZW4KCQkJCQktLSBvcGVuIGluIGEgc2VwYXJhdGUgd2luZG93CgkJCQkJ
LS0gdG8gZG86IHJ1biBzZWxmCgkJCQkJY3JlYXRlX3Byb2Nlc3MoIi9zeXN0ZW0vYXBwcy9maWxl
bmF2LnA2NCIsCgkJCQkJeyAKCQkJCQkJYXJndiA9IHsKCQkJCQkJCWZ1bGxwYXRoKGZpbGVuYW1l
KSwgCgkJCQkJCQlmdWxscGF0aChmaWxlbmFtZSkKCQkJCQkJfSwKCQkJCQkJd2luZG93X2F0dHJp
YnM9ewoJCQkJCQkJc2hvd19pbl93b3Jrc3BhY2U9dHJ1ZSAtLSB0byBhY3RpdmF0ZSB3aW5kb3cK
CQkJCQkJfQoJCQkJCX0pCgkJCQkJCgkJCQllbHNlCgkJCQkJY2QoZmlsZW5hbWUpCgkJCQkJcmVm
cmVzaF9ndWkgPSB0cnVlCgkJCQllbmQKCQkJCQoJCQllbHNlCgkJCQoJCQkJLS0gb25seSBzZWxl
Y3RlZCBpbnRlbnRpb25zIGdldCBwcm9jZXNzZWQgYnkKCQkJCS0tIGRvdWJsZSBjbGlja2luZyBv
biBhIGZpbGUuIGZvciBleGFtcGxlLAoJCQkJLS0gdW5kZXIgbmV3X2ZpbGUgKG5ldyB0YWIpIGRv
dWJsZSBjbGlja2luZwoJCQkJLS0gc2hvdWxkIHN0aWxsIG1lYW4gZWRpdGluZyB0aGF0IGZpbGUg
YXMgdXN1YWwKCQkJCS0tIHVwZGF0ZTogY291bGRuJ3QgZmluZCBhbiBpbnRlbnRpb24gdGhhdCAv
aXMvCgkJCQktLSBhcHByb3ByaWF0ZSBoZXJlISAtPiBhbHdheXMgZWRpdAoJCQkJCgkJCQlpZiAo
aW50ZW50aW9uID09ICJzYXZlX2ZpbGVfYXMiKSB0aGVuCgkJCQkJLS0gZmlsZW5hbWUgaW4gdGV4
dCBmaWVsZCBzaG91bGQgYWxyZWFkeSBiZSBzZXQKCQkJCQlwcm9jZXNzX2ludGVudGlvbigpCgkJ
CQllbHNlCgkJCQkJLS0gb3BlbiBieSBmaWxlIGV4dGVuc2lvbgoJCQkJCWNyZWF0ZV9wcm9jZXNz
KGVudigpLm9wZW5fd2l0aCBhbmQgZW52KCkub3Blbl93aXRoIG9yICIvc3lzdGVtL3V0aWwvb3Bl
bi5sdWEiLAoJCQkJCQl7CgkJCQkJCQlhcmd2ID0ge2Z1bGxwYXRoKGZpbGVuYW1lKX0sCgkJCQkJ
CQktLXB3ZCA9IHB3ZCgpCgkJCQkJCX0KCQkJCQkpCgkJCQkKCQkJCWVuZAoJCQkKCQkJZW5kCgkJ
ZW5kCgkJCgllbmQKCgo6OiB0YWJjb21wLmx1YQotLVtbcG9kX2Zvcm1hdD0icmF3IixjcmVhdGVk
PSIyMDIzLTUzLTI2IDE5OjUzOjAwIixtb2RpZmllZD0iMjAyNC0wNC0wMyAwNTozMjozOSIscmV2
aXNpb249NTksc3RvcmVkPSIyMDIzLTU5LTA3IDA3OjU5OjQ0Il1dCi0tW1sKCWZhOiBjcmVhdGUg
Z3VpIHdpdGggcmVsYXRpdmUgc2l6ZXMKXV0KLS0gKiogaW5jcmVkaWJseSBpbmVmZmljaWVudCEg
dG8gZG86IG5lZWQgdG8gcmVwbGFjZSB3aXRoIHN0cmluZyBtYXRjaGluZwpmdW5jdGlvbiBmaW5k
X2NvbW1vbl9wcmVmaXgoczAsIHMxKQoJaWYgKHR5cGUoczApIH49ICJzdHJpbmciKSB0aGVuIHJl
dHVybiBuaWwgZW5kCglpZiAodHlwZShzMSkgfj0gInN0cmluZyIpIHRoZW4gcmV0dXJuIG5pbCBl
bmQKCWlmIChzMCA9PSBzMSkgdGhlbiByZXR1cm4gczAgZW5kCglsb2NhbCBsZW4gPSAwCgl3aGls
ZShzdWIoczAsMSxsZW4rMSkgPT0gc3ViKHMxLDEsbGVuKzEpKSBkbwoJCWxlbiA9IGxlbiArIDEK
CQktLXByaW50aChsZW4pCgllbmQKCXJldHVybiBzdWIoczAsMSxsZW4pCmVuZApmdW5jdGlvbiB0
YWJfY29tcGxldGVfZmlsZW5hbWUoY21kKQoJaWYgKGNtZCA9PSAiIikgdGhlbiByZXR1cm4gY21k
IGVuZAoJLS0gZ2V0IHN0cmluZwoJbG9jYWwgYXJncyA9IHNwbGl0KGNtZCwgIiBcIiIsIGZhbHNl
KSAgLS0gYWxzbyBzcGxpdCBvbiAiIHRvIGFsbG93IHRhYi1jb21wbGV0aW5nIGZpbGVuYW1lcyBp
bnNpZGUgc3RyaW5ncwoJbG9jYWwgcHJlZml4ID0gYXJnc1sjYXJnc10gb3IgIiIKCS0tIGNvbnN0
cnVjdCBwYXRoIHByZWZpeCAgLS0gZXZlcnl0aGluZyAoY2Fub25pY2FsIHBhdGgpIGV4Y2VwdCB0
aGUgZmlsZW5hbWUKCWxvY2FsIHByZWZpeCA9IGZ1bGxwYXRoKHByZWZpeCkKCWxvY2FsIHBhdGhz
ZWcgPSBzcGxpdChwcmVmaXgsIi8iLGZhbHNlKQoJaWYgKG5vdCBwYXRoc2VnKSB0aGVuIHJldHVy
biBjbWQgZW5kCglsb2NhbCBwYXRoX3BhcnQgPSAiIgoJZm9yIGk9MSwjcGF0aHNlZy0xIGRvCgkJ
cGF0aF9wYXJ0ID0gcGF0aF9wYXJ0IC4uICIvIiAuLiBwYXRoc2VnW2ldCgllbmQKCWlmIChwYXRo
X3BhcnQgPT0gIiIpIHRoZW4gcGF0aF9wYXJ0ID0gIi8iIGVuZCAtLSBjYW5vbmljYWwgZmlsZW5h
bWUgc3BlY2lhbCBjYXNlCglwcmVmaXggPSAocGF0aHNlZyBhbmQgcGF0aHNlZ1sjcGF0aHNlZ10p
IG9yICIvIgoJLS0gcHJpbnRoKCJAQEAgcGF0aCBwYXJ0OiAiLi5wYXRoX3BhcnQuLiIgcHdkOiIu
LnB3ZCgpKQoJbG9jYWwgZmlsZXMgPSBscyhwYXRoX3BhcnQpCglpZiAobm90IGZpbGVzKSByZXR1
cm4gY21kCgktLSBmaW5kIG1hdGNoZXMKCWxvY2FsIHNlZ21lbnQgPSBuaWwKCWxvY2FsIG1hdGNo
ZXMgPSAwCglsb2NhbCBzaW5nbGVfZmlsZW5hbWUgPSBuaWwKCglmb3IgaT0xLCNmaWxlcyBkbwoJ
CS0tcHJpbnRoKHByZWZpeC4uIiA6OiAiLi5maWxlc1tpXSkKCQlpZiAoc3ViKGZpbGVzW2ldLCAx
LCAjcHJlZml4KSA9PSBwcmVmaXgpIHRoZW4KCQkJbWF0Y2hlcyA9IG1hdGNoZXMgKyAxCgkJCWxv
Y2FsIGNhbmRpZGF0ZSA9IHN1YihmaWxlc1tpXSwgI3ByZWZpeCArIDEpIC0tIHJlbWFpbmRlcgoK
CQkJLS0gc2V0IHNlZ21lbnQgdG8gc3RhcnRpbmcgc2VxdWVuY2UgY29tbW9uIHRvIGNhbmRpZGF0
ZSBhbmQgc2VnbWVudAoJCQlzZWdtZW50ID0gc2VnbWVudCBhbmQgZmluZF9jb21tb25fcHJlZml4
KGNhbmRpZGF0ZSwgc2VnbWVudCkgb3IgY2FuZGlkYXRlCgkJCXNpbmdsZV9maWxlbmFtZSA9IHBh
dGhfcGFydC4uIi8iLi5maWxlc1tpXSAtLSB1c2VkIHdoZW4gc2luZ2xlIG1hdGNoIGlzIGZvdW5k
CgkJZW5kCgllbmQKCQoJaWYgKHNlZ21lbnQpIHRoZW4KCQljbWQgPSBjbWQgLi4gc2VnbWVudAoJ
CS0tY3Vyc29yX3BvcyA9IGN1cnNvcl9wb3MgKyAjc2VnbWVudAoJZW5kCgoJaWYgbWF0Y2hlcyA9
PSAxIGFuZCBzaW5nbGVfZmlsZW5hbWUgYW5kIGZzdGF0KHNpbmdsZV9maWxlbmFtZSkgPT0gImZv
bGRlciIgdGhlbgoJCWNtZCAuLj0gIi8iCgllbmQKCgkKCXJldHVybiBjbWQKZW5kCgoKCgo6OiBb
ZW9jXQo=
:: apps/code.p64
b64$cGljb3Ryb24gY2FydHJpZGdlIC8vIHd3dy5waWNvdHJvbi5uZXQKdmVyc2lvbiAyCgo6OiAu
aW5mby5wb2QKYjY0JExTMWJXM0J2WkN4dWIzUmxjejBpSWl4aGRYUm9iM0k5SW14bGVHRnNiMlpt
YkdVaUxITjBiM0psWkQwaU1qQXlNeTAxTkMweApNaUF4TURvMU5Eb3dOaUlzYVdOdmJqMTFjMlZ5
WkdGMFlTZ2lkVGdpTERFMkxERTJMQ0l3TURBd01EQXdNVEF4TURFd01UQXhNREV3Ck1UQXhNREV3
TVRBd01EQXdNREF3TURBd01UQTNNRGN3TnpBM01EY3dOekEzTURjd056QTNNREV3TURBd01EQXdN
VEEzTUdRd1pEQmsKTUdRd1pEQmtNR1F3WkRCa01HUXdOekF4TURBd01UQTNNR1F3WkRCa01HUXda
REJrTUdRd1pEQmtNR1F3WkRCa01EY3dNVEF4TURjdwpaREJrTUdRd056QTNNR1F3WkRBM01EY3da
REJrTUdRd056QXhNREV3TnpCa01HUXdOekEzTUdRd1pEQmtNR1F3TnpBM01HUXdaREEzCk1ERXdN
VEEzTUdRd1pEQTNNRGN3WkRCa01HUXdaREEzTURjd1pEQmtNRGN3TVRBeE1EY3daREJrTURjd056
QmtNR1F3WkRCa01EY3cKTnpCa01HUXdOekF4TURFd056QmtNR1F3TnpBM01HUXdaREJrTUdRd056
QTNNR1F3WkRBM01ERXdNVEEzTUdRd1pEQmtNRGN3TnpCawpNR1F3TnpBM01HUXdaREJrTURjd01U
QXhNRGN3WkRCa01HUXdaREJrTUdRd1pEQmtNR1F3WkRCa01HUXdOekF4TURFd05qQTNNR1F3ClpE
QmtNR1F3WkRCa01HUXdaREJrTUdRd056QTJNREV3TVRBMk1EWXdOekEzTURjd056QTNNRGN3TnpB
M01EY3dOekEyTURZd01UQXcKTURFd05qQTJNRFl3TmpBMk1EWXdOakEyTURZd05qQTJNRFl3TVRB
d01EQXdNREF4TURZd05qQTJNRFl3TmpBMk1EWXdOakEyTURZdwpNVEF3TURBd01EQXdNREF3TVRB
eE1ERXdNVEF4TURFd01UQXhNREV3TVRBd01EQXdNQ0lwTEhScGRHeGxQU0pRYVdOdmRISnZiaUJE
CmIyUmxJRVZrYVhSdmNpSXNZM0psWVhSbFpEMGlNakF5TkMwd05DMHpNQ0F4T1Rvd09Ub3pNeUlz
Ylc5a2FXWnBaV1E5SWpJd01qUXQKTURjdE1EWWdNVEU2TkRnNk16WWlMSFpsY25OcGIyNDlJakF1
TVNJc2QyOXlhM053WVdObGN6MTdlMnh2WTJGMGFXOXVQU0p0WVdsdQpMbXgxWVNJc2QyOXlhM053
WVdObFgybHVaR1Y0UFRGOUxIdHNiMk5oZEdsdmJqMGlaMlo0THpBdVoyWjRJaXgzYjNKcmMzQmhZ
MlZmCmFXNWtaWGc5TW4wc2UyeHZZMkYwYVc5dVBTSnRZWEF2TUM1dFlYQWlMSGR2Y210emNHRmpa
VjlwYm1SbGVEMHpmWDFkWFd4Nk5BQUUKQUFBQUF3QUFBREJ1YVd3PQo6OiBnZngvCjo6IGdmeC8u
aW5mby5wb2QKYjY0JExTMWJXM0J2WkN4amNtVmhkR1ZrUFNJeU1ESXpMVEF4TFRJMElERTVPakF4
T2pVMklpeHRiMlJwWm1sbFpEMGlNakF5TkMwdwpOeTB3TmlBeE1UbzBPRG96TmlJc2MzUnZjbVZr
UFNJeU1ESXpMVEF4TFRJMElERTVPakF4T2pVMklsMWRiSG8wQUFRQUFBQURBQUFBCk1HNXBiQT09
Cjo6IGdmeC8wLmdmeApiNjQkTFMxYlczQnZaQ3hqY21WaGRHVmtQU0l5TURJekxUUTNMVEkxSURB
M09qUTNPalV3SWl4dGIyUnBabWxsWkQwaU1qQXlNeTAxCk5DMHhNaUF4TURvMU5Eb3dOaUlzY21W
MmFYTnBiMjQ5TWwxZGJIbzBBSEVBQUFBRk13QUE4eFI3V3pCZFBYdGliWEE5Y0hoMUFFTWcKRUJB
RThQQXNabXhoWjNNOU1DeHdZVzVmZUFnQTczazlNQ3h6WTJGc1pUMHhNbjBzTXdELS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLQotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LV9kUVBURXlmWDA9Cjo6IG1hcC8KOjogbWFwLy5pbmZvLnBvZApiNjQkTFMxYlczQnZaQ3hqY21W
aGRHVmtQU0l5TURJekxUQXhMVEkwSURFNU9qQXhPalUySWl4dGIyUnBabWxsWkQwaU1qQXlOQzB3
Ck55MHdOaUF4TVRvME9Eb3pOaUlzYzNSdmNtVmtQU0l5TURJekxUQXhMVEkwSURFNU9qQXhPalUy
SWwxZGJIbzBBQVFBQUFBREFBQUEKTUc1cGJBPT0KOjogbWFwLzAubWFwCmI2NCRMUzFiVzNCdlpD
eGpjbVZoZEdWa1BTSXlNREl6TFRRM0xUSTFJREEzT2pRM09qVXdJaXh0YjJScFptbGxaRDBpTWpB
eU15MDEKTkMweE1pQXhNRG8xTkRvd05pSXNjbVYyYVhOcGIyNDlNbDFkYkhvMEFGMEFBQUJZQkFB
QThCTjdiR0Y1WlhJOWUxc3dYVDE3WW0xdwpQWFZ6WlhKa1lYUmhLQ0pwTVRZaUxERTJBd0F2SWpB
QkFQLS0tX19oSWlrc2NHRnVYM2c5TUFnQThnWjVQVEFzYzJOaGJHVTlNU3gwCmFXeGxYMmc5TVRZ
S0FIQjNQVEUyZlgxOQo6OiBzZngvCjo6IHNmeC8uaW5mby5wb2QKYjY0JExTMWJXM0J2WkN4amNt
VmhkR1ZrUFNJeU1ESXpMVEF4TFRJMElERTVPakF4T2pVMklpeHRiMlJwWm1sbFpEMGlNakF5TkMw
dwpOeTB3TmlBeE1UbzBPRG96TmlJc2MzUnZjbVZrUFNJeU1ESXpMVEF4TFRJMElERTVPakF4T2pV
MklsMWRiSG8wQUFRQUFBQURBQUFBCk1HNXBiQT09Cjo6IG1haW4ubHVhCi0tW1twb2RfZm9ybWF0
PSJyYXciLGNyZWF0ZWQ9IjIwMjMtMDItMjQgMTk6MDI6MDAiLG1vZGlmaWVkPSIyMDIzLTU0LTEy
IDEwOjU0OjA2IixyZXZpc2lvbj0zXV0KbG9jYWwgY2UKCmZ1bmN0aW9uIF9kcmF3KCkKCglnOmRy
YXdfYWxsKCkgLS0gY292ZXJzIHdob2xlIHNjcmVlbjsgZG9uJ3QgbmVlZCB0byBjbHMoKQoKZW5k
CgpmdW5jdGlvbiBfdXBkYXRlKCkKCgktLSBjb2RlIGVkaXRvciBhbHdheXMgaGFzIGtleWJvYXJk
IGZvY3VzIHdoZW4gc2VhcmNoIGlzIG5vdCBvcGVuCglpZiAobm90IGNlOnNlYXJjaF9ib3hfaXNf
b3BlbigpKSBjZTpzZXRfa2V5Ym9hcmRfZm9jdXModHJ1ZSkKCglnOnVwZGF0ZV9hbGwoKQoKZW5k
CgoKZnVuY3Rpb24gX2luaXQoKQoKCXdpbmRvd3sKCQl0YWJiZWQgPSB0cnVlLAoJCWljb24gICA9
IHVzZXJkYXRhKCJbZ2Z4XTA4MDgwNzcwMDc3MDc3MDAwMDc3NzcwMDAwNzc3NzAwMDA3Nzc3MDAw
MDc3NzcwMDAwNzcwNzcwMDc3MDAwMDAwMDAwWy9nZnhdIiksCgl9CgoJZyA9IGNyZWF0ZV9ndWko
KQoJCgljZSA9IGc6YXR0YWNoX3RleHRfZWRpdG9yKHsKCQl4PTAseT0wLAoJCXdpZHRoPWdldF9k
aXNwbGF5KCk6d2lkdGgoKSwKCQloZWlnaHQ9Z2V0X2Rpc3BsYXkoKTpoZWlnaHQoKSwKCQlzeW50
YXhfaGlnaGxpZ2h0aW5nPXRydWUsCgkJc2hvd19saW5lX251bWJlcnM9dHJ1ZSwKCQltYXJrdXA9
ZmFsc2UsIC0tIHRvIGRvOiByZW1vdmUgbWFya3VwIGZyb20gZWRpdG9yIHdpZGdldAoJCWVtYmVk
X3BvZHM9dHJ1ZSwKCQloYXNfc2VhcmNoPXRydWUKCX0pCgoJY2U6YXR0YWNoX3Njcm9sbGJhcnMo
KQoJCgl3cmFuZ2xlX3dvcmtpbmdfZmlsZSgKCgkJLS0gc2F2ZSB0byBvYmoKCQlmdW5jdGlvbiAo
KQoJCQlyZXR1cm4gdGFibGUuY29uY2F0KGNlOmdldF90ZXh0KCksIlxuIikKCQllbmQsCgoJCS0t
IGxvYWQgZnJvbSBvYmogKGFzc3VtZWQgdG8gYmUgYSBzdHJpbmcpCgkJZnVuY3Rpb24gKHN0ciwg
bWV0YSkKCQkJbG9jYWwgdGV4dCA9IHNwbGl0KHN0ciwgIlxuIiwgZmFsc2UpCgkJCS0taWYgKHRl
eHQpIHByaW50aCgiY29kZTogbG9hZGVkICIuLiN0ZXh0Li4iIGxpbmVzIikKCQkJaWYgKG5vdCB0
ZXh0IG9yICN0ZXh0ID09IDApIHRoZW4gdGV4dCA9IHsiIn0gZW5kCgkJCWNlOnNldF90ZXh0KHRl
eHQpCgkJCWNlLnN5bnRheF9oaWdobGlnaHRpbmcgPSBwd2YoKTpleHQoKSA9PSAibHVhIgoJCWVu
ZCwKCgkJLS0gZGVmYXVsdCBmaWxlbmFtZQoJCSJ1bnRpdGxlZC50eHQiLCAKCgkJLS0gbG9jYXRp
b24gc3RyaW5nCgkJZnVuY3Rpb24oKQoJCQlsb2NhbCB4LHkgPSBjZTpnZXRfY3Vyc29yKCkKCQkJ
cmV0dXJuIHkKCQllbmQsCgoJCS0tIHByb2Nlc3MgbG9jYXRpb24gc3RyaW5nLiBpZiBpdCBpcyBh
IG51bWJlciwganVtcCB0byB0aGF0IG51bWJlcgoJCS0tIHRvIGRvOiAiaG9nZS5sdWEjZnVuY3Rp
b246Zm9vIj8gb3IganVzdCAiaG9nZS5sdWEjZm9vIiB0byBzZWFyY2ggZm9yIHRoYXQgc3RyaW5n
PwoKCQlmdW5jdGlvbihsb2MpCgkJCS0tcHJpbnRoKCJjb2RlIHJlY2lldmVkIGxvYzogIi4ucG9k
KGxvYykpCgkJCWlmIHRvbnVtKGxvYykgdGhlbgoJCQkJLS1wcmludGgoIltjb2RlXSBzZXR0aW5n
IGN1cnNvciB5IHRvOiAiLi5sb2MpCgkJCQljZTpzZXRfY3Vyc29yKG5pbCwgdG9udW0obG9jKSkK
CQkJCS0tY2U6Y2VudGVyX2N1cnNvcigwLjMpIC0tIDAuMyBwdXQgY3Vyc29yIG5lYXJlciB0byB0
b3AuICB0byBkbzogd2h5IGRvZXMgdGhpcyBub3Qgd29yayBvbiBmaXJzdCBsb2FkIHZpYSBpbmZv
YmFyPwoJCQllbmQKCQllbmQKCgkpCgkKCS0tIHRvIGRvOiBtZW51IGl0ZW1zCgktLVtbCgkiXF46
MzA0ODg0ODQ0YzM2MDMwMCBGaW5kIFRleHQgICAgIChDVFJMLUYpIiwKCSJcXjoxZjAwM2YwMDNl
MDA3YzAwIEp1bXAgdG8gTGluZSAgKENUUkwtTCkiLAoJXV0KCgktLSB0ZXN0CgljZTpjZW50ZXJf
Y3Vyc29yKDAuNSkKCmVuZAoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgo6OiB1bnRpdGxlZC50
eHQKLS1bW3BvZF9mb3JtYXQ9InJhdyIsY3JlYXRlZD0iMjAyNC00Mi0yNSAwMTo0MjoxNCIsbW9k
aWZpZWQ9IjIwMjQtNDItMjUgMDE6NDI6MTQiLHJldmlzaW9uPTBdXQoKOjogW2VvY10K
:: apps/about.p64
b64$cGljb3Ryb24gY2FydHJpZGdlIC8vIHd3dy5waWNvdHJvbi5uZXQKdmVyc2lvbiAyCgo6OiAu
aW5mby5wb2QKYjY0JExTMWJXM0J2WkN4dWIzUmxjejBpUm1sc1pTQnRaWFJoWkdGMFlTQjJhV1Yz
WlhJZ1lXNWtJR1ZrYVhSdmNpNWNia05zYVdOcgpJRzl1SUhSb1pTQnBZMjl1SUhSdklHVmthWFFn
YVhRaElpeGhkWFJvYjNJOUlucGxjQ0lzYzNSdmNtVmtQU0l5TURJMExUQXpMVEl6CklERTVPak0w
T2pFMUlpeHBZMjl1UFhWelpYSmtZWFJoS0NKMU9DSXNNVFlzTVRZc0lqQXdNREF3TURBeE1ERXdN
VEF4TURFd01UQXgKTURFd01UQXhNREF3TURBd01EQXdNREF4TURjd056QTNNRGN3TnpBM01EY3dO
ekEzTURjd01UQXdNREF3TURBeE1EY3daREJrTUdRdwpaREJrTUdRd1pEQmtNR1F3WkRBM01ERXdN
REF4TURjd1pEQmtNR1F3WkRBM01EY3dOekEzTUdRd1pEQmtNR1F3TnpBeE1ERXdOekJrCk1HUXda
REEzTURjd1pEQmtNRGN3TnpCa01HUXdaREEzTURFd01UQTNNR1F3WkRBM01EY3dOekEzTURjd056
QTNNRGN3WkRCa01EY3cKTVRBeE1EY3daREJrTURjd056QTNNR1F3WkRBM01EY3dOekJrTUdRd056
QXhNREV3TnpCa01HUXdOekEzTURjd1pEQmtNRGN3TnpBMwpNR1F3WkRBM01ERXdNVEEzTUdRd1pE
QTNNRGN3TnpCa01HUXdOekEzTURjd1pEQmtNRGN3TVRBeE1EY3daREJrTUdRd056QTNNR1F3ClpE
QTNNRGN3WkRCa01HUXdOekF4TURFd056QmtNR1F3WkRCa01EY3dOekEzTURjd1pEQmtNR1F3WkRB
M01ERXdNVEEyTURjd1pEQmsKTUdRd1pEQmtNR1F3WkRCa01HUXdaREEzTURZd01UQXhNRFl3TmpB
M01EY3dOekEzTURjd056QTNNRGN3TnpBM01EWXdOakF4TURBdwpNVEEyTURZd05qQTJNRFl3TmpB
Mk1EWXdOakEyTURZd05qQXhNREF3TURBd01ERXdOakEyTURZd05qQTJNRFl3TmpBMk1EWXdOakF4
Ck1EQXdNREF3TURBd01EQXhNREV3TVRBeE1ERXdNVEF4TURFd01UQXhNREF3TURBd0lpa3NkR2ww
YkdVOUlrRmliM1YwSWl4amNtVmgKZEdWa1BTSXlNREkwTFRBMExUTXdJREU1T2pBNU9qTXpJaXh0
YjJScFptbGxaRDBpTWpBeU5DMHdOeTB3TmlBeE1UbzBPRG96TmlJcwpkbVZ5YzJsdmJqMGlJaXgz
YjNKcmMzQmhZMlZ6UFh0N2JHOWpZWFJwYjI0OUltMWhhVzR1YkhWaEl6a3dJaXgzYjNKcmMzQmhZ
MlZmCmFXNWtaWGc5TVgwc2UyeHZZMkYwYVc5dVBTSm5kV2t1YkhWaEl6RTFNaUlzZDI5eWEzTndZ
V05sWDJsdVpHVjRQVEY5TEh0c2IyTmgKZEdsdmJqMGlhV052Ymk1c2RXRWpNU0lzZDI5eWEzTndZ
V05sWDJsdVpHVjRQVEY5TEh0c2IyTmhkR2x2YmowaVoyWjRMekF1WjJaNApJaXgzYjNKcmMzQmhZ
MlZmYVc1a1pYZzlNbjBzZTJ4dlkyRjBhVzl1UFNKdFlYQXZNQzV0WVhBaUxIZHZjbXR6Y0dGalpW
OXBibVJsCmVEMHpmWDFkWFd4Nk5BQUVBQUFBQXdBQUFEQnVhV3c9Cjo6IGdmeC8KOjogZ2Z4Ly5p
bmZvLnBvZApiNjQkTFMxYlczQnZaQ3hqY21WaGRHVmtQU0l5TURJekxURXdMVEUySURBMk9qTXhP
alV5SWl4dGIyUnBabWxsWkQwaU1qQXlOQzB3Ck55MHdOaUF4TVRvME9Eb3pOaUlzYzNSdmNtVmtQ
U0l5TURJekxUTXhMVEUySURBMk9qTXhPalV5SWwxZGJIbzBBQVFBQUFBREFBQUEKTUc1cGJBPT0K
OjogZ2Z4LzAuZ2Z4CmI2NCRMUzFiVzNCdlpDeGpjbVZoZEdWa1BTSXlNREl6TFRNeUxURTJJREEy
T2pNeU9qRTRJaXh0YjJScFptbGxaRDBpTWpBeU5DMHcKTXkweE15QXdOem93TlRvMU5DSXNjbVYy
YVhOcGIyNDlPVGs0WFYxc2VqUUFCZ0lBQUVZekFBRHpGM3RiTUYwOWUySnRjRDF3ZUhVQQpReUFG
QVFRQUFRMEdCeXhtYkdGbmN6MHdMSEJoYmw5NENBRExlVDB3TEhwdmIyMDlPSDBzTkFCdkR4SVBE
ZzhYTndBYVh4QVFCUER3Ck1RRC1FLU1GQXhjQU53QVhRQWVRQnlBSHNBY1FCN0FIOEFJSkFCd1FF
UUJSSUFlUUIwQXdBQy13QTVrQUhnOHhBUDlELXdIMk5SOFIKOWc0ZDlnNGZIUllmRi1abGNBQWVE
ekVBLTBUZkNWR0FBUzBtQVFCaExUWVIxZ0lBQVU4QkFORUFWUUFobnlZbkFRQmhKamNSMXdJQQpB
UTlWQUNHUEFQRUIxeEVIdlFjRUFBTC1CZGNSRjRZbkVSZUdGd1lSdHdZQkFBRzJBUkRCX2dNZS13
b0FrVkFCZHdZQlFBRjNGZ0V3CkFYY21BU0FCZHpZQkVBRzNCQUFURDlNQUhwQVFvVEFCcGdFUUFR
Y0dBQkFSQ2dBLXRnRUFEZ0FNLXdPV0VSQ3hCd0VRRVpjR0FTQUIKbGdGQWtTQjFBQ0FSclhVQVFL
MEJFQkVLQURfOUFRQU9BQXdVblhVQVh3MEJJQUdkZFFBZ2ItRUJGcGNXRVFRQUJRSnFBb01tZ1JZ
UgpKZ0UzTVFZQVFRRUFBUllJQUM4UTBXMEFITEFna1VBQmx3RWdBUWVkQjc0QUJ5WUNEd1FBQVZB
R0I1MEhCb2NBQVRZQ0QxUUJJeS13CjhERUEtMFJnRWRFQUViY2hNZ1Q1QUJlZEZ4RUhEUkVORmdF
R0RSRU5Cd3dBQUJ3QXo5Y1IzUkU5VVQwQkFOSHdFWmNBSGc4eEFQLS0KLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVdWQnRQVGg5ZlE9PQo6OiBtYXAv
Cjo6IG1hcC8uaW5mby5wb2QKYjY0JExTMWJXM0J2WkN4amNtVmhkR1ZrUFNJeU1ESXpMVEV3TFRF
MklEQTJPak14T2pVeUlpeHRiMlJwWm1sbFpEMGlNakF5TkMwdwpOeTB3TmlBeE1UbzBPRG96TmlJ
c2MzUnZjbVZrUFNJeU1ESXpMVE14TFRFMklEQTJPak14T2pVeUlsMWRiSG8wQUFRQUFBQURBQUFB
Ck1HNXBiQT09Cjo6IG1hcC8wLm1hcApiNjQkTFMxYlczQnZaQ3hqY21WaGRHVmtQU0l5TURJekxU
TXlMVEUySURBMk9qTXlPakU0SWl4dGIyUnBabWxsWkQwaU1qQXlOQzB3Ck15MHhNeUF3Tnpvd05U
bzFOQ0lzY21WMmFYTnBiMjQ5T1RNelhWMXNlalFBWEFBQUFGZ0VBQUR3Q0h0N1ltMXdQWFZ6WlhK
a1lYUmgKS0NKcE1UWWlMREUyQXdBdklqQUJBUC0tLV8teENDSXBMR2hwWkdSbGJqMW1ZV3h6WlN4
d1lXNWZlRDB3Q0FEU2VUMHdMSFJwYkdWZgphRDB4TmdvQUVIY0tBSUI2YjI5dFBURjlmUT09Cjo6
IHNmeC8KOjogc2Z4Ly5pbmZvLnBvZApiNjQkTFMxYlczQnZaQ3hqY21WaGRHVmtQU0l5TURJekxU
RXdMVEUySURBMk9qTXhPalV5SWl4dGIyUnBabWxsWkQwaU1qQXlOQzB3Ck55MHdOaUF4TVRvME9E
b3pOaUlzYzNSdmNtVmtQU0l5TURJekxUTXhMVEUySURBMk9qTXhPalV5SWwxZGJIbzBBQVFBQUFB
REFBQUEKTUc1cGJBPT0KOjogZ3VpLmx1YQotLVtbcG9kX2Zvcm1hdD0icmF3IixjcmVhdGVkPSIy
MDIzLTE3LTIyIDEwOjE3OjU3Iixtb2RpZmllZD0iMjAyNC0wMy0xMyAwNzowNTo1NCIscmV2aXNp
b249OTI2XV0KZnVuY3Rpb24gZ2VuZXJhdGVfZ3VpKCkKCQoJZ3VpID0gY3JlYXRlX2d1aSgpCgkK
CWlmIG1vZGUgPT0gInZpZXciIHRoZW4KCQoJZ3VpOmF0dGFjaF9idXR0b257CgkJeD0tMTAseT0t
NCwKCQlqdXN0aWZ5PSJyaWdodCIsCgkJdmp1c3RpZnk9ImJvdHRvbSIsCgkJbGFiZWwgPSAiRWRp
dCIsCgkJYmdjb2w9MHgwNzBkLAoJCWNsaWNrID0gZnVuY3Rpb24oKQkKCQkJbW9kZSA9ICJlZGl0
IgoJCQlnZW5lcmF0ZV9ndWkoKQoJCWVuZAoJfQoKCS0tIGljb24KCQoJZ3VpOmF0dGFjaHsKCQl4
PTEwLHk9OCwKCQl3aWR0aD0xNiwgaGVpZ2h0PTE2LAoJCWRyYXcgPSBmdW5jdGlvbigpCgkJCXNw
cihtZXRhLmljb24gb3IgZ2V0X3Nwcig4KSwwLDApCgkJZW5kLAoJCWNsaWNrID0gZnVuY3Rpb24o
KQkKCQkJbW9kZSA9ICJpY29uIgoJCQlnZW5lcmF0ZV9ndWkoKQoJCWVuZAoJfQkKCQoJZW5kCgkK
CWlmIG1vZGUgPT0gImljb24iIHRoZW4KCQlndWk6YXR0YWNoKGNyZWF0ZV9pY29uX2VkaXRvcigp
KQoJCWd1aTphdHRhY2goY3JlYXRlX3BhbGV0dGVfY2hvb3NlcigpKQoJCQoJCS0tIHByZXNldHMg
LyB0ZW1wbGF0ZXMKCQlmb3IgeT0wLDEgZG8KCQkJZm9yIHg9MCwzIGRvCgkJCQlndWk6YXR0YWNo
KGNyZWF0ZV9wcmVzZXRfYnV0dG9ue3g9MTEyK3gqMjAsIHk9NDIreSoyMCwgaW5kZXg9eCt5KjR9
KQoJCQllbmQKCQllbmQKCWVuZAoJCglpZiAobW9kZSA9PSAiZWRpdCIpIHRoZW4KCQoJZnVuY3Rp
b24gY3JlYXRlX2ZpZWxkKGxhYmVsLCBrZXksIHgsIHksIGhlaWdodCkKCQoJCS0tIGxhYmVsCgkJ
Z3VpOmF0dGFjaHsKCQkJeCA9IHgtMzAsIHkgPSB5KzQsIGxhYmVsID0gbGFiZWwsCgkJCXdpZHRo
ID0gNDAsIGhlaWdodCA9IDEzLAoJCQlkcmF3ID0gZnVuY3Rpb24oc2VsZikKCQkJCWNsaXAoKQoJ
CQkJcHJpbnQoIlwwMTQiLi5zZWxmLmxhYmVsLCAwLDAsIDUpCgkJCWVuZAoJCX0KCQkKCQlsb2Nh
bCB0ZXh0ZWQgPSBndWk6YXR0YWNoX3RleHRfZWRpdG9yewoJCQl4ID0geCwgeSA9IHksIGtleSA9
IGtleSwKCQkJd2lkdGggPSAxNjAsIGhlaWdodCA9IGhlaWdodCBvciAxMywKCQkJLS1ibG9ja19z
Y3JvbGxpbmcgPSB0cnVlLAoJCQltYXhfbGluZXMgPSAyLAoJCQkKCQkJa2V5X2NhbGxiYWNrID0g
ewoJCQkJZW50ZXIgPSAobm90IGhlaWdodCkgYW5kIGZ1bmN0aW9uICgpIAoJCQkJCS0tIGtlZXAg
bmV3IHZhbHVlIGFuZCBjbG9zZQoJCQkJCS0tbmV3dmFsW2tleV0gPSB0ZXh0ZWQ6Z2V0X3RleHQo
KQoJCQkJZW5kLAoJCQkJZXNjYXBlCSA9IGZ1bmN0aW9uKCkKCQkJCQktLSBjbG9zZSB3aXRob3V0
IGtlZXBpbmcgdmFsdWUKCQkJCQktLSAKCQkJCWVuZCwKCQkJfQoJCX0KCQkKCQlpZiAobWV0YVtr
ZXldKSB0ZXh0ZWQ6c2V0X3RleHQobWV0YVtrZXldKQoJCXRleHRlZC5rZXkgPSBrZXkKCQktLXBy
aW50aCgiYWRkZWQgdGV4dCBmaWVsZCB3aXRoIGtleTogIi4udG9zdHIodGV4dGVkLmtleSkpCgkJ
cmV0dXJuIHRleHRlZAoJZW5kCgkKCS0tIGZpZWxkcwoJbG9jYWwgeHg9MzQKCWZpZWxkID0gewoJ
CWNyZWF0ZV9maWVsZCgidGl0bGUgICIsICJ0aXRsZSIsIHh4LCAxMCksCgkJY3JlYXRlX2ZpZWxk
KCJ2ZXJzaW9uIiwgInZlcnNpb24iLCB4eCwgMjUpLAoJCWNyZWF0ZV9maWVsZCgiYXV0aG9yICIs
ICJhdXRob3IiLCB4eCwgNDApLAoJCWNyZWF0ZV9maWVsZCgibm90ZXMgICIsICJub3RlcyIsIHh4
LCA1NSwgMjYpLAoJCQoJfQoJCgkKCQoJZW5kCgkKCS0tIENhbmNlbCwgU2F2ZSBidXR0b25zIHNo
b3duIGluIGJvdGggZWRpdGluZyBtb2RlcwoJaWYgKG1vZGUgfj0gInZpZXciKSB0aGVuCgkKCWd1
aTphdHRhY2hfYnV0dG9uewoJCWxhYmVsID0gIlNhdmUiLAoJCXg9LTEwLHk9LTQsanVzdGlmeT0i
cmlnaHQiLHZqdXN0aWZ5PSJib3R0b20iLAoJCWJnY29sPTB4MDcwZCwKCQljbGljayA9IGZ1bmN0
aW9uKCkKCQkKCQkJaWYgKG1vZGUgPT0gImljb24iKSB0aGVuCgkJCQltZXRhLmljb24gPSBibXAt
LXVucG9kKHBvZChibXApKQoJCQllbHNlCgkJCQlmb3IgaT0xLCNmaWVsZCBkbwoJCQkJCW1ldGFb
ZmllbGRbaV0ua2V5XSA9IHRhYmxlLmNvbmNhdChmaWVsZFtpXTpnZXRfdGV4dCgpLCJcbiIpCgkJ
CQllbmQKCQkJZW5kCgkJCQoJCQlzeW5jX21ldGFkYXRhKCkKCQkJbW9kZSA9ICJ2aWV3IgoJCQln
ZW5lcmF0ZV9ndWkoKQoJCQkKCQkJLS0gbGV0IGZpbGVuYXYga25vdyAoaW5jYXNlIGljb24gY2hh
bmdlcykKCQkJc2VuZF9tZXNzYWdlKDIsIHsKCQkJCWV2ZW50ID0gImJyb2FkY2FzdCIsCgkJCQlt
c2cgPSB7CgkJCQkJZXZlbnQgPSAiZmlsZW5hdl9yZWZyZXNoIgoJCQkJfQoJCQl9KQoJCQkKCQll
bmQKCX0KCQoJZ3VpOmF0dGFjaF9idXR0b257CgkJbGFiZWwgPSAiQ2FuY2VsIiwKCQl4PS00NSx5
PS00LGp1c3RpZnk9InJpZ2h0Iix2anVzdGlmeT0iYm90dG9tIiwKCQliZ2NvbD0weDA3MGQsCgkJ
Y2xpY2sgPSBmdW5jdGlvbigpCgkJCXN5bmNfbWV0YWRhdGEoKQoJCQltb2RlID0gInZpZXciCgkJ
CWJtcCA9IG5pbAoJCQlnZW5lcmF0ZV9ndWkoKQoJCWVuZAoJfQoJCglpZiAobW9kZSA9PSAiZWRp
dCIpIHRoZW4KCQlndWk6YXR0YWNoX2J1dHRvbnsKCQkJbGFiZWwgPSAiRWRpdCBJY29uIiwKCQkJ
eD0xMCx5PS00LGp1c3RpZnk9ImxlZnQiLHZqdXN0aWZ5PSJib3R0b20iLAoJCQliZ2NvbD0weDA3
MGQsCgkJCWNsaWNrID0gZnVuY3Rpb24oKQoJCQkJbW9kZT0iaWNvbiIKCQkJCWdlbmVyYXRlX2d1
aSgpCgkJCWVuZAoJCX0KCWVuZAoJCgllbmQKCQplbmQKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoK
CgoKCjo6IGljb24ubHVhCi0tW1twb2RfZm9ybWF0PSJyYXciLGNyZWF0ZWQ9IjIwMjMtNDUtMjUg
MDg6NDU6MjAiLG1vZGlmaWVkPSIyMDI0LTAzLTEzIDA3OjA1OjU0IixyZXZpc2lvbj00NTBdXQot
LVtbCgoJc3BlY2lhbGlzZWQgaWNvbiBlZGl0b3IKCWp1c3QgZm9yIGFib3V0IGJveAoKXV0KCmZ1
bmN0aW9uIGNyZWF0ZV9wcmVzZXRfYnV0dG9uKGVsKQoKCWVsLndpZHRoPTE2CgllbC5oZWlnaHQ9
MTYKCWVsLmJtcD1nZXRfc3ByKDI0K2VsLmluZGV4KQoJCglmdW5jdGlvbiBlbDpkcmF3KCkKCQlz
cHIoc2VsZi5ibXAsIDAsIDApCgllbmQKCQoJZnVuY3Rpb24gZWw6Y2xpY2soKQoJCWJsaXQoc2Vs
Zi5ibXAsYm1wKQoJZW5kCgkKCQoJCglyZXR1cm4gZWwKCQplbmQKCmZ1bmN0aW9uIGNyZWF0ZV9w
YWxldHRlX2Nob29zZXIoKQoKCWxvY2FsIGVsID0gewoJCXggPSAxMTAsIHkgPSA2LAoJCXdpZHRo
ID0gNjAsIGhlaWdodCA9IDEyCgl9CgkKCWZ1bmN0aW9uIGVsOmRyYXcobXNnKQoJCWNsaXAoKQoJ
CXJlY3RmaWxsKC0xLC0xLHNlbGYud2lkdGgsc2VsZi5oZWlnaHQsMCkKCQlzc3ByKGdldF9zcHIo
MCksMCwwLDUsMSwwLDAsc2VsZi53aWR0aCxzZWxmLmhlaWdodCkKCQkKCQlmb3IgaT0wLDQgZG8K
CQkJaWYgKGNvbCA9PSBnZXRfc3ByKDApOmdldChpLDApKSB0aGVuCgkJCQlsb2NhbCB3dyA9IHNl
bGYud2lkdGgvNQoJCQkJbG9jYWwgc3ggPSBpICogd3cKCQkJCXJlY3Qoc3gsMCxzeCt3dy0xLHNl
bGYuaGVpZ2h0LTEsMCkKCQkJCXJlY3Qoc3gtMSwwLTEsc3grd3csc2VsZi5oZWlnaHQsNykKCQkJ
ZW5kCgkJZW5kCgkJCgkJLS0gZHVtcCBvdGhlciBzdHVmZiBoZXJlCgkJLS1yZWN0ZmlsbCg3MCww
LDgxLDExLGNvbCkKCQkKCQlzcHIoYm1wLDY4LC0yKQoJCgkJcHJpbnQoIlwwMTQtLSB0ZW1wbGF0
ZXMgLS0tIiwxMCwyNCwxMykKCWVuZAoJCglmdW5jdGlvbiBlbDpkcmFnKG1zZykKCQlsb2NhbCBi
bXAgPSBnZXRfc3ByKDApCgkJbG9jYWwgeCA9IG1zZy5teCAqIGJtcDp3aWR0aCgpIC8gc2VsZi53
aWR0aAoJCWxvY2FsIHkgPSBtc2cubXkgKiBibXA6aGVpZ2h0KCkgLyBzZWxmLmhlaWdodAoJCWNv
bCA9IGJtcDpnZXQoeCx5KQoJZW5kCgkJCglyZXR1cm4gZWwKZW5kCgoKCmZ1bmN0aW9uIGNyZWF0
ZV9pY29uX2VkaXRvcigpCgoJbG9jYWwgZWQgPSB7CgkJeD02LHk9NiwKCQl3aWR0aD05NixoZWln
aHQ9OTYKCX0KCQoJLS0gZ2xvYmFsCgljb2wgPSA3CgkKCWJtcCA9IHVzZXJkYXRhKCJ1OCIsMTYs
MTYpCgkKCWxvY2FsIGJtcF93aWR0aCA9IGJtcDp3aWR0aCgpCglsb2NhbCBibXBfaGVpZ2h0PSBi
bXA6aGVpZ2h0KCkKCWlmIChtZXRhLmljb24pIGJsaXQobWV0YS5pY29uLCBibXAsIDAsIDAsIDAs
IDApCgkKCWZ1bmN0aW9uIGVkOmRyYXcobXNnKQoJCWNsaXAoKQoJCXJlY3RmaWxsKC0xLC0xLHNl
bGYud2lkdGgsc2VsZi5oZWlnaHQsMCkKCQlzc3ByKGJtcCwwLDAsMTYsMTYsMCwwLHNlbGYud2lk
dGgsc2VsZi5oZWlnaHQpCgkJCgllbmQKCQoJZnVuY3Rpb24gZWQ6ZHJhZyhtc2cpCgkJbG9jYWwg
eCA9IG1zZy5teCAqIGJtcF93aWR0aCAvIHNlbGYud2lkdGgKCQlsb2NhbCB5ID0gbXNnLm15ICog
Ym1wX2hlaWdodCAvIHNlbGYuaGVpZ2h0CgkJaWYgKG1zZy5tYiA_IDEpIHRoZW4KCQkJY29sID0g
Z2V0KGJtcCx4LHksY29sKQoJCWVsc2UKCQkJc2V0KGJtcCx4LHksY29sKQoJCWVuZAoJZW5kCgkK
CQoJcmV0dXJuIGVkCmVuZAoKCgoKCgoKCgoKCgoKCgoKCgoKCjo6IG1haW4ubHVhCi0tW1twb2Rf
Zm9ybWF0PSJyYXciLGNyZWF0ZWQ9IjIwMjMtMzItMTYgMDY6MzI6MTgiLG1vZGlmaWVkPSIyMDI0
LTAzLTEzIDA3OjA1OjU0IixyZXZpc2lvbj0xMTc2XV0KLS1bWwoKCWFib3V0LnA2NAoJZ2VuZXJh
bCBwdXJwb3NlIG1ldGFkYXRhIHZpZXdlciBhbmQgZWRpdG9yCgkKCWZ1dHVyZTogY2FsY3VsYXRl
IHRvdGFsIHNpemUgb2YgZm9sZGVyCglmdXR1cmU6IG1hbmFnZSBjdXJyZW50IGNhcnRyaWRnZSAo
Q2FydHJpZGdlIEluZm8gZnJvbSBwaWNvdHJvbiBtZW51KQoJZnV0dXJlOiBzeXN0ZW0gaW5mbyAo
d2hlbiBpbnNwZWN0aW5nIC9zeXN0ZW0pCglmdXR1cmU6IG11bHRpcGxlIGZpbGVzIGFuZCBmbGlw
IHRocm91Z2ggdGhlbSAoZS5nLiBDVFJMLUEsIENUUkwtSSkKCQpdXQoKaW5jbHVkZSAiaWNvbi5s
dWEiCmluY2x1ZGUgImd1aS5sdWEiCgotLSB2aWV3LCBlZGl0LCBpY29uCm1vZGUgPSAidmlldyIK
CmZ1bmN0aW9uIHN5bmNfbWV0YWRhdGEoKQoKCWlmIChtZXRhKSBzdG9yZV9tZXRhZGF0YShmbiwg
bWV0YSkKCW1ldGEgPSBtZXRhIG9yIGZldGNoX21ldGFkYXRhKGZuKSBvciB7fQoJLS1wcmludGgo
IlthM10gZmV0Y2hpbmcgbWV0YWRhdGEgZm9yIGZpbGU6ICIuLmZuLi4iICAvLyBwYXRoOiIuLnB3
ZCgpKQoJCmVuZAoKYnVubnkgPSB1c2VyZGF0YSJbZ2Z4XTEwMTAwMDAwMDAwMDAwMDAwMDAwMDAw
MTExMTExMTExMTAwMDAwMWRkZGRkZGRkZGQxMDAwMWQxMTExMTExMTExZDEwMWQxMTExMTExMTEx
MTFkMTFkMTExNzcxMTc3MTExZDExZDExMTc3MTE3NzExMWQxMWQxMTE3NzExNzcxMTFkMTFkMTEx
Nzc3Nzc3MTExZDExZDExMTcxNzcxNzExMWQxMWQxMTE3Nzc3NzcxMTFkMTFkMTExMTExMTExMTEx
ZDEwMWQxMTExMTExMTExZDEwMDAxZGRkZGRkZGRkZDEwMDAwMDExMTExMTExMTEwMDAwMDAwMDAw
MDAwMDAwMDAwWy9nZnhdIgoKZnVuY3Rpb24gX2luaXQoKQoJCgljbHMoNykKCQoJcG9rZSgweDQw
MDAsZ2V0KGZldGNoIi9zeXN0ZW0vZm9udHMvbGlsLmZvbnQiKSkKCXBva2UoMHg1NjAwLGdldChm
ZXRjaCIvc3lzdGVtL2ZvbnRzL3A4LmZvbnQiKSkKCXBva2UoMHg1NjAyLDYpIC0tIHRvIGRvOiBz
aG91bGQgYmUgc3RhbmRhcmQgZm9yIHA4LmZvbnQKCQoJY2QoZW52KCkucGF0aCkgLS0gY2FuIHVz
ZSBmcm9tIHRlcm1pbmFsCglmbiA9IGVudigpLmFyZ3ZbMV0gb3IgZW52KCkucHJvZyBvciAiL3Jh
bS9jYXJ0IgoJCgktLXByaW50aCgiW2EzXSBpbml0aWFsIGZuOiAiLi5mbikKCWZuID0gZnVsbHBh
dGgoZm4pCgkKCWxvY2FsIHNlZ3MgPSBzcGxpdChmbiwiLyIsZmFsc2UpCglmbl9zaG9ydCA9IHNl
Z3NbI3NlZ3NdCglmbl9wYXRoICA9IHN0cmluZy5zdWIoZm4sIDEsIC0jc2Vnc1sjc2Vnc10gLSAy
KQoKCWNkKGZuX3BhdGgpIC0tIHNhbWUgcGF0aCBhcyB0aGUgZmlsZSBvciBmb2xkZXIgaW4gcXVl
c3Rpb24KCQoJLS1wcmludGgoIlthM10gY2hhbmdlZCB0byBmbl9wYXRoOiAiLi5mbl9wYXRoKQoK
CXN5bmNfbWV0YWRhdGEoKQoJCgl3aW5kb3d7CgkJd2lkdGggPSAyMDAsCgkJaGVpZ2h0ID0gMTA4
LAoJCXRpdGxlID0gIkFib3V0IgoJfQoJCglnZW5lcmF0ZV9ndWkoKQoJCmVuZAoKZnVuY3Rpb24g
X2RyYXcoKQoJY2xzKDYpCgkKCWlmIChtb2RlID09ICJ2aWV3IikgdGhlbgoJLS1yZWN0ZmlsbCgw
LDAsMTAwMCwzMiw3KQoJCgktLSBzcHJpdGUgaGFuZGxlZCBieSBndWkgZWxlbWVudAoJLS1zcHIo
bWV0YS5pY29uIG9yIGdldF9zcHIoOCksMTAsOCkKCQoJbG9jYWwgdGl0bGUgPSBtZXRhLnRpdGxl
CglpZiAodHlwZSh0aXRsZSkgfj0gInN0cmluZyIpIHRpdGxlID0gZm5fc2hvcnQgb3IgIiIKCQoJ
CQoJbG9jYWwgdmVyc2lvbiA9IG1ldGEudmVyc2lvbgoJaWYgKHR5cGUodmVyc2lvbikgfj0gInN0
cmluZyIpIHZlcnNpb24gPSBuaWwKCQoJbG9jYWwgYXV0aG9yID0gbWV0YS5hdXRob3IgCglpZiAo
dHlwZShhdXRob3IpIH49ICJzdHJpbmciKSBhdXRob3IgPSBuaWwKCQoJdGl0bGUuLj0gIiBcMDE0
XF5pXHxoIi0tLi5tZXRhLnZlcnNpb24KCQoJcHJpbnQodGl0bGUsIDM0LCAodmVyc2lvbiBvciBh
dXRob3IpIGFuZCA4IG9yIDEyLCAxKQoJCgkJbG9jYWwgc3RyID0gIlwwMTQiCgkJaWYgKHZlcnNp
b24pIHN0ci4uPSAiXF5pIi4ubWV0YS52ZXJzaW9uLi4iXF4taSAiCgkJaWYgKGF1dGhvciBhbmQg
YXV0aG9yIH49ICIiKSBzdHIuLj0gIlxmZGJ5ICIuLm1ldGEuYXV0aG9yOmxvd2VyKCkKCQlwcmlu
dChzdHIsIDMzLCAyMCwgMTMpCQoJCQotLVtbCglpZiAobWV0YS5hdXRob3IgYW5kIG1ldGEuYXV0
aG9yICE9ICIiKSB0aGVuCgkJY3Vyc29yKDEwLDMyKSBjb2xvcigxMykKCQlwcmludCgiLy8gYnkg
Ii4ubWV0YS5hdXRob3IpCgllbmQKXV0KCgktLSAyIGxpbmVzIG9mIG5vdGVzCglpZiAobWV0YS5u
b3RlcyBhbmQgbWV0YS5ub3RlcyAhPSAiIikgdGhlbgoJCWN1cnNvcigxMCwzOCkgY29sb3IoNSkK
CQlwcmludChtZXRhLm5vdGVzKQoJZW5kCgkKCQoJbG9jYWwgYXR0cmlicywgc2l6ZSwgb3JpZ2lu
ID0gZnN0YXQoZm4pCgkKCWxvY2FsIHl5ID0gZ2V0X2Rpc3BsYXkoKTpoZWlnaHQoKS0zOAoJaWYg
KG5vdCBvcmlnaW4pIHl5ICs9IDYKCWN1cnNvcigxMCwgeXkpIGNvbG9yKDEzKQoJLS0-IlwwMTRh
dXRob3I6ICAgICIuLigiemVwIiBvciAiLSIpCgktLT8iXDAxNHJldmlzaW9uOiAgIi4uKG1ldGEu
cmV2aXNpb24gb3IgIi0iKQoKCS0tcmVjdGZpbGwoMCx5eS00LDEwMDAsMTAwMCwxKQoJY29sb3Io
MTMpCgk-IlwwMTQiLi4oZm4gb3IgIj8iKQoJPyJcMDE0Ii4uKChzaXplIGFuZCAoc2l6ZS4uIiBi
eXRlcyBvbiBkaXNrIikpIG9yICItIikKCgktLSBsb2NhbCB0aW1lczsgdG8gZG86IGNsaWNrIHRv
IHRvZ2dsZSBnbXQKCS0tIHRvIGRvOiBuIGRheXMgYWdvCgk-IlwwMTQiLi4obWV0YS5jcmVhdGVk
IGFuZCBkYXRlKCIlWS0lbS0lZCAlSDolTTolUyIsIG1ldGEuY3JlYXRlZCkgb3IgIltubyBkYXRl
X2NyZWF0ZWRdIikKCT8iXDAxNCIuLihtZXRhLm1vZGlmaWVkIGFuZCBkYXRlKCIlWS0lbS0lZCAl
SDolTTolUyIsIG1ldGEubW9kaWZpZWQpIG9yICJbbm8gZGF0ZV9tb2RpZmllZF0iKQoJaWYgKG9y
aWdpbikgdGhlbgoJPyJcMDE0b3JpZ2luOiAiLi4ob3JpZ2luIG9yIGZ1bGxwYXRoKGZuKSBvciAi
PyIpCQoJZW5kCgkKCWVuZCAtLSAidmlldyIgbW9kZQoJCgkKCWd1aTpkcmF3X2FsbCgpCmVuZAoK
ZnVuY3Rpb24gX3VwZGF0ZSgpCgoJaWYgKGtleSJjdHJsIikgdGhlbgoJCgkJaWYgKG1vZGUgPT0g
Imljb24iKSB0aGVuCgkJCWlmIChrZXlwKCJ2IikpIHRoZW4KCQkJCWxvY2FsIGMsbSA9IHVucG9k
KGdldF9jbGlwYm9hcmQoKSkKCQkJCgkJCQlpZiAodHlwZShjKT09InVzZXJkYXRhIiBhbmQgYzp3
aWR0aCgpPT0xNiBhbmQgYzpoZWlnaHQoKT09MTYpIHRoZW4KCQkJCQltZXRhLmljb24gPSBjCgkJ
CQkJYm1wID0gYyAtLSBpbiBjYXNlIGluc2lkZSBlZGl0b3IKCQkJCQlzeW5jX21ldGFkYXRhKCkJ
CgkJCQllbmQKCQkKCQkJZW5kCgkJCgkJCS0tIGNvcHkgaWNvbgoJCQlpZiAoa2V5cCgiYyIpKSB0
aGVuCgkJCQlsb2NhbCBiYiA9IGJtcCBvciBtZXRhLmljb24KCQkJCWlmIChiYikgdGhlbiAKCQkJ
CQlzZXRfY2xpcGJvYXJkKHBvZChiYikse3BvZF90eXBlPSJpbWFnZSJ9KQoJCQkJCW5vdGlmeSgi
Y29waWVkIGljb24iKQoJCQkJZW5kCgkJCWVuZAoJCWVuZAoJCgllbmQKCQoJZ3VpOnVwZGF0ZV9h
bGwoKQplbmQKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCjo6IFtlb2NdCg==
:: apps/gfx.p64
b64$cGljb3Ryb24gY2FydHJpZGdlIC8vIHd3dy5waWNvdHJvbi5uZXQKdmVyc2lvbiAyCgo6OiAu
aW5mby5wb2QKYjY0JExTMWJXM0J2WkN4amNtVmhkR1ZrUFNJeU1ESXpMVEV3TFRFNUlERXlPalV3
T2pVd0lpeGhkWFJvYjNJOUlteGxlR0ZzYjJabQpiR1VpTEc1dmRHVnpQU0lpTEdsamIyNDlkWE5s
Y21SaGRHRW9JblU0SWl3eE5pd3hOaXdpTURBd01EQXdNREV3TVRBeE1ERXdNVEF4Ck1ERXdNVEF4
TURFd01EQXdNREF3TURBd01ERXdOekEzTURjd056QTNNRGN3TnpBM01EY3dOekF4TURBd01EQXdN
REV3TnpCa01HUXcKWkRCa01HUXdaREJrTUdRd1pEQmtNRGN3TVRBd01ERXdOekJrTUdRd1pEQmtN
R1F3WkRCa01HUXdaREJrTUdRd1pEQTNNREV3TVRBMwpNR1F3WkRCa01EY3dOekJrTUdRd056QTNN
R1F3WkRCa01EY3dNVEF4TURjd1pEQmtNR1F3TnpBM01HUXdaREEzTURjd1pEQmtNR1F3Ck56QXhN
REV3TnpCa01HUXdaREEzTURjd1pEQmtNRGN3TnpCa01HUXdaREEzTURFd01UQTNNR1F3WkRCa01E
Y3dOekEzTURjd056QTMKTUdRd1pEQmtNRGN3TVRBeE1EY3daREJrTUdRd056QmtNRGN3TnpCa01E
Y3daREJrTUdRd056QXhNREV3TnpCa01HUXdaREEzTURjdwpOekEzTURjd056QmtNR1F3WkRBM01E
RXdNVEEzTUdRd1pEQmtNR1F3WkRCa01HUXdaREJrTUdRd1pEQmtNRGN3TVRBeE1EWXdOekJrCk1H
UXdaREJrTUdRd1pEQmtNR1F3WkRCa01EY3dOakF4TURFd05qQTJNRGN3TnpBM01EY3dOekEzTURj
d056QTNNRGN3TmpBMk1ERXcKTURBeE1EWXdOakEyTURZd05qQTJNRFl3TmpBMk1EWXdOakEyTURF
d01EQXdNREF3TVRBMk1EWXdOakEyTURZd05qQTJNRFl3TmpBMgpNREV3TURBd01EQXdNREF3TURF
d01UQXhNREV3TVRBeE1ERXdNVEF4TURFd01EQXdNREFpS1N4dGIyUnBabWxsWkQwaU1qQXlOQzB3
Ck55MHdOaUF4TVRvME9Eb3pOaUlzY25WdWRHbHRaVDAxTEhOMGIzSmxaRDBpTWpBeU5DMHdNeTB5
TWlBeE1UbzBNem94TWlJc2RHbDAKYkdVOUlsQnBZMjkwY205dUlGQnBlR1ZzY3lJc2RtVnljMmx2
YmowaU1DNHhJaXgzYjNKcmMzQmhZMlZ6UFh0N2JHOWpZWFJwYjI0OQpJbTFoYVc0dWJIVmhJekl5
TXlJc2QyOXlhM053WVdObFgybHVaR1Y0UFRGOUxIdHNiMk5oZEdsdmJqMGlaSEpoZHk1c2RXRWpN
U0lzCmQyOXlhM053WVdObFgybHVaR1Y0UFRGOUxIdHNiMk5oZEdsdmJqMGlkWEJrWVhSbExteDFZ
U00yT1NJc2QyOXlhM053WVdObFgybHUKWkdWNFBURjlMSHRzYjJOaGRHbHZiajBpYm1GMkxteDFZ
U015T0NJc2QyOXlhM053WVdObFgybHVaR1Y0UFRGOUxIdHNiMk5oZEdsdgpiajBpWjNWcExteDFZ
U014TWpBaUxIZHZjbXR6Y0dGalpWOXBibVJsZUQweGZTeDdiRzlqWVhScGIyNDlJbU5oYm5aaGN5
NXNkV0VqCk1qUTBJaXgzYjNKcmMzQmhZMlZmYVc1a1pYZzlNWDBzZTJ4dlkyRjBhVzl1UFNKblpu
Z3ZNQzVuWm5naUxIZHZjbXR6Y0dGalpWOXAKYm1SbGVEMHlmU3g3Ykc5allYUnBiMjQ5SW1kbWVD
OHdMbWRtZUNJc2QyOXlhM053WVdObFgybHVaR1Y0UFRkOWZWMWRiSG8wQUFRQQpBQUFEQUFBQU1H
NXBiQT09Cjo6IGNhbnZhcy5sdWEKLS1bW3BvZF9mb3JtYXQ9InJhdyIsY3JlYXRlZD0iMjAyMy0w
NC0xMSAwMjowNDowMiIsbW9kaWZpZWQ9IjIwMjQtMDQtMDkgMDk6MjA6MzYiLHJldmlzaW9uPTI5
MzUsc3RvcmVkPSIyMDIzLTI0LTI4IDAwOjI0OjAwIl1dCmxvY2FsIHd3LGhoPTAsMApsb2NhbCBm
aWxsX2NwdT0wCmxvY2FsIHgwLHkwPTAsMApmdW5jdGlvbiBkb19maWxsXzAoYm1wLCB4LCB5LCB0
YykKCglpZiAoZ2V0KGJtcCx4LHkpICE9IHRjKSByZXR1cm4KCWlmICh4IDwgMCBvciB5IDwgMCBv
ciB4ID49IHd3IG9yIHkgPj0gaGgpIHJldHVybgoKCWxvY2FsIGwscj14LHgKCXdoaWxlKGdldChi
bXAsbCx5KT09dGMgYW5kIGw_PTApIGwtPTEKCWwrPTEKCXdoaWxlKGdldChibXAscix5KT09dGMg
YW5kIHI8d3cpIHIrPTEKCXItPTEKCQoJZm9yIHh4PWwsciBkbwoJCXNldChibXAseHgseSxjb2wp
CgllbmQKCQoJaWYgKHkgPiAwKSB0aGVuCgkJbG9jYWwgbGFzdCA9IG5pbAoJCWZvciB4eD1sLHIg
ZG8KCQkJbG9jYWwgdmFsID0gZ2V0KGJtcCx4eCx5LTEpID09IHRjCgkJCWlmICh2YWwgYW5kIG5v
dCBsYXN0KSB0aGVuCgkJCQlkb19maWxsXzAoYm1wLHh4LHktMSx0YykKCQkJZW5kCgkJCWxhc3Qg
PSB2YWwKCQllbmQKCWVuZAoJCglpZiAoeSA8IGhoLTEpIHRoZW4KCQlsb2NhbCBsYXN0ID0gbmls
CgkJZm9yIHh4PWwsciBkbwoJCQlsb2NhbCB2YWwgPSBnZXQoYm1wLHh4LHkrMSkgPT0gdGMKCQkJ
aWYgKHZhbCBhbmQgbm90IGxhc3QpIHRoZW4KCQkJCWRvX2ZpbGxfMChibXAseHgseSsxLHRjKQoJ
CQllbmQKCQkJbGFzdCA9IHZhbAoJCWVuZAoJZW5kCgkKCS0tICNwdXRhZmxpcGluaXQKCS0tIHRv
IGRvOiB3aHkgaXMgdGhpcyBjYXVzaW5nIHdtIGZsaWNrZXIgdy8gbG93IHZhbHVlcyAoMC4yNSkg
fiBob3cgaXMgdGhhdCBwb3NzaWJsZT8KCS0tIG9oLi4gaXMganVzdCB0aGUgYXBwIGd1aT8gbmVl
ZCB0byBtYW51YWxseSBob2xkIGZyYW1lIGFnYWluIGFmdGVyIGZsaXAuIGJsZWguCgktLVtbCglp
ZiAoc3RhdCgxKSAtIGZpbGxfY3B1ID4gMikgdGhlbgoJCWZpbGxfY3B1ID0gc3RhdCgxKSBndWk6
ZHJhd19hbGwoKSBmbGlwKCkKCQlwb2tlKDB4NTQ3YywgMSkgLS0ga2VlcCBob2xkaW5nIGZyYW1l
CgllbmQKCV1dCgkKZW5kCgpmdW5jdGlvbiBkb19maWxsKGJtcCwgeCwgeSkKCWxvY2FsIHRjID0g
Z2V0KGJtcCwgeCwgeSkKCWlmIChjb2wgPT0gdGMpIHJldHVybgoJd3csaGggPSBibXA6YXR0cmli
cygpCglmaWxsX2NwdSA9IDAKCXJldHVybiBkb19maWxsXzAoYm1wLCB4LCB5LCB0YykKZW5kCgpm
dW5jdGlvbiBjcmVhdGVfb3V0bGluZShibXAsIHd3LCBoaCkKCglsb2NhbCBvdXQgPSB1c2VyZGF0
YSgidTgiLCB3dysyLCBoaCsyKSAtLSAxcHggYm91bmRhcnkKCXNldF9kcmF3X3RhcmdldChvdXQp
CgkKCXNzcHIoYm1wLCAwLCAwLCBfLCBfLDEsIDEsIHd3LCBoaCkKCQoJd3cgKz0gMiBoaCArPSAy
CgkKCWxvY2FsIG91dDAgPSBvdXQ6Y29weSgpCgkKCS0tb3V0ID0gb3V0OmFkZChvdXQsIG91dCwg
bmlsLCAyKSAtLSB3aG9hIQoJLS0gc3JjX29mZnNldCwgZGVzdF9vZmZzZXQsIGl0ZW1fd2lkdGgs
IHNyY19zdHJpZGUsIGRlc3Rfc3RyaWRlLCBudW1faXRlbXMKCW91dDphZGQob3V0MCwgdHJ1ZSwg
d3crMSwgd3crMCwgd3ctMSwgd3csIHd3LCBoaC0yKQoJb3V0OmFkZChvdXQwLCB0cnVlLCB3dysx
LCB3dysyLCB3dy0xLCB3dywgd3csIGhoLTIpCglvdXQ6YWRkKG91dDAsIHRydWUsIHd3KzEsIHd3
KjArMSwgd3ctMSwgd3csIHd3LCBoaC0yKQoJb3V0OmFkZChvdXQwLCB0cnVlLCB3dysxLCB3dyoy
KzEsIHd3LTEsIHd3LCB3dywgaGgtMikKCQoJLS0gZGlzY28KCWZvciB5PTAsaGgtMSBkbwoJCW91
dDphZGQoOCsoKHlcMyklMykqOCwgdHJ1ZSwgMCwgeSp3dywgNCwgMCwgOCwgd3cvOCsxKQoJZW5k
CgkKCW91dDphZGQoOCwgdHJ1ZSwgIDAsIDAsIHd3KjQsIHd3LCB3dyo4LCBoaC84KzEpCgkKCXNl
dF9kcmF3X3RhcmdldCgpCglyZXR1cm4gb3V0CmVuZAoKCgpmdW5jdGlvbiB1ZHJlY3RmaWxsKHVk
LCB4MCwgeTAsIHgxLHkxLCBjb2wpCglpZiAodHlwZSh1ZCkgfj0gInVzZXJkYXRhIikgcmV0dXJu
Cgl4MFw9MSB5MFw9MSB4MVw9MSB5MVw9MQoJaWYgKHgxPHgwKXgwLHgxPXgxLHgwCglpZiAoeTE8
eTApeTAseTE9eTEseTAKCQoJeDAgPSBtYXgoMCwgeDApCgl5MCA9IG1heCgwLCB5MCkKCglsb2Nh
bCB3aWR0aCwgaGVpZ2h0ID0gKHgxLXgwKSsxLCAoeTEteTApKzEKCXdpZHRoID0gbWluKHdpZHRo
LCB1ZDp3aWR0aCgpLXgwKQoJaGVpZ2h0ID0gbWluKGhlaWdodCwgdWQ6aGVpZ2h0KCkteTApCgkK
CWlmICh3aWR0aCA8IDEgb3IgaGVpZ2h0IDwgMSkgcmV0dXJuCgkKCWxvY2FsIHVkdyA9IHVkOndp
ZHRoKCkKCXVkOmNvcHkoY29sLCB0cnVlLCBuaWwsIHgwK3kwKnVkdyx3aWR0aCwgbmlsLHVkdyxo
ZWlnaHQpCmVuZAoKZnVuY3Rpb24gY3JlYXRlX2NhbnZhcyhlbCkKCglsb2NhbCB3dyxoaCx4MCx5
MAoJbG9jYWwgZHJhZ194MCxkcmFnX3kwID0gMCwwCglsb2NhbCBtdG9vbAoJCgkKCQoJZnVuY3Rp
b24gZWw6dXBkYXRlKCkKCQoJCWVsLmN1cnNvciA9ICJjcm9zc2hhaXIiCgkJaWYgKG10b29sID09
ICJwYW4iKSBlbC5jdXJzb3IgPSAiZ3JhYiIKCQlpZiAobXRvb2wgPT0gImZpbGwiKSBlbC5jdXJz
b3IgPSBnZXRfc3ByKDU2KQoJCQoJCQoJCS0tIHNhZmV0eSBbZHVyaW5nIGRldl0KCQljaS56b29t
ID0gY2kuem9vbSBvciAxCgkJY2kucGFuX3ggPSBjaS5wYW5feCBvciAwCgkJY2kucGFuX3kgPSBj
aS5wYW5feSBvciAwCgkJCgkJd3cgPSBjYm1wX3dpZHRoICAqIGNpLnpvb20KCQloaCA9IGNibXBf
aGVpZ2h0ICogY2kuem9vbQoJCQoJCW10b29sID0gY3Rvb2wKCQlpZiAoa2V5InNwYWNlIikgbXRv
b2wgPSAicGFuIgoJCWlmIChrZXkicyIpIG10b29sID0gInNlbGVjdCIKCQkKCQktLSBwaXhlbCBs
b29raW5nIGF0IGluIGNlbnRlcgoJCWxvY2FsIHB4ID0gY2JtcF93aWR0aC8yICArIGNpLnBhbl94
CgkJbG9jYWwgcHkgPSBjYm1wX2hlaWdodC8yICsgY2kucGFuX3kKCQkKCQl4MCA9IGVsLndpZHRo
XDIgIC0gcHggKiBjaS56b29tCgkJeTAgPSBlbC5oZWlnaHRcMiAtIHB5ICogY2kuem9vbQoJCQoJ
ZW5kCgkKCWZ1bmN0aW9uIGVsOmNsaWNrKG1zZykKCQliYWNrdXBfc3RhdGUoKQoJCQoJCWlmIG10
b29sID09ICJzZWxlY3QiIHRoZW4KCQkJLS0gbmVlZHMgdG8gaGFwcGVuIGZpcnN0IGZvciBjYWxj
dWxhdGluZyB4LHkKCQkJY2xlYXJfc2VsZWN0aW9uKCkKCQllbmQKCQkKCQlsb2NhbCB4ID0gKG1z
Zy5teCAtIHgwKSBcIGNpLnpvb20KCQlsb2NhbCB5ID0gKG1zZy5teSAtIHkwKSBcIGNpLnpvb20K
CQlsb2NhbCB4eCx5eSA9IHgseQoJCWlmIChjaS5sYXllcikgeC09IGNpLmxheWVyX3ggeS09IGNp
LmxheWVyX3kKCQktLXByaW50aCgiY2xpY2s6ICIuLnBvZHt4LHl9KQoJCQoJCQoJCS0tIHRhcmdl
IGJpdG1hcDogZHJhdyB0byBmbG9hdGluZyBsYXllciBpZiBpdCBleGlzdHMKCQlsb2NhbCB0Ym1w
ID0gY2kubGF5ZXIgb3IgY2JtcCAKCQlsb2NhbCB0Ym1wX3dpZHRoLCB0Ym1wX2hlaWdodCA9IHRi
bXA6YXR0cmlicygpCgkJaWYgKHR5cGUodGJtcCl_PSJ1c2VyZGF0YSIpIHRibXA9Y2JtcCBwcmlu
dGgoIioqIG5vIHRibXAhISIpCgkJCgkJZHJhZ194MCAgPSB4ICBkcmFnX3kwICA9IHkKCQljbGlj
a194MCA9IHggIGNsaWNrX3kwID0geSAKCQljbGlja194eDAgPSB4eCAgY2xpY2tfeXkwID0geXkK
CQlvcF9ibXAgPSB0Ym1wOmNvcHkoKQoJCWJsaXQodGJtcCwgb3BfYm1wKSAtLSB0byBkbzogcmVt
b3ZlCgkJCgkJCgkJCgkJaWYgbXRvb2wgPT0gImZpbGwiIHRoZW4KCQkJZG9fZmlsbCh0Ym1wLCB4
LCB5KQoJCWVuZAoJCQoJCS0tIHJlcGxhY2UKCQlpZiAobXRvb2wgPT0gInBlbmNpbCIgYW5kIGtl
eSJjdHJsIikgdGhlbgoJCQlsb2NhbCBjb2wwID0gZ2V0KHRibXAsIHgseSkKCQkJZm9yIHl5PTAs
dGJtcF9oZWlnaHQtMSBkbwoJCQkJZm9yIHh4PTAsdGJtcF93aWR0aC0xIGRvCgkJCQkJaWYgKGdl
dCh0Ym1wLHh4LHl5KSA9PSBjb2wwKSBzZXQodGJtcCx4eCx5eSxjb2wpCgkJCQllbmQKCQkJZW5k
CgkJZW5kCgkJCgllbmQKCQoJCglmdW5jdGlvbiBlbDpkcmFnKG1zZykKCQktLSB0YXJnZSBiaXRt
YXA6IGRyYXcgdG8gZmxvYXRpbmcgbGF5ZXIgaWYgaXQgZXhpc3RzCgkJbG9jYWwgdGJtcCA9IGNp
LmxheWVyIG9yIGNibXAgCgkJCgkJc2V0X2RyYXdfdGFyZ2V0KHRibXApCgkJCgkJbG9jYWwgeCA9
IChtc2cubXggLSB4MCkgXCBjaS56b29tCgkJbG9jYWwgeSA9IChtc2cubXkgLSB5MCkgXCBjaS56
b29tCgkJbG9jYWwgeHgseXkgPSB4LHkKCQlpZiAoY2kubGF5ZXIpIHRoZW4KCQkJc2V0X2RyYXdf
dGFyZ2V0KGNpLmxheWVyKQoJCQl4LT0gY2kubGF5ZXJfeCB5LT0gY2kubGF5ZXJfeQoJCWVuZAoJ
CQoJCWlmIChtdG9vbCA9PSAicGFuIikgdGhlbgoJCQljaS5wYW5feCAtPSBtc2cuZHggLyBjaS56
b29tCgkJCWNpLnBhbl95IC09IG1zZy5keSAvIGNpLnpvb20KCQllbHNlaWYgbXRvb2wgPT0gInN0
YW1wIiB0aGVuCgkJCWlmIChsYXN0X3N0YW1wX2JtcF9zdHIgfj0gZ2V0X2NsaXBib2FyZCgpKSB0
aGVuCgkJCQlsYXN0X3N0YW1wX2JtcF9zdHIgPSBnZXRfY2xpcGJvYXJkKCkKCQkJCWxhc3Rfc3Rh
bXBfYm1wID0gdW5wb2QobGFzdF9zdGFtcF9ibXBfc3RyKQoJCQllbmQKCQkKCQkJbG9jYWwgYm1w
ID0gbGFzdF9zdGFtcF9ibXAKCQkJaWYgKHR5cGUoYm1wKSA9PSAidXNlcmRhdGEiKSB0aGVuCgkJ
CQlibGl0KG9wX2JtcCwgdGJtcCkKCQkJCXNldF9kcmF3X3RhcmdldCh0Ym1wKQoJCQkJbG9jYWwg
d3csaGggPSBibXA6YXR0cmlicygpCgkJCQktLSBpbnZlcnRlZCBwaWNvLTggYmVoYXZpb3VyISB0
cmFuc3BhcmVuY3kgYnkgZGVmYXVsdAoJCQkJaWYgKGtleSJjdHJsIikgcmVjdGZpbGwoeC13dy8y
LHktaGgvMix4K3d3LzItMSx5K2hoLzItMSwwKQoJCQkJc3ByKGJtcCwgeCAtIHd3LzIsIHkgLSBo
aC8yKQoJCQkJc2V0X2RyYXdfdGFyZ2V0KCkKCQkJZW5kCgkJCgkJZWxzZWlmIChtdG9vbCA9PSAi
c2VsZWN0IikgdGhlbgoJCQktLSB4eCx5eSAtLSBub3QgcmVsYXRpdmUgdG8gc2VsZWN0aW9uCgkJ
CWNzZWw6Y2xlYXIoKQoJCQlzZXRfZHJhd190YXJnZXQoY3NlbCkKCQkJcmVjdGZpbGwoY2xpY2tf
eHgwICsuNSwgY2xpY2tfeXkwICsuNSwgeHggKy41LCB5eSArLjUsIDEpCgkJCXNldF9kcmF3X3Rh
cmdldCgpCgkJCWNzZWxfb3V0bGluZSA9IG5pbCAtLSByZWdlbmVyYXRlCgkJZWxzZWlmIChtdG9v
bCA9PSAicGVuY2lsIiBvciBtdG9vbCA9PSAiYnJ1c2giKSB0aGVuCgkJCWlmIChtc2cubWIgPT0g
MSkgdGhlbgoJCQkJbG9jYWwgZHgsIGR5ID0geC1kcmFnX3gwLCB5LWRyYWdfeTAKCQkJCWxvY2Fs
IHN0ZXBzID0gbWF4KGFicyhkeCksYWJzKGR5KSkgKiAyCgkJCQlkeCAvPSBzdGVwcyBkeSAvPSBz
dGVwcwoJCQkJbG9jYWwgeHggPSBkcmFnX3gwCgkJCQlsb2NhbCB5eSA9IGRyYWdfeTAKCQkJCWlm
IChtdG9vbCA9PSAiYnJ1c2giKSB0aGVuCgkJCQkJLS0gcHJvdmlzaW9uYWwgcnVsZToKCQkJCQkt
LSBvbmx5IHRyYW5zcGFyZW50IHdoZW4gZHJhdyBjb2xvdXIgaXMgbm90IDAKCQkJCQlmaWxscChi
cnVzaC5wYXQpIHBva2UoMHg1NTBiLGNvbCA9PSAwIGFuZCAweDAwIG9yIDB4ZmYpCgkJCQkJcGFs
KDcsY29sKQoJCQkJCWxvY2FsIGJydXNoX3Nwcml0ZSA9IGJydXNoX2dmeFticnVzaC53aGljaF0K
CQkJCQkKCQkJCQlmb3IgaT0wLHN0ZXBzIGRvCgkJCQkJCS0tY2lyY2ZpbGwoeHgsIHl5LCBicnVz
aC50aGlja25lc3MsIGNvbCkKCQkJCQkJCgkJCQkJCXNwcihicnVzaF9zcHJpdGUseHgtMyx5eS0z
KQoJCQkJCQl4eCArPSBkeAoJCQkJCQl5eSArPSBkeQoJCQkJCWVuZAoJCQkJCXBhbCgpCgkJCQkJ
ZmlsbHAoKSBwYWx0KCkgcG9rZSgweDU1MGIsMHgwMCkKCQkJCWVsc2UKCQkJCQlmb3IgaT0wLHN0
ZXBzIGRvCgkJCQkJCXNldCh0Ym1wLCB4eCwgeXksIGNvbCkKCQkJCQkJeHggKz0gZHgKCQkJCQkJ
eXkgKz0gZHkKCQkJCQllbmQKCQkJCWVuZAoJCQllbmQKCQkJaWYgKG1zZy5tYiA9PSAyKSBjb2wg
PSBnZXQodGJtcCwgeCwgeSkKCQllbHNlaWYgbXRvb2wgPT0gInJlY3QiIHRoZW4KCQkJYmxpdChv
cF9ibXAsIHRibXApCgkJCWxvY2FsIGZ1bmMgPSBrZXkoImN0cmwiKSBhbmQgcmVjdGZpbGwgb3Ig
cmVjdAoJCQlmdW5jKGNsaWNrX3gwICsuNSwgY2xpY2tfeTAgKy41LCB4ICsuNSwgeSArLjUsIGNv
bCkKCQllbHNlaWYgbXRvb2wgPT0gImNpcmMiIHRoZW4KCQkJYmxpdChvcF9ibXAsIHRibXApCgkJ
CWxvY2FsIGZ1bmMgPSBrZXkoImN0cmwiKSBhbmQgb3ZhbGZpbGwgb3Igb3ZhbAoJCQlmdW5jKGNs
aWNrX3gwICsuNSwgY2xpY2tfeTAgKy41LCB4ICsuNSwgeSArLjUsIGNvbCkKCQllbHNlaWYgbXRv
b2wgPT0gImxpbmUiIHRoZW4KCQkJYmxpdChvcF9ibXAsIHRibXApCgkJCWxpbmUoY2xpY2tfeDAg
Ky41LCBjbGlja195MCArLjUsIHggKy41LCB5ICsuNSwgY29sKQoJCWVuZAoJCQoJCWRyYWdfeDAg
PSB4IAoJCWRyYWdfeTAgPSB5CgkJCgkJLS0gdXBkYXRlIGNibXAgd2l0aCBhbnkgY2hhbmdlcyBk
cmF3biB0byBjaS5sYXllcgoJCWlmIChjaS5sYXllcikgYmxpdChjaS5sYXllciwgY2JtcCwgMCwg
MCwgY2kubGF5ZXJfeCwgY2kubGF5ZXJfeSkKCQkKCWVuZAoJCglmdW5jdGlvbiBlbDpyZWxlYXNl
KG1zZykKCgkJbG9jYWwgeCA9IChtc2cubXggLSB4MCkgXCBjaS56b29tCgkJbG9jYWwgeSA9ICht
c2cubXkgLSB5MCkgXCBjaS56b29tCgkJCgkJaWYgKG10b29sID09ICJzZWxlY3QiKSB0aGVuCgkJ
CWlmIChjbGlja194MCA9PSB4IGFuZCBjbGlja195MCA9PSB5KSB0aGVuCgkJCQktLSBjYW4ndCBz
ZWxlY3Qgc2luZ2xlIHBpeGVsOyBkZXNlbGVjdAoJCQkJY2xlYXJfc2VsZWN0aW9uKCkKCQkJZWxz
ZQoJCQkJLS0gY3JlYXRlIGZsb2F0aW5nIGxheWVyCgkJCQlpZiAoeCA8IGNsaWNrX3gwKSBjbGlj
a194MCx4ID0geCxjbGlja194MAoJCQkJaWYgKHkgPCBjbGlja195MCkgY2xpY2tfeTAseSA9IHks
Y2xpY2tfeTAKCQkJCWxvY2FsIHd3ID0geCAtIGNsaWNrX3gwICsgMQoJCQkJbG9jYWwgaGggPSB5
IC0gY2xpY2tfeTAgKyAxCgkJCQkKCQkJCWNpLmxheWVyID0gdXNlcmRhdGEoInU4Iix3dyxoaCkK
CQkJCWNpLmxheWVyX3ggPSBjbGlja194MAoJCQkJY2kubGF5ZXJfeSA9IGNsaWNrX3kwCgkJCQlj
aS5sYXllcjAgPSBjYm1wOmNvcHkoKQoJCQkJc2V0X2RyYXdfdGFyZ2V0KGNpLmxheWVyMCkKCQkJ
CXJlY3RmaWxsKGNsaWNrX3gwLCBjbGlja195MCwgY2xpY2tfeDAgKyB3dy0xLCBjbGlja195MCAr
IGhoLTEsIDApCgkJCQlzZXRfZHJhd190YXJnZXQoKQoJCQkJYmxpdChjYm1wLGNpLmxheWVyLGNs
aWNrX3gwLCBjbGlja195MCwwLDAsd3csaGgpCgkJCWVuZAoJCWVuZAkKCgllbmQKCQoJCglmdW5j
dGlvbiBlbDpkcmF3KG1zZykKCQlsb2NhbCB4ID0gKG1zZy5teCAtIHgwKSBcIGNpLnpvb20KCQls
b2NhbCB5ID0gKG1zZy5teSAtIHkwKSBcIGNpLnpvb20KCQkKCQktLWZpbGxwKDB4MTI0OCkKCQlm
aWxscCgpCgkJcmVjdGZpbGwoMCwwLHNlbGYud2lkdGgsc2VsZi5oZWlnaHQsMzIpCgkJZmlsbHAo
KQkKCQkKCQlsb2NhbCB4MSx5MSA9IHgwICsgd3csIHkwICsgaGgKCQlsb2NhbCBzY2FsZSA9IGNp
Lnpvb20KCgkJY29sb3IoNSkKCQlsaW5lKHgwLTIseTAtMSpzY2FsZS0xLHgwLTIseTErMSpzY2Fs
ZSkKCQlsaW5lKHgxKzEseTAtMSpzY2FsZS0xLHgxKzEseTErMSpzY2FsZSkKCQkKCQlsaW5lKHgw
LTEqc2NhbGUtMSx5MC0yLHgxKzEqc2NhbGUseTAtMikKCQlsaW5lKHgwLTEqc2NhbGUtMSx5MSsx
LHgxKzEqc2NhbGUseTErMSkKCQkKCQlyZWN0ZmlsbCh4MC0xLHkwLTEseDArd3cseTAraGgsMCkK
CQkKCQlzc3ByKGNibXAsIDAsIDAsIF8sIF8sIHgwLHkwLHd3LGhoKQoJCQoJCWlmIChjc2VsKSB0
aGVuCgkJCgkJCWxvY2FsIHNlbF9zY2FsZSA9IG1pbihzY2FsZSwgMSkKCQkJd2hpbGUgc2VsX3Nj
YWxlIDwgc2NhbGUgYW5kIAoJCQkJc2VsX3NjYWxlICogY2JtcDp3aWR0aCgpIDwgNTEyIGFuZAoJ
CQkJc2VsX3NjYWxlICogY2JtcDpoZWlnaHQoKSA8IDUxMiBkbwoJCQkJc2VsX3NjYWxlICs9IDEK
CQkJZW5kCgkJCWxvY2FsIHNlbF93dyA9IGNibXA6d2lkdGgoKSAqIHNlbF9zY2FsZQoJCQlsb2Nh
bCBzZWxfaGggPSBjYm1wOmhlaWdodCgpICogc2VsX3NjYWxlCgkJCgkJCS0tIHRvIGRvOiBhbHNv
IHVwZGF0ZSBoaWdoIGJpdHMgaW4gaW1hZ2UgdG8gcHJvdGVjdAoJCQktLSBwaXhlbHMgb3V0c2lk
ZSBvZiBzZWxlY3Rpb24gZnJvbSBtb2RpZmljYXRpb24KCQkJaWYgKG5vdCBjc2VsX291dGxpbmUg
b3Igc2VsX3d3IH49IGxhc3Rfb3V0bGluZV93dykgdGhlbgoJCQkJY3NlbF9vdXRsaW5lID0gY3Jl
YXRlX291dGxpbmUoY3NlbCxzZWxfd3csc2VsX2hoKQoJCQkJbGFzdF9vdXRsaW5lX3d3ID0gc2Vs
X3d3CgkJCWVuZAoJCQkKCQkJLS1zcHIoY3NlbF9vdXRsaW5lLHgwLHkwKQoJCQlmb3IgaT0wLDYz
IGRvCgkJCQlwYWx0KGksdHJ1ZSkKCQkJZW5kCgkJCXBhbHQoMSxmYWxzZSkgcGFsdCgyLGZhbHNl
KQoJCQkKCQkJcGFsKDEsNykgcGFsKDIsNykKCQkJCgkJCWxvY2FsIGNjPSh0KCkqOCklOAoJCQlw
YWwoOSwgIDggKyAoY2MrMCklOCkKCQkJcGFsKDE3LCA4ICsgKGNjKzIpJTgpCgkJCXBhbCgyNSwg
OCArIChjYys0KSU4KQoJCQlwYWwoMzMsIDggKyAoY2MrNiklOCkKCQkJCgkJCQoJCQlmaWxscCgw
eGM5MzY5MzZjMzZjOTZjOTMgPj4gKCgodGltZSgpKjE1KVwxKSU0KSoxNikKCQkJCgkJCS0tIHRv
IGRvOiBmaXggbWF0Y2hpbmcKCQkJbG9jYWwgcXEgPSAxCgkJCWlmIChzZWxfc2NhbGUgPCBzY2Fs
ZSkgcXEgPSAyCgkJCQoJCQktLXFxID0gc2NhbGUgLyBzZWxfc2NhbGUKCQkJLS1wYWwoKSBmaWxs
cCgpCgkJCXNzcHIoY3NlbF9vdXRsaW5lLCAwLCAwLCBfLCBfLCAKCQkJCXgwLXFxLCB5MC1xcSwg
d3crcXEqMiwgaGgrcXEqMikKCQkJCgkJZW5kCgkJCgkJLS1wcmludChwb2R7c2VsX3NjYWxlLHgw
LHkwLHd3LGhofSwyLDIsNykKCQlwYWwoKSBmaWxscCgpCgkJCgkJcHJpbnQoc3RyaW5nLmZvcm1h
dCgiXCMwICUzZCAlM2QgIix4LHkpLCAxMiwgIHNlbGYuaGVpZ2h0LTE0LCA2KQoJCQoJCQoJCQoJ
CS0tcHJpbnQocG9ke2NpLnBhbl94LCBjaS5wYW5feSwgY2kuem9vbX0sMiwyLDcpCgllbmQKCQoJ
ZnVuY3Rpb24gZWw6bW91c2V3aGVlbChtc2cpCgkKCQljaS56b29tICs9IG1zZy53aGVlbF95CgkJ
LS1zY2FsZSAqPSAobXNnLndoZWVsX3kgPCAwKSBhbmQgMC41IG9yIDIuMAoJCQoJCSAtLSB0byBk
bzogY2FuIHNjYWxlIDAuNSBmb3IgbGFyZ2UgaW1hZ2VzPwoJCQoJCWxvY2FsIG1pbl9zY2FsZSA9
IDEuMAoJCWxvY2FsIG1heF9zY2FsZSA9IDE2LjAKCQkKCQktLSBjYW4gem9vbSBvdXQgZnVydGhl
ciB3aGVuIHdvdWxkbid0IGZpdCBvdGhlcndpc2UKCQlpZiAoY2JtcDp3aWR0aCgpICA_PSBzZWxm
LndpZHRoICkgbWluX3NjYWxlID0gMC41CgkJaWYgKGNibXA6aGVpZ2h0KCkgPj0gc2VsZi5oZWln
aHQpIG1pbl9zY2FsZSA9IDAuNQkJCgkJCgkJY2kuem9vbSA9IG1pZChtaW5fc2NhbGUsIGNpLnpv
b20sIG1heF9zY2FsZSkKCQlpZiAoY2kuem9vbSA_PSAxKSBjaS56b29tIFw9IDEKCWVuZAoJCgly
ZXR1cm4gZWwKCmVuZAoKCjo6IGRyYXcubHVhCi0tW1twb2RfZm9ybWF0PSJyYXciLGNyZWF0ZWQ9
IjIwMjMtMTAtMTIgMDM6MjY6MjAiLG1vZGlmaWVkPSIyMDI0LTA0LTA5IDA5OjIwOjM2IixyZXZp
c2lvbj0xODcyLHN0b3JlZD0iMjAyMy0yNC0yOCAwMDoyNDowMCJdXQpmdW5jdGlvbiBfZHJhdygp
CgkKCWNscyg1KQoJCgoJLS0gb3BlcmF0aW9ucyBkdXJpbmcgX3VwZGF0ZSBjYW4gcmVxdWVzdCBh
CgktLSBndWkgdXBkYXRlIGJlZm9yZSBpdCBpcyBuZXh0IGRyYXcgKGF2b2lkIGZsaWNrZXIpCglp
ZiAocmVmcmVzaF9ndWkpIHRoZW4KCQlnZW5lcmF0ZV9ndWkoKQoJCS0tIGd1aTpkcmF3X2FsbCgp
IGV4cGVjdHMgOnVwZGF0ZV9hbGwoKSBjYWxsZWQgZmlyc3Qgb24gY3VycmVudCBzdGF0ZSBvZiBn
dWkKCQlndWk6dXBkYXRlX2FsbCgpCgkJcmVmcmVzaF9ndWkgPSBmYWxzZQoJZW5kCgkJCglndWk6
ZHJhd19hbGwoKQoJCgktLSBjdXN0b20gZGlzcGxheSBwYWxldHRlCgktLSBhdCBlbmQuLiBzb21l
dGhpbmcgaW4gOmRyYXdfYWxsKCkgcHJvYmFibHkgY2FsbHMgcGFsKCkKCXBva2U0KDB4NTAwMCsz
Mio0LCAweDIwMjAyMDIwKQoJCglpZiAoY3VzdG9tX3BhbGV0dGUpIHRoZW4KCQlwb2tlNCgweDUw
MDAsIGdldChjdXN0b21fcGFsZXR0ZSkpCgllbmQKCQplbmQKCgo6OiBndWkubHVhCi0tW1twb2Rf
Zm9ybWF0PSJyYXciLGNyZWF0ZWQ9IjIwMjMtMDUtMTEgMDI6MDU6MTYiLG1vZGlmaWVkPSIyMDI0
LTA0LTA5IDA5OjIwOjM2IixyZXZpc2lvbj0yNjk1LHN0b3JlZD0iMjAyMy0yNC0yOCAwMDoyNDow
MCJdXQotLVtbCgoJc2hvdWxkIG9ubHkgbmVlZDoKCXBhbGV0dGUgIC0tICB3aXRoIHRhYiB0byBz
aG93IG9wZXJhdGlvbnMgKG9yIG90aGVyIHBhbGV0dGUgc3R5bGVzKQoJdG9vbHMKCXRvb2wgYXR0
cmlidXRlcyAvLyBicnVzaCBzaXplLCBmaWxsIHBhdHRlcm4KCW5hdmlnYXRvcgoKCXRoZSBwYWxl
dHRlIGFuZCBuYXZpZ2F0b3IgY2FuIC9mcmFtZS8gdGhlIHRvb2xzICsgYXR0cmlidXRlcwkKCl1d
CgpzaG93X3BhbmUgPSB0cnVlCgogLS0gdXBkYXRlIGxheW91dCB3aXRob3V0IG5lZWRpbmcgdG8g
cmVnZW5lcmF0ZSBndWkKIC0tIHRvIGRvOiBjb3VsZCBhbHNvIHVzZSB0aGlzIGZvciBoYW5kbGlu
ZyBjaGFuZ2VzIGluIGRpc3BsYXkgc2l6ZQogZnVuY3Rpb24gdXBkYXRlX2d1aV9sYXlvdXQoKQog
CWlmIChub3Qgc2lkZWJhciBvciBub3QgY2FudmFzX2VsKSByZXR1cm4KIAkKIAl4dCA9IHNob3df
cGFuZSBhbmQgMzM2IG9yIDQ4MAogCXNpZGViYXJfeCA9IHNpZGViYXJfeCBvciBzaWRlYmFyLngK
IAlzaWRlYmFyX3ggPSAoc2lkZWJhcl94ICogMyArIHh0KSAvIDQKIAkKCWlmIChzaWRlYmFyX3gg
PiB4dCkgdGhlbgoJCXNpZGViYXJfeCA9IG1heCh4dCwgc2lkZWJhcl94IC0gOCkKCWVsc2UKCQlz
aWRlYmFyX3ggPSBtaW4oeHQsIHNpZGViYXJfeCArIDgpCgllbmQKCQoJLS0gISEgaW5zdGFudCBj
aGFuZ2UgLS0gbWF5YmUgYmV0dGVyIChzdGlsbCBnZXQgdG9vbGJhciB0cmFuc2l0aW9uISkKCXNp
ZGViYXJfeCA9IHh0CgogCXNpZGViYXIueCA9IHNpZGViYXJfeCBcIDEKIAlzaWRlYmFyLmhlaWdo
dCA9IGdldF9kaXNwbGF5KCk6aGVpZ2h0KCkKIAoJY2FudmFzX2VsLndpZHRoID0gc2lkZWJhcl94
IFwgMQoJY2FudmFzX2VsLmhlaWdodCA9IGdldF9kaXNwbGF5KCk6aGVpZ2h0KCkKIAoJLS0gc2Vu
ZCBhIG1lc3NhZ2UgdG8gd20gYXNraW5nIHRvIHVuZG9jayAvIGRvY2sgdG9vbGJhcgoJaWYgc2hv
d19wYW5lIH49IGxhc3Rfc2hvd19wYW5lIHRoZW4JCgkJLS1zZW5kX21lc3NhZ2UoMywge2V2ZW50
PSJkb2NrX3Rvb2xiYXIiLCBzdGF0ZSA9IHNob3dfcGFuZX0pCgllbmQKCWxhc3Rfc2hvd19wYW5l
ID0gc2hvd19wYW5lCiBlbmQKIAoKZnVuY3Rpb24gZ2VuZXJhdGVfZ3VpKCkKCglndWkgPSBjcmVh
dGVfZ3VpKCkKCQoJY2FudmFzX2VsID0gZ3VpOmF0dGFjaChjcmVhdGVfY2FudmFze3g9MCx5PTAs
Cgl3aWR0aD0zMzYsaGVpZ2h0PWdldF9kaXNwbGF5KCk6aGVpZ2h0KCl9KQoKCXNpZGViYXIgPSBn
dWk6YXR0YWNoe3g9NDgwLTE0NCx5PTAsd2lkdGg9MTUwLGhlaWdodD0yNTB9CgkKCS0tIGEgbGl0
dGxlIHNwYWNlIGFib3ZlIHBhbGV0dGUgZm9yIHRhYnMgKG9wZXJhdGlvbikKCWxvY2FsIHBhbF9l
bCA9IHNpZGViYXI6YXR0YWNoKGNyZWF0ZV9wYWxldHRle3g9OCx5PTE0LHdpZHRoPTEyOCxoZWln
aHQ9MzJ9KQoKCXNpZGViYXI6YXR0YWNoKGNyZWF0ZV9wYWxfdGFic3t4PTExMix5PTQsd2lkdGg9
NDgsaGVpZ2h0PTl9KQoJCi0tW1sKCXNpZGViYXI6YXR0YWNoewoJCXg9MTI4LHk9OCx3aWR0aD04
LGhlaWdodD02LAoJCWRyYXc9ZnVuY3Rpb24oKSAKCQkJLS1mb3IgeT0wLDMgZG8gZm9yIHg9MCw3
IGRvCgkJCS0tCXBzZXQoeCx5LHgreSo4KSBlbmQgZW5kCgkJCXJlY3RmaWxsKDAsMCw3LDMsNikg
CgkJZW5kLAoJCWNsaWNrPWZ1bmN0aW9uKCkgcGFsX3N3YXRjaCBeXj0gMSByZWZyZXNoX2d1aT0x
IGVuZAoJfQpdXQkKCQkKCS0tc2lkZWJhcjphdHRhY2goY3JlYXRlX2l0ZW1faW5mb3t4PTgseT02
NCx3aWR0aD0xMjgsaGVpZ2h0PTIwfSkKCglzaWRlYmFyOmF0dGFjaChjcmVhdGVfaXRlbV9pbmZv
e3g9OCx5PTk2LHdpZHRoPTEyOCxoZWlnaHQ9MjR9KQoJc2lkZWJhcjphdHRhY2goY3JlYXRlX2Jh
bmtfdGFic3t4PTgrMTI4LTQ4KzEseT0xMTYtOSx3aWR0aD00OCxoZWlnaHQ9OX0pCglzaWRlYmFy
OmF0dGFjaChjcmVhdGVfbmF2e3g9OCx5PTExNix3aWR0aD0xMjgsaGVpZ2h0PTEyOH0pCgkKCgkt
LS0tIHRvb2xzIC0tLS0KCQoJbG9jYWwgdG9vbHMgPSB7CgkJInBlbmNpbCIsImJydXNoIiwibGlu
ZSIsInJlY3QiLCAiY2lyYyIsCgkJImZpbGwiLCAic3RhbXAiLCAic2VsZWN0IiwgInBhbiIKCQkt
LSJlcmFzZXIiLAoJCS0tInNtdWRnZSIsCgkJLS0ic3dlZXAiLCJ0ZXh0Iiwic2NyYW1ibGUiCgl9
CgkKCWxvY2FsIHd3PTEyCglsb2NhbCB5eT1wYWxfZWwueSArIHBhbF9lbC5oZWlnaHQgKyA0Cglm
b3IgaT0wLCN0b29scy0xIGRvCglzaWRlYmFyOmF0dGFjaChjcmVhdGVfdG9vbF9idXR0b24odG9v
bHNbaSsxXSwgCgkJMTArKGkld3cpKjE0LCB5eSsoaVx3dykqMTQpKQoJZW5kCgkKCS0tLS0gY29s
b3VyIC8gZmlsbCBwYXR0ZXJuIHByZXZpZXcgLS0tLS0KCi0tIG9ubHkgc2hvdyB3aGVuIHRvb2xz
IHRoYXQgdXNlIGZpbGwgcGF0dGVybiBpcyBzZWxlY3RlZAotLSAobGluZSBhbmQgc2hhcGUgZGlz
YWJsZWQgZm9yIG5vdykKaWYgKCh7YnJ1c2g9MSx4bGluZT0xLHhzaGFwZT0xfSlbY3Rvb2xdKSB0
aGVuIAoKCXl5Kz0xNgoJc2lkZWJhcjphdHRhY2goe3g9OCx5PXl5LHdpZHRoPTI0LGhlaWdodD0y
NCwKCQlkcmF3PWZ1bmN0aW9uKHNlbGYpCgkJCWNsaXAoKQoJCQlyZWN0ZmlsbCgtMSwtMSxzZWxm
LndpZHRoLHNlbGYuaGVpZ2h0LDApCgkJCWZpbGxwKGJydXNoLnBhdCkKCQkJcmVjdGZpbGwoMCww
LHNlbGYud2lkdGgtMSxzZWxmLmhlaWdodC0xLGNvbCkKCQkJZmlsbHAoKQoJCWVuZAoJfSkKCQoJ
LS0gYnJ1c2hlcwoJCglsb2NhbCB4eCA9IDM2CgkKCQoJZm9yIGk9MCw3IGRvCgkJc2lkZWJhcjph
dHRhY2goY3JlYXRlX2JydXNoX2J1dHRvbihpKzEsIHh4ICsoaSV3dykqMTIsIHl5KSkKCWVuZAoJ
CgktLSAweDgwODUKCS0tIGZpbGwgcGF0dGVybnMKCQoJbG9jYWwgcGF0ID0ge1swXT0KCQkweDAw
MDAsMHg1MGEwLDB4NWE1YSwweDUwYTB_MHhmZmZmLAkKCQkweDM2YzksMHg5YzYzLDB4MTI0OH4w
eGZmZmYsMHg4NDIxfjB4ZmZmZiwKCgkJMHgwMDAwLCAweDgwYjksIDB4ODEzZCwKCQkweDdlOTks
IDB4ODFkYiwgMHg3ZDdkLAoJCTB4ODI3MiwgMHg4MzRmCgl9Cgl5eSArPSAxNAoJZm9yIGk9MCw3
IGRvCgkJCXNpZGViYXI6YXR0YWNoKHt4ID0geHggKyBpKjEyLCB5ID0geXksIHdpZHRoPTExLGhl
aWdodD0xMCwKCQkJCXBhdCA9IHBhdFtpXSwKCQkJCWRyYXc9ZnVuY3Rpb24oc2VsZikKCQkJCQlj
bGlwKCkKCQkJCQktLXBva2UoMHg1NTBiLDB4ZmYpCgkJCQkJcmVjdGZpbGwoLTEsLTEsc2VsZi53
aWR0aCxzZWxmLmhlaWdodCwwKQoJCQkKCQkJCQlmaWxscChzZWxmLnBhdCkKCQkJCQlyZWN0Zmls
bCgwLDAsc2VsZi53aWR0aC0xLHNlbGYuaGVpZ2h0LTEsCgkJCQkJCXNlbGYucGF0PT1icnVzaC5w
YXQgYW5kIDcgb3IgNSkKCQkJCQlmaWxscCgpCgkJCQllbmQsCgkJCQljbGljayA9IGZ1bmN0aW9u
KHNlbGYpCgkJCQkJYnJ1c2gucGF0ID0gc2VsZi5wYXQKCQkJCWVuZAoJCQl9KQoJZW5kCmVuZCAt
LSBicnVzaCBlbGVtZW50cwoKCXVwZGF0ZV9ndWlfbGF5b3V0KCkKCmVuZAoKbG9jYWwgdG9vbF9n
Zng9ewpwZW5jaWw9IltnZnhdMDgwODAwMDA3MDAwMDAwNzc3MDAwMDc3Nzc3MDA3Nzc3NzAwNzA3
NzcwMDA3MDA3MDAwMDc3NzAwMDAwMDAwMDAwMDBbL2dmeF0iLApicnVzaD0iW2dmeF0wODA4MDAw
MDA3NzAwMDAwNzcwMDAwMDc3MDAwMDAwNzAwMDAwNzcwMDAwMDA3NzAwMDAwNzcwMDAwMDAwMDAw
MDAwMFsvZ2Z4XSIsCmxpbmU9IltnZnhdMDgwODAwMDAwMDcwMDAwMDA3MDAwMDAwNzAwMDAwMDcw
MDAwMDA3MDAwMDAwNzAwMDAwMDcwMDAwMDAwMDAwMDAwMDBbL2dmeF0iLApzZWxlY3Q9IltnZnhd
MDgwODc3MDcwNzcwNzAwMDAwNzAwMDAwMDAwMDcwMDAwMDcwMDAwMDAwMDA3MDAwMDA3MDc3MDcw
NzcwMDAwMDAwMDBbL2dmeF0iLApyZWN0PSJbZ2Z4XTA4MDg3Nzc3Nzc3MDcwMDAwMDcwNzAwMDAw
NzA3MDAwMDA3MDcwMDAwMDcwNzAwMDAwNzA3Nzc3Nzc3MDAwMDAwMDAwWy9nZnhdIiwKY2lyYz11
bnBvZCgiYjY0OmJIbzBBQ0FBQUFBaUFBQUE4d1Z3ZUhVQVF5QUlDQVFRSnpBSElBY1FCMEFIQUFR
QWNCQUhJQWN3SjZBPSIpLApwYW49IltnZnhdMDgwODAwNzA3MDAwMDA3MDcwNzAwMDcwNzA3MDAw
Nzc3NzcwNzA3Nzc3NzAwNzc3Nzc3MDAwNzc3NzAwMDAwMDAwMDBbL2dmeF0iLApmaWxsPSJbZ2Z4
XTA4MDgwMDAwNzAwMDAwMDAwNzAwMDAwMDAwNzAwNzc3Nzc3NzcwNzc3NzcwNzAwNzc3MDA3MDAw
NzAwMDAwMDAwMDAwWy9nZnhdIiwKc3RhbXA9IltnZnhdMDgwODAwNzc3MDAwMDA3NzcwMDAwMDc3
NzAwMDAwNzc3MDAwNzc3Nzc3NzA3MDAwMDA3MDc3Nzc3NzcwMDAwMDAwMDBbL2dmeF0iLApzbXVk
Z2U9IltnZnhdMDgwODAwNzAwMDAwMDA3MDAwMDAwMDcwNzA3MDAwNzc3NzcwNzA3Nzc3NzAwNzc3
Nzc3MDAwNzc3NzAwMDAwMDAwMDBbL2dmeF0iLApzd2VlcD0iW2dmeF0wODA4MDAwMDcwMDAwMDAw
NzAwMDAwMDA3MDAwMDAwNzAwMDAwMDA3MDAwMDc3Nzc3NzcwNzA3MDcwNzAwMDAwMDAwMFsvZ2Z4
XSIsCnRleHQ9IltnZnhdMDgwODc3Nzc3NzcwNzcwMDc3NzA3Nzc3MDc3MDc3MDAwNzcwNzA3NzA3
NzA3NzAwNzA3MDc3Nzc3NzcwMDAwMDAwMDBbL2dmeF0iLApzY3JhbWJsZT0iW2dmeF0wODA4MDcw
MDA3MDAwNzAwMDcwMDc3Nzc3NzcwNzA3NzcwNzA3Nzc3Nzc3MDA3MDAwNzAwNzcwMDA3NzAwMDAw
MDAwMFsvZ2Z4XSIsCmVyYXNlcj0iW2dmeF0wODA4MDAwNzcwMDAwMDc3NzcwMDA3Nzc3NzcwNzA3
Nzc3NzA3MDA3NzcwMDA3MDA3MDAwMDA3NzAwMDAwMDAwMDAwMFsvZ2Z4XSIsCn0KCmJydXNoX2dm
eD17CnVzZXJkYXRhIltnZnhdMDgwODAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDcwMDAwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBbL2dmeF0iLAp1c2VyZGF0YSJbZ2Z4XTA4MDgw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA3NzAwMDAwMDc3MDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwWy9nZnhdIiwKdXNlcmRhdGEiW2dmeF0wODA4MDAwMDAwMDAwMDAwMDAwMDAwMDcwMDAw
MDA3NzcwMDAwMDA3MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFsvZ2Z4XSIsCnVzZXJkYXRh
IltnZnhdMDgwODAwMDAwMDAwMDAwMDAwMDAwMDA3NzAwMDAwNzc3NzAwMDA3Nzc3MDAwMDA3NzAw
MDAwMDAwMDAwMDAwMDAwMDBbL2dmeF0iLAp1c2VyZGF0YSJbZ2Z4XTA4MDgwMDAwMDAwMDAwMDc3
MDAwMDA3Nzc3MDAwNzc3Nzc3MDA3Nzc3NzcwMDA3Nzc3MDAwMDA3NzAwMDAwMDAwMDAwWy9nZnhd
IiwKdXNlcmRhdGEiW2dmeF0wODA4MDA3Nzc3MDAwNzc3Nzc3MDc3Nzc3Nzc3Nzc3Nzc3Nzc3Nzc3
Nzc3Nzc3Nzc3Nzc3MDc3Nzc3NzAwMDc3NzcwMFsvZ2Z4XSIsCi0tW1twb2QscG9kX3R5cGU9Imlt
YWdlIl1ddW5wb2QoImI2NDpiSG8wQUE4QUFBQU9BQUFBNEhCNGRRQkRJQWdJQlBBSlItQVMiKSwK
LS1bW3BvZCxwb2RfdHlwZT0iaW1hZ2UiXV11bnBvZCgiYjY0OmJIbzBBQm9BQUFBWUFBQUE4QWx3
ZUhVQVF5QUlDQVJRQjFBWFFCZEFGMEFYUUJkQUY5QT0iKSwKdXNlcmRhdGEiW2dmeF0wODA4MDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDc3NzcwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMFsvZ2Z4XSIsCnVzZXJkYXRhIltnZnhdMDgwODAwMDAwMDAwMDAwMDAwMDAwMDAwMDcwMDAw
MDA3MDAwMDAwNzAwMDAwMDcwMDAwMDA3MDAwMDAwMDAwMDAwMDBbL2dmeF0iCn0KCgpmdW5jdGlv
biBjcmVhdGVfYnJ1c2hfYnV0dG9uKHdoaWNoLCB4LCB5KQoJbG9jYWwgZWw9IHsKCQl3aGljaCA9
IHdoaWNoLCB4ID0geCwgeSA9IHksIHdpZHRoPTEyLCBoZWlnaHQgPSAxMiwKCQljdXJzb3I9InBv
aW50ZXIiCQoJfQoJCgllbC5nZnggPSBicnVzaF9nZnhbd2hpY2hdCgkKCWZ1bmN0aW9uIGVsOmRy
YXcoKQoJCXJlY3RmaWxsKDAsMSxzZWxmLndpZHRoLTIsc2VsZi5oZWlnaHQtMiwwKQoJCXBhbCg3
LCBzZWxmLndoaWNoID09IGJydXNoLndoaWNoIGFuZCA3IG9yIDEzKQoJCXNwcihzZWxmLmdmeCwy
LDIpCgkJcGFsKDcsNykKCWVuZAoJCglmdW5jdGlvbiBlbDp0YXAoKQoJCWJydXNoLndoaWNoID0g
c2VsZi53aGljaAoJCWJydXNoLnRoaWNrbmVzcyA9IHNlbGYud2hpY2gtMQoJCWJydXNoLnNwcml0
ZSA9IGVsLmdmeAoJZW5kCgkKCXJldHVybiBlbAplbmQKCgpmdW5jdGlvbiBjcmVhdGVfdG9vbF9i
dXR0b24od2hpY2gsIHgsIHkpCglsb2NhbCBlbD0ge3doaWNoID0gd2hpY2gsIHggPSB4LCB5ID0g
eSwgd2lkdGg9MTIsIGhlaWdodCA9IDEyLGN1cnNvcj0icG9pbnRlciJ9CgkKCWlmIHR5cGUodG9v
bF9nZnhbd2hpY2hdKSA9PSAidXNlcmRhdGEiIHRoZW4KCQllbC5nZnggPSB0b29sX2dmeFt3aGlj
aF0KCWVsc2UKCQllbC5nZnggPSB1c2VyZGF0YSh0b29sX2dmeFt3aGljaF0pCgllbmQKCQoJZnVu
Y3Rpb24gZWw6ZHJhdygpCgktLVtbCgkJbGluZSgxLDAsOSwwLDEzKQoJCXJlY3RmaWxsKDAsMSwx
MCw5LDEzKQoJCWxpbmUoMSwxMCw5LDEwLDEzKQoJXV0KCQlwYWwoNywgd2hpY2ggPT0gY3Rvb2wg
YW5kIDcgb3IgMTMpCgkJc3ByKHNlbGYuZ2Z4LDIsMikKCQlwYWwoNyw3KQoJZW5kCgkKCWZ1bmN0
aW9uIGVsOnRhcCgpCgkJY3Rvb2wgPSBzZWxmLndoaWNoCgkJcmVmcmVzaF9ndWkgPSB0cnVlCgll
bmQKCQoKCXJldHVybiBlbAplbmQKCgoKCjo6IG1haW4ubHVhCi0tW1twb2RfZm9ybWF0PSJyYXci
LGNyZWF0ZWQ9IjIwMjMtMDQtMTEgMDI6MDQ6NTQiLG1vZGlmaWVkPSIyMDI0LTA0LTA5IDA5OjIw
OjM2IixyZXZpc2lvbj0yNzY5LHN0b3JlZD0iMjAyMy0yNC0yOCAwMDoyNDowMCJdXQotLVtbCgln
Zng1OiBwYW5uaW5nLCB2aWV3IGdyb3VwaW5nCl1dCgppbmNsdWRlICJkcmF3Lmx1YSIKaW5jbHVk
ZSAidXBkYXRlLmx1YSIKaW5jbHVkZSAiZ3VpLmx1YSIKaW5jbHVkZSAiY2FudmFzLmx1YSIKaW5j
bHVkZSAicGFsLmx1YSIKaW5jbHVkZSAibmF2Lmx1YSIKaW5jbHVkZSAidW5kby5sdWEiCgpjYm1w
LGNibXBfd2lkdGgsY2JtcF9oZWlnaHQsY3NlbCA9IG5pbCxuaWwsbmlsCgotLVtbCglzZWxlY3Rp
b24gbGF5ZXIgc3RhdGUgaXMgbm90IHNhdmVkCl1dCmZ1bmN0aW9uIHNhdmVfd29ya2luZ19maWxl
KCkKCS0tcHJpbnRoKCJAQCBbZ2Z4XSBzYXZpbmcgd29ya2luZyBmaWxlIikKCWxvY2FsIG91dHB1
dCA9IHt9Cglmb3IgaT0wLCNpdGVtIGRvCgkJbG9jYWwgaWk9aXRlbVtpXQoJCW91dHB1dFtpXSA9
IHsKCQkJYm1wID0gaWkuYm1wLAoJCQlmbGFncyA9IGlpLmZsYWdzLAoJCQlwYW5feCA9IGlpLnBh
bl94LAoJCQlwYW5feSA9IGlpLnBhbl95LAoJCQl6b29tID0gaWkuem9vbQoJCX0KCWVuZAoJcmV0
dXJuIG91dHB1dAplbmQKCmZ1bmN0aW9uIGxvYWRfd29ya2luZ19maWxlKGl0ZW1fMSkKCglpdGVt
XzEgPSBpdGVtXzEgb3Ige30KCgkKCQlpdGVtID0ge30KCQlmb3IgaT0wLDI1NSBkbwoJCQlzcmMg
PSBpdGVtXzFbaV0gb3Ige30KCQkJaXRlbVtpXSA9IHsKCQkJCWJtcCAgID0gc3JjLmJtcCBvciB1
c2VyZGF0YSgidTgiLDE2LDE2KSwKCQkJCXNlbCAgID0gc3JjLnNlbCBvciB1c2VyZGF0YSgidTgi
LDE2LDE2KSwKCQkJCWZsYWdzID0gc3JjLmZsYWdzIG9yIDAsCgkJCQlleHRyYSA9IHNyYy5leHRy
YSBvciBuaWwsIC0tIHRleHQuIG1heWJlICJub3RlcyI-CgkJCQlwYW5feCA9IHNyYy5wYW5feCBv
ciAwLAoJCQkJcGFuX3kgPSBzcmMucGFuX3kgb3IgMCwKCQkJCXpvb20gPSBzcmMuem9vbSBvciA4
CgkJCX0KCQkJCgkJCWFkZF91bmRvX3N0YWNrKGl0ZW1baV0pCgkJCQoJCQktLXByaW50aCgibG9h
ZGVkIGl0ZW0gIi4uaS4uIiAgYm1wIHdpZHRoOiIuLml0ZW1baV0uYm1wOndpZHRoKCkpCgkJZW5k
CQoJCQoJc2V0X2N1cnJlbnRfaXRlbSgwKQoJCmVuZAoKZnVuY3Rpb24gX2luaXQoKQoKCXBva2Uo
MHg0MDAwLGdldChmZXRjaCIvc3lzdGVtL2ZvbnRzL3A4LmZvbnQiKSkKCQoJd2luZG93ewoJCXRh
YmJlZCA9IHRydWUsCgkJaWNvbiA9IHVzZXJkYXRhIltnZnhdMDgwODc3NzAwNzc3Nzc3MDA3Nzc3
NzcwMDc3Nzc3Nzc3Nzc3NzA3Nzc3MDc3MDc3NzcwNzc3Nzc3Nzc3MDAwMDAwMDBbL2dmeF0iCgl9
CgkKCW1rZGlyKCIvcmFtL2NhcnQvZ2Z4IikKCQoJd3JhbmdsZV93b3JraW5nX2ZpbGUoCgkJc2F2
ZV93b3JraW5nX2ZpbGUsCgkJbG9hZF93b3JraW5nX2ZpbGUsCgkJIi9yYW0vY2FydC9nZngvMC5n
ZngiIC0tIGRlZmF1bHQKCSkKCQoJc2V0X2N1cnJlbnRfaXRlbSgwKQoJc2V0X2N1cnJlbnRfYmFu
aygwKQoKCWdlbmVyYXRlX2d1aSgpCgkKCWNvbCA9IDcKCWN0b29sID0gInBlbmNpbCIKCQoJYnJ1
c2ggPSB7CgkJc3BhY2luZz0xLAoJCXRoaWNrbmVzcz0yLAoJCXdoaWNoPTMsCgkJcGF0PTB4MAoJ
fQoJCglyZWZyZXNoX2d1aSA9IHRydWUKCQplbmQKCmZ1bmN0aW9uIHNldF9jdXJyZW50X2Jhbmso
aSkKCS0tcHJpbnRoKCJzZXR0aW5nIGJhbms6ICIuLmkpCgljdXJyZW50X2JhbmsgPSBpCmVuZAoK
ZnVuY3Rpb24gc2V0X25laWdoYm91cnNfdmlldyhpLCBkaSkKCWlmIChub3QgaSkgcmV0dXJuCglp
ZiAoaSA8IDAgb3IgaSA_IDI1NSkgcmV0dXJuCglsb2NhbCBiID0gaXRlbVtpXS5ibXAKCWlmIChi
IGFuZCBiOndpZHRoKCkgPT0gY2JtcF93aWR0aCBhbmQgYjpoZWlnaHQoKSA9PSBjYm1wX2hlaWdo
dCkgdGhlbgoJCWl0ZW1baV0ucGFuX3ggPSBjaS5wYW5feAoJCWl0ZW1baV0ucGFuX3kgPSBjaS5w
YW5feQoJCWl0ZW1baV0uem9vbSAgPSBjaS56b29tCgkJc2V0X25laWdoYm91cnNfdmlldyhpICsg
ZGksIGRpKQoJZW5kCmVuZAoKZnVuY3Rpb24gc2V0X2N1cnJlbnRfaXRlbShpKQoJaSA9IGkgb3Ig
Y3VycmVudF9pdGVtCglpZiAobm90IGl0ZW1baV0pIHJldHVybiAtLSBvdXQgb2YgcmFuZ2UKCQoJ
aWYgKGN1cnJlbnRfaXRlbSkgdGhlbgoJCXNldF9uZWlnaGJvdXJzX3ZpZXcoY3VycmVudF9pdGVt
KzEsMSkKCQlzZXRfbmVpZ2hib3Vyc192aWV3KGN1cnJlbnRfaXRlbS0xLC0xKQoJZW5kCgkKCWN1
cnJlbnRfaXRlbSA9IGZscihpKSAgLS0gd2FudCBpdCB0byBiZSBhbiBpbnRlZ2VyCgljaSA9IGl0
ZW1bY3VycmVudF9pdGVtXQoKCWNibXAgPSBpdGVtW2N1cnJlbnRfaXRlbV0uYm1wCgljYm1wX3dp
ZHRoLCBjYm1wX2hlaWdodCA9IGNibXA6d2lkdGgoKSwgY2JtcDpoZWlnaHQoKQoKCWlmIG5vdCBp
dGVtW2N1cnJlbnRfaXRlbV0uc2VsIG9yCgkJaXRlbVtjdXJyZW50X2l0ZW1dLnNlbDp3aWR0aCgp
IH49IGNibXBfd2lkdGggb3IKCQlpdGVtW2N1cnJlbnRfaXRlbV0uc2VsOmhlaWdodCgpIH49IGNi
bXBfaGVpZ2h0Cgl0aGVuCgkJaXRlbVtjdXJyZW50X2l0ZW1dLnNlbCA9IHVzZXJkYXRhKCJ1OCIs
Y2JtcF93aWR0aCwgY2JtcF9oZWlnaHQpCgllbmQKCQoJY3NlbCA9IGl0ZW1bY3VycmVudF9pdGVt
XS5zZWwKCWNzZWxfb3V0bGluZSA9IGl0ZW1bY3VycmVudF9pdGVtXS5zZWxfb3V0bGluZQoJCgkt
LSBnZW5lcmF0ZV9ndWkoKQoJLS1yZWZyZXNoX2d1aSA9IHRydWUKZW5kCgpvbl9ldmVudCgibG9z
dF9mb2N1cyIsCglmdW5jdGlvbiAobXNnKQoJCW1hcF9nZnhfc3RhdGUgPSBtYXBfZ2Z4X3N0YXRl
IG9yIGZldGNoIi9yYW0vc2hhcmVkL21hcF9nZngucG9kIiBvciB7fQoJCW1hcF9nZnhfc3RhdGUu
Y3VycmVudF9zcHJpdGVfaW5kZXggPSBjdXJyZW50X2l0ZW0KCQltYXBfZ2Z4X3N0YXRlLmdmeF9w
cm9jX2lkID0gcGlkKCkKCQlzdG9yZSgiL3JhbS9zaGFyZWQvbWFwX2dmeC5wb2QiLCBtYXBfZ2Z4
X3N0YXRlKQoJZW5kCikKCm9uX2V2ZW50KCJnYWluZWRfZm9jdXMiLAoJZnVuY3Rpb24oKQoJCW1h
cF9nZnhfc3RhdGUgPSBmZXRjaCIvcmFtL3NoYXJlZC9tYXBfZ2Z4LnBvZCIKCQlpZiAobWFwX2dm
eF9zdGF0ZSkgdGhlbgoJCQlzZXRfY3VycmVudF9pdGVtKG1hcF9nZnhfc3RhdGUuY3VycmVudF9z
cHJpdGVfaW5kZXgpCgkJZW5kCgllbmQKKQoKb25fZXZlbnQoInNldF9wYWxldHRlIiwKCWZ1bmN0
aW9uKG1zZykKCQlpZiAodHlwZShtc2cucGFsZXR0ZSkgPT0gInVzZXJkYXRhIikgdGhlbgoJCQls
b2NhbCB3LCBoLCB0eXBlID0gbXNnLnBhbGV0dGU6YXR0cmlicygpCgkJCWlmICh3ID09IDY0IGFu
ZCB0eXBlID09ICJpMzIiKSB0aGVuCgkJCQljdXN0b21fcGFsZXR0ZSA9IG1zZy5wYWxldHRlCgkJ
CWVuZAoJCWVuZAoJZW5kCikKCi0tW1sKCQpdXQpmdW5jdGlvbiBjb2xvdXJfZml0KGJtcCwgcGFs
MCkKCglsb2NhbCBjb2xzID0gcGFsMDp3aWR0aCgpCglsb2NhbCBwYWwxID0ge30KCQoJZm9yIGk9
MCxjb2xzLTEgZG8KCQlsb2NhbCByID0gKHBhbDA6Z2V0KGkpID4_IDE2KSAmIDB4ZmYKCQlsb2Nh
bCBnID0gKHBhbDA6Z2V0KGkpID4_ICA4KSAmIDB4ZmYKCQlsb2NhbCBiID0gKHBhbDA6Z2V0KGkp
ID4_ICAwKSAmIDB4ZmYKCQkKCQlsb2NhbCBiZXN0X2Rpc3QsIGJlc3RfY29sID0gMTAwMDAwMDAw
LCAwCgkJZm9yIGk9MCw2MyBkbwoJCQlsb2NhbCByMSA9IHBlZWsoMHg1MDAwK2kqNCsyKQoJCQls
b2NhbCBnMSA9IHBlZWsoMHg1MDAwK2kqNCsxKQoJCQlsb2NhbCBiMSA9IHBlZWsoMHg1MDAwK2kq
NCswKQoJCQlsb2NhbCBkaXN0ID0gKHIxLXIpXjIgKyAoZzEtZyleMiArIChiMS1iKV4yCgkJCWlm
IChkaXN0IDwgYmVzdF9kaXN0KSBiZXN0X2NvbCA9IGkgYmVzdF9kaXN0ID0gZGlzdAoJCWVuZAoJ
CQoJCXBhbDFbaV0gPSBiZXN0X2NvbAoJZW5kCgkKCS0tIHNldCBkcmF3IHBhbCBhbmQgZHJhdyBv
biB0byBzZWxmCglwYWx0KDApIC0tIG5vIHRyYW5zcGFyZW5jeQoJcGFsKHBhbDEpCgkKCXNldF9k
cmF3X3RhcmdldChibXApCglzcHIoYm1wKQoJc2V0X2RyYXdfdGFyZ2V0KCkKCQoJcmV0dXJuIGJt
cAplbmQKCgpvbl9ldmVudCgiZHJvcF9pdGVtcyIsZnVuY3Rpb24obXNnKQoKCS0tIHNpbmdsZSBm
aWxlIGZvciBub3cKCWxvY2FsIGRyb3BwZWRfaXRlbSA9IG1zZy5pdGVtc1sxXQoJaWYgZHJvcHBl
ZF9pdGVtIGFuZCBkcm9wcGVkX2l0ZW0ucG9kX3R5cGUgPT0gImZpbGVfcmVmZXJlbmNlIiBhbmQg
CgkJdHlwZShkcm9wcGVkX2l0ZW0uZnVsbHBhdGgpID09ICJzdHJpbmciIGFuZAoJCWRyb3BwZWRf
aXRlbS5mdWxscGF0aDpleHQoKSA9PSAicG5nIiB0aGVuCgkJCgkJbG9jYWwgZyA9IGZldGNoKGRy
b3BwZWRfaXRlbS5mdWxscGF0aCkKCQlpZiAodHlwZShnKSA9PSAidXNlcmRhdGEiKSB0aGVuCgkJ
CQoJCQlsb2NhbCBibXAsIHBhbDEgPSBnOmNvbnZlcnQoInU4IiwgdHJ1ZSkKCQkJYmFja3VwX3N0
YXRlKCkKCQkJaXRlbVtjdXJyZW50X2l0ZW1dLmJtcCA9IGNvbG91cl9maXQoYm1wLCBwYWwxKQoJ
CQlzZXRfY3VycmVudF9pdGVtKGN1cnJlbnRfaXRlbSkKCQkJY2xlYXJfc2VsZWN0aW9uKCkKCQll
bmQKCgllbHNlCgkJbm90aWZ5KCJjb3VsZCBub3QgbG9hZCBkcm9wcGVkIGZpbGUiKQoJZW5kCgkK
CQplbmQpCgoKCgo6OiBuYXYubHVhCi0tW1twb2RfZm9ybWF0PSJyYXciLGNyZWF0ZWQ9IjIwMjMt
MTAtMTEgMDI6MTg6NDgiLG1vZGlmaWVkPSIyMDI0LTA0LTA5IDA5OjIwOjM2IixyZXZpc2lvbj0z
NDM1LHN0b3JlZD0iMjAyMy0yNC0yOCAwMDoyNDowMCJdXQotLVtbCgluYXZpZ2F0ZSBzcHJpdGUg
YmFuawoJKyB0b3AtbGV2ZWwgb3BlcmF0aW9ucyAocmVzaXplIGJpdG1hcCkKCgl0YWIgdG8gdG9n
Z2xlIHBhbmUgKGFuZCBkb2NrL3VuZG9jayB0b29sYmFyISkKXV0KCmxvY2FsIGljb25zPQp7Cgkt
LSBub3RlcwoJIltnZnhdMDgwODc3Nzc3NzAwNzc3Nzc3MDA3MDAwMDcwMDc3Nzc3NzAwNzAwMDA3
MDA3Nzc3NzcwMDA3Nzc3NzcwMDAwMDAwMDBbL2dmeF0iLAoJCgktLSBzY2FsZQoJIltnZnhdMDgw
ODcwNzA3MDcwMDAwMDAwMDA3MDAwMDA3MDAwMDAwMDAwNzc3MDAwNzA3NzcwMDAwMDc3NzA3MDcw
MDAwMDAwMDBbL2dmeF0iLAoJCgktLSB1bmxvY2ssIGxvY2sKCSJbZ2Z4XTA4MDgwMDc3NzAwMDA3
MDAwNzAwMDcwMDAwMDAwNzc3NzcwMDA3NzA3NzAwMDc3Nzc3MDAwMDAwMDAwMDAwMDAwMDAwWy9n
ZnhdIiwKCSJbZ2Z4XTA4MDgwMDAwMDAwMDAwNzc3MDAwMDcwMDA3MDAwNzc3NzcwMDA3NzA3NzAw
MDc3Nzc3MDAwMDAwMDAwMDAwMDAwMDAwWy9nZnhdIgp9CgpmdW5jdGlvbiBtYWtlX3RvZ2dsZV9i
dXR0b24oZWwpCgoJbG9jYWwgZWwgPSBlbCBvciB7fQoJZWwud2lkdGggPSBlbC53aWR0aCBvciA3
CgllbC5oZWlnaHQgPSBlbC5oZWlnaHQgb3IgNwoJZWwuc2V0ID0gZWwuc2V0IG9yIGZ1bmN0aW9u
KCkgZW5kCgllbC5nZXQgPSBlbC5nZXQgb3IgZnVuY3Rpb24oKSBlbmQKCWVsLmN1cnNvcj0icG9p
bnRlciIKCQoJZnVuY3Rpb24gZWw6ZHJhdygpCgkJbG9jYWwgYiA9IGVsLmJtcDAKCQlpZiAoc2Vs
Zi5nZXQoKSBhbmQgZWwuYm1wMSkgYiA9IGVsLmJtcDEKCQlsb2NhbCBjb2wgPSBzZWxmLmdldCgp
IGFuZCA3IG9yIDEzCgkJcGFsKDcsY29sKQoJCXNwcihiLCAwLCAwKQoJCXBhbCgpCgllbmQKCQoJ
ZnVuY3Rpb24gZWw6Y2xpY2soKQoJCWVsLnNldChub3QgZWwuZ2V0KCkpCgllbmQKCQoJcmV0dXJu
IGVsCmVuZAoKCi0tIHRvIGRvOiBsb2NrIGFzcGVjdCBidXR0b24gCi0tIChvbmx5IG5lZWQgdG8g
Y2hhbmdlIHdpZHRoIHRvIGdvIGZyb20gMTJ4OCAtPiAyNHgxNikKZnVuY3Rpb24gcmVzaXplX2l0
ZW0oaW5kZXgsIHdpZHRoLCBoZWlnaHQpCgktLSBub3RlOiB1c2VyZGF0YSBvbmx5IHRha2VzIG51
bWJlcnMgZm9yIHNpemVzLCBub3Qgc3RyaW5ncyAoISkKCglpZiAod2lkdGgpIHdpZHRoPXRvbnVt
KHdpZHRoKQoJaWYgKGhlaWdodCkgaGVpZ2h0PXRvbnVtKGhlaWdodCkKCQoJbG9jYWwgd3cgPSBp
dGVtW2luZGV4XS5ibXA6d2lkdGgoKQoJbG9jYWwgaGggPSBpdGVtW2luZGV4XS5ibXA6aGVpZ2h0
KCkKCWxvY2FsIGFzcGVjdCA9IHd3IC8gaGgKCglsb2NhbCB3dyA9IHRvbnVtKHdpZHRoKSBvciB3
dwoJbG9jYWwgaGggPSB0b251bShoZWlnaHQpIG9yIGhoCgkKCWlmIChsb2NrX2FzcGVjdCkgdGhl
bgoJCWlmIChub3Qgd2lkdGgpICB3aWR0aCAgPSBoaCAqIGFzcGVjdAoJCWlmIChub3QgaGVpZ2h0
KSBoZWlnaHQgPSB3dyAvIGFzcGVjdAoJZWxzZQoJCXdpZHRoID0gd2lkdGggb3Igd3cKCQloZWln
aHQgPSBoZWlnaHQgb3IgaGgKCWVuZAoJCgktLXByaW50aCgid2lkdGg6Ii4udG9zdHIod2lkdGgp
Li4iICBoZWlnaHQ6Ii4udG9zdHIoaGVpZ2h0KSkKCS0tcHJpbnRoKCJ0eXBlKHdpZHRoKToiLi50
eXBlKHdpZHRoKS4uIiAgdHlwZShoZWlnaHQpOiIuLnR5cGUoaGVpZ2h0KSkKCglpZiAod2lkdGgg
PCAxIG9yIHdpZHRoID4gODE5MiBvcgoJCWhlaWdodCA8IDEgb3IgaGVpZ2h0ID4gODE5MiBvcgoJ
CXdpZHRoICogaGVpZ2h0ID4gMTAyNCoxMDI0KSB0aGVuCgkJLS0gdG8gZG86IGVycm9yICJiYWQg
c2l6ZSIgb3IgInRvbyBiaWciCgkJcmV0dXJuCgllbmQKCQkKCWxvY2FsIG9sZCA9IGl0ZW1baW5k
ZXhdLmJtcAoJbG9jYWwgbmV3ID0gdXNlcmRhdGEoInU4Iiwgd2lkdGgsIGhlaWdodCkKCQoJYmxp
dChvbGQsIG5ldywgMCwwLCAKCQluZXc6d2lkdGgoKVwyIC0gb2xkOndpZHRoKClcMiwKCQluZXc6
aGVpZ2h0KClcMiAtIG9sZDpoZWlnaHQoKVwyCgkpCgkKCWl0ZW1baW5kZXhdLmJtcCA9IG5ldwoJ
CglzZXRfY3VycmVudF9pdGVtKGluZGV4KSAtLSB1cGRhdGUgCglyZWZyZXNoX2d1aSA9IHRydWUK
ZW5kCgoKZnVuY3Rpb24gY3JlYXRlX2l0ZW1faW5mbyhlbCkKCgllbCA9IGd1aTpuZXcoZWwpCgoJ
ZnVuY3Rpb24gZWw6ZHJhdygpCgkJLS1yZWN0KDAsMCxzZWxmLndpZHRoLTEsIHNlbGYuaGVpZ2h0
LTEsIDEzKQoJZW5kCgkKCS0tIHByZXZpZXcgdGh1bWIKCWVsOmF0dGFjaHsKCQl4PTAseT0wLHdp
ZHRoPTE2LGhlaWdodD0xNiwKCQlkcmF3PWZ1bmN0aW9uKHNlbGYpCgkJCXJlY3RmaWxsKDAsMCwy
MywyMywwKQoJCQlsb2NhbCBiPSBpdGVtW2N1cnJlbnRfaXRlbV0uYm1wCgkJCXNwcihiLHNlbGYu
d2lkdGgvMiAtIGI6d2lkdGgoKS8yLCBzZWxmLmhlaWdodC8yLWI6aGVpZ2h0KCkvMikKCQllbmQK
CX0KCQoJbG9jYWwgeHgwID0gMjAKCWxvY2FsIHl5ICA9IDAKCS0tIGluZGV4CgllbDphdHRhY2h7
CgkJeD14eDAseT15eSx3aWR0aD0xNSxoZWlnaHQ9NywKCQlkcmF3PWZ1bmN0aW9uKHNlbGYpCgkJ
CWxvY2FsIGI9IGl0ZW1bY3VycmVudF9pdGVtXS5ibXAKCQkJcmVjdGZpbGwoMCwwLHNlbGYud2lk
dGgtMSxzZWxmLmhlaWdodC0xLDApCgkJCXByaW50KHN0cmluZy5mb3JtYXQoIiUwM2QiLGN1cnJl
bnRfaXRlbSksMiwxLDcpCgkJZW5kCgl9CgkKCWxvY2FsIHh4ID0geHgwICsgMTgKCQoJLS0gd2lk
dGgKCWVsOmF0dGFjaF9maWVsZHsKCQl4PXh4LHk9eXksd2lkdGg9MTUsaGVpZ2h0PTcsCgkJZ2V0
PWZ1bmN0aW9uKCkgcmV0dXJuIGl0ZW1bY3VycmVudF9pdGVtXS5ibXA6d2lkdGgoKSBlbmQsCgkJ
c2V0PWZ1bmN0aW9uKHNlbGYsdmFsKSAKCQkJcmVzaXplX2l0ZW0oY3VycmVudF9pdGVtLCB2YWws
IG5pbCkKCQllbmQsCgkJbGFiZWw9IiItLXNpemU6IgoJfQoJCgktLSB0b2dnbGUgbG9jawoJZWw6
YXR0YWNoKG1ha2VfdG9nZ2xlX2J1dHRvbnsKCQl4PXh4KzE2LHk9MCwKCQlibXAwPXVzZXJkYXRh
KGljb25zWzNdKSwKCQlibXAxPXVzZXJkYXRhKGljb25zWzRdKSwKCQlzZXQ9ZnVuY3Rpb24odmFs
KSBsb2NrX2FzcGVjdCA9IHZhbCBlbmQsCgkJZ2V0PWZ1bmN0aW9uKCkgcmV0dXJuIGxvY2tfYXNw
ZWN0IGVuZCwKCX0pCgkKCS0tIGhlaWdodAoJZWw6YXR0YWNoX2ZpZWxkewoJCXg9eHgrMjQseT15
eSx3aWR0aD0xNSxoZWlnaHQ9NywKCQlnZXQ9ZnVuY3Rpb24oKSByZXR1cm4gaXRlbVtjdXJyZW50
X2l0ZW1dLmJtcDpoZWlnaHQoKSBlbmQsCgkJc2V0PWZ1bmN0aW9uKHNlbGYsdmFsKSAKCQkJcmVz
aXplX2l0ZW0oY3VycmVudF9pdGVtLCBuaWwsIHZhbCkKCQllbmQsCgkJbGFiZWw9IiIKCX0JCgkK
CS0tIHNwcml0ZSBmbGFncwoJZm9yIGk9MCw3IGRvCgkJZWw6YXR0YWNoewoJCWN1cnNvcj0icG9p
bnRlciIsCgkJLS14PXh4MCtpKjcsCgkJeD04MStpKjYsCgkJeT0wLAoJCXdpZHRoPTUsaGVpZ2h0
PTksCgkJaW5kZXg9aSwKCQlkcmF3PWZ1bmN0aW9uKHNlbGYpCgkJCWxvY2FsIGNvbDAgPSAxCgkJ
CWxvY2FsIGNvbDEgPSAxMwoJCQlpZiAoaXRlbVtjdXJyZW50X2l0ZW1dLmZsYWdzICYgKDE8PHNl
bGYuaW5kZXgpKSA_IDAgdGhlbgoJCQkJY29sMCA9IDggKyBzZWxmLmluZGV4CgkJCQljb2wxID0g
NwoJCQllbmQKCQkJY2lyY2ZpbGwoMiwyLDIsY29sMCkKCQkJY2lyYygyLDIsMiwwKQoJCWVuZCwK
CQkKCQljbGljayA9IGZ1bmN0aW9uKHNlbGYpCgkJCWJhY2t1cF9zdGF0ZSgpCgkJCWl0ZW1bY3Vy
cmVudF9pdGVtXS5mbGFncyBeXj0gKDE8PHNlbGYuaW5kZXgpCgkJZW5kLAoJfQoJZW5kCgkKCS0t
IGVkaXQgZXh0cmEuIGxhdGVyIQoJLS1bWwoJZWw6YXR0YWNoKG1ha2VfdG9nZ2xlX2J1dHRvbnsK
CQl4PTIwLHk9OSwKCQlibXAwPXVzZXJkYXRhKGljb25zWzFdKQoJfSkKCV1dCgkKCS0tIHN0cmV0
Y2g7IGRvbid0IG5lZWQKCS0tW1sKCWVsOmF0dGFjaChtYWtlX3RvZ2dsZV9idXR0b257CgkJeD01
NCx5PTksCgkJYm1wMD11c2VyZGF0YShpY29uc1syXSkKCX0pCQoJXV0KCglyZXR1cm4gZWwKZW5k
CgoKZnVuY3Rpb24gY3JlYXRlX2JhbmtfdGFicyhlbCkKCgllbCA9IGd1aTpuZXcoZWwpCgoJZnVu
Y3Rpb24gZWw6ZHJhdygpCgkJLS1yZWN0KDAsMCxzZWxmLndpZHRoLTEsIHNlbGYuaGVpZ2h0LTEs
IDEzKQoJZW5kCgkKCWZvciBpPTAsMyBkbwoJCWxvY2FsIHlfb2ZmcyA9IGkgPT0gY3VycmVudF9i
YW5rIGFuZCAwIG9yIDEKCQlsb2NhbCB0YWIgPSBlbDphdHRhY2goewoJCQl4PWkqMTIseT15X29m
ZnMsd2lkdGg9MTEsaGVpZ2h0PWVsLmhlaWdodCAtIHlfb2ZmcywKCQkJaW5kZXg9aSwKCQkJY3Vy
c29yPSJwb2ludGVyIiwKCQkJZHJhdyA9IGZ1bmN0aW9uKHNlbGYpCgkJCQlsb2NhbCBzZWwgPSBj
dXJyZW50X2JhbmsgPT0gc2VsZi5pbmRleAoJCQkJcmVjdGZpbGwoMCwwLHNlbGYud2lkdGgtMSwg
c2VsZi5oZWlnaHQtMSwgc2VsIGFuZCA3IG9yIDYpCgkJCQlwc2V0KDAsMCw1KQoJCQkJbGluZSgw
LDEsMSwwLDUpCgkJCQlsaW5lKDAsMiwyLDAsNSkKCQkJCQoJCQkJcHNldChzZWxmLndpZHRoLTEs
MCw1KQoJCQkJCgkJCQlsaW5lKDAsc2VsZi5oZWlnaHQtMSxzZWxmLndpZHRoLTEsc2VsZi5oZWln
aHQtMSwxMykKCQkJCXByaW50KHNlbGYuaW5kZXgsNSwxLDEzKQoJCQllbmQsCgkJCWNsaWNrID0g
ZnVuY3Rpb24oc2VsZikKCQkJCXNldF9jdXJyZW50X2Jhbmsoc2VsZi5pbmRleCkKCQkJCXJlZnJl
c2hfZ3VpID0gdHJ1ZQoJCQllbmQKCQkJCgkJfSkKCWVuZAoJCgoJCglyZXR1cm4gZWwKZW5kCgpm
dW5jdGlvbiBjcmVhdGVfbmF2KGVsKQoKCWZ1bmN0aW9uIGVsOmRyYXcoKQoJCWNsaXAoKQoJCXJl
Y3RmaWxsKC0xLC0xLHNlbGYud2lkdGgsIHNlbGYuaGVpZ2h0LCAwKQoJCQoJCWZvciB5PTAsNyBk
bwoJCQlmb3IgeD0wLDcgZG8KCQkJCWxvY2FsIHNjYWxlID0gMQoJCQkJbG9jYWwgYm1wID0gaXRl
bVt4ICsgeSo4ICsgY3VycmVudF9iYW5rKjY0XS5ibXAKCQkJCWxvY2FsIHd3LGhoID0gYm1wOndp
ZHRoKCksIGJtcDpoZWlnaHQoKQoJCQkJLS0gdG8gZG86IHRoaXMgbWFrZXMgdmVyeSB0aGluIGJt
cHMgaW52aXNpYmxlIGluIHByZXZpZXcKCQkJCXNjYWxlID0gMTYgLyBtYXgod3csaGgpCgkJCQlp
ZiAoc2NhbGUgPj0gMSkgdGhlbgoJCQkJCXNjYWxlID0gc2NhbGUgXCAxCgkJCQllbHNlaWYgKHNj
YWxlID49IDAuNjY2KSB0aGVuCgkJCQkJc2NhbGUgPSAxIC0tIHVwIHRvIDI0eDI0LCBzdGlsbCBz
aG93IHBpeGVsIGZvciBwaXhlbAoJCQkJZW5kCgkJCQkKCQkJCQoJCQkJY2xpcChzZWxmLnN4ICsg
eCoxNiwgc2VsZi5zeSArIHkqMTYsIDE2LDE2KQoJCQkJc3NwcihibXAsCgkJCQkJMCwwLG5pbCxu
aWwsCgkJCQkJeCoxNiArIDggLSB3dyAqIHNjYWxlLzIsCgkJCQkJeSoxNiArIDggLSBoaCAqIHNj
YWxlLzIsCgkJCQkJd3cqc2NhbGUsIGhoKnNjYWxlKQoJCQllbmQKCQllbmQKCQkKCQlpZiAoY3Vy
cmVudF9iYW5rID09IGN1cnJlbnRfaXRlbVw2NCkgdGhlbgoJCQkKCQkJbG9jYWwgaWkgPSAoY3Vy
cmVudF9pdGVtIC0gY3VycmVudF9iYW5rKjY0KQoJCQlsb2NhbCB4eCA9IChpaSAlIDgpICogMTYK
CQkJbG9jYWwgeXkgPSAoaWkgXCA4KSAqIDE2CgkKCQkJY2xpcCgpCgkJCQoJCQlyZWN0KHh4LTIs
eXktMix4eCsxNyx5eSsxNywwKQoJCQlyZWN0KHh4LTEseXktMSx4eCsxNix5eSsxNiw3KQoJCWVu
ZAoJCQoJCQoJZW5kCgkKCglmdW5jdGlvbiBlbDpkcmFnKG1zZykKCQlsb2NhbCBpID0gKG1zZy5t
eCAqIDggXCBzZWxmLndpZHRoKSArIChtc2cubXkgKiA4IFwgc2VsZi5oZWlnaHQpICogOAoJCXNl
dF9jdXJyZW50X2l0ZW0oaSArIGN1cnJlbnRfYmFuayo2NCkKCWVuZAoJCglyZXR1cm4gZWwKZW5k
CgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoK
CgoKCgoKCgoKCgoKCgoKCjo6IHBhbC5sdWEKLS1bW3BvZF9mb3JtYXQ9InJhdyIsY3JlYXRlZD0i
MjAyMy0wNS0xMSAwMjowNTowMSIsbW9kaWZpZWQ9IjIwMjQtMDMtMDcgMDg6MjM6MzkiLHJldmlz
aW9uPTY1NSxzdG9yZWQ9IjIwMjMtMTEtMjggMDM6MTE6MTkiXV0KbG9jYWwgcGNvbHMgPSB7WzBd
PQoJMCwxOSwzLDI3LCAgMTEsMjYsMTAsMjMsCgkxLDE3LDEyLDI4LCAxOCwxNiwxMywyOSwKCTIs
MzAsMTQsMzEsIDI0LDgsMjUsOSwKCTIwLDQsMjEsMTUsIDUsMjIsNiw3LAp9CgpwY29sc19jb250
aW51b3VzID0ge1swXSA9CgkwLDIwLDQsMzEsMTUsOCwyNCwyLAoJMjEsNSwyMiw2LDcsMjMsMTQs
MzAsCgkxLDE2LDE3LDEyLDI4LDI5LDEzLDE4LAoJMTksMywyNywxMSwyNiwxMCw5LDI1LAp9Cgpw
Y29sc19pZGVudGl0eSA9IHtbMF0gPQoJMCwxLDIsMyw0LDUsNiw3LDgsOSwxMCwxMSwxMiwxMywx
NCwxNSwKCTE2LDE3LDE4LDE5LDIwLDIxLDIyLDIzLDI0LDI1LDI2LDI3LDI4LDI5LDMwLDMxCn0K
CgoKZnVuY3Rpb24gY3JlYXRlX3BhbF90YWJzKGVsKQoKCWVsID0gZ3VpOm5ldyhlbCkKCglmdW5j
dGlvbiBlbDpkcmF3KCkKCQktLXJlY3QoMCwwLHNlbGYud2lkdGgtMSwgc2VsZi5oZWlnaHQtMSwg
MTMpCgllbmQKCQoJbG9jYWwgc3dhdGNoX25hbWU9e1swXT0iXiIsIl4ifQoJCglmb3IgaT0wLDEg
ZG8KCQlsb2NhbCB5X29mZnMgPSBpID09IHBhbF9zd2F0Y2ggYW5kIDAgb3IgMQoJCWxvY2FsIHRh
YiA9IGVsOmF0dGFjaCh7CgkJCXg9aSoxMix5PXlfb2Zmcyx3aWR0aD0xMSxoZWlnaHQ9ZWwuaGVp
Z2h0IC0geV9vZmZzLAoJCQlpbmRleD1pLAoJCQlkcmF3ID0gZnVuY3Rpb24oc2VsZikKCQkJCWxv
Y2FsIHNlbCA9IHBhbF9zd2F0Y2ggPT0gc2VsZi5pbmRleAoJCQkJcmVjdGZpbGwoMCwwLHNlbGYu
d2lkdGgtMSwgc2VsZi5oZWlnaHQtMSwgc2VsIGFuZCA2IG9yIDEzKQoJCQkJcHNldCgwLDAsNSkK
CQkJCWxpbmUoMCwxLDEsMCw1KQoJCQkJbGluZSgwLDIsMiwwLDUpCgkJCQkKCQkJCXBzZXQoc2Vs
Zi53aWR0aC0xLDAsNSkKCQkJCQoJCQkJbGluZSgwLHNlbGYuaGVpZ2h0LTEsc2VsZi53aWR0aC0x
LHNlbGYuaGVpZ2h0LTEsMTMpCgkJCQlwcmludChzd2F0Y2hfbmFtZVtzZWxmLmluZGV4XSw1LDEs
NSkKCQkJCQoJCQllbmQsCgkJCQoJCQljbGljayA9IGZ1bmN0aW9uKHNlbGYpCgkJCQlwYWxfc3dh
dGNoID0gc2VsZi5pbmRleAoJCQkJcmVmcmVzaF9ndWkgPSB0cnVlCgkJCWVuZAoJCQkKCQl9KQoJ
ZW5kCgkKCgkKCXJldHVybiBlbAplbmQKCgoKLS1mb3IgaT0wLDYzIGRvIHBjb2xzW2ldPWkgZW5k
CgotLVtbCnBjb2xzWzIyXSxwY29sc1syMV09cGNvbHNbMjFdLHBjb2xzWzIyXQpwY29sc1sxNl0s
cGNvbHNbMTddLHBjb2xzWzE4XSA9IHBjb2xzWzE4XSwgcGNvbHNbMTZdLHBjb2xzWzE3XQpdXQoK
cGFsX3N3YXRjaCA9IDEKCmZ1bmN0aW9uIGNyZWF0ZV9wYWxldHRlKGVsKQoKCS0tIGlkZW50aXR5
Cglmb3IgaT0wLDYzIGRvIHBjb2xzW2ldID0gaSBlbmQKCQoJaWYgcGFsX3N3YXRjaCA9PSAxIHRo
ZW4KCQlmb3IgaT0wLDYzIGRvIAoJCQlwY29sc1tpXSA9IHBjb2xzX2NvbnRpbnVvdXNbaVwyXSBv
ciAwIAoJCWVuZAoJZW5kCgkKCS0tIHRvIGRvOiBhZGFwdGl2ZQoJbG9jYWwgZXByID0gMTYKCWxv
Y2FsIHd3ID0gZWwud2lkdGggLyBlcHIKCWxvY2FsIGhoID0gZWwuaGVpZ2h0IC8gNAoJCglmdW5j
dGlvbiBlbDpkcmF3KCkKCQljbGlwKCkKCQkKCQlyZWN0ZmlsbCgwLDAsc2VsZi53aWR0aCwgc2Vs
Zi5oZWlnaHQsIDApCgkJcmVjdGZpbGwoLTEsLTEsc2VsZi53aWR0aCwgc2VsZi5oZWlnaHQsIDAp
CgkJCgkJZm9yIHk9MCw2NFxlcHItMSBkbwoJCQlmb3IgeD1lcHItMSwwLC0xIGRvCgkJCQlyZWN0
ZmlsbCh4ICogd3csIHkgKiBoaCwgeCAqIHd3ICsgd3ctMSwgeSAqIGhoICsgaGgtMSwgCgkJCQlw
Y29sc1t4ICsgeSplcHJdKQoJCQkJaWYgKHBjb2xzW3ggKyB5KmVwcl0gPT0gY29sKSB0aGVuCgkJ
CQkJbG9jYWwgeHggPSB4ICogd3cKCQkJCQlsb2NhbCB5eSA9IHkgKiBoaAoJCQkJCWlmIChwYWxf
c3dhdGNoID09IDAgb3IgeCUyID09IDApIHRoZW4KCQkJCQkJcmVjdCh4eCswLHl5KzAseHgrd3cq
KDErcGFsX3N3YXRjaCktMSx5eStoaC0xLDcpCgkJCQkJCXJlY3QoeHgrMSx5eSsxLHh4K3d3Kigx
K3BhbF9zd2F0Y2gpLTIseXkraGgtMiwwKQoJCQkJCWVuZAoJCQkJZW5kCgkJCWVuZAoJCWVuZAoJ
CQoJCQoJZW5kCgkKCWZ1bmN0aW9uIGVsOmRyYWcobXNnKQoJCWxvY2FsIHh4ID0gbXNnLm14IFwg
d3cKCQlsb2NhbCB5eSA9IG1zZy5teSBcIGhoCgkJY29sID0gcGNvbHNbeHggKyB5eSAqIGVwcl0g
b3IgMAoJZW5kCgkKCQoJcmV0dXJuIGVsCmVuZAoKCgoKCgoKCgoKOjogdW5kby5sdWEKLS1bW3Bv
ZF9mb3JtYXQ9InJhdyIsY3JlYXRlZD0iMjAyMy0yOS0xNCAwMzoyOToyNyIsbW9kaWZpZWQ9IjIw
MjQtNDEtMDQgMTE6NDE6MjciLHJldmlzaW9uPTE1MDEsc3RvcmVkPSIyMDIzLTI0LTI4IDAwOjI0
OjAwIl1dCgoKbG9jYWwgZnVuY3Rpb24gdW5kb19zYXZlX3N0YXRlKGlpKQoJLS0gZG9uJ3Qgc3Rv
cmUgbmlscywgdG8gcHJlc2VydmUgb3JkZXIKCXJldHVybiB7CgkJCgkJaWkuZmxhZ3MsCgkJaWku
Ym1wOmNvcHkoKSwKCQlpaS5zZWwgYW5kIGlpLnNlbDpjb3B5KCksCgkJaWkubGF5ZXIwIGFuZCBp
aS5sYXllcjA6Y29weSgpLAoJCWlpLmxheWVyIGFuZCBpaS5sYXllcjpjb3B5KCksCgkJaWkubGF5
ZXJfeCBvciAwLAoJCWlpLmxheWVyX3kgb3IgMCwKCQlpaS5wYW5feCwKCQlpaS5wYW5feSwKCQlp
aS56b29tCgl9CmVuZAoKbG9jYWwgZnVuY3Rpb24gdW5kb19sb2FkX3N0YXRlKHMsIGlpKQoKCWlp
LmZsYWdzID0gc1sxXQoJaWkuYm1wID0gICBzWzJdCglpaS5zZWwgPSAgIHNbM10gb3IgbmlsCglp
aS5sYXllcjAgPSBzWzRdIG9yIG5pbAoJaWkubGF5ZXIgPSBzWzVdIG9yIG5pbAoJaWkubGF5ZXJf
eCA9IHNbNl0KCWlpLmxheWVyX3kgPSBzWzddCglpaS5wYW5feCA9IHNbOF0KCWlpLnBhbl95ID0g
c1s5XQoJaWkuem9vbSA9IHNbMTBdCgkKZW5kCgpmdW5jdGlvbiBiYWNrdXBfc3RhdGUoKQoKCWxv
Y2FsIGlpID0gaXRlbVtjdXJyZW50X2l0ZW1dCglsb2NhbCB0dDAgPSBzdGF0KDEpCglpaS51bmRv
X3N0YWNrOmNoZWNrcG9pbnQoKQoKLS0JcHJpbnRoKHN0cmluZy5mb3JtYXQoIiUzLjNmIixzdGF0
KDEpLXR0MCkuLiIgLy8gcGF0Y2ggc2l6ZToiLi4KLS0JCSMoaWkudW5kb19zdGFjay51bmRvX3N0
YWNrWyNpaS51bmRvX3N0YWNrLnVuZG9fc3RhY2tdKSkKZW5kCgoKZnVuY3Rpb24gdW5kbygpCgls
b2NhbCBpaSA9IGl0ZW1bY3VycmVudF9pdGVtXQoJaWkudW5kb19zdGFjazp1bmRvKCkKZW5kCgpm
dW5jdGlvbiByZWRvKCkKCWxvY2FsIGlpID0gaXRlbVtjdXJyZW50X2l0ZW1dCglpaS51bmRvX3N0
YWNrOnJlZG8oKQplbmQKCmZ1bmN0aW9uIGFkZF91bmRvX3N0YWNrKGlpKQoJaWkudW5kb19zdGFj
ayA9IGNyZWF0ZV91bmRvX3N0YWNrKHVuZG9fc2F2ZV9zdGF0ZSwgdW5kb19sb2FkX3N0YXRlLCAw
eDExLCBpaSkKZW5kCgoKCgo6OiB1cGRhdGUubHVhCi0tW1twb2RfZm9ybWF0PSJyYXciLGNyZWF0
ZWQ9IjIwMjMtMTAtMTAgMDc6NDU6MjYiLG1vZGlmaWVkPSIyMDI0LTA0LTA5IDA5OjIwOjM2Iixy
ZXZpc2lvbj0yNTQzLHN0b3JlZD0iMjAyMy0yNC0yOCAwMDoyNDowMCJdXQoKZnVuY3Rpb24gZ2V0
X3NlbGVjdGVkX3JlZ2lvbigpCglsb2NhbCB4MCx5MCA9IDEwMDAwLCAxMDAwMAoJbG9jYWwgeDEs
eTEgPSAwLDAKCWZvciB5ID0gMCwgY2JtcF9oZWlnaHQtMSBkbwoJCWZvciB4ID0gMCwgY2JtcF93
aWR0aC0xIGRvCgkJCWlmIChnZXQoY3NlbCwgeCwgeSkgPiAwKSB0aGVuCgkJCQl4MCA9IG1pbih4
MCwgeCkgeTAgPSBtaW4oeTAsIHkpCgkJCQl4MSA9IG1heCh4MSwgeCkgeTEgPSBtYXgoeTEsIHkp
CgkJCWVuZCAKCQllbmQKCWVuZAoJaWYgKHgwID09IDEwMDAwKSB4MCx5MCx4MSx5MSA9IDAsIDAs
IGNibXBfd2lkdGgtMSwgY2JtcF9oZWlnaHQtMQoJCglyZXR1cm4geDAsIHkwLCB4MS14MCsxLCB5
MS15MCsxCmVuZAoKCmZ1bmN0aW9uIGNvcHlfc2VsZWN0ZWRfcmVnaW9uKCkKCWxvY2FsIHgwLCB5
MCwgd3csIGhoID0gZ2V0X3NlbGVjdGVkX3JlZ2lvbigpCglsb2NhbCBvdXQgPSB1c2VyZGF0YSgi
dTgiLCB3dywgaGgpCgktLXByaW50aChwb2R7eDAseTAsIHd3LGhofSkKCWJsaXQoY2JtcCwgb3V0
LCB4MCwgeTAsIDAsIDApCglyZXR1cm4gb3V0CmVuZAoKCmZ1bmN0aW9uIHJvdGF0ZV9zZWxlY3Rp
b24oZHgsIGR5KQoJLS1sb2NhbCB4LHksdyxoID0gZ2V0X3NlbGVjdGVkX3JlZ2lvbigpCgktLWxv
Y2FsIGJtcDIgPSBjb3B5X3NlbGVjdGVkX3JlZ2lvbigpCglsb2NhbCB4LHkgPSAwLCAwCglsb2Nh
bCBibXAyID0gY2JtcDpjb3B5KCkKCWxvY2FsIHcsaCA9IGJtcDI6YXR0cmlicygpCglzZXRfZHJh
d190YXJnZXQoY2JtcCkKCQoJY2xpcCh4LHksdyxoKQoJcmVjdGZpbGwoeCx5LHgrdy0xLHkraC0x
LDApCglmb3IgeXk9LTEsMSBkbwoJCWZvciB4eD0tMSwxIGRvCgkJCXNwcihibXAyLGR4K3greHgq
dyxkeSt5K3l5KmgpCgkJZW5kCgllbmQKCQkJCgljbGlwKCkKCXNldF9kcmF3X3RhcmdldCgpCmVu
ZAoKZnVuY3Rpb24gbW92ZV9zZWxlY3Rpb24oZHgsIGR5KQoJCgliYWNrdXBfc3RhdGUoKQoJCglp
ZiAobm90IGNpLmxheWVyKSByZXR1cm4gcm90YXRlX3NlbGVjdGlvbihkeCwgZHkpCgkKCWJsaXQo
Y2kubGF5ZXIwLCBjYm1wKQoJY2kubGF5ZXJfeCArPSBkeAoJY2kubGF5ZXJfeSArPSBkeQoJYmxp
dChjaS5sYXllciwgY2JtcCwgMCwgMCwgY2kubGF5ZXJfeCwgY2kubGF5ZXJfeSkKCQoJLS0gbmV3
IHNlbGVjdGlvbgoJY3NlbDpjbGVhcigpCglsb2NhbCB3dywgaGggPSBjaS5sYXllcjphdHRyaWJz
KCkKCXNldF9kcmF3X3RhcmdldChjc2VsKQoJcmVjdGZpbGwoY2kubGF5ZXJfeCwgY2kubGF5ZXJf
eSwgY2kubGF5ZXJfeCArIHd3LTEsIGNpLmxheWVyX3kgKyBoaC0xLCAxKQoJY3NlbF9vdXRsaW5l
ID0gbmlsIC0tIHJlZ2VuZXJhdGUKCXNldF9kcmF3X3RhcmdldCgpCmVuZAoKIApmdW5jdGlvbiBj
bGVhcl9zZWxlY3Rpb24oKQoJaWYgKGNzZWwpIGNzZWw6Y2xlYXIoKQoJY3NlbF9vdXRsaW5lID0g
bmlsIC0tIHJlZnJlc2gKCWNpLmxheWVyLCBjaS5iYWNrID0gbmlsLCBuaWwgLS0gd2hhdCBpcyBj
aS5iYWNrPyB0byBkbzogZGVsZXRlIGlmIG5vdCB1c2VkCmVuZAoKZnVuY3Rpb24gc2VsZWN0X2Fs
bCgpCgliYWNrdXBfc3RhdGUoKQoJY3NlbDpjb3B5KDEsdHJ1ZSkKCWNzZWxfb3V0bGluZSA9IG5p
bCAtLSByZWdlbmVyYXRlCQoJbG9jYWwgd3csaGggPSBjYm1wX3dpZHRoLGNibXBfaGVpZ2h0Cglj
aS5sYXllciA9IHVzZXJkYXRhKCJ1OCIsd3csaGgpCgljaS5sYXllcl94ID0gMAoJY2kubGF5ZXJf
eSA9IDAKCWNpLmxheWVyMCA9IGNibXA6Y29weSgpCglibGl0KGNibXAsY2kubGF5ZXIpCmVuZAoK
CmZ1bmN0aW9uIG1vZGlmeV9zZWxlY3Rpb24ob3ApCgliYWNrdXBfc3RhdGUoKQoJCglsb2NhbCB0
Ym1wID0gY2kubGF5ZXIgb3IgY2JtcAoJbG9jYWwgb3JpZyA9IHRibXA6Y29weSgpCgkKCWlmIChv
cCA9PSAiZmxpcF94IikgdGhlbgoJCWZvciB4PTAsIHRibXA6d2lkdGgoKS0xIGRvCgkJCWJsaXQo
b3JpZyx0Ym1wLHgsMCx0Ym1wOndpZHRoKCktMS14LDAsMSx0Ym1wOmhlaWdodCgpKQoJCWVuZAoJ
CQoJZW5kCgkKCWlmIChvcCA9PSAiZmxpcF95IikgdGhlbgoJCWZvciB5PTAsIHRibXA6aGVpZ2h0
KCktMSBkbwoJCQlibGl0KG9yaWcsdGJtcCwwLHksMCx0Ym1wOmhlaWdodCgpLTEteSx0Ym1wOndp
ZHRoKCksMSkKCQllbmQKCWVuZAoJCgktLSBsYXllciBvbmx5IC0tIGRvbid0IGNsZWFyIHdob2xl
IG1hcCB3aXRoIGRlbAoJaWYgKGNpLmxheWVyIGFuZCBvcCA9PSAiY2xlYXIiKSB0aGVuCgkJY2ku
bGF5ZXI6Y2xlYXIoKQoJZW5kCgkKCS0tIHVwZGF0ZSBjaGFuZ2VzCglpZiAoY2kubGF5ZXIpIGJs
aXQoY2kubGF5ZXIsIGNibXAsIDAsIDAsIGNpLmxheWVyX3gsIGNpLmxheWVyX3kpCmVuZAoKCiBm
dW5jdGlvbiBfdXBkYXRlKCkKIAotLVtbCgktLSB1c2UgdXBkYXRlX2d1aV9sYXlvdXQgaW5zdGVh
ZAoJaWYgKGdldF9kaXNwbGF5KCk6aGVpZ2h0KCkgIT0gbGFzdF9kaXNwbGF5X2hlaWdodCkgcmVm
cmVzaF9ndWkgPSB0cnVlCglsYXN0X2Rpc3BsYXlfaGVpZ2h0ID0gZ2V0X2Rpc3BsYXkoKTpoZWln
aHQoKQpdXQkKCglpZiAocmVmcmVzaF9ndWkpIHRoZW4KCQlnZW5lcmF0ZV9ndWkoKQoJCXJlZnJl
c2hfZ3VpID0gZmFsc2UKCWVuZAoJCiAJZ3VpOnVwZGF0ZV9hbGwoKQogCXVwZGF0ZV9ndWlfbGF5
b3V0KCkKIAlzZXRfZHJhd190YXJnZXQoKQogCQogCS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLQogCWlmIChndWk6Z2V0X2tleWJvYXJkX2ZvY3VzX2VsZW1lbnQoKSkg
cmV0dXJuCiAJLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCiAJCiAJ
aWYga2V5cCgidGFiIikgdGhlbgoJCXNob3dfcGFuZSA9IG5vdCBzaG93X3BhbmUKCWVsc2VpZiBr
ZXlwKCJlbnRlciIpIHRoZW4KCQljbGVhcl9zZWxlY3Rpb24oKQoJZW5kCgkKCWxvY2FsIG1hZyA9
IGtleSgiY3RybCIpIGFuZCA4IG9yIDEKCWlmIChrZXlwKCJsZWZ0IikpICBtb3ZlX3NlbGVjdGlv
bigtbWFnLCAwKQoJaWYgKGtleXAoInJpZ2h0IikpIG1vdmVfc2VsZWN0aW9uKCBtYWcsIDApCglp
ZiAoa2V5cCgidXAiKSkgICAgbW92ZV9zZWxlY3Rpb24oIDAsLW1hZykKCWlmIChrZXlwKCJkb3du
IikpICBtb3ZlX3NlbGVjdGlvbiggMCwgbWFnKQoJCglpZiAoa2V5cCgiZiIpKSBtb2RpZnlfc2Vs
ZWN0aW9uKCJmbGlwX3giKQoJaWYgKGtleXAoInYiKSkgbW9kaWZ5X3NlbGVjdGlvbigiZmxpcF95
IikKCWlmIChrZXlwKCJkZWwiKSBvciBrZXlwKCJiYWNrc3BhY2UiKSkgbW9kaWZ5X3NlbGVjdGlv
bigiY2xlYXIiKQoJCgktLSBuYXZpZ2F0ZQoJbG9jYWwgbWFnID0ga2V5KCJzaGlmdCIpIGFuZCA4
IG9yIDEKCWlmIChrZXlwKCItIikpIHNldF9jdXJyZW50X2l0ZW0oY3VycmVudF9pdGVtIC0gbWFn
KQoJaWYgKGtleXAoIisiKSkgc2V0X2N1cnJlbnRfaXRlbShjdXJyZW50X2l0ZW0gKyBtYWcpCgkK
CQogCS0tIGN0cmwgLS0KIAkKIAlpZiAoa2V5KCJjdHJsIikpIHRoZW4KIAogCWlmIGtleXAoImMi
KSBvciBrZXlwKCJ4IikgdGhlbgogCQlzZXRfY2xpcGJvYXJkKHBvZChjb3B5X3NlbGVjdGVkX3Jl
Z2lvbigpLDcse3BvZF90eXBlPSJnZngifSkpCgkJaWYga2V5cCgieCIpIHRoZW4KCQkJYmFja3Vw
X3N0YXRlKCkKCQkJc2V0X2RyYXdfdGFyZ2V0KGNibXApCgkJCWxvY2FsIHgseSx3LGggPSBnZXRf
c2VsZWN0ZWRfcmVnaW9uKCkKCQkJcmVjdGZpbGwoeCx5LHgrdy0xLHkraC0xLDApCgkJCXNldF9k
cmF3X3RhcmdldCgpCgkJZW5kCgllbmQKCQoJaWYga2V5cCgidiIpIG9yIGtleXAoImIiKSB0aGVu
CgkJbG9jYWwgY3QgPSBnZXRfY2xpcGJvYXJkKCkKCQlsb2NhbCBibXAxID0gbmlsCgkJaWYgKHN1
YihjdCwxLDUpID09ICJbZ2Z4XSIpIHRoZW4KCQkJYm1wMSA9IHVzZXJkYXRhKGN0KQoJCWVsc2UK
CQkJYm1wMSA9IHVucG9kKGN0KQoJCWVuZAoJCWlmICh0eXBlKGJtcDEpID09ICJ1c2VyZGF0YSIp
IHRoZW4KCQkKCQkJLS0gcGFzdGUgYmlnCgkJCWlmIChrZXlwImIiKSB0aGVuCgkJCQlsb2NhbCB3
LGggPSBibXAxOmF0dHJpYnMoKQoJCQkJbG9jYWwgYm1wMiA9IHVzZXJkYXRhKCJ1OCIsdyoyLGgq
MikKCQkJCWZvciB5PTAsaCoyLTEgZG8KCQkJCQlmb3IgeD0wLHcqMi0xIGRvCgkJCQkJCWJtcDI6
c2V0KHgseSxnZXQoYm1wMSx4LzIseS8yKSkKCQkJCQllbmQKCQkJCWVuZAoJCQkJYm1wMSA9IGJt
cDIKCQkJZW5kCgkJCQoJCQliYWNrdXBfc3RhdGUoKQoJCQlpdGVtW2N1cnJlbnRfaXRlbV0uYm1w
ID0gYm1wMQoJCQlzZXRfY3VycmVudF9pdGVtKGN1cnJlbnRfaXRlbSkKCQllbmQKCWVuZAoJCglp
ZiBrZXlwKCJ6IikgdGhlbgoJCXVuZG8oKQoJCXNldF9jdXJyZW50X2l0ZW0oY3VycmVudF9pdGVt
KQoJCXJlZnJlc2hfZ3VpID0gdHJ1ZQoJZW5kCgkKCWlmIGtleXAoInkiKSB0aGVuCgkJcmVkbygp
CgkJc2V0X2N1cnJlbnRfaXRlbShjdXJyZW50X2l0ZW0pCgkJcmVmcmVzaF9ndWkgPSB0cnVlCgll
bmQKCQoJaWYga2V5cCgiYSIpIHRoZW4KCQlzZWxlY3RfYWxsKCkKCWVuZAoJCgkKCWVuZCAtLSBj
dHJsCgkKCQogZW5kCgo6OiBbZW9jXQo=
:: apps/notebook.p64
b64$cGljb3Ryb24gY2FydHJpZGdlIC8vIHd3dy5waWNvdHJvbi5uZXQKdmVyc2lvbiAyCgo6OiAu
aW5mby5wb2QKYjY0JExTMWJXM0J2WkN4dWIzUmxjejBpZDNKcGRHVWdjM1IxWm1ZaUxHRjFkR2h2
Y2owaWVtVndJaXh6ZEc5eVpXUTlJakl3TWpRdApNRE10TVRBZ01ERTZOREE2TlRJaUxHbGpiMjQ5
ZFhObGNtUmhkR0VvSW5VNElpd3hOaXd4Tml3aU1EQXdNREF4TURFd01UQXhNREV3Ck1UQXhNREV3
TVRBeE1ERXdNREF3TURBd01EQXhNR1F3WkRCa01HUXdaREJrTUdRd1pEQmtNR1F3WkRBeE1EQXdN
REF4TURjd01UQmsKTUdRd1pEQmtNR1F3WkRCa01HUXdaREJrTUdRd01UQXdNREF3TVRBeE1HUXda
REJrTUdRd1pEQmtNR1F3WkRCa01HUXdaREF4TURBdwpNREF4TUdRd1pEQmtNR1F3WkRCa01HUXda
REJrTUdRd1pEQmtNREV3TURBeE1EY3dNVEJrTUdRd1pEQmtNR1F3WkRCa01HUXdaREJrCk1HUXdN
VEF3TURBd01UQXhNR1F3WkRCa01HUXdaREJrTUdRd1pEQmtNR1F3WkRBeE1EQXdNREF4TUdRd1pE
QmtNR1F3WkRCa01HUXcKWkRCa01HUXdaREJrTURFd01EQXhNRGN3TVRCa01HUXdaREJrTUdRd1pE
QmtNR1F3WkRCa01HUXdNVEF3TURBd01UQXhNR1F3WkRCawpNR1F3WkRCa01HUXdaREJrTUdRd1pE
QXhNREF3TURBeE1HUXdaREJrTUdRd1pEQmtNR1F3WkRCa01HUXdaREJrTURFd01EQXhNRGN3Ck1U
QmtNR1F3WkRCa01HUXdaREJrTUdRd1pEQmtNREV3TVRBd01EQXdNVEF4TURFd01UQXhNREV3TVRB
eE1ERXdNVEF4TURFd056QXgKTURBd01EQXhNREV3TnpBM01EY3dOekEzTURjd056QTNNRGN3TnpC
a01ERXdNREF3TURBd01UQmtNR1F3WkRCa01HUXdaREJrTUdRdwpaREJrTURFd01EQXdNREF3TURB
d01ERXdNVEF4TURFd01UQXhNREV3TVRBeE1ERXdNREF3TURBaUtTeDBhWFJzWlQwaVRtOTBaV0p2
CmIyc2lMR055WldGMFpXUTlJakl3TWpRdE1EUXRNekFnTVRrNk1EazZNek1pTEcxdlpHbG1hV1Zr
UFNJeU1ESTBMVEEzTFRBMklERXgKT2pRNE9qTTJJaXgyWlhKemFXOXVQU0lpTEhkdmNtdHpjR0Zq
WlhNOWUzdHNiMk5oZEdsdmJqMGliV0ZwYmk1c2RXRWlMSGR2Y210egpjR0ZqWlY5cGJtUmxlRDB4
ZlN4N2JHOWpZWFJwYjI0OUltZG1lQzh3TG1kbWVDSXNkMjl5YTNOd1lXTmxYMmx1WkdWNFBUSjlM
SHRzCmIyTmhkR2x2YmowaWJXRndMekF1YldGd0lpeDNiM0pyYzNCaFkyVmZhVzVrWlhnOU0zMHNl
Mnh2WTJGMGFXOXVQU0p6Wm5ndk1DNXoKWm5naUxIZHZjbXR6Y0dGalpWOXBibVJsZUQwMGZYMWRY
V3g2TkFBRUFBQUFBd0FBQURCdWFXdz0KOjogZ2Z4Lwo6OiBnZngvLmluZm8ucG9kCmI2NCRMUzFi
VzNCdlpDeGpjbVZoZEdWa1BTSXlNREl6TFRFd0xUQTFJREE0T2pRNE9qUTBJaXh0YjJScFptbGxa
RDBpTWpBeU5DMHcKTnkwd05pQXhNVG8wT0Rvek5pSXNjM1J2Y21Wa1BTSXlNREl6TFRRNExUQTFJ
REE0T2pRNE9qUTBJbDFkYkhvMEFBUUFBQUFEQUFBQQpNRzVwYkE9PQo6OiBnZngvMC5nZngKYjY0
JExTMWJXM0J2WkN4amNtVmhkR1ZrUFNJeU1ESXpMVFV3TFRBMUlEQTRPalV3T2pBNElpeHRiMlJw
Wm1sbFpEMGlNakF5TkMwdwpNeTB4TUNBd01UbzBNRG8xTWlJc2NtVjJhWE5wYjI0OU1UWmRYV3g2
TkFCdEFBQUFCVEVBQVBNVWUxc3dYVDE3WW0xd1BYQjRkUUJECklCQVFCUER3TEdac1lXZHpQVEFz
Y0dGdVgzZ0lBTTk1UFRBc2VtOXZiVDA0ZlN3eEFQLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0K
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLV9kUWJUMDRmWDA9Cjo6IG1hcC8K
OjogbWFwLy5pbmZvLnBvZApiNjQkTFMxYlczQnZaQ3hqY21WaGRHVmtQU0l5TURJekxURXdMVEEx
SURBNE9qUTRPalEwSWl4dGIyUnBabWxsWkQwaU1qQXlOQzB3Ck55MHdOaUF4TVRvME9Eb3pOaUlz
YzNSdmNtVmtQU0l5TURJekxUUTRMVEExSURBNE9qUTRPalEwSWwxZGJIbzBBQVFBQUFBREFBQUEK
TUc1cGJBPT0KOjogbWFwLzAubWFwCmI2NCRMUzFiVzNCdlpDeGpjbVZoZEdWa1BTSXlNREl6TFRV
d0xUQTFJREE0T2pVd09qQTRJaXh0YjJScFptbGxaRDBpTWpBeU5DMHcKTXkweE1DQXdNVG8wTURv
MU1pSXNjbVYyYVhOcGIyNDlNVFpkWFd4Nk5BQlNBQUFBVHdRQUFQQU1lMXN3WFQxN1ltMXdQWFZ6
WlhKawpZWFJoS0NKcE1UWWlMREUyQXdBdklqQUJBUC0tLV9faElpa3NjR0Z1WDNnOU1BZ0Ewbms5
TUN4MGFXeGxYMmc5TVRZS0FCQjNDZ0NBCmVtOXZiVDB4ZlgwPQo6OiBtYXAvbWFwMC5tYXAKYjY0
JExTMWJXM0J2WkN4amNtVmhkR1ZrUFNJeU1ESTBMVEF6TFRBMklEQTVPakkxT2pRMElpeHRiMlJw
Wm1sbFpEMGlNakF5TkMwdwpNeTB3TmlBd09Ub3lOVG8wTkNJc2NtVjJhWE5wYjI0OU1GMWRiSG8w
QUdrQUFBQ2pDQUFBOEJON2JHRjVaWEk5ZTFzd1hUMTdZbTF3ClBYVnpaWEprWVhSaEtDSnBNVFlp
TERFMkF3QXZJakFCQVAtLS1fX2hJaWtzY0dGdVgzZzlNQWdBOGdaNVBUQXNjMk5oYkdVOU1TeDAK
YVd4bFgyZzlNVFlLQUc5M1BURTJmU3hMQlAtLS0tODRVREUyZlgxOQo6OiBzZngvCjo6IHNmeC8u
aW5mby5wb2QKYjY0JExTMWJXM0J2WkN4amNtVmhkR1ZrUFNJeU1ESXpMVEV3TFRBMUlEQTRPalE0
T2pRMElpeHRiMlJwWm1sbFpEMGlNakF5TkMwdwpOeTB3TmlBeE1UbzBPRG96TmlJc2MzUnZjbVZr
UFNJeU1ESXpMVFE0TFRBMUlEQTRPalE0T2pRMElsMWRiSG8wQUFRQUFBQURBQUFBCk1HNXBiQT09
Cjo6IHNmeC8wLnNmeApiNjQkTFMxYlczQnZaQ3hqY21WaGRHVmtQU0l5TURJekxUVTFMVEV5SURF
d09qVTFPakV4SWl4dGIyUnBabWxsWkQwaU1qQXlOQzB3Ck15MHhNQ0F3TVRvME1EbzFNaUlzY21W
MmFYTnBiMjQ5TVRCZFhXeDZOQUJ2QUFBQTdRWUFBTjl3ZUhVQUF5Z0FBQU1BQlBELUFRRHMKLXlm
eEFSQUdEeUFRQVNBQklBSHdBQUlRQWc0UUFTQVBJU0FCTUE5QThNTVBLQS0tOE1ZUF9Bb1Atd19B
RC1jUERRSHdDUUVRQmc0dwpBUDg1SC04QkFOelBfQTlBQUE4UVFQLS1zUEJ3Q3dELS02TWYtd0VB
bDFELS0tLS1Idz09Cjo6IHNmeC9zZngwLnNmeApiNjQkTFMxYlczQnZaQ3hqY21WaGRHVmtQU0l5
TURJMExUQXpMVEEySURBNU9qSTFPalEwSWl4dGIyUnBabWxsWkQwaU1qQXlOQzB3Ck15MHdOaUF3
T1RveU5UbzBOQ0lzY21WMmFYTnBiMjQ5TUYxZGJIbzBBQkFCQUFCUkJ3QUE4Q2R3ZUhVQUF5Z0FB
QU1BQkE5QUVBSU8KQUFHZ0FTQUNvQTRBRHhBQURmREtBUUlEQkFVR0J3RVAtNUFJQ1FvTER3d1BE
UThPRHc4UUFQQUFEUThSRHhJUEV3OFVEeFVQRmc4WApFd0R4QVE4WUR4a1BHZzhiRHh3UEhROGVE
eDhVQVBFQUlBOGhEeUlQSXc4a0R5VVBKZzhuRkFEeEFDZ1BLUThxRHlzUExBOHREeTRQCkx4UUE4
UUF3RHpFUE1nOHpEelFQTlE4MkR6Y1VBUDhGT0E4NUR6b1BPdzg4RHowUFBnOC1BUS0tOFA4QkFP
di1KMW9CRUFZUElCQUIKSUFFZ0FmQUFBaEFDREJBQklBOGhJQUV3RDBEd3d3OG9ELS13eGctNENn
LS1ENEFQOXc4TkFmQUpBUkFHRERBQS16a2Ytd0VBM0wtNApEMEFBRFVELS03RHdjQW9BLS05a0gt
OEJBSmRRLS0tLS14OD0KOjogbWFpbi5sdWEKLS1bW3BvZF9mb3JtYXQ9InJhdyIsY3JlYXRlZD0i
MjAyMy00OS0wNSAwODo0OTo1MiIsbW9kaWZpZWQ9IjIwMjQtMDMtMTAgMDE6NDA6NTIiLHJldmlz
aW9uPTIyXV0KbG9jYWwgY2UKCmZ1bmN0aW9uIF9kcmF3KCkKCglnOmRyYXdfYWxsKCkgLS0gY292
ZXJzIHdob2xlIHNjcmVlbjsgZG9uJ3QgbmVlZCB0byBjbHMoKQoKZW5kCgpmdW5jdGlvbiBfdXBk
YXRlKCkKCgktLSBjb2RlIGVkaXRvciBhbHdheXMgaGFzIGtleWJvYXJkIGZvY3VzIHdoZW4gc2Vh
cmNoIGlzIG5vdCBvcGVuCglpZiAobm90IGNlOnNlYXJjaF9ib3hfaXNfb3BlbigpKSBjZTpzZXRf
a2V5Ym9hcmRfZm9jdXModHJ1ZSkKCglnOnVwZGF0ZV9hbGwoKQoKZW5kCgoKZnVuY3Rpb24gX2lu
aXQoKQoKCS0tIGRlZmF1bHQ6IHZhcmlhYmxlIHdpZHRoIGZvbnQKCXBva2UoMHg0MDAwLGdldChm
ZXRjaCIvc3lzdGVtL2ZvbnRzL2xpbC5mb250IikpCgkKCglsb2NhbCBpY29uPQoJdXNlcmRhdGEi
W2dmeF0wODA4MDc3Nzc3MDA3Nzc3NzcwMDc3Nzc3NzAwNzc3Nzc3MDA3Nzc3NzcwMDc3MDAwMDAw
MDc3Nzc3MDAwMDAwMDAwMFsvZ2Z4XSIKCgl3aW5kb3d7CgkJd2lkdGggPSAyODAsCgkJaGVpZ2h0
ID0gMjAwLAoJCWljb24gICA9IGljb24KCX0KCQoKCWcgPSBjcmVhdGVfZ3VpKCkKCQoJY2UgPSBn
OmF0dGFjaF90ZXh0X2VkaXRvcih7CgkJeD0wLHk9MCwKCQl3aWR0aD1nZXRfZGlzcGxheSgpOndp
ZHRoKCksCgkJaGVpZ2h0PWdldF9kaXNwbGF5KCk6aGVpZ2h0KCksCgkJd2lkdGhfcmVsICA9IDEu
MCwKCQloZWlnaHRfcmVsID0gMS4wLAoJCXN5bnRheF9oaWdobGlnaHRpbmcgPSBmYWxzZSwKCQlz
aG93X2xpbmVfbnVtYmVycyAgID0gZmFsc2UsCgkJbWFya3VwICAgICA9IHRydWUsCgkJZW1iZWRf
cG9kcyA9IHRydWUsCgkJaGFzX3NlYXJjaCA9IHRydWUsCgkJYmdjb2wgPSA3LAkKCQlmZ2NvbCA9
IDUKCX0pCgoKCgljZTphdHRhY2hfc2Nyb2xsYmFycygpCgkKCXdyYW5nbGVfd29ya2luZ19maWxl
KAoKCQktLSBzYXZlIHRvIG9iagoJCWZ1bmN0aW9uICgpCgkJCXJldHVybiB0YWJsZS5jb25jYXQo
Y2U6Z2V0X3RleHQoKSwiXG4iKQoJCWVuZCwKCgkJLS0gbG9hZCBmcm9tIG9iaiAoYXNzdW1lZCB0
byBiZSBhIHN0cmluZykKCQlmdW5jdGlvbiAoc3RyKQoJCQlsb2NhbCB0ZXh0ID0gc3BsaXQoc3Ry
LCAiXG4iLCBmYWxzZSkKCQkJLS1wcmludGgoInN0cjogWyIuLnN0ci4uIl0iKQoJCQktLXByaW50
aCgibm90ZXBhZDogbG9hZGVkICIuLiN0ZXh0Li4iIGxpbmVzIikKCQkJaWYgKG5vdCB0ZXh0IG9y
ICN0ZXh0ID09IDApIHRoZW4gdGV4dCA9IHsiIn0gZW5kCgkJCWNlOnNldF90ZXh0KHRleHQpCgkJ
ZW5kLAoKCQkiL2Rlc2t0b3AvdW50aXRsZWQudHh0IiAtLSBkZWZhdWx0CgkpCgplbmQKCgoKCgoK
CgoKCgoKCgoKOjogdW50aXRsZWQudHh0Ci0tW1twb2RfZm9ybWF0PSJyYXciLGNyZWF0ZWQ9IjIw
MjQtMDMtMDcgMjI6MDM6MzUiLG1vZGlmaWVkPSIyMDI0LTA0LTAxIDExOjA0OjI5IixyZXZpc2lv
bj0zXV0KZml4bWU6IGRlZmF1bHQgbG9jYXRpb24gc2hvdWxkbid0IGJlIC9pbnNpZGUvIHRoZSBh
cHAhCgoKOjogW2VvY10K
:: apps/map.p64
b64$cGljb3Ryb24gY2FydHJpZGdlIC8vIHd3dy5waWNvdHJvbi5uZXQKdmVyc2lvbiAyCgo6OiAu
aW5mby5wb2QKYjY0JExTMWJXM0J2WkN4amNtVmhkR1ZrUFNJeU1ESTBMVEF6TFRJNUlERXlPak01
T2pVeklpeGhkWFJvYjNJOUlteGxlR0ZzYjJabQpiR1VpTEc1dmRHVnpQU0lpTEdsamIyNDlkWE5s
Y21SaGRHRW9JblU0SWl3eE5pd3hOaXdpTURBd01EQXdNREV3TVRBeE1ERXdNVEF4Ck1ERXdNVEF4
TURFd01EQXdNREF3TURBd01ERXdOekEzTURjd056QTNNRGN3TnpBM01EY3dOekF4TURBd01EQXdN
REV3TnpCa01HUXcKWkRCa01HUXdaREJrTUdRd1pEQmtNRGN3TVRBd01ERXdOekJrTUdRd1pEQmtN
R1F3WkRCa01HUXdaREJrTUdRd1pEQTNNREV3TVRBMwpNR1F3WkRCa01EY3dOekEzTUdRd056QTNN
R1F3WkRCa01EY3dNVEF4TURjd1pEQmtNR1F3TnpBM01EY3daREEzTURjd1pEQmtNR1F3Ck56QXhN
REV3TnpCa01HUXdaREEzTURjd056QmtNR1F3WkRCa01HUXdaREEzTURFd01UQTNNR1F3WkRCa01H
UXdaREJrTURjd056QTMKTUdRd1pEQmtNRGN3TVRBeE1EY3daREJrTUdRd056QTNNR1F3TnpBM01E
Y3daREJrTUdRd056QXhNREV3TnpCa01HUXdaREEzTURjdwpaREEzTURjd056QmtNR1F3WkRBM01E
RXdNVEEzTUdRd1pEQmtNR1F3WkRCa01HUXdaREJrTUdRd1pEQmtNRGN3TVRBeE1EWXdOekJrCk1H
UXdaREJrTUdRd1pEQmtNR1F3WkRCa01EY3dOakF4TURFd05qQTJNRGN3TnpBM01EY3dOekEzTURj
d056QTNNRGN3TmpBMk1ERXcKTURBeE1EWXdOakEyTURZd05qQTJNRFl3TmpBMk1EWXdOakEyTURF
d01EQXdNREF3TVRBMk1EWXdOakEyTURZd05qQTJNRFl3TmpBMgpNREV3TURBd01EQXdNREF3TURF
d01UQXhNREV3TVRBeE1ERXdNVEF4TURFd01EQXdNREFpS1N4dGIyUnBabWxsWkQwaU1qQXlOQzB3
Ck55MHdOaUF4TVRvME9Eb3pOaUlzY25WdWRHbHRaVDAxTEhOMGIzSmxaRDBpTWpBeU5DMHdOQzB3
TXlBd05qb3dORG95T0NJc2RHbDAKYkdVOUlsQnBZMjkwY205dUlFMWhjQ0JGWkdsMGIzSWlMSFps
Y25OcGIyNDlJakF1TVdVaUxIZHZjbXR6Y0dGalpYTTllM3RzYjJOaApkR2x2YmowaWJXRnBiaTVz
ZFdFak1pSXNkMjl5YTNOd1lXTmxYMmx1WkdWNFBURjlMSHRzYjJOaGRHbHZiajBpWkhKaGR5NXNk
V0VqCk1TSXNkMjl5YTNOd1lXTmxYMmx1WkdWNFBURjlMSHRzYjJOaGRHbHZiajBpZFhCa1lYUmxM
bXgxWVNNeElpeDNiM0pyYzNCaFkyVmYKYVc1a1pYZzlNWDBzZTJ4dlkyRjBhVzl1UFNKdVlYWXVi
SFZoSXpZaUxIZHZjbXR6Y0dGalpWOXBibVJsZUQweGZTeDdiRzlqWVhScApiMjQ5SW1kMWFTNXNk
V0VqTVNJc2QyOXlhM053WVdObFgybHVaR1Y0UFRGOUxIdHNiMk5oZEdsdmJqMGlZMkZ1ZG1Gekxt
eDFZU001Ck15SXNkMjl5YTNOd1lXTmxYMmx1WkdWNFBURjlMSHRzYjJOaGRHbHZiajBpZFc1a2J5
NXNkV0VqTkRnaUxIZHZjbXR6Y0dGalpWOXAKYm1SbGVEMHhmU3g3Ykc5allYUnBiMjQ5SW1kbWVD
OHdZaTVuWm5naUxIZHZjbXR6Y0dGalpWOXBibVJsZUQweWZTeDdiRzlqWVhScApiMjQ5SW0xaGND
OHdMbTFoY0NJc2QyOXlhM053WVdObFgybHVaR1Y0UFRkOWZWMWRiSG8wQUFRQUFBQURBQUFBTUc1
cGJBPT0KOjogY2FudmFzLmx1YQotLVtbcG9kX2Zvcm1hdD0icmF3IixjcmVhdGVkPSIyMDIzLTA0
LTExIDAyOjA0OjAyIixtb2RpZmllZD0iMjAyNC0wNC0wMyAwNjowNDoyOCIscmV2aXNpb249Mjg2
NF1dCgpsb2NhbCB3dyxoaD0wLDAKbG9jYWwgZmlsbF9jcHU9MApsb2NhbCB4MCx5MD0wLDAKCi0t
W1sKbG9jYWwgdGlsZV93ID0gMTYKbG9jYWwgdGlsZV9oID0gMTYKXV0KCmZ1bmN0aW9uIGRvX2Zp
bGxfMChibXAsIHgsIHksIHRjKQoJaWYgKGdldChibXAseCx5KSAhPSB0YykgcmV0dXJuCglpZiAo
eCA8IDAgb3IgeSA8IDAgb3IgeCA_PSB3dyBvciB5ID49IGhoKSByZXR1cm4KCWxvY2FsIGwscj14
LHgKCXdoaWxlKGdldChibXAsbCx5KT09dGMgYW5kIGw_PTApIGwtPTEKCWwrPTEKCXdoaWxlKGdl
dChibXAscix5KT09dGMgYW5kIHI8d3cpIHIrPTEKCXItPTEKCQoJZm9yIHh4PWwsciBkbwoJCXNl
dChibXAseHgseSxjb2wpCQoJZW5kCgkKCWlmICh5ID4gMCkgdGhlbgoJCWxvY2FsIGxhc3QgPSBu
aWwKCQlmb3IgeHg9bCxyIGRvCgkJCWxvY2FsIHZhbCA9IGdldChibXAseHgseS0xKSA9PSB0YwoJ
CQlpZiAodmFsIGFuZCBub3QgbGFzdCkgdGhlbgoJCQkJZG9fZmlsbF8wKGJtcCx4eCx5LTEsdGMp
CgkJCWVuZAoJCQlsYXN0ID0gdmFsCgkJZW5kCgllbmQKCQoJaWYgKHkgPCBoaC0xKSB0aGVuCgkJ
bG9jYWwgbGFzdCA9IG5pbAoJCWZvciB4eD1sLHIgZG8KCQkJbG9jYWwgdmFsID0gZ2V0KGJtcCx4
eCx5KzEpID09IHRjCgkJCWlmICh2YWwgYW5kIG5vdCBsYXN0KSB0aGVuCgkJCQlkb19maWxsXzAo
Ym1wLHh4LHkrMSx0YykKCQkJZW5kCgkJCWxhc3QgPSB2YWwKCQllbmQKCWVuZAoJCgktLSAjcHV0
YWZsaXBpbml0CgktLSB0byBkbzogd2h5IGlzIHRoaXMgY2F1c2luZyB3bSBmbGlja2VyIHcvIGxv
dyB2YWx1ZXMgKDAuMjUpIH4gaG93IGlzIHRoYXQgcG9zc2libGU-CgktLSBvaC4uIGlzIGp1c3Qg
dGhlIGFwcCBndWk-IG5lZWQgdG8gbWFudWFsbHkgaG9sZCBmcmFtZSBhZ2FpbiBhZnRlciBmbGlw
LiBibGVoLgoJLS1bWwoJaWYgKHN0YXQoMSkgLSBmaWxsX2NwdSA_IDIpIHRoZW4KCQlmaWxsX2Nw
dSA9IHN0YXQoMSkgZ3VpOmRyYXdfYWxsKCkgZmxpcCgpCgkJcG9rZSgweDU0N2MsIDEpIC0tIGtl
ZXAgaG9sZGluZyBmcmFtZQoJZW5kCgldXQplbmQKCmZ1bmN0aW9uIGRvX2ZpbGwoYm1wLCB4LCB5
KQoJbG9jYWwgdGMgPSBnZXQoYm1wLCB4LCB5KQoJaWYgKGNvbCA9PSB0YykgcmV0dXJuCgl3dyxo
aCA9IGJtcDp3aWR0aCgpLCBibXA6aGVpZ2h0KCkKCWZpbGxfY3B1ID0gMAoJcmV0dXJuIGRvX2Zp
bGxfMChibXAsIHgsIHksIHRjKQplbmQKCi0tIHVzZSBwYW4gb2YgY3VycmVudCBpdGVtCi0tIHRv
IGRvOiBnbG9iYWwgcGFuL3NjYWxlIG1vZGU-CmZ1bmN0aW9uIGRyYXdfbGF5ZXIoZWwsIGlpLCBw
YW5feCwgcGFuX3ksIHNjYWxlKQoKCWxvY2FsIGxibXAgPSBpaS5ibXAKCWlmIChub3QgbGJtcCkg
cmV0dXJuCglpZiAoaWkuaGlkZGVuKSByZXR1cm4KCQoJbG9jYWwgdGlsZV93ID0gaWkudGlsZV93
IG9yIDE2Cglsb2NhbCB0aWxlX2ggPSBpaS50aWxlX2ggb3IgMTYKCQoJbG9jYWwgdGlsZV93dyA9
IHRpbGVfdyAqIHNjYWxlCglsb2NhbCB0aWxlX2hoID0gdGlsZV9oICogc2NhbGUKCgktLSBwaXhl
bCBsb29raW5nIGF0IGluIGNlbnRlcgoJbG9jYWwgd3cgPSAobGJtcDp3aWR0aCgpICogdGlsZV93
KQoJbG9jYWwgaGggPSAobGJtcDpoZWlnaHQoKSAqIHRpbGVfaCkKCWxvY2FsIHB4ID0gd3cgLzIg
ICsgcGFuX3gKCWxvY2FsIHB5ID0gaGggLzIgKyBwYW5feQoJCglsb2NhbCB4MCA9IGVsLndpZHRo
XDIgIC0gcHggKiBzY2FsZQoJbG9jYWwgeTAgPSBlbC5oZWlnaHRcMiAtIHB5ICogc2NhbGUKCQkK
CWxvY2FsIHgxLHkxID0geDAgKyB3dyAqIHNjYWxlLCB5MCArIGhoICogc2NhbGUKCQkKCWxvY2Fs
IG1pbl94ID0gbWlkKDAsICgwIC0geDApIFwgdGlsZV93dyAtIDEsIGxibXA6d2lkdGgoKS0xKQoJ
bG9jYWwgbWluX3kgPSBtaWQoMCwgKDAgLSB5MCkgXCB0aWxlX2hoIC0gMSwgbGJtcDpoZWlnaHQo
KS0xKQoJbG9jYWwgbWF4X3ggPSBtaWQoMCwgbWluX3ggKyAoZWwud2lkdGggXCB0aWxlX3d3KSAr
IDIsIGxibXA6d2lkdGgoKS0xKQoJbG9jYWwgbWF4X3kgPSBtaWQoMCwgbWluX3kgKyAoZWwuaGVp
Z2h0IFwgdGlsZV9oaCkgKyAyLCBsYm1wOmhlaWdodCgpLTEpCgkKCS0tIHRvIGRvOiB1c2UgdGxp
bmUKCS0tIHRoaXMgaXMgdG9vIHNsb3cgd2hlbiB6b29tZWQgb3V0IHdpdGggc21hbGwgdGlsZXMK
CWZvciB5PW1pbl95LCBtYXhfeSBkbwoJCWZvciB4PW1pbl94LCBtYXhfeCBkbwoJCQlsb2NhbCBz
eCA9IHgwICsgeCAqIHRpbGVfd3cKCQkJbG9jYWwgc3kgPSB5MCArIHkgKiB0aWxlX2hoCgkJCWxv
Y2FsIHZhbD1nZXQobGJtcCx4LHkpCgkJCXNzcHIoZ2V0X3Nwcih2YWwpLAoJCQkgMCwgMCwgdGls
ZV93LCB0aWxlX2gsIAoJCQkgc3gsIHN5LCB0aWxlX3d3LCB0aWxlX2hoLAoJCQkgdmFsJjB4NDAw
MD4wLCB2YWwmMHg4MDAwPjApCgkJCS0tc3ByKGdldChjYm1wLHgseSksc3gsc3kpCgkJZW5kCgll
bmQKCQoJLS0gZ3JpZCBsaW5lcyAodG8gZG86IHRpbnRlZCkKCQlpZiAoa2V5KCJzcGFjZSIpIGFu
ZCBpaSA9PSBjaSkgdGhlbgoJCQlmaWxscCgpIHBhbCgpCgkJCS0tZmlsbHAoMHhmZjAwKQoJCQlm
b3IgeD1taW5feCp0aWxlX3d3LG1heF94KnRpbGVfd3csdGlsZV93dyBkbwoJCQkJbGluZSh4MCt4
LHkwLHgwK3gseTEtMSwweDAyMDEpCgkJCWVuZAoJCQoJCQktLWZpbGxwKDB4NjY2NikKCQkJZm9y
IHk9bWluX3kqdGlsZV9oaCxtYXhfeSp0aWxlX2hoLHRpbGVfaGggZG8KCQkJCWxpbmUoeDAseTAr
eSx4MS0xLHkwK3ksMHgwMjAxKQoJCQllbmQKCQkJCgkJCWZpbGxwKCkKCQllbmQKZW5kCgoKZnVu
Y3Rpb24gY3JlYXRlX291dGxpbmUoYm1wLCB3dywgaGgpCgoJLS1wcmludGgoImNyZWF0aW5nIG91
dGxpbmU6ICIuLnBvZHt3dyxoaH0pCgoJbG9jYWwgb3V0ID0gdXNlcmRhdGEoInU4Iiwgd3crMiwg
aGgrMikgLS0gMXB4IGJvdW5kYXJ5CglzZXRfZHJhd190YXJnZXQob3V0KQoJCglzc3ByKGJtcCwg
MCwgMCwgXywgXywxLCAxLCB3dywgaGgpCgkKCXd3ICs9IDIgaGggKz0gMgoJCglsb2NhbCBvdXQw
ID0gb3V0OmNvcHkoKQoJCgktLW91dCA9IG91dDphZGQob3V0LCBvdXQsIG5pbCwgMikgLS0gd2hv
YSEKCS0tIHNyY19vZmZzZXQsIGRlc3Rfb2Zmc2V0LCBpdGVtX3dpZHRoLCBzcmNfc3RyaWRlLCBk
ZXN0X3N0cmlkZSwgbnVtX2l0ZW1zCglvdXQ6YWRkKG91dDAsIHRydWUsIHd3KzEsIHd3KzAsIHd3
LTEsIHd3LCB3dywgaGgtMikKCW91dDphZGQob3V0MCwgdHJ1ZSwgd3crMSwgd3crMiwgd3ctMSwg
d3csIHd3LCBoaC0yKQoJb3V0OmFkZChvdXQwLCB0cnVlLCB3dysxLCB3dyowKzEsIHd3LTEsIHd3
LCB3dywgaGgtMikKCW91dDphZGQob3V0MCwgdHJ1ZSwgd3crMSwgd3cqMisxLCB3dy0xLCB3dywg
d3csIGhoLTIpCgkKCS0tIGRpc2NvCglmb3IgeT0wLGhoLTEgZG8KCQlvdXQ6YWRkKDgrKCh5XDMp
JTMpKjgsIHRydWUsIDAsIHkqd3csIDQsIDAsIDgsIHd3LzgrMSkKCWVuZAoJCglvdXQ6YWRkKDgs
IHRydWUsICAwLCAwLCB3dyo0LCB3dywgd3cqOCwgaGgvOCsxKQoJCglzZXRfZHJhd190YXJnZXQo
KQoJcmV0dXJuIG91dAplbmQKCgpmdW5jdGlvbiB1ZHJlY3RmaWxsKHVkLCB4MCwgeTAsIHgxLHkx
LCBjb2wpCglpZiAodHlwZSh1ZCkgfj0gInVzZXJkYXRhIikgcmV0dXJuCgl4MFw9MSB5MFw9MSB4
MVw9MSB5MVw9MQoJaWYgKHgxPHgwKXgwLHgxPXgxLHgwCglpZiAoeTE8eTApeTAseTE9eTEseTAK
CQoJeDAgPSBtYXgoMCwgeDApCgl5MCA9IG1heCgwLCB5MCkKCglsb2NhbCB3aWR0aCwgaGVpZ2h0
ID0gKHgxLXgwKSsxLCAoeTEteTApKzEKCXdpZHRoID0gbWluKHdpZHRoLCB1ZDp3aWR0aCgpLXgw
KQoJaGVpZ2h0ID0gbWluKGhlaWdodCwgdWQ6aGVpZ2h0KCkteTApCgkKCWlmICh3aWR0aCA8IDEg
b3IgaGVpZ2h0IDwgMSkgcmV0dXJuCgkKCWxvY2FsIHVkdyA9IHVkOndpZHRoKCkKCXVkOmNvcHko
Y29sLCB0cnVlLCBuaWwsIHgwK3kwKnVkdyx3aWR0aCwgbmlsLHVkdyxoZWlnaHQpCmVuZAoKCmZ1
bmN0aW9uIGNyZWF0ZV9jYW52YXMoZWwpCglsb2NhbCB3dyxoaCx4MCx5MAoJbG9jYWwgZHJhZ194
MCxkcmFnX3kwID0gMCwwCgkKCWZ1bmN0aW9uIGVsOnVwZGF0ZSgpCgkKCQllbC5jdXJzb3IgPSAi
Y3Jvc3NoYWlyIgoJCWlmIChtdG9vbCA9PSAicGFuIikgZWwuY3Vyc29yID0gImdyYWIiCgkJaWYg
KG10b29sID09ICJmaWxsIikgZWwuY3Vyc29yID0gaWNvbnMuYnVja2V0X2N1cnNvcgoKCQktLSBz
YWZldHkgW2R1cmluZyBkZXZdCgkJY2kuem9vbSA9IGl0ZW1bMV0uem9vbSBvciAxCgkJY2kucGFu
X3ggPSBpdGVtWzFdLnBhbl94IG9yIDAKCQljaS5wYW5feSA9IGl0ZW1bMV0ucGFuX3kgb3IgMAoJ
CQoJCS0tIHRlbXBvcmFyeTogc2V0IGxheWVyIHRvIHNpemUgb2Ygc3ByaXRlIDAKCQktLSAobGF0
ZXI6IGFsbG93IHBlci1sYXllciB0aWxlIHNpemUpCgkJbG9jYWwgc3ByMCA9IGdldF9zcHIoMCkK
CQlpZiAoc3ByMCkgY2kudGlsZV93LCBjaS50aWxlX2ggPSBzcHIwOndpZHRoKCksIHNwcjA6aGVp
Z2h0KCkKCQkKCgkJdGlsZV93ID0gY2kudGlsZV93CgkJdGlsZV9oID0gY2kudGlsZV9oCgkJd3cg
PSBjYm1wX3dpZHRoICAqIGNpLnpvb20gKiB0aWxlX3cKCQloaCA9IGNibXBfaGVpZ2h0ICogY2ku
em9vbSAqIHRpbGVfaAoKCQltdG9vbCA9IGN0b29sCgkJaWYgKGtleSJzcGFjZSIpIG10b29sID0g
InBhbiIKCQlpZiAoa2V5InMiKSBtdG9vbCA9ICJzZWxlY3QiCgkJCgkJLS0gcGl4ZWwgbG9va2lu
ZyBhdCBpbiBjZW50ZXIKCQlsb2NhbCBweCA9IChjYm1wX3dpZHRoICogdGlsZV93KSAvMiAgKyBj
aS5wYW5feAoJCWxvY2FsIHB5ID0gKGNibXBfaGVpZ2h0ICogdGlsZV9oKSAvMiArIGNpLnBhbl95
CgkJCgkJeDAgPSBlbC53aWR0aFwyICAtIHB4ICogY2kuem9vbQoJCXkwID0gZWwuaGVpZ2h0XDIg
LSBweSAqIGNpLnpvb20KCWVuZAoJCglmdW5jdGlvbiBlbDpjbGljayhtc2cpCgkJCgkJYmFja3Vw
X3N0YXRlKCkKCgkJaWYgbXRvb2wgPT0gInNlbGVjdCIgb3IgbXRvb2wgPT0gInBpY2siIHRoZW4K
CQkJLS0gbmVlZHMgdG8gaGFwcGVuIGZpcnN0IGZvciBjYWxjdWxhdGluZyB4LHkKCQkJY2xlYXJf
c2VsZWN0aW9uKCkKCQllbmQKCgoJCWxvY2FsIHggPSAobXNnLm14IC0geDApIFwgKGNpLnpvb20g
KiB0aWxlX3cpCgkJbG9jYWwgeSA9IChtc2cubXkgLSB5MCkgXCAoY2kuem9vbSAqIHRpbGVfaCkK
CQlsb2NhbCB4eCx5eSA9IHgseQoJCQoJCWlmIChjaS5sYXllcikgeC09IGNpLmxheWVyX3ggeS09
IGNpLmxheWVyX3kKCgkJLS0gdGFyZ2UgYml0bWFwOiBkcmF3IHRvIGZsb2F0aW5nIGxheWVyIGlm
IGl0IGV4aXN0cwoJCWxvY2FsIHRibXAgPSBjaS5sYXllciBvciBjYm1wIAoJCWxvY2FsIHRibXBf
d2lkdGgsIHRibXBfaGVpZ2h0ID0gdGJtcDphdHRyaWJzKCkKCQlpZiAodHlwZSh0Ym1wKX49InVz
ZXJkYXRhIikgdGJtcD1jYm1wIHByaW50aCgiKiogbm8gdGJtcCEhIikKCgkJZHJhZ194MCAgPSB4
ICBkcmFnX3kwICA9IHkKCQljbGlja194MCA9IHggIGNsaWNrX3kwID0geSAKCQljbGlja194eDAg
PSB4eCAgY2xpY2tfeXkwID0geXkKCQlvcF9ibXAgPSB0Ym1wOmNvcHkoKQoJCWJsaXQodGJtcCwg
b3BfYm1wKSAtLSB0byBkbzogcmVtb3ZlCgkJCgkJaWYgbXRvb2wgPT0gImZpbGwiIGFuZCBub3Qg
a2V5InNwYWNlIiB0aGVuCgkJCWRvX2ZpbGwodGJtcCwgeCwgeSkKCQllbmQKCQkKCQlpZiAobXRv
b2wgPT0gInBpY2siKSB0aGVuCgkJCS0tIDF4MSBzZWxlY3Rpb24gKGR1cGUpCgkJCQoJCQljaS5s
YXllciA9IHVzZXJkYXRhKCJpMTYiLDEsMSkKCQkJY2kubGF5ZXJfeCA9IHh4CgkJCWNpLmxheWVy
X3kgPSB5eQoJCQljaS5sYXllcjAgPSBjYm1wOmNvcHkoKQoJCQktLSBjb3B5IGZyb20gbWFwIHRv
IGZsb2F0aW5nIGxheWVyCgkJCWJsaXQoY2JtcCxjaS5sYXllcix4eCx5eSwwLDAsMSwxKQoJCWVu
ZAoJCQoJCQoJZW5kCgkKCQoJZnVuY3Rpb24gZWw6ZHJhZyhtc2cpCgoJCWxvY2FsIHRibXAgPSBj
aS5sYXllciBvciBjYm1wIAoJCQoJCS0tIHNldF9kcmF3X3RhcmdldChjYm1wKQoJCQoJCWxvY2Fs
IHggPSAobXNnLm14IC0geDApIFwgKGNpLnpvb20gKiB0aWxlX3cpCgkJbG9jYWwgeSA9IChtc2cu
bXkgLSB5MCkgXCAoY2kuem9vbSAqIHRpbGVfaCkKCQlsb2NhbCBkcmF3X3RhcmdldCA9IGNpLmJt
cAoJCWxvY2FsIHh4LHl5ID0geCx5CgkJaWYgKGNpLmxheWVyKSB0aGVuCgkJCS0tIHNldF9kcmF3
X3RhcmdldChjaS5sYXllcikKCQkJZHJhd190YXJnZXQgPSBjaS5sYXllcgoJCQl4LT0gY2kubGF5
ZXJfeCB5LT0gY2kubGF5ZXJfeQoJCWVuZAoJCQoJCWlmIChtdG9vbCA9PSAicGFuIiBvciBrZXki
c3BhY2UiKSB0aGVuCgkJCS0tY2kucGFuX3ggLT0gbXNnLmR4IC8gY2kuem9vbQoJCQktLWNpLnBh
bl95IC09IG1zZy5keSAvIGNpLnpvb20KCQkJaXRlbVsxXS5wYW5feCAtPSBtc2cuZHggLyBjaS56
b29tCgkJCWl0ZW1bMV0ucGFuX3kgLT0gbXNnLmR5IC8gY2kuem9vbQoJCQkKCQllbHNlaWYgKG10
b29sID09ICJzZWxlY3QiKSB0aGVuCgkJCS0tIHh4LHl5IC0tIG5vdCByZWxhdGl2ZSB0byBzZWxl
Y3Rpb24KCQkJc2V0X2RyYXdfdGFyZ2V0KGNzZWwpCgkJCXJlY3RmaWxsKDAsMCwxMDI0LDEwMjQs
MCkKCQkJcmVjdGZpbGwoY2xpY2tfeHgwICsuNSwgY2xpY2tfeXkwICsuNSwgeHggKy41LCB5eSAr
LjUsIDEpCgkJCWNzZWxfb3V0bGluZSA9IG5pbCAtLSByZWdlbmVyYXRlCgkJZWxzZWlmIChtdG9v
bCA9PSAicGVuY2lsIiBvciBtdG9vbCA9PSAiZXJhc2VyIikgdGhlbgoJCQlpZiAobXNnLm1iID09
IDEpIHRoZW4KCQkJCWxvY2FsIGR4LCBkeSA9IHgtZHJhZ194MCwgeS1kcmFnX3kwCgkJCQlsb2Nh
bCBzdGVwcyA9IG1heChhYnMoZHgpLGFicyhkeSkpCgkJCQlkeCAvPSBzdGVwcyBkeSAvPSBzdGVw
cwoJCQkJbG9jYWwgeHggPSBkcmFnX3gwCgkJCQlsb2NhbCB5eSA9IGRyYWdfeTAKCQkJCQoJCQkJ
Zm9yIGk9MCxzdGVwcyBkbwoJCQkJCXNldChkcmF3X3RhcmdldCwgeHgsIHl5LCBjb2wpCgkJCQkJ
eHggKz0gZHgKCQkJCQl5eSArPSBkeQoJCQkJZW5kCgkJCQoJCQllbmQKCQkJaWYgKG1zZy5tYiA9
PSAyKSBjb2wgPSBnZXQodGJtcCwgeCwgeSkKCQllbHNlaWYgbXRvb2wgPT0gInJlY3QiIHRoZW4K
CQkJYmxpdChvcF9ibXAsIHRibXApCgkJCXVkcmVjdGZpbGwodGJtcCwgY2xpY2tfeDAgKy41LCBj
bGlja195MCArLjUsIHggKy41LCB5ICsuNSwgY29sKQoJCWVsc2VpZiBtdG9vbCA9PSAic3RhbXAi
IHRoZW4KCQkJaWYgKGxhc3Rfc3RhbXBfYm1wX3N0ciB_PSBnZXRfY2xpcGJvYXJkKCkpIHRoZW4K
CQkJCWxhc3Rfc3RhbXBfYm1wX3N0ciA9IGdldF9jbGlwYm9hcmQoKQoJCQkJbGFzdF9zdGFtcF9i
bXAgPSB1bnBvZChsYXN0X3N0YW1wX2JtcF9zdHIpCgkJCWVuZAoJCQoJCQlsb2NhbCBibXAgPSBs
YXN0X3N0YW1wX2JtcAoJCQlpZiAodHlwZShibXApID09ICJ1c2VyZGF0YSIpIHRoZW4KCQkJCWJs
aXQob3BfYm1wLCB0Ym1wKQoJCQkJbG9jYWwgd3csaGggPSBibXA6YXR0cmlicygpCgkJCQlibGl0
KGJtcCwgdGJtcCwgMCwgMCwgeCwgeSkgLS0gdGxjIG1vcmUgY29tbW9uOyB0byBkbzogb3B0aW9u
CgkJCQktLWJsaXQoYm1wLCB0Ym1wLCAwLCAwLCB4IC0gd3cvMiArICh3dyYxKS8yLCB5IC0gaGgv
MiArIChoaCYxKS8yKQoJCQkJCgkJCWVuZAoJCQkKCQllbHNlaWYgbXRvb2wgPT0gImxpbmUiIHRo
ZW4KCQkJYmxpdChvcF9ibXAsIHRibXApCgkJCS0tbGluZShjbGlja194MCArLjUsIGNsaWNrX3kw
ICsuNSwgeCArLjUsIHkgKy41LCBjb2wpIC0tIHRvIGRvIC0tIGRyYXcgbGluZSBvbiB0Ym1wCgkJ
ZW5kCgkJCgkJZHJhZ194MCA9IHggCgkJZHJhZ195MCA9IHkKCQkKCQktLSB1cGRhdGUgY2JtcCB3
aXRoIGFueSBjaGFuZ2VzIGRyYXduIHRvIGNpLmxheWVyCgkJaWYgKGNpLmxheWVyKSBibGl0KGNp
LmxheWVyLCBjYm1wLCAwLCAwLCBjaS5sYXllcl94LCBjaS5sYXllcl95KQoJCQoJZW5kCgoJZnVu
Y3Rpb24gZWw6cmVsZWFzZShtc2cpCgkJCgkJbG9jYWwgeCA9IChtc2cubXggLSB4MCkgXCAoY2ku
em9vbSAqIHRpbGVfdykKCQlsb2NhbCB5ID0gKG1zZy5teSAtIHkwKSBcIChjaS56b29tICogdGls
ZV9oKQoJCQoJCWlmIChtdG9vbCA9PSAic2VsZWN0IikgdGhlbgoJCQlpZiAoY2xpY2tfeDAgPT0g
eCBhbmQgY2xpY2tfeTAgPT0geSkgdGhlbgoJCQkJLS0gY2FuJ3Qgc2VsZWN0IHNpbmdsZSB0aWxl
IHVubGVzcyBob2xkIGZvciBhIGhhbGYgYSBzZWNvbmQKCQkJCS0tIGRlc2VsZWN0CgkJCQljbGVh
cl9zZWxlY3Rpb24oKQoJCQllbHNlCgkJCQktLSBjcmVhdGUgZmxvYXRpbmcgbGF5ZXIKCQkJCWlm
ICh4IDwgY2xpY2tfeDApIGNsaWNrX3gwLHggPSB4LGNsaWNrX3gwCgkJCQlpZiAoeSA8IGNsaWNr
X3kwKSBjbGlja195MCx5ID0geSxjbGlja195MAoJCQkJbG9jYWwgd3cgPSB4IC0gY2xpY2tfeDAg
KyAxCgkJCQlsb2NhbCBoaCA9IHkgLSBjbGlja195MCArIDEKCQkJCQoJCQkJY2kubGF5ZXIgPSB1
c2VyZGF0YSgiaTE2Iix3dyxoaCkKCQkJCWNpLmxheWVyX3ggPSBjbGlja194MAoJCQkJY2kubGF5
ZXJfeSA9IGNsaWNrX3kwCgkJCQkKCQkJCS0tIGNvcHkgb2YgdGhlIGltYWdlIAoJCQkJY2kubGF5
ZXIwID0gY2JtcDpjb3B5KCkKCQkJCS0tIC4uIHdpdGggdGhhdCBhcmVhIGN1dCBvdXQKCQkJCXVk
cmVjdGZpbGwoY2kubGF5ZXIwLCBjbGlja194MCwgY2xpY2tfeTAsIGNsaWNrX3gwICsgd3ctMSwg
Y2xpY2tfeTAgKyBoaC0xLCAwKQoKCQkJCS0tIGNvcHkgZnJvbSBtYXAgdG8gZmxvYXRpbmcgbGF5
ZXIKCQkJCWJsaXQoY2JtcCxjaS5sYXllcixjbGlja194MCwgY2xpY2tfeTAsMCwwLHd3LGhoKQoJ
CQllbmQKCQllbmQJCgkJY2xpY2tfeDAsIGNsaWNrX3kwID0gbmlsIC0tIGRvbid0IGRyYXcgYSBz
ZWxlY3Rpb24gaW4gcHJvZ3Jlc3MKCWVuZAoJCglmdW5jdGlvbiBlbDpkcmF3KG1zZykKCQkKCQls
b2NhbCB4ID0gKG1zZy5teCAtIHgwKSBcIChjaS56b29tICogdGlsZV93KQoJCWxvY2FsIHkgPSAo
bXNnLm15IC0geTApIFwgKGNpLnpvb20gKiB0aWxlX2gpCgkJCgkJbG9jYWwgc2NhbGUgPSBjaS56
b29tCgkJbG9jYWwgdGlsZV93dyA9IHRpbGVfdyAqIHNjYWxlCgkJbG9jYWwgdGlsZV9oaCA9IHRp
bGVfaCAqIHNjYWxlCgkJCgkJCgkJZmlsbHAoMHg5MzZjKQoJCXJlY3RmaWxsKDAsMCxzZWxmLndp
ZHRoLHNlbGYuaGVpZ2h0LDEpCgkJZmlsbHAoKQoJCXJlY3RmaWxsKHgwLTEseTAtMSx4MCt3dyx5
MCtoaCwwKQoJCXJlY3QgICAoeDAtMix5MC0yLHgwK3d3KzEseTAraGgrMSw2KQoJCQoJCS0tIGRy
YXcgYm90dG9tIHRvIHRvcAoJCWZvciBpPSNpdGVtLDEsLTEgZG8KCQkJZHJhd19sYXllcihlbCwg
aXRlbVtpXSwgaXRlbVsxXS5wYW5feCwgaXRlbVsxXS5wYW5feSwgaXRlbVsxXS56b29tKQoJCWVu
ZAoJCQoJCQoJCS0tW1sKCQktLSB0bGluZSB2ZXJzaW9uOiBkcmF3IGEgYnVuY2ggb2YgdGxpbmVz
OyBjbGlwIHRvIHZpZXdhYmxlIGFyZWEKCQktLSBvbmx5IHdvcmtzIGZvciBuXjIgbWFwIHNpemVz
CgkJbG9jYWwgeXkwPW1heCgwLDAteTApCgkJbG9jYWwgeXkxPW1pbihoaCxzZWxmLmhlaWdodC15
MCktMQoJCWZvciB5eT15eTAseXkxIGRvCgkJCWxvY2FsIHN5ID0geTAreXkKCQkJLS0gMHgxMDAg
Zm9yIGhhbGYtb3BlbiBtb2RlIChkb24ndCBkcmF3IGxhc3QgcGl4ZWwgLS0gc2ltcGxpZmllcyBt
YXRoKQoJCQl0bGluZTNkKGNibXAsIHgwLHN5LHgxLHN5LCAwLHl5L3RpbGVfaGgsY2JtcDp3aWR0
aCgpLHl5L3RpbGVfaGgsIG5pbCxuaWwsMHgxMDApCgkJZW5kCgkJXV0KCQkKCQktLSBlZGdlIGd1
aWRlbGluZXMKCQktLVtbCgkJbGluZSh4MC0xLCAwLCB4MC0xLCAxMDAwLCA1KQoJCWxpbmUoeDEr
MCwgMCwgeDErMCwgMTAwMCwgNSkKCQlsaW5lKDAsIHkwLTEsIDEwMDAsIHkwLTEsIDUpCgkJbGlu
ZSgwLCB5MSswLCAxMDAwLCB5MSswLCA1KQoJIAoJCXByaW50KHBvZHt5eTAsIHl5MSwgc3RhdCgx
KX0sMjAsMjAsNykKCQldXQoJCQoJCQoJCQoJCWZpbGxwKCkKCgoJCS0tLS0tLS0tLS0gZHJhdyBz
ZWxlY3Rpb24KCgkJaWYgKGZhbHNlKSB0aGVuCi0tCQlpZiAoY3NlbCkgdGhlbgoJCQoJCQlsb2Nh
bCBzZWxfc2NhbGUgPSBtaW4oc2NhbGUsIDAuNSkKCgkJCXdoaWxlIHNlbF9zY2FsZSA8IHNjYWxl
IGFuZCAKCQkJCXNlbF9zY2FsZSAqIGNibXA6d2lkdGgoKSAqIHRpbGVfdyA8IDEyOCBhbmQKCQkJ
CXNlbF9zY2FsZSAqIGNibXA6aGVpZ2h0KCkgKiB0aWxlX2ggPCAxMjggZG8KCQkJCXNlbF9zY2Fs
ZSArPSAxCgkJCWVuZAoJCQlsb2NhbCBzZWxfd3cgPSBjYm1wOndpZHRoKCkgKiB0aWxlX3cgKiBz
ZWxfc2NhbGUKCQkJbG9jYWwgc2VsX2hoID0gY2JtcDpoZWlnaHQoKSAqIHRpbGVfaCAqIHNlbF9z
Y2FsZQoJCQoJCQktLSB0byBkbzogYWxzbyB1cGRhdGUgaGlnaCBiaXRzIGluIGltYWdlIHRvIHBy
b3RlY3QKCQkJLS0gcGl4ZWxzIG91dHNpZGUgb2Ygc2VsZWN0aW9uIGZyb20gbW9kaWZpY2F0aW9u
Ci0tW1sKCQkJaWYgKG5vdCBjc2VsX291dGxpbmUgb3Igc2VsX3d3IH49IGxhc3Rfb3V0bGluZV93
dykgdGhlbgoJCQkJY3NlbF9vdXRsaW5lID0gY3JlYXRlX291dGxpbmUoY3NlbCwgc2VsX3d3LCBz
ZWxfaGgpCgkJCQlsYXN0X291dGxpbmVfd3cgPSBzZWxfd3cKCQkJZW5kCl1dCgkJCgkJCS0tc3By
KGNzZWxfb3V0bGluZSx4MCx5MCkKCQkJZm9yIGk9MCw2MyBkbwoJCQkJcGFsdChpLHRydWUpCgkJ
CWVuZAoJCQlwYWx0KDEsZmFsc2UpIHBhbHQoMixmYWxzZSkKCQkJCgkJCXBhbCgxLDcpIHBhbCgy
LDcpCgkJCQoJCQlsb2NhbCBjYz0odCgpKjgpJTgKCQkJcGFsKDksICA4ICsgKGNjKzApJTgpCgkJ
CXBhbCgxNywgOCArIChjYysyKSU4KQoJCQlwYWwoMjUsIDggKyAoY2MrNCklOCkKCQkJcGFsKDMz
LCA4ICsgKGNjKzYpJTgpCgkJCQoJCQkKCQkJZmlsbHAoMHhjOTM2OTM2YzM2Yzk2YzkzID4_ICgo
KHRpbWUoKSoxNSlcMSklNCkqMTYpCgkJCQoJCQktLSB0byBkbzogZml4IG1hdGNoaW5nCgkJCWxv
Y2FsIHFxID0gMQoJCQlpZiAoc2VsX3NjYWxlIDwgc2NhbGUpIHFxID0gMgoJCQkKCQkJLS1xcSA9
IHNjYWxlIC8gc2VsX3NjYWxlCgkJCS0tcGFsKCkgZmlsbHAoKQoKCQkJcGFsKCkKCgkJCQotLQkJ
CXNzcHIoY3NlbF9vdXRsaW5lLCAwLCAwLCBfLCBfLCB4MC1xcSwgeTAtcXEsIHd3K3FxKjIsIGho
K3FxKjIpCgoJCQkKCQkJCgkJZW5kCgoJCXBhbCgpCgkJZmlsbHAoMHhjOTM2OTM2YzM2Yzk2Yzkz
ID4_ICgoKHRpbWUoKSoxNSlcMSklNCkqMTYpCgoJCWlmIChjaS5sYXllciBhbmQgY2kubGF5ZXJf
eCkgdGhlbgoJCQlsb2NhbCBzeDAgPSB4MCArIGNpLmxheWVyX3ggKiB0aWxlX3cgKiBzY2FsZQoJ
CQlsb2NhbCBzeTAgPSB5MCArIGNpLmxheWVyX3kgKiB0aWxlX2ggKiBzY2FsZQoJCQlsb2NhbCBz
eDEgPSBzeDAgKyBjaS5sYXllcjp3aWR0aCgpICogdGlsZV93ICogc2NhbGUKCQkJbG9jYWwgc3kx
ID0gc3kwICsgY2kubGF5ZXI6aGVpZ2h0KCkgKiB0aWxlX2ggKiBzY2FsZQoKCQkJcmVjdChzeDAt
MSxzeTAtMSxzeDEsc3kxLDB4MDcwMSkKCgkJZWxzZWlmIChjbGlja194MCBhbmQgbXRvb2wgPT0g
InNlbGVjdCIgYW5kIG1zZy5tYiA_IDApIHRoZW4KCQkKCQkJLS0gc2VsZWN0aW9uIGluIHByb2dy
ZXNzCgkJCWxvY2FsIG14MCA9IGNsaWNrX3gwCgkJCWxvY2FsIG15MCA9IGNsaWNrX3kwCgkJCWxv
Y2FsIG14MSA9IHgKCQkJbG9jYWwgbXkxID0geQoJCQlpZiAobXgwID4gbXgxKSBteDAsbXgxID0g
bXgxLG14MAoJCQlpZiAobXkwID4gbXkxKSBteTAsbXkxID0gbXkxLG15MAoJCQkKCQkJbG9jYWwg
c3gwID0geDAgKyBteDAgKiB0aWxlX3cgKiBzY2FsZQoJCQlsb2NhbCBzeTAgPSB5MCArIG15MCAq
IHRpbGVfaCAqIHNjYWxlCgkJCWxvY2FsIHN4MSA9IHgwICsgKG14MSsxKSAqIHRpbGVfdyAqIHNj
YWxlCgkJCWxvY2FsIHN5MSA9IHkwICsgKG15MSsxKSAqIHRpbGVfaCAqIHNjYWxlCgoJCQlyZWN0
KHN4MC0xLHN5MC0xLHN4MSxzeTEsMHgwNzAxKQoKCQllbmQKCgkJZmlsbHAoKSBwYWwoKQoKCQlw
cmludChzdHJpbmcuZm9ybWF0KCJcIzAgJTNkICUzZCAiLHgseSksIDEyLCAgc2VsZi5oZWlnaHQt
MTQsIDYpCgkJCgkJLS1wcmludChzdGF0KDEpLDEwLDEwLDcpCgotLQkJaWYgKGNpLmxheWVyKSBw
cmludCgibGF5ZXI6ICIuLnBvZHtjaS5sYXllcl94LGNpLmxheWVyX3ksY2kubGF5ZXI6YXR0cmli
cygpfSwgMjAsIDIwLDcpIC0tIHRvIGRvOiBkcmF3IHNlbGVjdGlvbi4gY3JlYXRlX291dGxpbmUg
b24gZGVtYW5kIGV0YwotLQkJcHJpbnQoIm10b29sOiAiLi5tdG9vbCwyMCwzMCw3KQoJZW5kCgkK
CWZ1bmN0aW9uIGVsOm1vdXNld2hlZWwobXNnKQoJCgkJbG9jYWwgaWkgPSBpdGVtWzFdIC0tIGds
b2JhbCB6b29tIGZvciBub3cKCQlpZiAoaWkuem9vbSA8PSAxKSB0aGVuCgkJCWlmIChtc2cud2hl
ZWxfeSA8IDApIGlpLnpvb20gLz0gMgoJCQlpZiAobXNnLndoZWVsX3kgPiAwKSBpaS56b29tICo9
IDIKCQllbHNlCgkJCWlpLnpvb20gKz0gbXNnLndoZWVsX3kKCQllbmQKCQkKCQlsb2NhbCBtaW5f
c2NhbGUgPSAwLjI1CgkJbG9jYWwgbWF4X3NjYWxlID0gNAoJCQoJCS0tIGNhbiB6b29tIG91dCBm
dXJ0aGVyIHdoZW4gd291bGRuJ3QgZml0IG90aGVyd2lzZQoJCS0tIGlmIChjYm1wOndpZHRoKCkg
ID49IHNlbGYud2lkdGggKSBtaW5fc2NhbGUgPSAwLjUKCQktLSBpZiAoY2JtcDpoZWlnaHQoKSA_
PSBzZWxmLmhlaWdodCkgbWluX3NjYWxlID0gMC41CQkKCQkKCQlpaS56b29tID0gbWlkKG1pbl9z
Y2FsZSwgaWkuem9vbSwgbWF4X3NjYWxlKQoJCWlmIChpaS56b29tID49IDEpIGlpLnpvb20gXD0g
MQoJZW5kCgkKCQoJcmV0dXJuIGVsCmVuZAoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoK
CgoKCgoKOjogZHJhdy5sdWEKLS1bW3BvZF9mb3JtYXQ9InJhdyIsY3JlYXRlZD0iMjAyMy0yNi0x
MiAwMzoyNjoyMCIsbW9kaWZpZWQ9IjIwMjQtMDQtMDMgMDY6MDQ6MjgiLHJldmlzaW9uPTE3OTFd
XQpmdW5jdGlvbiBfZHJhdygpCgljbHMoNSkKCS0tIG9wZXJhdGlvbnMgZHVyaW5nIF91cGRhdGUg
Y2FuIHJlcXVlc3QgYQoJLS0gZ3VpIHVwZGF0ZSBiZWZvcmUgaXQgaXMgbmV4dCBkcmF3IChhdm9p
ZCBmbGlja2VyKQoJaWYgKHJlZnJlc2hfZ3VpKSB0aGVuCgkJZ2VuZXJhdGVfZ3VpKCkKCQktLSBn
dWk6ZHJhd19hbGwoKSBleHBlY3RzIDp1cGRhdGVfYWxsKCkgY2FsbGVkIGZpcnN0IG9uIGN1cnJl
bnQgc3RhdGUgb2YgZ3VpCgkJZ3VpOnVwZGF0ZV9hbGwoKQoJCXJlZnJlc2hfZ3VpID0gZmFsc2UK
CWVuZAoJCQoJZmlsbHAoKSBwYWwoKQoJZ3VpOmRyYXdfYWxsKCkKCQoJLS0gZGFyayBncmF5Cglw
b2tlNCgweDUwMDArMzIqNCwgMHgyMDIwMjAyMCkKCQoJaWYgKGN1c3RvbV9wYWxldHRlKSB0aGVu
CgkJcG9rZTQoMHg1MDAwLCBnZXQoY3VzdG9tX3BhbGV0dGUpKQoJZW5kCgkKZW5kCgoKOjogZ3Vp
Lmx1YQotLVtbcG9kX2Zvcm1hdD0icmF3IixjcmVhdGVkPSIyMDIzLTA1LTExIDAyOjA1OjE2Iixt
b2RpZmllZD0iMjAyNC0wNC0wMyAwNjowNDoyOCIscmV2aXNpb249MjYwMl1dCgpzaG93X3BhbmUg
PSB0cnVlCgoKCiAtLSB1cGRhdGUgbGF5b3V0IHdpdGhvdXQgbmVlZGluZyB0byByZWdlbmVyYXRl
IGd1aQogLS0gdG8gZG86IGNvdWxkIGFsc28gdXNlIHRoaXMgZm9yIGhhbmRsaW5nIGNoYW5nZXMg
aW4gZGlzcGxheSBzaXplCiBmdW5jdGlvbiB1cGRhdGVfZ3VpX2xheW91dCgpCiAJaWYgKG5vdCBz
aWRlYmFyIG9yIG5vdCBjYW52YXNfZWwpIHJldHVybgogCQogCXh0ID0gc2hvd19wYW5lIGFuZCAz
MzYgb3IgNDgwCiAJc2lkZWJhcl94ID0gc2lkZWJhcl94IG9yIHNpZGViYXIueAogCXNpZGViYXJf
eCA9IChzaWRlYmFyX3ggKiAzICsgeHQpIC8gNAogCQoJaWYgKHNpZGViYXJfeCA_IHh0KSB0aGVu
CgkJc2lkZWJhcl94ID0gbWF4KHh0LCBzaWRlYmFyX3ggLSA4KQoJZWxzZQoJCXNpZGViYXJfeCA9
IG1pbih4dCwgc2lkZWJhcl94ICsgOCkKCWVuZAoJCgktLSAhISBpbnN0YW50IGNoYW5nZSAtLSBt
YXliZSBiZXR0ZXIgKHN0aWxsIGdldCB0b29sYmFyIHRyYW5zaXRpb24hKQoJc2lkZWJhcl94ID0g
eHQKCiAJc2lkZWJhci54ID0gc2lkZWJhcl94IFwgMQogCXNpZGViYXIuaGVpZ2h0ID0gZ2V0X2Rp
c3BsYXkoKTpoZWlnaHQoKQogCgljYW52YXNfZWwud2lkdGggPSBzaWRlYmFyX3ggXCAxCgljYW52
YXNfZWwuaGVpZ2h0ID0gZ2V0X2Rpc3BsYXkoKTpoZWlnaHQoKQogCgktLSBzZW5kIGEgbWVzc2Fn
ZSB0byB3bSBhc2tpbmcgdG8gdW5kb2NrIC8gZG9jayB0b29sYmFyCglpZiBzaG93X3BhbmUgfj0g
bGFzdF9zaG93X3BhbmUgdGhlbgkKCQktLXNlbmRfbWVzc2FnZSgzLCB7ZXZlbnQ9ImRvY2tfdG9v
bGJhciIsIHN0YXRlID0gc2hvd19wYW5lfSkKCWVuZAoJbGFzdF9zaG93X3BhbmUgPSBzaG93X3Bh
bmUKIGVuZAogCgpmdW5jdGlvbiBnZW5lcmF0ZV9ndWkoKQoJCglndWkgPSBjcmVhdGVfZ3VpKCkK
CQoJLS0gcmVtb3ZlIHRlbXBvcmFyeSBpdGVtcyBhdHRhY2hlZCBvbiBkZW1hbmQKCWxheWVyX25h
bWVfZWRpdG9yID0gbmlsCglmaWVsZF9lZGl0b3IgPSBuaWwKCQoJaWYgKG5vdCBzaG93X3BhbmUp
IHRoZW4KCQlndWk6YXR0YWNoKGNyZWF0ZV9jYW52YXN7eD0wLHk9MCx3aWR0aD00ODAsaGVpZ2h0
PWdldF9kaXNwbGF5KCk6aGVpZ2h0KCl9KQoJCXJldHVybgoJZW5kCgkKCWNhbnZhc19lbCA9IGd1
aTphdHRhY2goY3JlYXRlX2NhbnZhc3t4PTAseT0wLHdpZHRoPTMzNixoZWlnaHQ9MjYxfSkKCQoJ
c2lkZWJhciA9IGd1aTphdHRhY2h7eD00ODAtMTQ0LHk9MCx3aWR0aD0xNTAsaGVpZ2h0PTI1MH0K
CQoJc2lkZWJhcjphdHRhY2goY3JlYXRlX2xheWVyX2luZm97eD04LHk9NSx3aWR0aD0xMjgsaGVp
Z2h0PTI0fSkKCXNpZGViYXI6YXR0YWNoKGNyZWF0ZV9sYXllcl9uYXZ7eD04LHk9MTYsd2lkdGg9
MTI4LGhlaWdodD01NX0pCgkKCS0tIGEgbGl0dGxlIHNwYWNlIGFib3ZlIHBhbGV0dGUgZm9yIHRh
YnMgKG9wZXJhdGlvbikKCS0tbG9jYWwgcGFsX2VsID0gc2lkZWJhcjphdHRhY2goY3JlYXRlX3Bh
bGV0dGV7eD04LHk9MTQsd2lkdGg9MTI4LGhlaWdodD0zMn0pCgkJCgktLXNpZGViYXI6YXR0YWNo
KGNyZWF0ZV9pdGVtX2luZm97eD04LHk9NjQsd2lkdGg9MTI4LGhlaWdodD0yMH0pCglzaWRlYmFy
OmF0dGFjaChjcmVhdGVfaXRlbV9pbmZve3g9OCx5PTk2LHdpZHRoPTEyOCxoZWlnaHQ9MjR9KQoJ
c2lkZWJhcjphdHRhY2goY3JlYXRlX2JhbmtfdGFic3t4PTgrMTI4LTQ4KzEseT0xMTYtOSx3aWR0
aD00OCxoZWlnaHQ9OX0pCglzaWRlYmFyOmF0dGFjaChjcmVhdGVfbmF2e3g9OCx5PTExNix3aWR0
aD0xMjgsaGVpZ2h0PTEyOH0pCgkKCS0tLS0gdG9vbHMgLS0tLQoJCgktLSAqKiB0byBkbzogdG9v
bCBzaG91bGQgZGVwZW5kIG9uIGxheWVyIHR5cGUuCgktLSAqKiBlLmcuIGVudGl0eSBwaWNrZXIg
d2hlbiBsYXllciBpcyBlbnRpdGllcyBtb2RlCgkKCWxvY2FsIHRvb2xzID0gewoJCSJwZW5jaWwi
LCAicmVjdCIsImZpbGwiLCJzdGFtcCIsInNlbGVjdCIsInBpY2siLCJwYW4iCgl9CgkKCWxvY2Fs
IHd3PTEyCglsb2NhbCB5eT03NSAtLSBnZnggaXMgNTAKCWZvciBpPTAsI3Rvb2xzLTEgZG8KCXNp
ZGViYXI6YXR0YWNoKGNyZWF0ZV90b29sX2J1dHRvbih0b29sc1tpKzFdLCAKCQkxMCsoaSV3dykq
MTQsIHl5KyhpXHd3KSoxNCkpCgllbmQKCQoJCgkKCXVwZGF0ZV9ndWlfbGF5b3V0KCkKCgplbmQK
bG9jYWwgdG9vbF9nZng9ewpwZW5jaWw9IltnZnhdMDgwODAwMDA3MDAwMDAwNzc3MDAwMDc3Nzc3
MDA3Nzc3NzAwNzA3NzcwMDA3MDA3MDAwMDc3NzAwMDAwMDAwMDAwMDBbL2dmeF0iLApicnVzaD0i
W2dmeF0wODA4MDAwMDA3NzAwMDAwNzcwMDAwMDc3MDAwMDAwNzAwMDAwNzcwMDAwMDA3NzAwMDAw
NzcwMDAwMDAwMDAwMDAwMFsvZ2Z4XSIsCmxpbmU9IltnZnhdMDgwODAwMDAwMDcwMDAwMDA3MDAw
MDAwNzAwMDAwMDcwMDAwMDA3MDAwMDAwNzAwMDAwMDcwMDAwMDAwMDAwMDAwMDBbL2dmeF0iLAot
LXJlY3Q9IltnZnhdMDgwODc3Nzc3NzcwNzAwMDAwNzA3MDAwMDA3MDcwMDAwMDcwNzAwMDAwNzA3
MDAwMDA3MDc3Nzc3NzcwMDAwMDAwMDBbL2dmeF0iLApyZWN0PSAtLSBhbHdheSBmaWxsZWQgaW4g
bWFwIGVkaXRvcgotLVtbcG9kLHBvZF90eXBlPSJpbWFnZSJdXXVucG9kKCJiNjQ6YkhvMEFCUUFB
QUFYQUFBQXMzQjRkUUJESUFnSUJHY0FBZ0JRQUdjQVo0QT0iKSwKcGljaz0KLS1bW3BvZCxwb2Rf
dHlwZT0iaW1hZ2UiXV11bnBvZCgiYjY0OmJIbzBBQmdBQUFBV0FBQUE4QWR3ZUhVQVF5QUlDQVFn
QjJBSHNCY2dGN0FIWUFldyIpLApzZWxlY3Q9IltnZnhdMDgwODc3MDcwNzcwNzAwMDAwNzAwMDAw
MDAwMDcwMDAwMDcwMDAwMDAwMDA3MDAwMDA3MDc3MDcwNzcwMDAwMDAwMDBbL2dmeF0iLApzaGFw
ZT0iW2dmeF0wODA4Nzc3Nzc3NzA3MDAwMDA3MDcwMDAwMDcwNzAwMDAwNzA3MDAwMDA3MDcwMDAw
MDcwNzc3Nzc3NzAwMDAwMDAwMFsvZ2Z4XSIsCnBhbj0iW2dmeF0wODA4MDA3MDcwMDAwMDcwNzA3
MDAwNzA3MDcwMDA3Nzc3NzA3MDc3Nzc3MDA3Nzc3NzcwMDA3Nzc3MDAwMDAwMDAwMFsvZ2Z4XSIs
CmZpbGw9IltnZnhdMDgwODAwMDA3MDAwMDAwMDA3MDAwMDAwMDA3MDA3Nzc3Nzc3NzA3Nzc3NzA3
MDA3NzcwMDcwMDA3MDAwMDAwMDAwMDBbL2dmeF0iLApzdGFtcD0iW2dmeF0wODA4MDA3NzcwMDAw
MDc3NzAwMDAwNzc3MDAwMDA3NzcwMDA3Nzc3Nzc3MDcwMDAwMDcwNzc3Nzc3NzAwMDAwMDAwMFsv
Z2Z4XSIsCnNtdWRnZT0iW2dmeF0wODA4MDA3MDAwMDAwMDcwMDAwMDAwNzA3MDcwMDA3Nzc3NzA3
MDc3Nzc3MDA3Nzc3NzcwMDA3Nzc3MDAwMDAwMDAwMFsvZ2Z4XSIsCnN3ZWVwPSJbZ2Z4XTA4MDgw
MDAwNzAwMDAwMDA3MDAwMDAwMDcwMDAwMDA3MDAwMDAwMDcwMDAwNzc3Nzc3NzA3MDcwNzA3MDAw
MDAwMDAwWy9nZnhdIiwKdGV4dD0iW2dmeF0wODA4Nzc3Nzc3NzA3NzAwNzc3MDc3NzcwNzcwNzcw
MDA3NzA3MDc3MDc3MDc3MDA3MDcwNzc3Nzc3NzAwMDAwMDAwMFsvZ2Z4XSIsCnNjcmFtYmxlPSJb
Z2Z4XTA4MDgwNzAwMDcwMDA3MDAwNzAwNzc3Nzc3NzA3MDc3NzA3MDc3Nzc3NzcwMDcwMDA3MDA3
NzAwMDc3MDAwMDAwMDAwWy9nZnhdIiwKZXJhc2VyPSJbZ2Z4XTA4MDgwMDA3NzAwMDAwNzc3NzAw
MDc3Nzc3NzA3MDc3Nzc3MDcwMDc3NzAwMDcwMDcwMDAwMDc3MDAwMDAwMDAwMDAwWy9nZnhdIiwK
fQpsb2NhbCBicnVzaF9nZng9ewoiW2dmeF0wODA4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAw
NzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFsvZ2Z4XSIsCiJbZ2Z4XTA4MDgw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA3NzAwMDAwMDc3MDAwMDAwMDAwMDAwMDAwMDAwMDAw
MDAwMDAwWy9nZnhdIiwKIltnZnhdMDgwODAwMDAwMDAwMDAwMDAwMDAwMDA3MDAwMDAwNzc3MDAw
MDAwNzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBbL2dmeF0iLAoiW2dmeF0wODA4MDAwMDAw
MDAwMDAwMDAwMDAwMDc3MDAwMDA3Nzc3MDAwMDc3NzcwMDAwMDc3MDAwMDAwMDAwMDAwMDAwMDAw
MFsvZ2Z4XSIsCiJbZ2Z4XTA4MDgwMDAwMDAwMDAwMDc3MDAwMDA3Nzc3MDAwNzc3Nzc3MDA3Nzc3
NzcwMDA3Nzc3MDAwMDA3NzAwMDAwMDAwMDAwWy9nZnhdIiwKIltnZnhdMDgwODAwNzc3NzAwMDc3
Nzc3NzA3Nzc3Nzc3Nzc3Nzc3Nzc3Nzc3Nzc3Nzc3Nzc3Nzc3NzA3Nzc3NzcwMDA3Nzc3MDBbL2dm
eF0iLAoiW2dmeF0wODA4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDc3NzcwMDAw
MDAwMDAwMDAwMDAwMDAwMDAwMDAwMFsvZ2Z4XSIsCiJbZ2Z4XTA4MDgwMDAwMDAwMDAwMDAwMDAw
MDAwMDA3MDAwMDAwNzAwMDAwMDcwMDAwMDA3MDAwMDAwNzAwMDAwMDAwMDAwMDAwWy9nZnhdIgp9
CmZ1bmN0aW9uIGNyZWF0ZV9icnVzaF9idXR0b24od2hpY2gsIHgsIHkpCglsb2NhbCBlbD0ge3do
aWNoID0gd2hpY2gsIHggPSB4LCB5ID0geSwgd2lkdGg9MTIsIGhlaWdodCA9IDEyfQoJCgllbC5n
ZnggPSB1c2VyZGF0YShicnVzaF9nZnhbd2hpY2hdKQoJCglmdW5jdGlvbiBlbDpkcmF3KCkKCQly
ZWN0ZmlsbCgwLDEsc2VsZi53aWR0aC0yLHNlbGYuaGVpZ2h0LTIsMCkKCQlwYWwoNywgc2VsZi53
aGljaCA9PSBicnVzaC53aGljaCBhbmQgNyBvciAxMykKCQlzcHIoc2VsZi5nZngsMiwyKQoJCXBh
bCg3LDcpCgllbmQKCQoJZnVuY3Rpb24gZWw6dGFwKCkKCQlicnVzaC53aGljaCA9IHNlbGYud2hp
Y2gKCQlicnVzaC50aGlja25lc3MgPSBzZWxmLndoaWNoLTEKCWVuZAoJCglyZXR1cm4gZWwKZW5k
CmZ1bmN0aW9uIGNyZWF0ZV90b29sX2J1dHRvbih3aGljaCwgeCwgeSkKCWxvY2FsIGVsPSB7d2hp
Y2ggPSB3aGljaCwgeCA9IHgsIHkgPSB5LCB3aWR0aD0xMiwgaGVpZ2h0ID0gMTJ9CgkKCWVsLmdm
eCA9IHRvb2xfZ2Z4W3doaWNoXQoJaWYgKHR5cGUoZWwuZ2Z4KT09InN0cmluZyIpIGVsLmdmeCA9
IHVzZXJkYXRhKHRvb2xfZ2Z4W3doaWNoXSkKCQoJZnVuY3Rpb24gZWw6ZHJhdygpCgktLVtbCgkJ
bGluZSgxLDAsOSwwLDEzKQoJCXJlY3RmaWxsKDAsMSwxMCw5LDEzKQoJCWxpbmUoMSwxMCw5LDEw
LDEzKQoJXV0KCQlwYWwoNywgd2hpY2ggPT0gY3Rvb2wgYW5kIDcgb3IgMTMpCgkJc3ByKHNlbGYu
Z2Z4LDIsMikKCQlwYWwoNyw3KQoJZW5kCgkKCWZ1bmN0aW9uIGVsOnRhcCgpCgkJY3Rvb2wgPSBz
ZWxmLndoaWNoCgkJcmVmcmVzaF9ndWkgPSB0cnVlCgllbmQKCQoJcmV0dXJuIGVsCmVuZAoKCgoK
OjogbWFpbi5sdWEKLS1bW3BvZF9mb3JtYXQ9InJhdyIsY3JlYXRlZD0iMjAyMy0wNC0xMSAwMjow
NDo1NCIsbW9kaWZpZWQ9IjIwMjQtMDQtMDMgMDY6MDQ6MjgiLHJldmlzaW9uPTI2NzJdXQotLVtb
CglQaWNvdHJvbiBNYXAgRWRpdG9yCl1dCmluY2x1ZGUgImRyYXcubHVhIgppbmNsdWRlICJ1cGRh
dGUubHVhIgppbmNsdWRlICJndWkubHVhIgppbmNsdWRlICJjYW52YXMubHVhIgppbmNsdWRlICJu
YXYubHVhIgppbmNsdWRlICJ1bmRvLmx1YSIKLS0gZGVsZXRlbWUKY2JtcCxjYm1wX3dpZHRoLGNi
bXBfaGVpZ2h0ID0gbmlsLG5pbCxuaWwKCi0tIHRvIGRvOiB1bmlmeSB3aXRoIGxvYWRfd29ya2lu
Z19maWxlCmZ1bmN0aW9uIGNyZWF0ZV9kZWZhdWx0X21hcHMoKQoJLS0gZGVmYXVsdCBtYXBzCgli
bXAgPSB7fQoJaXRlbSA9IHt9Cglmb3IgaT0xLDEgZG8KCQlpdGVtW2ldID0gewoJCQlibXAgICA9
IHVzZXJkYXRhKCJ1MTYiLDMyLDMyKSwKCQkJbmFtZSA9IG5pbCwgLS0ibGF5ZXIgIi4uaSwgLS0g
bGF0ZXI6IGN1c3RvbSBuYW1lcyBmb3IgbGF5ZXJzCgkJCWV4dHJhID0gbmlsLCAtLSB0ZXh0LiBt
YXliZSAibm90ZXMiPwoJCQlwYW5feCA9IDAsCgkJCXBhbl95ID0gMCwKCQkJc2NhbGUgPSAxLAoJ
CQl0aWxlX3cgPSAxNiwKCQkJdGlsZV9oID0gMTYKCQl9CgkJYWRkX3VuZG9fc3RhY2soaXRlbVtp
XSkKCWVuZAplbmQKCmZ1bmN0aW9uIHNhdmVfd29ya2luZ19maWxlKCkKCWxvY2FsIG91dHB1dCA9
IHt9Cglmb3IgaT0xLCNpdGVtIGRvCgkJbG9jYWwgaWk9aXRlbVtpXQoJCW91dHB1dFtpXSA9IHsK
CQkJbmFtZSA9IGlpLm5hbWUsCgkJCWJtcCA9IGlpLmJtcCwKCQkJcGFuX3ggPSBpaS5wYW5feCwK
CQkJcGFuX3kgPSBpaS5wYW5feSwKCQkJem9vbSA9IGlpLnpvb20sCgkJCXRpbGVfdyA9IGlpLnRp
bGVfdywKCQkJdGlsZV9oID0gaWkudGlsZV9oLAoJCQloaWRkZW4gPSBpaS5oaWRkZW4KCQl9Cgll
bmQKCQoJcmV0dXJuIG91dHB1dAplbmQKCmZ1bmN0aW9uIGxvYWRfd29ya2luZ19maWxlKGl0ZW1f
MSkKCQoJaXRlbV8xID0gdHlwZShpdGVtXzEpID09ICJ0YWJsZSIgYW5kIGl0ZW1fMSBvciB7fQoJ
CgktLSBkZXYgbGVnYWN5OiB6ZXJvLWJhc2VkIGxheWVyIGNvbGxlY3Rpb24KCWlmIChub3QgaXRl
bV8xWzFdIGFuZCBpdGVtXzFbMF0pIHRoZW4KCQlpdGVtXzEgPSB7aXRlbV8xWzBdfQoJZW5kCglp
dGVtID0ge30KCglmb3IgaT0xLCNpdGVtXzEgZG8KCQlpZiAodHlwZShpdGVtXzEubGF5ZXIpPT0i
dGFibGUiKSBpdGVtXzEgPSBpdGVtXzEubGF5ZXIgLS0gbGVnYWN5CgkJaXRlbVtpXSA9IGl0ZW1f
MVtpXSBvciB7fQoJCQoJCWxvY2FsIGl0bSA9IGl0ZW1baV0KCgkJaXRtLmJtcCAgID0gaXRtLmJt
cCBvciB1c2VyZGF0YSgiaTE2IiwxNiwxNikKCQlpdG0uc2VsICAgPSBpdG0uc2VsIG9yIHVzZXJk
YXRhKCJ1OCIsIDE2LDE2KQoJCWl0bS5uYW1lICA9IGl0bS5uYW1lIG9yIG5pbAoJCWl0bS5leHRy
YSA9IGl0bS5leHRyYSBvciBuaWwgLS0gdGV4dC4gbWF5YmUgIm5vdGVzIj8KCQlpdG0ucGFuX3gg
PSBpdG0ucGFuX3ggb3IgMAoJCWl0bS5wYW5feSA9IGl0bS5wYW5feSBvciAwCgkJaXRtLnpvb20g
ID0gaXRtLnpvb20gb3IgMQoJCWl0bS50aWxlX3cgPSBpdG0udGlsZV93IG9yIDE2CgkJaXRtLnRp
bGVfaCA9IGl0bS50aWxlX2ggb3IgMTYKCQlpdG0uaGlkZGVuID0gaXRtLmhpZGRlbiBvciBmYWxz
ZQoJCWFkZF91bmRvX3N0YWNrKGl0ZW1baV0pCgllbmQJCgkKCXNldF9jdXJyZW50X2l0ZW0oMSkK
CQplbmQKCi0tW1sKCWxvYWQgZXZlcnl0aGluZyBpbiAvcmFtL2NhcnQvZ2Z4Cgl0byBkbzogcGVy
IGJhbmsgaW52YWxpZGF0aW9uCgl0byBkbzogZ2Z4IGZpbGVzIHJlbGF0aXZlIHRvIG1hcCBmaWxl
PwoJCS0tIG1pZ2h0IHdhbnQgdG8gbWFrZSBtYXBzIG91dHNpZGUgb2YgY2FydCBjb250ZXh0Cl1d
CmZ1bmN0aW9uIGxvYWRfc3ByaXRlYmFua3MoKQotLQlwcmludGgoIiAtLSBsb2FkX3Nwcml0ZWJh
bmtzKCkgLS0iKQoJZ2Z4X2xzID0gbHMoIi9yYW0vY2FydC9nZngiKQoJZ2Z4X2ZpbGUgPSB7fQoJ
Zm9yIGk9MSwjZ2Z4X2xzIGRvCgkJbG9jYWwgZm4gPSBnZnhfbHNbaV0KCQlsb2NhbCBudW0gPSB0
b251bShzdHJpbmcuc3ViKGZuLDEsMSkpCgkJZm4gPSAiL3JhbS9jYXJ0L2dmeC8iLi5mbiAKLS0J
CXByaW50aCgibG9hZGluZyAiLi5mbikKCQlpZiAobnVtKSB0aGVuCgkJCWdmeF9maWxlW251bV0g
PSBmbgoJCQlsb2NhbCBnZnhfZGF0ID0gZmV0Y2goZm4pCgkJCWlmICh0eXBlKGdmeF9kYXQgPT0g
InRhYmxlIikgYW5kIGdmeF9kYXRbMF0gYW5kIGdmeF9kYXRbMF0uYm1wKSB0aGVuCgkJCQlmb3Ig
aT0wLCNnZnhfZGF0IGRvCgkJCQkJc2V0X3NwcihudW0gKiAyNTYgKyBpLCBnZnhfZGF0W2ldLmJt
cCkKCQkJCWVuZAoJCQllbmQKCQllbmQKCWVuZAplbmQKCmZ1bmN0aW9uIF9pbml0KCkKCQoJcG9r
ZSgweDQwMDAsZ2V0KGZldGNoIi9zeXN0ZW0vZm9udHMvcDguZm9udCIpKQoJLS1wb2tlKDB4NDAw
Miw2KSAtLSB0byBkbzogc2hvdWxkIGJlIGF0dHJpYnV0ZSBvZiBwOC5mb250CgkKCS0tIGRlZmF1
bHQgZmlsZW5hbWUgaXMgZHVtbXkgZm9yIG5vdwoJLS0gbm90ZTogc2F2ZWQgaW5zaWRlIHNlbGYg
KGdmeC5wNjQpIHdoZW4gbG9hZGVkIGFzIGNwcm9qCgktLWNyZWF0ZV9kZWZhdWx0X2JhbmsoKQoJ
d2luZG93ewoJCXRhYmJlZCA9IHRydWUsCgkJaWNvbiA9IHVzZXJkYXRhIltnZnhdMDgwODAwMDAw
Nzc3Nzc3NzA3Nzc3Nzc3MDc3Nzc3NzcwMDAwNzc3Nzc3NzA3Nzc3Nzc3MDc3Nzc3NzcwMDAwMDAw
MDBbL2dmeF0iCgl9CgkJCglta2RpcigiL3JhbS9jYXJ0L21hcCIpCgkKCXdyYW5nbGVfd29ya2lu
Z19maWxlKAoJCXNhdmVfd29ya2luZ19maWxlLAoJCWxvYWRfd29ya2luZ19maWxlLAoJCSIvcmFt
L2NhcnQvbWFwLzAubWFwIiAtLSBkZWZhdWx0CgkpCgoJbG9hZF9zcHJpdGViYW5rcygpCgkKCXNl
dF9jdXJyZW50X2l0ZW0oMSkKCXNldF9jdXJyZW50X2JhbmsoMCkKCXNldF9jdXJyZW50X2Jhbmtf
cGFnZSgwKQoJCglnZW5lcmF0ZV9ndWkoKQoJCgljb2wgPSAyIC0tIHNwcml0ZSBpbmRleAoJCglj
dG9vbCA9ICJwZW5jaWwiCgltdG9vbCA9IGN0b29sCglpZiAoa2V5InMiKSBtdG9vbCA9ICJzZWxl
Y3QiCgkKCWJydXNoID0gewoJCXNwYWNpbmc9MSwKCQl0aGlja25lc3M9MiwKCQl3aGljaD0zLAoJ
CXBhdD0weDAKCX0KCQoJcmVmcmVzaF9ndWkgPSB0cnVlCgkKZW5kCmZ1bmN0aW9uIHNldF9jdXJy
ZW50X2JhbmtfcGFnZShpKQoJLS1wcmludGgoInNldHRpbmcgYmFuazogIi4uaSkKCWN1cnJlbnRf
YmFua19wYWdlID0gaQplbmQKZnVuY3Rpb24gc2V0X2N1cnJlbnRfYmFuayhpLCBkaSkKCglpID0g
aSBvciBjdXJyZW50X2JhbmsKCglpZiAoZGkpIHRoZW4KCQkKCQlsb2NhbCBpMCA9IGkKCQlpICs9
IGRpCgkJaWYgKG5vdCBnZnhfZmlsZVtpXSkgdGhlbgoJCQlpID0gKGkgKyBkaSkgJSA2NAoJCQl3
aGlsZSAobm90IGdmeF9maWxlW2ldIGFuZCBpIH49IGkwKSBkbwoJCQkJaSA9IChpICsgZGkpICUg
NjQKCQkJZW5kCgkJZW5kCgllbmQKCQoJY3VycmVudF9iYW5rID0gaQoJcmVmcmVzaF9ndWkgPSB0
cnVlCmVuZApmdW5jdGlvbiBzZXRfY3VycmVudF9pdGVtKGkpCgoJLS0gdG8gZG86IHJlbW92ZQoJ
aWYgKCNpdGVtID09IDApIHRoZW4KCQljcmVhdGVfZGVmYXVsdF9tYXBzKCkKCWVuZAoKCWFzc2Vy
dCgjaXRlbSA_IDApCglpID0gaSBvciBjdXJyZW50X2l0ZW0KCWkgPSBtaWQoMSwgaSwgI2l0ZW0p
CgktLXByaW50aCgic2V0dGluZyBpdGVtOiAiLi5pKQoJY3VycmVudF9pdGVtID0gZmxyKGkpICAt
LSB3YW50IGl0IHRvIGJlIGFuIGludGVnZXIKCWNpID0gaXRlbVtjdXJyZW50X2l0ZW1dCgljYm1w
ID0gaXRlbVtjdXJyZW50X2l0ZW1dLmJtcAoJY2JtcF93aWR0aCwgY2JtcF9oZWlnaHQgPSBjYm1w
OndpZHRoKCksIGNibXA6aGVpZ2h0KCkKCgktLSBzZWxlY3Rpb24KCWlmIG5vdCBpdGVtW2N1cnJl
bnRfaXRlbV0uc2VsIG9yCgkJaXRlbVtjdXJyZW50X2l0ZW1dLnNlbDp3aWR0aCgpICB_PSBjYm1w
X3dpZHRoIG9yCgkJaXRlbVtjdXJyZW50X2l0ZW1dLnNlbDpoZWlnaHQoKSB_PSBjYm1wX2hlaWdo
dAoJdGhlbgoJCWl0ZW1bY3VycmVudF9pdGVtXS5zZWwgPSB1c2VyZGF0YSgidTgiLCBjYm1wX3dp
ZHRoLCBjYm1wX2hlaWdodCkKCWVuZAoJCgljc2VsID0gaXRlbVtjdXJyZW50X2l0ZW1dLnNlbAoJ
Y3NlbF9vdXRsaW5lID0gaXRlbVtjdXJyZW50X2l0ZW1dLnNlbF9vdXRsaW5lCmVuZAoKb25fZXZl
bnQoImxvc3RfZm9jdXMiLAoJZnVuY3Rpb24gKG1zZykKCQltYXBfZ2Z4X3N0YXRlID0gbWFwX2dm
eF9zdGF0ZSBvciBmZXRjaCIvcmFtL3NoYXJlZC9tYXBfZ2Z4LnBvZCIgb3Ige30KCQltYXBfZ2Z4
X3N0YXRlLmN1cnJlbnRfc3ByaXRlX2luZGV4ID0gY29sCgkJbWFwX2dmeF9zdGF0ZS5tYXBfcHJv
Y19pZCA9IHBpZCgpCgkJc3RvcmUoIi9yYW0vc2hhcmVkL21hcF9nZngucG9kIiwgbWFwX2dmeF9z
dGF0ZSkKCWVuZAopCm9uX2V2ZW50KCJnYWluZWRfZm9jdXMiLAoJZnVuY3Rpb24gKG1zZykKCQkt
LXByaW50aCgiQEAgW21hcF0gcmVsb2FkaW5nIHNwcml0ZWJhbmtzIG9uIGdhaW5pbmcgZm9jdXMi
KQoJCWxvYWRfc3ByaXRlYmFua3MoKQoKCQktLSB0ZW1wb3Jhcnk6IHNldCB0aWxlIHNpemVzIHRv
IHNwcml0ZTAKCQlsb2NhbCBzcHIwID0gZ2V0X3NwcigwKQoJCWlmIChzcHIwKSB0aGVuCgkJCWZv
ciBpPTEsI2l0ZW0gZG8KCQkJCWl0ZW1baV0udGlsZV93LCBpdGVtW2ldLnRpbGVfaCA9IHNwcjA6
d2lkdGgoKSwgc3ByMDpoZWlnaHQoKQoJCQllbmQKCQllbmQKCgkJCgkJbWFwX2dmeF9zdGF0ZSA9
IGZldGNoIi9yYW0vc2hhcmVkL21hcF9nZngucG9kIgoJCWlmIChtYXBfZ2Z4X3N0YXRlKSBjb2wg
PSBtYXBfZ2Z4X3N0YXRlLmN1cnJlbnRfc3ByaXRlX2luZGV4CgoJZW5kCikKCm9uX2V2ZW50KCJz
ZXRfcGFsZXR0ZSIsCglmdW5jdGlvbihtc2cpCgkJaWYgKHR5cGUobXNnLnBhbGV0dGUpID09ICJ1
c2VyZGF0YSIpIHRoZW4KCQkJbG9jYWwgdywgaCwgdHlwZSA9IG1zZy5wYWxldHRlOmF0dHJpYnMo
KQoJCQlpZiAodyA9PSA2NCBhbmQgdHlwZSA9PSAiaTMyIikgdGhlbgoJCQkJY3VzdG9tX3BhbGV0
dGUgPSBtc2cucGFsZXR0ZQoJCQllbmQKCQllbmQKCWVuZAopCgoKCjo6IG5hdi5sdWEKLS1bW3Bv
ZF9mb3JtYXQ9InJhdyIsY3JlYXRlZD0iMjAyMy0xOC0xMSAwMjoxODo0OCIsbW9kaWZpZWQ9IjIw
MjQtMDQtMDMgMDY6MDQ6MjgiLHJldmlzaW9uPTM0NDRdXQotLVtbCgluYXZpZ2F0ZSBzcHJpdGUg
YmFuawoJCgl0byBkbzogcGluIHRhYnMgZnJvbSBtdWx0aXBsZSBzcHJpdGUgYmFua3MgYXQgb25j
ZQoJKGJ1dCA0IHRhYnMgb24gdGhlIHJpZ2h0ICIwIi4uIjMiIGFyZSBhbHdheXMgZnJvbSBzZWxl
Y3RlZCAuZ2Z4IGZpbGUpCgpdXQppY29ucyA9CnsKCS0tIG5vdGVzCgkiW2dmeF0wODA4Nzc3Nzc3
MDA3Nzc3NzcwMDcwMDAwNzAwNzc3Nzc3MDA3MDAwMDcwMDc3Nzc3NzAwMDc3Nzc3NzAwMDAwMDAw
MFsvZ2Z4XSIsCgkKCS0tIHNjYWxlCgkiW2dmeF0wODA4NzA3MDcwNzAwMDAwMDAwMDcwMDAwMDcw
MDAwMDAwMDA3NzcwMDA3MDc3NzAwMDAwNzc3MDcwNzAwMDAwMDAwMFsvZ2Z4XSIsCgkKCS0tIHVu
bG9jaywgbG9jawoJbG9jazA9IltnZnhdMDgwODAwNzc3MDAwMDcwMDA3MDAwNzAwMDAwMDA3Nzc3
NzAwMDc3MDc3MDAwNzc3NzcwMDAwMDAwMDAwMDAwMDAwMDBbL2dmeF0iLAoJbG9jazE9IltnZnhd
MDgwODAwMDAwMDAwMDA3NzcwMDAwNzAwMDcwMDA3Nzc3NzAwMDc3MDc3MDAwNzc3NzcwMDAwMDAw
MDAwMDAwMDAwMDBbL2dmeF0iLAoKCWhpZGRlbjA9dW5wb2QoImI2NDpiSG8wQUI4QUFBQWhBQUFB
OHdOd2VIVUFReUFJQ0FTUUp6QUhBQWNBQnhBQ0FJQUFCd0FITUNmd0F3PT0iKSwKCWhpZGRlbjE9
dW5wb2QoImI2NDpiSG8wQUE4QUFBQU9BQUFBNEhCNGRRQkRJQWdJQlBBSVotQVIiKSwKCQoJYnVj
a2V0X2N1cnNvcj11bnBvZCgiYjY0OmJIbzBBRThBQUFCUEFBQUE4Z0J3ZUhVQVF5QVZGUVRRQWZB
REFRY0ZBUEFyNEVFSEFjQUJad0dnQVFjQlJ3R3dBUWNSSndIQUFRY0JBQUVIQWRBQkJ3RVFBZEFC
SUFIZ0FRY2dCd0hnQVNBQjhBRUJCd0h3QXdId2pRPT0iKSwKCWFkZF9sYXllcj11bnBvZCgiYjY0
OmJIbzBBQ0FBQUFBaEFBQUE0WEI0ZFFCRElBZ0lCRzBBTFFjdEJBRGdEVWNOQUMwSExRQXRCeTBB
YllBPSIpLAoJZGVsX2xheWVyPXVucG9kKCJiNjQ6YkhvMEFDZ0FBQUFyQUFBQTh3VndlSFVBUXlB
SUNBUU5SdzBBWndBSERTY05Cd1lBUUNjTkp3QVdBSUFOQncwSERRY05nQT09IiksCgoJZWRpdCA9
IHVucG9kKCJiNjQ6YkhvMEFCa0FBQUFYQUFBQThBaHdlSFVBUXlBSUNBU3dCMUFuTUNjd0J3QUhR
QmZ3QlE9PSIpLAoJCglsYXllcl91cCA9IHVucG9kKCJiNjQ6YkhvMEFCWUFBQUFVQUFBQThBVndl
SFVBUXlBSUNBVHdBd2RRSnpCSFFBZndCQT09IiksCglsYXllcl9kb3duID0gdW5wb2QoImI2NDpi
SG8wQUJZQUFBQVVBQUFBOEFWd2VIVUFReUFJQ0FUd0F3ZEFSekFuVUFmd0JBPT0iKSwKCQp9Cgpm
dW5jdGlvbiBtYWtlX3RvZ2dsZV9idXR0b24oZWwpCglsb2NhbCBlbCA9IGVsIG9yIHt9CgllbC53
aWR0aCA9IGVsLndpZHRoIG9yIDcKCWVsLmhlaWdodCA9IGVsLmhlaWdodCBvciA3CgllbC5zZXQg
PSBlbC5zZXQgb3IgZnVuY3Rpb24oKSBlbmQKCWVsLmdldCA9IGVsLmdldCBvciBmdW5jdGlvbigp
IGVuZAoJCgllbC5jdXJzb3IgPSAicG9pbnRlciIKCQoJZnVuY3Rpb24gZWw6ZHJhdygpCgkJbG9j
YWwgYiA9IGVsLmJtcDAKCQlpZiAoc2VsZi5nZXQoKSBhbmQgZWwuYm1wMSkgYiA9IGVsLmJtcDEK
CQlsb2NhbCBjb2wgPSBzZWxmLmdldCgpIGFuZCA3IG9yIDEzCgkJcGFsKDcsY29sKQoJCXNwcihi
LCAwLCAwKQoJCXBhbCgpCgllbmQKCQoJZnVuY3Rpb24gZWw6Y2xpY2soKQoJCWVsLnNldChub3Qg
ZWwuZ2V0KCkpCgllbmQKCQoJcmV0dXJuIGVsCmVuZAoKCgpmdW5jdGlvbiBtYWtlX29wZXJhdGlv
bl9idXR0b24oZWwpCglsb2NhbCBlbCA9IGVsIG9yIHt9CgllbC53aWR0aCA9IGVsLndpZHRoIG9y
IDcKCWVsLmhlaWdodCA9IGVsLmhlaWdodCBvciA3CgkKCWVsLmN1cnNvciA9ICJwb2ludGVyIgoJ
CglmdW5jdGlvbiBlbDpkcmF3KCkKCQlsb2NhbCBiID0gZWwuYm1wMAoJCWxvY2FsIGNvbCA9IDcK
CQlwYWwoNyxjb2wpCgkJc3ByKGIsIDAsIDApCgkJcGFsKCkKCWVuZAoJCglyZXR1cm4gZWwKZW5k
CgoKLS0gdG8gZG86IGxvY2sgYXNwZWN0IGJ1dHRvbiAKLS0gKG9ubHkgbmVlZCB0byBjaGFuZ2Ug
d2lkdGggdG8gZ28gZnJvbSAxMng4IC0_IDI0eDE2KQpmdW5jdGlvbiByZXNpemVfbWFwKGluZGV4
LCB3aWR0aCwgaGVpZ2h0KQoJLS0gbm90ZTogdXNlcmRhdGEgb25seSB0YWtlcyBudW1iZXJzIGZv
ciBzaXplcywgbm90IHN0cmluZ3MgKCEpCglpZiAod2lkdGgpIHdpZHRoPXRvbnVtKHdpZHRoKQoJ
aWYgKGhlaWdodCkgaGVpZ2h0PXRvbnVtKGhlaWdodCkKCQoJbG9jYWwgd3cgPSBpdGVtW2luZGV4
XS5ibXA6d2lkdGgoKQoJbG9jYWwgaGggPSBpdGVtW2luZGV4XS5ibXA6aGVpZ2h0KCkKCWxvY2Fs
IGFzcGVjdCA9IHd3IC8gaGgKCWxvY2FsIHd3ID0gdG9udW0od2lkdGgpIG9yIHd3Cglsb2NhbCBo
aCA9IHRvbnVtKGhlaWdodCkgb3IgaGgKCQoJaWYgKGxvY2tfYXNwZWN0KSB0aGVuCgkJaWYgKG5v
dCB3aWR0aCkgIHdpZHRoICA9IGhoICogYXNwZWN0CgkJaWYgKG5vdCBoZWlnaHQpIGhlaWdodCA9
IHd3IC8gYXNwZWN0CgllbHNlCgkJd2lkdGggPSB3aWR0aCBvciB3dwoJCWhlaWdodCA9IGhlaWdo
dCBvciBoaAoJZW5kCgkKCWlmICh3aWR0aCA8IDEgb3Igd2lkdGggPiA4MTkyIG9yCgkJaGVpZ2h0
IDwgMSBvciBoZWlnaHQgPiA4MTkyIG9yCgkJd2lkdGggKiBoZWlnaHQgPiAxMDI0KjEwMjQpIHRo
ZW4KCQktLSB0byBkbzogZXJyb3IgImJhZCBzaXplIiBvciAidG9vIGJpZyIKCQlyZXR1cm4KCWVu
ZAoJCQoJbG9jYWwgb2xkID0gaXRlbVtpbmRleF0uYm1wCglsb2NhbCBuZXcgPSB1c2VyZGF0YSgi
dTE2Iiwgd2lkdGgsIGhlaWdodCkKCQoJYmxpdChvbGQsIG5ldywgMCwwLCAKCQluZXc6d2lkdGgo
KVwyIC0gb2xkOndpZHRoKClcMiwKCQluZXc6aGVpZ2h0KClcMiAtIG9sZDpoZWlnaHQoKVwyCgkp
CgkKCWl0ZW1baW5kZXhdLmJtcCA9IG5ldwoJCglyZWZyZXNoX2d1aSA9IHRydWUKCXNldF9jdXJy
ZW50X2l0ZW0oKQplbmQKCmZ1bmN0aW9uIG1vdmVfbGF5ZXIoaW5kZXgsIGRpbmRleCkKCWxvY2Fs
IGkxID0gaW5kZXggKyBkaW5kZXgKCWlmIChpMSA8IDEgb3IgaTEgPiAjaXRlbSkgcmV0dXJuCglp
dGVtW2kxXSxpdGVtW2luZGV4XSA9IGl0ZW1baW5kZXhdLGl0ZW1baTFdCglpZiAoY3VycmVudF9p
dGVtID09IGkxKSB0aGVuCgkJc2V0X2N1cnJlbnRfaXRlbShpbmRleCkKCWVsc2VpZiBjdXJyZW50
X2l0ZW0gPT0gaW5kZXggdGhlbgoJCXNldF9jdXJyZW50X2l0ZW0oaTEpCgllbmQKCQoJcmVmcmVz
aF9ndWkgPSB0cnVlCmVuZAoKCi0tIG5vdGU6IG5vcm1hbGx5IG9ubHkgbmVlZCA8IH40IGxheWVy
cywgc28KLS0gc2Nyb2xsYmFyIHdvdWxkIGJlIG5vcm1hbGx5IG5vdCBuZWVkZWQKLS0gcGxhY2Vo
b2xkZXIuIHdpbGwgaGF2ZTogbGF5ZXIgbmFtZSwgdmlzaWJsZSwgW3BhcmVudCAvIHRyZWUgc3Ry
dWN0dXJlXQotLSAqKiBlYWNoIGxheWVyIGhhcyBhIHR5cGUgdGhhdCBpbmZsdWVuY2VzIHVpICoq
CmZ1bmN0aW9uIGNyZWF0ZV9sYXllcl9uYXYoZWwpCgoJbG9jYWwgaXRlbV9oID0gOAoJCgllbCA9
IGd1aTpuZXcoZWwpCglmdW5jdGlvbiBlbDpkcmF3KCkKCQlyZWN0ZmlsbCgwLDAsc2VsZi53aWR0
aC0xLHNlbGYuaGVpZ2h0LTEsMCkKCQlsb2NhbCB5eSA9IDIKCQlmb3IgaT0xLCNpdGVtIGRvCgkJ
CWxvY2FsIHNlbGVjdGVkID0gaSA9PSBjdXJyZW50X2l0ZW0KCQkJbGFiZWwgPSBpdGVtW2ldLm5h
bWUgb3IgIltsYXllciAiLi5pLi4iXSIKCQkJaWYgKHNlbGVjdGVkIGFuZCBub3QgbGF5ZXJfbmFt
ZV9lZGl0b3IpIHJlY3RmaWxsKDQseXksc2VsZi53aWR0aC01LHl5KzYsMTIpCgkJCQoJCQljbGlw
KGVsLnN4LGVsLnN5LDUrNzIsMTAwMCkKCQkJcHJpbnQobGFiZWwsNSx5eSsxLCBpID09IDAgYW5k
IDcgb3IgNikKCQkJY2xpcCgpCgkJCXNwcihpdGVtW2ldLmhpZGRlbiBhbmQgaWNvbnMuaGlkZGVu
MSBvciBpY29ucy5oaWRkZW4wLHNlbGYud2lkdGgtMTQseXkpCgkJCXNwcihpY29ucy5lZGl0LHNl
bGYud2lkdGgtMjYseXkpCgkJCXBhbCg3LDEzKQoJCQlzcHIoaWNvbnMubGF5ZXJfdXAsc2VsZi53
aWR0aC0zOCx5eSkKCQkJc3ByKGljb25zLmxheWVyX2Rvd24sc2VsZi53aWR0aC00OCx5eSkKCQkJ
cGFsKDcsNykKCQkJCgkJCXl5ICs9IGl0ZW1faAoJCWVuZAoJCQoJZW5kCgkKCWZ1bmN0aW9uIGVs
OmNsaWNrKG1zZykKCQlpZiAobGF5ZXJfbmFtZV9lZGl0b3IpIHJlZnJlc2hfZ3VpID0gdHJ1ZQoJ
ZW5kCgkKCQoJZnVuY3Rpb24gZWw6dGFwKG1zZykKCQlsb2NhbCBpbmRleCA9IDEgKyAobXNnLm15
IC0gMikgXCBpdGVtX2gKCQlpbmRleCA9IG1pZCgxLCBpbmRleCwgI2l0ZW0pCgkJaWYgKG1zZy5t
eCA_IHNlbGYud2lkdGggLSAxOCkgdGhlbgoJCQlpdGVtW2luZGV4XS5oaWRkZW4gPSBub3QgaXRl
bVtpbmRleF0uaGlkZGVuCgkJZWxzZWlmIChtc2cubXggPiBzZWxmLndpZHRoIC0gMzApIHRoZW4K
CQkKCQkJbGF5ZXJfbmFtZV9lZGl0b3IgPSBlbDphdHRhY2hfdGV4dF9lZGl0b3J7CgkJCQl4PTIs
IHk9IDArIChpbmRleC0xKSppdGVtX2gsIHdpZHRoPTc0LCBoZWlnaHQ9IDksIAoJCQkJYmxvY2tf
c2Nyb2xsaW5nID0gdHJ1ZSwgbWF4X2xpbmVzID0gMSwKCQkJCWtleV9jYWxsYmFjayA9IHsKCQkJ
CQllbnRlciA9IGZ1bmN0aW9uICgpIAoJCQkJCQlpdGVtW2luZGV4XS5uYW1lID0gbGF5ZXJfbmFt
ZV9lZGl0b3I6Z2V0X3RleHQoKVsxXQoJCQkJCQlsYXllcl9uYW1lX2VkaXRvciA9IG5pbAoJCQkJ
CQlyZWZyZXNoX2d1aSA9IHRydWUKCQkJCQllbmQKCQkJCX0sCgkJCQktLSBibG9jayBtb3VzZSBt
ZXNzYWdlcyBmcm9tIHNlbGVjdGluZyBvdGhlciBsYXllcnMKCQkJCWNsaWNrID0gZnVuY3Rpb24o
KSByZXR1cm4gdHJ1ZSBlbmQsCgkJCQl0YXAgPSBmdW5jdGlvbigpIHJldHVybiB0cnVlIGVuZAoJ
CQl9CgkJCWxheWVyX25hbWVfZWRpdG9yOnNldF90ZXh0KHsoaXRlbVtpbmRleF0ubmFtZSBvciAi
Iil9KQoJCQlsYXllcl9uYW1lX2VkaXRvcjpzZXRfa2V5Ym9hcmRfZm9jdXModHJ1ZSkKCQkJbGF5
ZXJfbmFtZV9lZGl0b3I6c2V0X2N1cnNvcigxMDAwLDEpCgkJCXdpbmRvd3tjYXB0dXJlX2VzY2Fw
ZXMgPSB0cnVlfQoJCQkKCQllbHNlaWYgKG1zZy5teCA_IHNlbGYud2lkdGggLSA0MikgdGhlbgoJ
CQltb3ZlX2xheWVyKGluZGV4LCAtMSkKCQllbHNlaWYgKG1zZy5teCA_IHNlbGYud2lkdGggLSA1
MikgdGhlbgoJCQltb3ZlX2xheWVyKGluZGV4LCAxKQoJCWVsc2UKCQkJc2V0X2N1cnJlbnRfaXRl
bShpbmRleCkKCQllbmQKCWVuZAoKCXJldHVybiBlbAplbmQKCmZ1bmN0aW9uIGNyZWF0ZV9sYXll
cl9pbmZvKGVsKQoJZWwgPSBndWk6bmV3KGVsKQoJCglsb2NhbCB4eCA9IDIwICsgMjQKCWxvY2Fs
IHl5ID0gMAoJCgktLSBtYXAgd2lkdGgKCWVsOmF0dGFjaF9maWVsZAoJewoJCXg9eHgseT15eSx3
aWR0aD0yMCxoZWlnaHQ9NywKCQlnZXQ9ZnVuY3Rpb24oKSByZXR1cm4gaXRlbVtjdXJyZW50X2l0
ZW1dLmJtcDp3aWR0aCgpIGVuZCwKCQlzZXQ9ZnVuY3Rpb24oc2VsZix2YWwpIAoJCQlyZXNpemVf
bWFwKGN1cnJlbnRfaXRlbSwgdmFsLCBuaWwpCgkJZW5kLAoJCWxhYmVsPSJsYXllciBzaXplOiIK
CX0KCQoJLS0gdG9nZ2xlIGFzcGVjdCBsb2NrCgllbDphdHRhY2gobWFrZV90b2dnbGVfYnV0dG9u
ewoJCXg9eHgrMjEseT0wLAoJCWJtcDA9dXNlcmRhdGEoaWNvbnMubG9jazApLAoJCWJtcDE9dXNl
cmRhdGEoaWNvbnMubG9jazEpLAoJCXNldD1mdW5jdGlvbih2YWwpIGxvY2tfYXNwZWN0ID0gdmFs
IGVuZCwKCQlnZXQ9ZnVuY3Rpb24oKSByZXR1cm4gbG9ja19hc3BlY3QgZW5kLAoJfSkKCQoJLS0g
bWFwIGhlaWdodAoJZWw6YXR0YWNoX2ZpZWxkewoJCXg9eHgrMjkseT15eSx3aWR0aD0yMCxoZWln
aHQ9NywKCQlnZXQ9ZnVuY3Rpb24oKSByZXR1cm4gaXRlbVtjdXJyZW50X2l0ZW1dLmJtcDpoZWln
aHQoKSBlbmQsCgkJc2V0PWZ1bmN0aW9uKHNlbGYsdmFsKSAKCQkJcmVzaXplX21hcChjdXJyZW50
X2l0ZW0sIG5pbCwgdmFsKQoJCWVuZCwKCQlsYWJlbD0iIgoJfQoJCgktLSBhZGQgbGF5ZXIKCWVs
OmF0dGFjaChtYWtlX29wZXJhdGlvbl9idXR0b257CgkJeD14eCs2MCx5PTAsCgkJYm1wMD1pY29u
cy5hZGRfbGF5ZXIsCgkJdGFwPWZ1bmN0aW9uKCkKCQkJLS1wcmludGgocG9kKGl0ZW1bY3VycmVu
dF9pdGVtXS5ibXApKQoJCQlsb2NhbCBuZXdfaXRlbSA9IHt9CgkJCWZvciBrLHYgaW4gcGFpcnMo
Y2kpIGRvCgkJCQluZXdfaXRlbVtrXSA9IHVucG9kKHBvZCh2KSkKCQkJZW5kCgkJCWFkZF91bmRv
X3N0YWNrKG5ld19pdGVtKQoJCQluZXdfaXRlbS5uYW1lID0gbmlsCgkJCW5ld19pdGVtLmJtcDpj
bGVhcigpCgkJCQoJCQlhZGQoaXRlbSwgbmV3X2l0ZW0sIGN1cnJlbnRfaXRlbSsxKQoJCQlyZWZy
ZXNoX2d1aSA9IHRydWUKCQllbmQKCX0pCgkKCS0tIHJlbSBsYXllcgoJZWw6YXR0YWNoKG1ha2Vf
b3BlcmF0aW9uX2J1dHRvbnsKCQl4PXh4KzcyLHk9MCwKCQlibXAwPWljb25zLmRlbF9sYXllciwK
CQl0YXA9ZnVuY3Rpb24oKQoJCQlpZiAoI2l0ZW0gPiAxKSB0aGVuCgkJCQlkZWxpKGl0ZW0sIGN1
cnJlbnRfaXRlbSkKCQkJCXNldF9jdXJyZW50X2l0ZW0oKQoJCQllbHNlCgkJCQlub3RpZnkoIm11
c3QgaGF2ZSBhdCBsZWFzdCBvbmUgbGF5ZXIiKQoJCQllbmQKCQllbmQKCX0pCgkJCglyZXR1cm4g
ZWwJCmVuZAoKCmZ1bmN0aW9uIGNyZWF0ZV9pdGVtX2luZm8oZWwpCgllbCA9IGd1aTpuZXcoZWwp
CglmdW5jdGlvbiBlbDpkcmF3KCkKCQktLXJlY3QoMCwwLHNlbGYud2lkdGgtMSwgc2VsZi5oZWln
aHQtMSwgMTMpCgllbmQKCQoJLS0gcHJldmlldyB0aHVtYgoJZWw6YXR0YWNoewoJCXg9MCx5PTAs
d2lkdGg9MTYsaGVpZ2h0PTE2LAoJCWRyYXc9ZnVuY3Rpb24oc2VsZikKCQkJcmVjdGZpbGwoMCww
LDIzLDIzLDApCgkJCWxvY2FsIGIgPSBnZXRfc3ByKGNvbCkKCQkJaWYgKGIpIHNwcihiLHNlbGYu
d2lkdGgvMiAtIGI6d2lkdGgoKS8yLCBzZWxmLmhlaWdodC8yLWI6aGVpZ2h0KCkvMikKCQllbmQK
CX0KCQoJbG9jYWwgeHgwID0gMjAKCWxvY2FsIHl5ICA9IDAKCWxvY2FsIGhleF9tb2RlID0gdHJ1
ZQoJCQoJLS0gaW5kZXggKGlzIDE2LWJpdCBpbmRleCBpbiBtYXAgZWRpdG9yKQoJLS0gdG8gZG86
IHRvZ2dsZSBoZXggbW9kZSAvIGRlY2ltYWwgbW9kZQoJZWw6YXR0YWNoewoJCXg9eHgwLHk9eXks
d2lkdGg9MjcsaGVpZ2h0PTcsCgkJZHJhdz1mdW5jdGlvbihzZWxmKQoJCQlsb2NhbCBiPSBpdGVt
W2N1cnJlbnRfaXRlbV0uYm1wCgkJCXJlY3RmaWxsKDAsMCxzZWxmLndpZHRoLTEsc2VsZi5oZWln
aHQtMSwxMykKCQkJbG9jYWwgc3RyID0gaGV4X21vZGUgYW5kCgkJCQlzdHJpbmcuZm9ybWF0KCIw
WCUwNHgiLGNvbCkgb3IKCQkJCXN0cmluZy5mb3JtYXQoIiVkIixjb2wpCgkJCXByaW50KHN0cixz
ZWxmLndpZHRoLTEtI3N0cio0LDEsNykKCQllbmQsCgkJdGFwPWZ1bmN0aW9uKHNlbGYpCgkJCWhl
eF9tb2RlID0gbm90IGhleF9tb2RlCgkJZW5kCgl9CgkKCS0tIGJhbmsgc2VsZWN0aW9uIHBsYWNl
aG9sZGVyCgktLSBjbGljayB0byBjaG9vc2UgZmlsZQoJLS0gbWF5YmUgcGluIHBhZ2VzIC8gZmls
ZXM-IAoJLS0gKGNyZWF0ZSBwcmltYXJ5IHNldCBvZiB0YWJzLCB3aGVyZSBwYWdlcyBhcmUgc2Vj
b25kYXJ5KQoJZWw6YXR0YWNoewoJCXg9eHgwICsgNTIseT15eSx3aWR0aD00OCxoZWlnaHQ9NywK
CQlkcmF3PWZ1bmN0aW9uKHNlbGYpCgkJCWxvY2FsIGI9IGl0ZW1bY3VycmVudF9pdGVtXS5ibXAK
CQkJcmVjdGZpbGwoMCwwLHNlbGYud2lkdGgtMSxzZWxmLmhlaWdodC0xLDEpCgkJCQoJCQlsb2Nh
bCBnZnhfZm4gPSBnZnhfZmlsZVtjdXJyZW50X2JhbmtdIG9yICI-PyIKCQkJCgkJCXByaW50KHN0
cmluZy5mb3JtYXQoZ2Z4X2ZuOmJhc2VuYW1lKCksY29sKSwyLDEsMTMpCgkJCQoJCWVuZAoJfQoJ
CgllbDphdHRhY2h7eD14eDAgKyA0Mix5PXl5LHdpZHRoPTgsaGVpZ2h0PTcsY3Vyc29yPSJwb2lu
dGVyIiwKCQlkcmF3PWZ1bmN0aW9uKHNlbGYpCgkJCXJlY3RmaWxsKDAsMCxzZWxmLndpZHRoLTEs
c2VsZi5oZWlnaHQtMSwxMykgcHJpbnQoIjwiLDIsMSw3KQoJCWVuZCwKCQl0YXA9ZnVuY3Rpb24o
c2VsZikgc2V0X2N1cnJlbnRfYmFuayhuaWwsIC0xKSBlbmQKCX0KCQoJZWw6YXR0YWNoe3g9eHgw
ICsgMTAxLHk9eXksd2lkdGg9OCxoZWlnaHQ9NyxjdXJzb3I9InBvaW50ZXIiLAoJCWRyYXc9ZnVu
Y3Rpb24oc2VsZikKCQkJcmVjdGZpbGwoMCwwLHNlbGYud2lkdGgtMSxzZWxmLmhlaWdodC0xLDEz
KSBwcmludCgiPiIsMiwxLDcpCgkJZW5kLAoJCXRhcD1mdW5jdGlvbihzZWxmKSBzZXRfY3VycmVu
dF9iYW5rKG5pbCwgMSkgZW5kCgl9CgkKCXJldHVybiBlbAplbmQKCQpmdW5jdGlvbiBjcmVhdGVf
YmFua190YWJzKGVsKQoJZWwgPSBndWk6bmV3KGVsKQoJZnVuY3Rpb24gZWw6ZHJhdygpCgkJLS1y
ZWN0KDAsMCxzZWxmLndpZHRoLTEsIHNlbGYuaGVpZ2h0LTEsIDEzKQoJZW5kCgkKCWZvciBpPTAs
MyBkbwoJCWxvY2FsIHlfb2ZmcyA9IGkgPT0gY3VycmVudF9iYW5rX3BhZ2UgYW5kIDAgb3IgMQoJ
CWxvY2FsIHRhYiA9IGVsOmF0dGFjaCh7CgkJCXg9aSoxMix5PXlfb2Zmcyx3aWR0aD0xMSxoZWln
aHQ9ZWwuaGVpZ2h0IC0geV9vZmZzLAoJCQlpbmRleD1pLAoJCQlkcmF3ID0gZnVuY3Rpb24oc2Vs
ZikKCQkJCWxvY2FsIHNlbCA9IGN1cnJlbnRfYmFua19wYWdlID09IHNlbGYuaW5kZXgKCQkJCXJl
Y3RmaWxsKDAsMCxzZWxmLndpZHRoLTEsIHNlbGYuaGVpZ2h0LTEsIHNlbCBhbmQgNyBvciA2KQoJ
CQkJcHNldCgwLDAsNSkKCQkJCWxpbmUoMCwxLDEsMCw1KQoJCQkJbGluZSgwLDIsMiwwLDUpCgkJ
CQkKCQkJCXBzZXQoc2VsZi53aWR0aC0xLDAsNSkKCQkJCQoJCQkJbGluZSgwLHNlbGYuaGVpZ2h0
LTEsc2VsZi53aWR0aC0xLHNlbGYuaGVpZ2h0LTEsMTMpCgkJCQlwcmludChzZWxmLmluZGV4LDUs
MSwxMykKCQkJZW5kLAoJCQljbGljayA9IGZ1bmN0aW9uKHNlbGYpCgkJCQlzZXRfY3VycmVudF9i
YW5rX3BhZ2Uoc2VsZi5pbmRleCwgMSkKCQkJCXJlZnJlc2hfZ3VpID0gdHJ1ZQoJCQllbmQKCQkJ
CgkJfSkKCWVuZAoJCglyZXR1cm4gZWwKZW5kCgpmdW5jdGlvbiBjcmVhdGVfbmF2KGVsKQoJZnVu
Y3Rpb24gZWw6ZHJhdygpCgkJY2xpcCgpCgkJcmVjdGZpbGwoLTEsLTEsc2VsZi53aWR0aCwgc2Vs
Zi5oZWlnaHQsIDApCgoJCWZvciB5PTAsNyBkbwoJCQlmb3IgeD0wLDcgZG8KCQkJCWxvY2FsIHNj
YWxlID0gMQoJCQkJCgkJCQlsb2NhbCBibXAgPSBnZXRfc3ByKHggKyB5KjggKyBjdXJyZW50X2Jh
bmtfcGFnZSo2NCArIGN1cnJlbnRfYmFuayoyNTYpCgkJCQlpZiAoYm1wKSB0aGVuIC0tIG1heWJl
IG5vIHNwcml0ZSBiYW5rcyBsb2FkZWQgW3lldF0KCQkJCQlsb2NhbCB3dyxoaCA9IGJtcDp3aWR0
aCgpLCBibXA6aGVpZ2h0KCkKCQkJCQktLSB0byBkbzogdGhpcyBtYWtlcyB2ZXJ5IHRoaW4gYm1w
cyBpbnZpc2libGUgaW4gcHJldmlldwoJCQkJCXNjYWxlID0gMTYgLyBtYXgod3csaGgpCgkJCQkJ
Y2xpcChzZWxmLnN4ICsgeCoxNiwgc2VsZi5zeSArIHkqMTYsIDE2LDE2KQoJCQkJCXNzcHIoYm1w
LAoJCQkJCQkwLDAsbmlsLG5pbCwKCQkJCQkJeCoxNiArIDggLSB3dyAqIHNjYWxlLzIsCgkJCQkJ
CXkqMTYgKyA4IC0gaGggKiBzY2FsZS8yLAoJCQkJCQl3dypzY2FsZSwgaGgqc2NhbGUpCgkJCQll
bmQKCQkJZW5kCgkJZW5kCgkJCgkJaWYgKGN1cnJlbnRfYmFua19wYWdlID09IGNvbFw2NCkgdGhl
bgoJCQkKCQkJbG9jYWwgaWkgPSAoY29sIC0gY3VycmVudF9iYW5rX3BhZ2UqNjQpCgkJCWxvY2Fs
IHh4ID0gKGlpICUgOCkgKiAxNgoJCQlsb2NhbCB5eSA9IChpaSBcIDgpICogMTYKCQoJCQljbGlw
KCkKCQkJCgkJCXJlY3QoeHgtMix5eS0yLHh4KzE3LHl5KzE3LDApCgkJCXJlY3QoeHgtMSx5eS0x
LHh4KzE2LHl5KzE2LDcpCgkJZW5kCgkJCgkJCgllbmQKCQoJLS0gc2VsZWN0IHNwcml0ZQoJZnVu
Y3Rpb24gZWw6ZHJhZyhtc2cpCgkJbG9jYWwgeCA9IG1pZCgwLG1zZy5teCAqIDggXCBzZWxmLndp
ZHRoLDcpCgkJbG9jYWwgeSA9IG1pZCgwLG1zZy5teSAqIDggXCBzZWxmLmhlaWdodCwgNykKCQls
b2NhbCBpID0geCArIHkgKiA4CgkJY29sID0gaSArIGN1cnJlbnRfYmFua19wYWdlKjY0ICsgY3Vy
cmVudF9iYW5rKjI1NgoJZW5kCglyZXR1cm4gZWwKZW5kCgoKCjo6IHBhbC5sdWEKLS1bW3BvZF9m
b3JtYXQ9InJhdyIsY3JlYXRlZD0iMjAyMy0wNS0xMSAwMjowNTowMSIsbW9kaWZpZWQ9IjIwMjQt
MDMtMDYgMDU6Mzc6MTYiLHJldmlzaW9uPTU2OCxzdG9yZWQ9IjIwMjMtMTEtMjggMDM6MTE6MTki
XV0KbG9jYWwgcGNvbHMgPSB7WzBdPQoJMCwxOSwzLDI3LCAgMTEsMjYsMTAsMjMsCgkxLDE3LDEy
LDI4LCAxOCwxNiwxMywyOSwKCTIsMzAsMTQsMzEsIDI0LDgsMjUsOSwKCTIwLDQsMjEsMTUsIDUs
MjIsNiw3LAp9CgpwY29sc19jb250aW51b3VzID0ge1swXSA9CgkwLDIwLDQsMzEsMTUsOCwyNCwy
LAoJMjEsNSwyMiw2LDcsMjMsMTQsMzAsCgkxLDE2LDE3LDEyLDI4LDI5LDEzLDE4LAoJMTksMywy
NywxMSwyNiwxMCw5LDI1LAp9CgpwY29sc19pZGVudGl0eSA9IHtbMF0gPQoJMCwxLDIsMyw0LDUs
Niw3LDgsOSwxMCwxMSwxMiwxMywxNCwxNSwKCTE2LDE3LDE4LDE5LDIwLDIxLDIyLDIzLDI0LDI1
LDI2LDI3LDI4LDI5LDMwLDMxCn0KCgoKZnVuY3Rpb24gY3JlYXRlX3BhbF90YWJzKGVsKQoKCWVs
ID0gZ3VpOm5ldyhlbCkKCglmdW5jdGlvbiBlbDpkcmF3KCkKCQktLXJlY3QoMCwwLHNlbGYud2lk
dGgtMSwgc2VsZi5oZWlnaHQtMSwgMTMpCgllbmQKCQoJbG9jYWwgc3dhdGNoX25hbWU9e1swXT0i
XiIsIl4ifQoJCglmb3IgaT0wLDEgZG8KCQlsb2NhbCB5X29mZnMgPSBpID09IHBhbF9zd2F0Y2gg
YW5kIDAgb3IgMQoJCWxvY2FsIHRhYiA9IGVsOmF0dGFjaCh7CgkJCXg9aSoxMix5PXlfb2Zmcyx3
aWR0aD0xMSxoZWlnaHQ9ZWwuaGVpZ2h0IC0geV9vZmZzLAoJCQlpbmRleD1pLAoJCQlkcmF3ID0g
ZnVuY3Rpb24oc2VsZikKCQkJCWxvY2FsIHNlbCA9IHBhbF9zd2F0Y2ggPT0gc2VsZi5pbmRleAoJ
CQkJcmVjdGZpbGwoMCwwLHNlbGYud2lkdGgtMSwgc2VsZi5oZWlnaHQtMSwgc2VsIGFuZCA2IG9y
IDEzKQoJCQkJcHNldCgwLDAsNSkKCQkJCWxpbmUoMCwxLDEsMCw1KQoJCQkJbGluZSgwLDIsMiww
LDUpCgkJCQkKCQkJCXBzZXQoc2VsZi53aWR0aC0xLDAsNSkKCQkJCQoJCQkJbGluZSgwLHNlbGYu
aGVpZ2h0LTEsc2VsZi53aWR0aC0xLHNlbGYuaGVpZ2h0LTEsMTMpCgkJCQlwcmludChzd2F0Y2hf
bmFtZVtzZWxmLmluZGV4XSw1LDEsNSkKCQkJCQoJCQllbmQsCgkJCQoJCQljbGljayA9IGZ1bmN0
aW9uKHNlbGYpCgkJCQlwYWxfc3dhdGNoID0gc2VsZi5pbmRleAoJCQkJcmVmcmVzaF9ndWkgPSB0
cnVlCgkJCWVuZAoJCQkKCQl9KQoJZW5kCgkKCgkKCXJldHVybiBlbAplbmQKCgoKLS1mb3IgaT0w
LDYzIGRvIHBjb2xzW2ldPWkgZW5kCgotLVtbCnBjb2xzWzIyXSxwY29sc1syMV09cGNvbHNbMjFd
LHBjb2xzWzIyXQpwY29sc1sxNl0scGNvbHNbMTddLHBjb2xzWzE4XSA9IHBjb2xzWzE4XSwgcGNv
bHNbMTZdLHBjb2xzWzE3XQpdXQoKcGFsX3N3YXRjaCA9IDEKCmZ1bmN0aW9uIGNyZWF0ZV9wYWxl
dHRlKGVsKQoKCS0tIGlkZW50aXR5Cglmb3IgaT0wLDYzIGRvIHBjb2xzW2ldID0gaSBlbmQKCQoJ
aWYgcGFsX3N3YXRjaCA9PSAxIHRoZW4KCQlmb3IgaT0wLDYzIGRvIAoJCQlwY29sc1tpXSA9IHBj
b2xzX2NvbnRpbnVvdXNbaVwyXSBvciAwIAoJCWVuZAoJZW5kCgkKCS0tIHRvIGRvOiBhZGFwdGl2
ZQoJbG9jYWwgZXByID0gMTYKCWxvY2FsIHd3ID0gZWwud2lkdGggLyBlcHIKCWxvY2FsIGhoID0g
ZWwuaGVpZ2h0IC8gNAoJCglmdW5jdGlvbiBlbDpkcmF3KCkKCQljbGlwKCkKCQkKCQlyZWN0Zmls
bCgwLDAsc2VsZi53aWR0aCwgc2VsZi5oZWlnaHQsIDApCgkJcmVjdGZpbGwoLTEsLTEsc2VsZi53
aWR0aCwgc2VsZi5oZWlnaHQsIDApCgkJCgkJZm9yIHk9MCw2NFxlcHItMSBkbwoJCQlmb3IgeD1l
cHItMSwwLC0xIGRvCgkJCQlyZWN0ZmlsbCh4ICogd3csIHkgKiBoaCwgeCAqIHd3ICsgd3ctMSwg
eSAqIGhoICsgaGgtMSwgCgkJCQlwY29sc1t4ICsgeSplcHJdKQoJCQkJaWYgKHBjb2xzW3ggKyB5
KmVwcl0gPT0gY29sKSB0aGVuCgkJCQkJbG9jYWwgeHggPSB4ICogd3cKCQkJCQlsb2NhbCB5eSA9
IHkgKiBoaAoJCQkJCWlmIChwYWxfc3dhdGNoID09IDAgb3IgeCUyID09IDApIHRoZW4KCQkJCQkJ
cmVjdCh4eCswLHl5KzAseHgrd3cqKDErcGFsX3N3YXRjaCktMSx5eStoaC0xLDcpCgkJCQkJCXJl
Y3QoeHgrMSx5eSsxLHh4K3d3KigxK3BhbF9zd2F0Y2gpLTIseXkraGgtMiwwKQoJCQkJCWVuZAoJ
CQkJZW5kCgkJCWVuZAoJCWVuZAoJCQoJCQoJZW5kCgkKCWZ1bmN0aW9uIGVsOmRyYWcobXNnKQoJ
CWxvY2FsIHh4ID0gbXNnLm14IFwgd3cKCQlsb2NhbCB5eSA9IG1zZy5teSBcIGhoCgkJY29sID0g
cGNvbHNbeHggKyB5eSAqIGVwcl0gb3IgMAoJZW5kCgkKCQoJcmV0dXJuIGVsCmVuZAoKCgoKCgoK
CgoKCjo6IHVuZG8ubHVhCi0tW1twb2RfZm9ybWF0PSJyYXciLGNyZWF0ZWQ9IjIwMjMtMjktMTQg
MDM6Mjk6MjciLG1vZGlmaWVkPSIyMDI0LTA0LTAzIDA2OjA0OjI4IixyZXZpc2lvbj0xNTQ4XV0K
CQkKZnVuY3Rpb24gYWRkX3VuZG9fc3RhY2soaWkpCglpaS51bmRvX3N0YWNrID0gY3JlYXRlX3Vu
ZG9fc3RhY2sodW5kb19zYXZlX3N0YXRlLCB1bmRvX2xvYWRfc3RhdGUsIDB4MTEsIGlpKQplbmQK
ZnVuY3Rpb24gdW5kb19zYXZlX3N0YXRlKGlpKQoJcmV0dXJuIHsKCQlpaS5ibXA6Y29weSgpLAoJ
CWlpLnNlbCBhbmQgaWkuc2VsOmNvcHkoKSwKCQlpaS5sYXllcjAgYW5kIGlpLmxheWVyMDpjb3B5
KCksCgkJaWkubGF5ZXIgYW5kIGlpLmxheWVyOmNvcHkoKSwKCQlpaS5sYXllcl94IG9yIDAsCgkJ
aWkubGF5ZXJfeSBvciAwLAoJCWlpLnBhbl94LAoJCWlpLnBhbl95LAoJCWlpLnpvb20KCX0KZW5k
CmZ1bmN0aW9uIHVuZG9fbG9hZF9zdGF0ZShzLCBpaSkKCWlpLmJtcCA9IHNbMV0gb3IgdXNlcmRh
dGEoInU4IiwxNiwxNikKCWlpLnNlbCA9ICAgc1syXSBvciBuaWwKCWlpLmxheWVyMCA9IHNbM10g
b3IgbmlsCglpaS5sYXllciA9IHNbNF0gb3IgbmlsCglpaS5sYXllcl94ID0gc1s1XQoJaWkubGF5
ZXJfeSA9IHNbNl0KCWlpLnBhbl94ID0gc1s3XSBvciAwCglpaS5wYW5feSA9IHNbOF0gb3IgMAoJ
aWkuem9vbSA9IHNbOV0gb3IgMQplbmQKCmZ1bmN0aW9uIGJhY2t1cF9zdGF0ZSgpCglsb2NhbCBp
aSA9IGl0ZW1bY3VycmVudF9pdGVtXQoJbG9jYWwgdHQwID0gc3RhdCgxKQoJaWkudW5kb19zdGFj
azpjaGVja3BvaW50KCkKLS0JcHJpbnRoKHN0cmluZy5mb3JtYXQoIiUzLjNmIixzdGF0KDEpLXR0
MCkuLiIgLy8gcGF0Y2ggc2l6ZToiLi4KLS0JCSMoaWkudW5kb19zdGFjay51bmRvX3N0YWNrWyNp
aS51bmRvX3N0YWNrLnVuZG9fc3RhY2tdKSkKZW5kCmZ1bmN0aW9uIHVuZG8oKQoJbG9jYWwgaWkg
PSBpdGVtW2N1cnJlbnRfaXRlbV0KCWlpLnVuZG9fc3RhY2s6dW5kbygpCmVuZApmdW5jdGlvbiBy
ZWRvKCkKCWxvY2FsIGlpID0gaXRlbVtjdXJyZW50X2l0ZW1dCglpaS51bmRvX3N0YWNrOnJlZG8o
KQplbmQKCgoKCjo6IHVwZGF0ZS5sdWEKLS1bW3BvZF9mb3JtYXQ9InJhdyIsY3JlYXRlZD0iMjAy
My00NS0xMCAwNzo0NToyNiIsbW9kaWZpZWQ9IjIwMjQtMDQtMDMgMDY6MDQ6MjgiLHJldmlzaW9u
PTIzMDddXQoKLS0gdXBkYXRlIGxheW91dCB3aXRob3V0IG5lZWRpbmcgdG8gcmVnZW5lcmF0ZSBn
dWkKIC0tIHRvIGRvOiBjb3VsZCBhbHNvIHVzZSB0aGlzIGZvciBoYW5kbGluZyBjaGFuZ2VzIGlu
IGRpc3BsYXkgc2l6ZQogZnVuY3Rpb24gdXBkYXRlX2d1aV9sYXlvdXQoKQogCWlmIChub3Qgc2lk
ZWJhciBvciBub3QgY2FudmFzX2VsKSByZXR1cm4KIAkKIAl4dCA9IHNob3dfcGFuZSBhbmQgMzM2
IG9yIDQ4MAogCXNpZGViYXJfeCA9IHNpZGViYXJfeCBvciBzaWRlYmFyLngKIAlzaWRlYmFyX3gg
PSAoc2lkZWJhcl94ICogMyArIHh0KSAvIDQKIAkKCWlmIChzaWRlYmFyX3ggPiB4dCkgdGhlbgoJ
CXNpZGViYXJfeCA9IG1heCh4dCwgc2lkZWJhcl94IC0gOCkKCWVsc2UKCQlzaWRlYmFyX3ggPSBt
aW4oeHQsIHNpZGViYXJfeCArIDgpCgllbmQKCQoJLS0gISEgaW5zdGFudCBjaGFuZ2UgLS0gbWF5
YmUgYmV0dGVyIChzdGlsbCBnZXQgdG9vbGJhciB0cmFuc2l0aW9uISkKCXNpZGViYXJfeCA9IHh0
CgogCXNpZGViYXIueCA9IHNpZGViYXJfeCBcIDEKIAlzaWRlYmFyLmhlaWdodCA9IGdldF9kaXNw
bGF5KCk6aGVpZ2h0KCkKIAoJY2FudmFzX2VsLndpZHRoID0gc2lkZWJhcl94IFwgMQoJY2FudmFz
X2VsLmhlaWdodCA9IGdldF9kaXNwbGF5KCk6aGVpZ2h0KCkKIAoJLS0gc2VuZCBhIG1lc3NhZ2Ug
dG8gd20gYXNraW5nIHRvIHVuZG9jayAvIGRvY2sgdG9vbGJhcgoJaWYgc2hvd19wYW5lIH49IGxh
c3Rfc2hvd19wYW5lIHRoZW4JCgkJLS1zZW5kX21lc3NhZ2UoMywge2V2ZW50PSJkb2NrX3Rvb2xi
YXIiLCBzdGF0ZSA9IHNob3dfcGFuZX0pCgllbmQKCWxhc3Rfc2hvd19wYW5lID0gc2hvd19wYW5l
CiBlbmQKCgpmdW5jdGlvbiBnZXRfc2VsZWN0ZWRfcmVnaW9uKCkKCWxvY2FsIHgwLHkwID0gMTAw
MDAsIDEwMDAwCglsb2NhbCB4MSx5MSA9IDAsMAoJZm9yIHkgPSAwLCBjYm1wX2hlaWdodC0xIGRv
CgkJZm9yIHggPSAwLCBjYm1wX3dpZHRoLTEgZG8KCQkJaWYgKGdldChjc2VsLCB4LCB5KSA_IDAp
IHRoZW4KCQkJCXgwID0gbWluKHgwLCB4KSB5MCA9IG1pbih5MCwgeSkKCQkJCXgxID0gbWF4KHgx
LCB4KSB5MSA9IG1heCh5MSwgeSkKCQkJZW5kIAoJCWVuZAoJZW5kCglpZiAoeDAgPT0gMTAwMDAp
IHgwLHkwLHgxLHkxID0gMCwgMCwgY2JtcF93aWR0aC0xLCBjYm1wX2hlaWdodC0xCgkKCXJldHVy
biB4MCwgeTAsIHgxLXgwKzEsIHkxLXkwKzEKZW5kCgoKZnVuY3Rpb24gY29weV9zZWxlY3RlZF9y
ZWdpb24oKQoJbG9jYWwgeDAsIHkwLCB3dywgaGggPSBnZXRfc2VsZWN0ZWRfcmVnaW9uKCkKCWxv
Y2FsIG91dCA9IHVzZXJkYXRhKCJpMTYiLCB3dywgaGgpCgktLXByaW50aChwb2R7eDAseTAsIHd3
LGhofSkKCWJsaXQoY2JtcCwgb3V0LCB4MCwgeTAsIDAsIDApCglyZXR1cm4gb3V0CmVuZAoKCmZ1
bmN0aW9uIG1vdmVfc2VsZWN0aW9uKGR4LCBkeSkKCWJhY2t1cF9zdGF0ZSgpCgkKCWlmIChub3Qg
Y2kubGF5ZXIpIHRoZW4KCQktLSBqdXN0IHBhbiAobG91aXMgaW5zdGluY3RpdmVseSB0cmllZCB0
aGlzKQoJCWl0ZW1bMV0ucGFuX3ggKz0gZHggKiBpdGVtWzFdLnpvb20gKiA0CgkJaXRlbVsxXS5w
YW5feSArPSBkeSAqIGl0ZW1bMV0uem9vbSAqIDQKCQlyZXR1cm4KCWVuZAoJCglibGl0KGNpLmxh
eWVyMCwgY2JtcCkKCWNpLmxheWVyX3ggKz0gZHgKCWNpLmxheWVyX3kgKz0gZHkKCWJsaXQoY2ku
bGF5ZXIsIGNibXAsIDAsIDAsIGNpLmxheWVyX3gsIGNpLmxheWVyX3kpCgkKCS0tIG5ldyBzZWxl
Y3Rpb24KCWNzZWw6Y2xlYXIoKQoJbG9jYWwgd3csIGhoID0gY2kubGF5ZXI6YXR0cmlicygpCgkK
CXNldF9kcmF3X3RhcmdldChjc2VsKQoJcmVjdGZpbGwoY2kubGF5ZXJfeCwgY2kubGF5ZXJfeSwg
Y2kubGF5ZXJfeCArIHd3LTEsIGNpLmxheWVyX3kgKyBoaC0xLCAxKQoJY3NlbF9vdXRsaW5lID0g
bmlsIC0tIHJlZ2VuZXJhdGUKCXNldF9kcmF3X3RhcmdldCgpCmVuZAoKIApmdW5jdGlvbiBjbGVh
cl9zZWxlY3Rpb24oKQoJYmFja3VwX3N0YXRlKCkKCWlmIChjc2VsKSBjc2VsOmNsZWFyKCkKCWNz
ZWxfb3V0bGluZSA9IG5pbCAtLSByZWZyZXNoCgljaS5sYXllciwgY2kuYmFjayA9IG5pbCwgbmls
CmVuZAoKZnVuY3Rpb24gc2VsZWN0X2FsbCgpCgliYWNrdXBfc3RhdGUoKQoJY3NlbDpjb3B5KDEs
dHJ1ZSkKCWNzZWxfb3V0bGluZSA9IG5pbCAtLSByZWdlbmVyYXRlCQoJbG9jYWwgd3csaGggPSBj
Ym1wX3dpZHRoLGNibXBfaGVpZ2h0CgljaS5sYXllciA9IHVzZXJkYXRhKCJpMTYiLHd3LGhoKQoJ
Y2kubGF5ZXJfeCA9IDAKCWNpLmxheWVyX3kgPSAwCgljaS5sYXllcjAgPSBjYm1wOmNvcHkoKQoJ
YmxpdChjYm1wLGNpLmxheWVyKQplbmQKCmZ1bmN0aW9uIG1vZGlmeV9zZWxlY3Rpb24ob3ApCgli
YWNrdXBfc3RhdGUoKQoJCglsb2NhbCB0Ym1wID0gY2kubGF5ZXIgb3IgY2JtcAoJbG9jYWwgb3Jp
ZyA9IHRibXA6Y29weSgpCgkKCWlmIChvcCA9PSAiZmxpcF94IikgdGhlbgoJCWZvciB4PTAsIHRi
bXA6d2lkdGgoKS0xIGRvCgkJCWJsaXQob3JpZyx0Ym1wLHgsMCx0Ym1wOndpZHRoKCktMS14LDAs
MSx0Ym1wOmhlaWdodCgpKQoJCWVuZAoJCXRibXA6YnhvcigweDQwMDAsIHRydWUpCgllbmQKCQoJ
aWYgKG9wID09ICJmbGlwX3kiKSB0aGVuCgkJZm9yIHk9MCwgdGJtcDpoZWlnaHQoKS0xIGRvCgkJ
CWJsaXQob3JpZyx0Ym1wLDAseSwwLHRibXA6aGVpZ2h0KCktMS15LHRibXA6d2lkdGgoKSwxKQoJ
CWVuZAoJCXRibXA6YnhvcigweDgwMDAsIHRydWUpCgllbmQKCQoJLS0gbGF5ZXIgb25seSAtLSBk
b24ndCBjbGVhciB3aG9sZSBtYXAgd2l0aCBkZWwKCWlmIChjaS5sYXllciBhbmQgb3AgPT0gImNs
ZWFyIikgdGhlbgoJCWNpLmxheWVyOmNsZWFyKCkKCWVuZAoJCgktLSB1cGRhdGUgY2hhbmdlcwoJ
aWYgKGNpLmxheWVyKSBibGl0KGNpLmxheWVyLCBjYm1wLCAwLCAwLCBjaS5sYXllcl94LCBjaS5s
YXllcl95KQplbmQKCgoKIAogZnVuY3Rpb24gX3VwZGF0ZSgpCiAKIAlndWk6dXBkYXRlX2FsbCgp
Cgl1cGRhdGVfZ3VpX2xheW91dCgpCgogCXNldF9kcmF3X3RhcmdldCgpCiAJCiAJLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQogCiAJ
aWYgKGtleXAoImVzY2FwZSIpKSB0aGVuCiAJCS0tIGdldCByaWQgb2YgYXR0YWNoLW9uLWRlbWFu
ZCBlbGVtZW50cwoJCXJlZnJlc2hfZ3VpID0gdHJ1ZQoJCXdpbmRvd3tjYXB0dXJlX2VzY2FwZXMg
PSBmYWxzZX0JCiAJZW5kCiAJCiAgCS0tIGxheWVyIG5hbWUgZWRpdG9yIChvciBzb21ldGhpbmcg
ZWxzZSkgaGFzIGtiZCBmb2N1cyAtPiBpZ25vcmUgb3RoZXIgaW5wdXQKIC0tCWlmIChsYXllcl9u
YW1lX2VkaXRvciBvciBmaWVsZF9lZGl0b3IpIHJldHVybgogCWlmIChndWk6Z2V0X2tleWJvYXJk
X2ZvY3VzX2VsZW1lbnQoKSkgcmV0dXJuCgktLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCiAJCglpZiBrZXlwKCJ0YWIiKSB0aGVuCgkJ
c2hvd19wYW5lID0gbm90IHNob3dfcGFuZQoJCXJlZnJlc2hfZ3VpPXRydWUKCWVsc2VpZiBrZXlw
KCJlbnRlciIpIHRoZW4KCQljbGVhcl9zZWxlY3Rpb24oKQoJZW5kCgkKCWxvY2FsIG1hZyA9IGtl
eSgiY3RybCIpIGFuZCA4IG9yIDEKCWlmIChrZXlwKCJsZWZ0IikpICBtb3ZlX3NlbGVjdGlvbigt
bWFnLCAwKQoJaWYgKGtleXAoInJpZ2h0IikpIG1vdmVfc2VsZWN0aW9uKCBtYWcsIDApCglpZiAo
a2V5cCgidXAiKSkgICAgbW92ZV9zZWxlY3Rpb24oIDAsLW1hZykKCWlmIChrZXlwKCJkb3duIikp
ICBtb3ZlX3NlbGVjdGlvbiggMCwgbWFnKQoJCglpZiAoa2V5cCgiZiIpKSBtb2RpZnlfc2VsZWN0
aW9uKCJmbGlwX3giKQoJaWYgKGtleXAoInYiKSkgbW9kaWZ5X3NlbGVjdGlvbigiZmxpcF95IikK
CWlmIChrZXlwKCJkZWwiKSBvciBrZXlwKCJiYWNrc3BhY2UiKSkgbW9kaWZ5X3NlbGVjdGlvbigi
Y2xlYXIiKQoKCQogCS0tIAogCWlmIChrZXkoImN0cmwiKSkgdGhlbgogCiAJaWYga2V5cCgiYyIp
IG9yIGtleXAoIngiKSB0aGVuCiAJCWxvY2FsIHRibXAgPSBjaS5sYXllciBvciBjYm1wCiAJCXNl
dF9jbGlwYm9hcmQocG9kKHRibXAsNyx7cG9kX3R5cGU9Im1hcCJ9KSkKIAkJaWYga2V5cCgieCIp
IHRoZW4KCQkJYmFja3VwX3N0YXRlKCkKCQkJdGJtcDpjbGVhcigpCgkJCWlmIChjaS5sYXllcikg
YmxpdChjaS5sYXllciwgY2JtcCwgMCwgMCwgY2kubGF5ZXJfeCwgY2kubGF5ZXJfeSkKCQkJbm90
aWZ5KHN0cmluZy5mb3JtYXQoImN1dCAlZCB4ICVkIHRpbGVzIix0Ym1wOndpZHRoKCksdGJtcDpo
ZWlnaHQoKSkpCiAJCWVsc2UKCQkJbm90aWZ5KHN0cmluZy5mb3JtYXQoImNvcGllZCAlZCB4ICVk
IHRpbGVzIix0Ym1wOndpZHRoKCksdGJtcDpoZWlnaHQoKSkpCgkJZW5kCgllbmQKCQoJaWYga2V5
cCgidiIpIHRoZW4KCQlsb2NhbCBjdCA9IGdldF9jbGlwYm9hcmQoKQoJCWxvY2FsIGJtcDEgPSBu
aWwKCQlpZiAoc3ViKGN0LDEsNSkgPT0gIltnZnhdIikgdGhlbgoJCQlibXAxID0gdXNlcmRhdGEo
Y3QpCgkJZWxzZQoJCQlibXAxID0gdW5wb2QoY3QpCgkJZW5kCgkJaWYgKHR5cGUoYm1wMSkgPT0g
InVzZXJkYXRhIikgdGhlbgoJCQliYWNrdXBfc3RhdGUoKQoJCQlpdGVtW2N1cnJlbnRfaXRlbV0u
Ym1wID0gYm1wMQoJCQlzZXRfY3VycmVudF9pdGVtKGN1cnJlbnRfaXRlbSkKCQllbmQKCWVuZAoJ
CglpZiBrZXlwKCJ6IikgdGhlbgoJCXVuZG8oKQoJCXNldF9jdXJyZW50X2l0ZW0oY3VycmVudF9p
dGVtKQoJCXJlZnJlc2hfZ3VpID0gdHJ1ZQoJZW5kCgkKCWlmIGtleXAoInkiKSB0aGVuCgkJcmVk
bygpCgkJc2V0X2N1cnJlbnRfaXRlbShjdXJyZW50X2l0ZW0pCgkJcmVmcmVzaF9ndWkgPSB0cnVl
CgllbmQKCQoJaWYga2V5cCgiYSIpIHRoZW4KCQlzZWxlY3RfYWxsKCkKCWVuZAoJCgkKCWVuZCAt
LSBjdHJsCgoKCQogZW5kCiAKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCjo6
IHdvcmtzcGFjZXMucG9kCmI2NCRMUzFiVzNCdlpDeGpjbVZoZEdWa1BTSXlNREl6TFRFM0xUSTJJ
REUwT2pFM09qRTJJaXh0YjJScFptbGxaRDBpTWpBeU15MHkKTUMweU5pQXhOam95TURvME1TSXNj
bVYyYVhOcGIyNDlORFJkWFd4Nk5BQjVBQUFBR3dFQUFQY2FlM3RzYjJOaGRHbHZiajBpYldGcApi
aTVzZFdFaUxIZHZjbXR6Y0dGalpWOXBibVJsZUQweGZTd29BRTlrY21GM0tBQURHVElvQUc5MWNH
UmhkR1VxQUFNWk15b0FQMjVoCmRpY0FBeGswSndBLVozVnBKd0FER1RVbkFHOWpZVzUyWVhNcUFB
TVpOaW9BVDNWdVpHOG9BQUZRZUQwMwo6OiBbZW9jXQo=
:: apps/settings.p64
b64$cGljb3Ryb24gY2FydHJpZGdlIC8vIHd3dy5waWNvdHJvbi5uZXQKdmVyc2lvbiAyCgo6OiAu
aW5mby5wb2QKYjY0JExTMWJXM0J2WkN4amNtVmhkR1ZrUFNJeU1ESTBMVEEwTFRFeUlEQXlPakUy
T2pBM0lpeGhkWFJvYjNJOUlucGxjQ0lzYm05MApaWE05SWlJc2FXTnZiajExYzJWeVpHRjBZU2dp
ZFRnaUxERTJMREUyTENJd01EQXdNREF3TVRBeE1ERXdNVEF4TURFd01UQXhNREV3Ck1UQXdNREF3
TURBd01EQXdNVEEzTURjd056QTNNRGN3TnpBM01EY3dOekEzTURFd01EQXdNREF3TVRBM01HUXda
REJrTUdRd1pEQmsKTUdRd1pEQmtNR1F3TnpBeE1EQXdNVEEzTUdRd1pEQmtNR1F3WkRCa01HUXda
REJrTUdRd1pEQmtNRGN3TVRBeE1EY3daREJrTUdRdwpaREJrTUdRd1pEQTNNRGN3WkRCa01HUXdO
ekF4TURFd056QmtNR1F3TVRBeE1ERXdNVEF4TURjd056QXhNR1F3WkRBM01ERXdNVEEzCk1HUXda
REJrTUdRd1pEQmtNR1F3TnpBM01HUXdaREJrTURjd01UQXhNRGN3WkRCa01HUXdOekEzTUdRd1pE
QmtNR1F3WkRCa01HUXcKTnpBeE1ERXdOekJrTUdRd01UQTNNRGN3TVRBeE1ERXdNVEF4TUdRd1pE
QTNNREV3TVRBM01HUXdaREJrTURjd056QmtNR1F3WkRCawpNR1F3WkRCa01EY3dNVEF4TURjd1pE
QmtNR1F3WkRCa01HUXdaREJrTUdRd1pEQmtNR1F3TnpBeE1ERXdOakEzTUdRd1pEQmtNR1F3ClpE
QmtNR1F3WkRCa01HUXdOekEyTURFd01UQTJNRFl3TnpBM01EY3dOekEzTURjd056QTNNRGN3TnpB
Mk1EWXdNVEF3TURFd05qQTIKTURZd05qQTJNRFl3TmpBMk1EWXdOakEyTURZd01UQXdNREF3TURB
eE1EWXdOakEyTURZd05qQTJNRFl3TmpBMk1EWXdNVEF3TURBdwpNREF3TURBd01UQXhNREV3TVRB
eE1ERXdNVEF4TURFd01UQXdNREF3TUNJcExHMXZaR2xtYVdWa1BTSXlNREkwTFRBM0xUQTJJREV4
Ck9qUTRPak0ySWl4eWRXNTBhVzFsUFRZc2MzUnZjbVZrUFNJeU1ESTBMVEF6TFRJeklERTRPak0y
T2pBNElpeDBhWFJzWlQwaVVHbGoKYjNSeWIyNGdVMlYwZEdsdVozTWlMSFpsY25OcGIyNDlJaUlz
ZDI5eWEzTndZV05sY3oxN2UyeHZZMkYwYVc5dVBTSnRZV2x1TG14MQpZU014T0RRaUxIZHZjbXR6
Y0dGalpWOXBibVJsZUQweGZTeDdiRzlqWVhScGIyNDlJbWRtZUM4d0xtZG1lQ0lzZDI5eWEzTndZ
V05sClgybHVaR1Y0UFRKOUxIdHNiMk5oZEdsdmJqMGliV0Z3THpBdWJXRndJaXgzYjNKcmMzQmhZ
MlZmYVc1a1pYZzlNMzBzZTJ4dlkyRjAKYVc5dVBTSnpabmd2TUM1elpuZ2lMSGR2Y210emNHRmpa
VjlwYm1SbGVEMDBmWDFkWFd4Nk5BQUVBQUFBQXdBQUFEQnVhV3c9Cjo6IGdmeC8KOjogZ2Z4Ly5p
bmZvLnBvZApiNjQkTFMxYlczQnZaQ3hqY21WaGRHVmtQU0l5TURJekxURXdMVEF5SURBMk9qUTBP
akl3SWl4dGIyUnBabWxsWkQwaU1qQXlOQzB3Ck55MHdOaUF4TVRvME9Eb3pOaUlzYzNSdmNtVmtQ
U0l5TURJekxUUTBMVEF5SURBMk9qUTBPakl3SWwxZGJIbzBBQVFBQUFBREFBQUEKTUc1cGJBPT0K
OjogZ2Z4LzAuZ2Z4CmI2NCRMUzFiVzNCdlpDeGpjbVZoZEdWa1BTSXlNREl6TFRFd0xUQXlJREEy
T2pRME9qVXlJaXh0YjJScFptbGxaRDBpTWpBeU5DMHcKTkMweE1pQXdNam94TnpvMU9DSXNjbVYy
YVhOcGIyNDlOVGs1WFYxc2VqUUFiUUFBQUFVeEFBRHpGSHRiTUYwOWUySnRjRDF3ZUhVQQpReUFR
RUFUdzhDeG1iR0ZuY3owd0xIQmhibDk0Q0FEUGVUMHdMSHB2YjIwOU9IMHNNUUQtLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tCi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLW5V
RzA5T0gxOQo6OiBtYXAvCjo6IG1hcC8uaW5mby5wb2QKYjY0JExTMWJXM0J2WkN4amNtVmhkR1Zr
UFNJeU1ESXpMVEV3TFRBeUlEQTJPalEwT2pJd0lpeHRiMlJwWm1sbFpEMGlNakF5TkMwdwpOeTB3
TmlBeE1UbzBPRG96TmlJc2MzUnZjbVZrUFNJeU1ESXpMVFEwTFRBeUlEQTJPalEwT2pJd0lsMWRi
SG8wQUFRQUFBQURBQUFBCk1HNXBiQT09Cjo6IG1hcC8wLm1hcApiNjQkTFMxYlczQnZaQ3hqY21W
aGRHVmtQU0l5TURJekxURXdMVEF5SURBMk9qUTBPalV5SWl4dGIyUnBabWxsWkQwaU1qQXlOQzB3
Ck5DMHhNaUF3TWpveE56bzFPQ0lzY21WMmFYTnBiMjQ5TlRrMFhWMXNlalFBYUFBQUFGZ1FBQUR3
Q0h0N1ltMXdQWFZ6WlhKa1lYUmgKS0NKcE1UWWlMRE15QXdBdklqQUJBUC0tLS0tLS0tLS0tLS0t
LS0tLS0tdnhDQ0lwTEdocFpHUmxiajFtWVd4elpTeHdZVzVmZUQwdwpDQURTZVQwd0xIUnBiR1Zm
YUQweE5nb0FFSGNLQUlCNmIyOXRQVEY5ZlE9PQo6OiBtYXAvbWFwMC5tYXAKYjY0JExTMWJXM0J2
WkN4amNtVmhkR1ZrUFNJeU1ESTBMVFE0TFRBMElERTJPalE0T2pBeElpeHRiMlJwWm1sbFpEMGlN
akF5TkMwMApPQzB3TkNBeE5qbzBPRG93TVNJc2NtVjJhWE5wYjI0OU1GMWRiSG8wQUdrQUFBQ2pD
QUFBOEJON2JHRjVaWEk5ZTFzd1hUMTdZbTF3ClBYVnpaWEprWVhSaEtDSnBNVFlpTERFMkF3QXZJ
akFCQVAtLS1fX2hJaWtzY0dGdVgzZzlNQWdBOGdaNVBUQXNjMk5oYkdVOU1TeDAKYVd4bFgyZzlN
VFlLQUc5M1BURTJmU3hMQlAtLS0tODRVREUyZlgxOQo6OiBzZngvCjo6IHNmeC8uaW5mby5wb2QK
YjY0JExTMWJXM0J2WkN4amNtVmhkR1ZrUFNJeU1ESXpMVEV3TFRBeUlEQTJPalEwT2pJd0lpeHRi
MlJwWm1sbFpEMGlNakF5TkMwdwpOeTB3TmlBeE1UbzBPRG96TmlJc2MzUnZjbVZrUFNJeU1ESXpM
VFEwTFRBeUlEQTJPalEwT2pJd0lsMWRiSG8wQUFRQUFBQURBQUFBCk1HNXBiQT09Cjo6IHNmeC8w
LnNmeApiNjQkTFMxYlczQnZaQ3hqY21WaGRHVmtQU0l5TURJekxURXdMVEF5SURBMk9qUTBPalV5
SWl4dGIyUnBabWxsWkQwaU1qQXlOQzB3Ck5DMHhNaUF3TWpveE56bzFOeUlzY21WMmFYTnBiMjQ5
TlRVd1hWMXNlalFBYndBQUFPMEdBQURmY0hoMUFBTW9BQUFEQUFUdy13RUEKN1A4bjhRRVFCZzhn
RUFFZ0FTQUI4QUFDRUFJT0VBRWdEeUVnQVRBUFFQREREeWdQLS1ER0QtZ0tELThQZ0EtM0R3MEI4
QWtCRUFZTwpNQUQtT1ItLUFRRGN6LWdQUUFBUEVFRC0tN0R3Y0FzQS0tX2pILThCQUpkUS0tLS0t
eDg9Cjo6IHNmeC9zZngwLnNmeApiNjQkTFMxYlczQnZaQ3hqY21WaGRHVmtQU0l5TURJMExUUTRM
VEEwSURFMk9qUTRPakF4SWl4dGIyUnBabWxsWkQwaU1qQXlOQzAwCk9DMHdOQ0F4TmpvME9Eb3dN
U0lzY21WMmFYTnBiMjQ5TUYxZGJIbzBBQkFCQUFCUkJ3QUE4Q2R3ZUhVQUF5Z0FBQU1BQkE5QUVB
SU8KQUFHZ0FTQUNvQTRBRHhBQURmREtBUUlEQkFVR0J3RVAtNUFJQ1FvTER3d1BEUThPRHc4UUFQ
QUFEUThSRHhJUEV3OFVEeFVQRmc4WApFd0R4QVE4WUR4a1BHZzhiRHh3UEhROGVEeDhVQVBFQUlB
OGhEeUlQSXc4a0R5VVBKZzhuRkFEeEFDZ1BLUThxRHlzUExBOHREeTRQCkx4UUE4UUF3RHpFUE1n
OHpEelFQTlE4MkR6Y1VBUDhGT0E4NUR6b1BPdzg4RHowUFBnOC1BUS0tOFA4QkFPdi1KMW9CRUFZ
UElCQUIKSUFFZ0FmQUFBaEFDREJBQklBOGhJQUV3RDBEd3d3OG9ELS13eGctNENnLS1ENEFQOXc4
TkFmQUpBUkFHRERBQS16a2Ytd0VBM0wtNApEMEFBRFVELS03RHdjQW9BLS05a0gtOEJBSmRRLS0t
LS14OD0KOjogbWFpbi5sdWEKLS1bW3BvZF9mb3JtYXQ9InJhdyIsY3JlYXRlZD0iMjAyMy0xMC0w
MiAwNjo0NDo1MiIsbW9kaWZpZWQ9IjIwMjQtMDQtMTIgMDI6MTc6NTgiLHJldmlzaW9uPTg3MV1d
Ci0tIHBpY290cm9uIHNldHRpbmdzCi0tIHRvIGRvOiBrZXlib2FyZCBjb250cm9sCgpwYWdlID0g
MQpzZGF0ID0ge30KCgpmdW5jdGlvbiBjcmVhdGVfY2hlY2tib3goeCwgeSwgbGFiZWwsIGtleSkK
CWxvY2FsIGVsID0gewoJCXggPSB4LCB5ID0geSwKCQl3aWR0aCA9IDkyLAoJCWhlaWdodCAgPSAx
MiwKCQlsYWJlbCA9IGxhYmVsLAoJCWtleSA9IGtleSwKCQljdXJzb3IgPSAicG9pbnRlciIKCX0K
CQoJZnVuY3Rpb24gZWw6ZHJhdygpCgkJcmVjdCgwLDAsOCw4LDEpCgkJaWYgKHNkYXRba2V5XSkg
cmVjdGZpbGwoMiwyLDYsNiwxKQoJCXByaW50KGxhYmVsLCAxNSwgMSwgMTMpCgllbmQKCQoJZnVu
Y3Rpb24gZWw6Y2xpY2soKQoJCXNkYXRba2V5XSA9IG5vdCBzZGF0W2tleV0KCQlzdG9yZV9zZXR0
aW5ncygpCgkJc2VuZF9tZXNzYWdlKDMsIHtldmVudD0icmVsb2FkX3NldHRpbmdzIn0pIC0tIGZv
ciBzcXVpc2h5IHdpbmRvd3MKCWVuZAoJCglyZXR1cm4gZWwKZW5kCgpmdW5jdGlvbiBjcmVhdGVf
Y2hvb3Nlcih4LCB5LCBrZXksIHBhdGgpCgoJbG9jYWwgZWwgPSBndWk6YXR0YWNoewoJCXggPSB4
LCB5ID0geSwKCQl3aWR0aCA9IDkwLAoJCWhlaWdodD01MCwKCQlrZXk9a2V5LAoJCXBhdGg9cGF0
aAoJfQoJCglsb2NhbCBpdGVtX2ggPSAxMgoJCglmdW5jdGlvbiBlbDpkcmF3KCkKCQlyZWN0Zmls
bCgwLDAsc2VsZi53aWR0aC0xLCBzZWxmLmhlaWdodC0xLDEpCgllbmQKCglsb2NhbCBwYXRoMSA9
IHBhdGgKCgoJLS0gY3VzdG9tIGZvbGRlcgoJaWYgKGZzdGF0KCIvYXBwZGF0YSIuLnBhdGgpID09
ICJmb2xkZXIiKSB0aGVuCgkJcGF0aDEgPSAiL2FwcGRhdGEiLi5wYXRoCgllbmQKCWZpbGVzID0g
bHMocGF0aDEpIG9yIHt9CgkKCQoJbG9jYWwgaXRlbSA9IHt9CglpZiAocGF0aCA9PSAiL3N5c3Rl
bS90aGVtZXMiKSB0aGVuCgkJYWRkKGl0ZW0sIHtsYWJlbCA9ICJbY3VzdG9tXSIsIGZpbGVuYW1l
ID0gIi9hcHBkYXRhL3N5c3RlbS90aGVtZS5wb2QifSkKCWVuZAoKCWlmIChwYXRoID09ICIvc3lz
dGVtL3NjcmVlbnNhdmVycyIpIHRoZW4KCQlhZGQoaXRlbSwge2xhYmVsID0gIltub25lXSIsIGZp
bGVuYW1lID0gbmlsfSkKCWVuZAoJCglmb3IgaT0xLCAjZmlsZXMgZG8KCQlhZGQoaXRlbSwge2xh
YmVsID0gc3BsaXQoZmlsZXNbaV0sIi4iKVsxXSwgZmlsZW5hbWUgPSBwYXRoMS4uIi8iLi5maWxl
c1tpXX0pCgllbmQKCQoJbG9jYWwgY29udGVudHMgPSBlbDphdHRhY2h7CgkJeCA9IDAsIHkgPSAw
LAoJCXdpZHRoID0gODAsIGhlaWdodCA9IDggKyAjaXRlbSAqIGl0ZW1faCwKCQlpdGVtID0gaXRl
bQoJfQoJCglmdW5jdGlvbiBjb250ZW50czpkcmF3KCkKCQlmb3IgaSA9IDEsICNzZWxmLml0ZW0g
ZG8KCQkJbG9jYWwgaXRlbSA9IHNlbGYuaXRlbVtpXQoJCQlsb2NhbCB5eSA9IDQgKyAoaS0xKSpp
dGVtX2gKCQkJY29sb3IoNikKCQkJaWYgKGl0ZW0uZmlsZW5hbWUgPT0gc2RhdFtrZXldKSByZWN0
ZmlsbCgwLHl5LTEsc2VsZi53aWR0aC0xLHl5KzgpIGNvbG9yKDEpCgkJCXByaW50KGl0ZW0ubGFi
ZWwsIDMsIHl5KQoJCWVuZAoJZW5kCgkKCWZ1bmN0aW9uIGNvbnRlbnRzOmNsaWNrKG1zZykKCQls
b2NhbCBpID0gbWlkKDEsIDEgKyAobXNnLm15IC0gNCkgXCBpdGVtX2gsICNzZWxmLml0ZW0pCgkJ
bmV3aSA9IGkgfj0gbGFzdF9pIGxhc3RfaSA9IGkKCQkKCQktLSBhY3Qgb24gc2VsZWN0aW9uIChj
YW4gcmV0dXJuIGVhcmx5IHRvIHJlamVjdCBjaGFuZ2UpCgkJCgkJLS0gdGhlbWUgY2hhbmdlOiBj
b3B5IG92ZXIgc3lzdGVtIGRlZmF1bHQKCQlpZiAocGF0aCA9PSAiL3N5c3RlbS90aGVtZXMiKSB0
aGVuCgkJCWxvY2FsIHRkYXQgPSBmZXRjaChzZWxmLml0ZW1baV0uZmlsZW5hbWUpCgkJCWlmICh0
ZGF0KSBzdG9yZSgiL3JhbS9zaGFyZWQvdGhlbWUucG9kIiwgdGRhdCkKCQllbmQKCQkKCQktLSBk
ZXNrdG9wIGNoYW5nZToga2lsbCBwcm9jZXNzIGFuZCBzdGFydCBuZXcgb25lICghKQoJCWlmIChw
YXRoID09ICIvc3lzdGVtL3dhbGxwYXBlcnMiKSB0aGVuCgkJCXNlbmRfbWVzc2FnZSgzLCB7ZXZl
bnQ9InNldF93YWxscGFwZXIiLCB3YWxscGFwZXIgPSBzZWxmLml0ZW1baV0uZmlsZW5hbWV9KQoJ
CWVuZAkKCQkKCQktLSBzdG9yZSBjaGFuZ2UgaW4gc3lzdGVtIHNldHRpbmdzCgkJLS0gdGhlbWUs
IHdhbGxwYXBlciBhbmQgc2NyZWVuc2F2ZXIgYXJlIGFsbCBmdWxsIHBhdGggZmlsZW5hbWVzCgkJ
CgkJc2RhdFtrZXldID0gc2VsZi5pdGVtW2ldLmZpbGVuYW1lCgkJc3RvcmVfc2V0dGluZ3MoKQoJ
CQoJZW5kCgkKCWZ1bmN0aW9uIGNvbnRlbnRzOmRvdWJsZWNsaWNrKG1zZykKCQlsb2NhbCBpID0g
bWlkKDEsIDEgKyAobXNnLm15IC0gNCkgXCBpdGVtX2gsICNzZWxmLml0ZW0pCgkJaWYgKG5ld2kp
IHJldHVybiAtLSBkb24ndCBjb3VudCBhcyBhIGRvdWJsZSBjbGljawoJCQoJCWlmIChrZXk9PSJz
Y3JlZW5zYXZlciIgYW5kIHNkYXQuc2NyZWVuc2F2ZXIpIHNlbmRfbWVzc2FnZSgzLCB7ZXZlbnQ9
InRlc3Rfc2NyZWVuc2F2ZXIifSkKCQkKCQlpZiAoa2V5PT0idGhlbWUiKSB0aGVuCgkJCS0tIGNv
cHkgb3ZlciBzeXN0ZW0gZGVmYXVsdCBhbmQgZWRpdCB0aGF0CgkJCXNkYXQudGhlbWUgPSAiL2Fw
cGRhdGEvc3lzdGVtL3RoZW1lLnBvZCIKCQkJc3RvcmVfc2V0dGluZ3MoKQoJCQkKCQkJbG9jYWwg
dGRhdCA9IGZldGNoKHNlbGYuaXRlbVtpXS5maWxlbmFtZSkKCQkJaWYgKHRkYXQpIHN0b3JlKCIv
YXBwZGF0YS9zeXN0ZW0vdGhlbWUucG9kIiwgdGRhdCkKCQkJY3JlYXRlX3Byb2Nlc3MoIi9zeXN0
ZW0vYXBwcy90aGVtZWQucDY0Iiwge2FyZ3Y9eyIvYXBwZGF0YS9zeXN0ZW0vdGhlbWUucG9kIn19
KQoJCWVuZAoJZW5kCgkKCQoJZWw6YXR0YWNoX3Njcm9sbGJhcnMoKQoKCXJldHVybiBlbAplbmQK
CmZ1bmN0aW9uIGdlbmVyYXRlX2d1aSgpCglndWkgPSBjcmVhdGVfZ3VpKCkKCQoJbG9jYWwgbGlu
ZV9oID0gMTIKCQoJLS0gcGFnZSB0b2dnbGUKCglndWk6YXR0YWNoewoJCXg9MTcwLHk9NCwgd2lk
dGg9MzUsIGhlaWdodD05LAoJCWN1cnNvcj0icG9pbnRlciIsCgkJZHJhdz1mdW5jdGlvbihzZWxm
LCBtc2cpCgkJCXJlY3RmaWxsKDAsMCxzZWxmLndpZHRoLHNlbGYuaGVpZ2h0LCBtc2cuaGFzX3Bv
aW50ZXIgYW5kIDE0IG9yIDEzKQoJCQlwcmludCgiXDAxNHBhZ2UgIi4ucGFnZS4uIi8yIiwyLDIs
NykKCQllbmQsCgkJdGFwPWZ1bmN0aW9uKHNlbGYpCgkJCXBhZ2UgPSBwYWdlID09IDEgYW5kIDIg
b3IgMQoJCQlnZW5lcmF0ZV9ndWkoKQoJCWVuZAoJfQoJCmlmIChwYWdlID09IDEpIHRoZW4KCWxv
Y2FsIHgsIHkgPSAxMCwyMAoJZ3VpOmF0dGFjaChjcmVhdGVfY2hlY2tib3goeCwgeSwgIkZ1bGxz
Y3JlZW4iLCAiZnVsbHNjcmVlbiIpKSB5ICs9IGxpbmVfaAoJZ3VpOmF0dGFjaChjcmVhdGVfY2hl
Y2tib3goeCwgeSwgIlBpeGVsIFBlcmZlY3QiLCAicGl4ZWxfcGVyZmVjdCIpKSB5ICs9IGxpbmVf
aAoJZ3VpOmF0dGFjaChjcmVhdGVfY2hlY2tib3goeCwgeSwgIlN0cmV0Y2giLCAic3RyZXRjaCIp
KSB5ICs9IGxpbmVfaAoJCglsb2NhbCB4LCB5ID0gMTA1LDIwCgkKCS0tZ3VpOmF0dGFjaChjcmVh
dGVfY2hlY2tib3goeCwgeSwgIlZvbHVtZSIsICJzeXN0ZW1fdm9sdW1lIikpIHkgKz0gbGluZV9o
CglndWk6YXR0YWNoKGNyZWF0ZV9jaGVja2JveCh4LCB5LCAiTXV0ZSIsICJtdXRlX2F1ZGlvIikp
IHkgKz0gbGluZV9oCglndWk6YXR0YWNoKGNyZWF0ZV9jaGVja2JveCh4LCB5LCAiU3dhcCBTdGVy
ZW8iLCAic3dhcF9zdGVyZW8iKSkgeSArPSBsaW5lX2gKCQoJZ3VpOmF0dGFjaChjcmVhdGVfY2hv
b3NlcigxMCwgODAsICJ0aGVtZSIsICIvc3lzdGVtL3RoZW1lcyIpKQoJZ3VpOmF0dGFjaChjcmVh
dGVfY2hvb3NlcigxMDUsIDgwLCAid2FsbHBhcGVyIiwgIi9zeXN0ZW0vd2FsbHBhcGVycyIpKQoJ
CmVsc2UKCS0tIHBhZ2UgMgoJbG9jYWwgeCwgeSA9IDEwLDIwCglndWk6YXR0YWNoKGNyZWF0ZV9j
aGVja2JveCh4LCB5LCAiTmV0d29yayIsICJuZXR3b3JrX2FjY2VzcyIpKSB5ICs9IGxpbmVfaAoJ
Z3VpOmF0dGFjaChjcmVhdGVfY2hlY2tib3goeCwgeSwgIkJhdHRlcnkgU2F2ZXIiLCAiYmF0dGVy
eV9zYXZlciIpKSB5ICs9IGxpbmVfaAoJCglndWk6YXR0YWNoKGNyZWF0ZV9jaGVja2JveCh4LHks
ICJTcXVpc2h5IFdpbmRvd3MiLCAic3F1aXNoeV93aW5kb3dzIikpIHkgKz0gbGluZV9oCgkKCXkg
PSAyMAoJZ3VpOmF0dGFjaChjcmVhdGVfY2hlY2tib3goMTA1LCB5LCAiUlNISUZUIE1hZ25pZnki
LCAicnNoaWZ0X21hZ25pZnkiKSkgeSArPSBsaW5lX2gKCWd1aTphdHRhY2goY3JlYXRlX2NoZWNr
Ym94KDEwNSwgeSwgIlNwYXJrbGVzIiwgICAgICAgInNwYXJrbGVzIikpIHkgKz0gbGluZV9oCgln
dWk6YXR0YWNoKGNyZWF0ZV9jaGVja2JveCgxMDUsIHksICJDVFJMLVEgU2h1dGRvd24iLCAiZmFz
dHF1aXQiKSkgeSArPSBsaW5lX2gKCQoJeSA9IDgwCglndWk6YXR0YWNoKGNyZWF0ZV9jaGVja2Jv
eCgxMDUsIHksICJBbnl3aGVuIiwgImFueXdoZW4iKSkgeSArPSBsaW5lX2gKCWd1aTphdHRhY2go
Y3JlYXRlX2NoZWNrYm94KDEwNSwgeSwgIkFsbG93IEhpZ2ggRFBJIiwgImFsbG93X2hpZ2hkcGki
KSkgeSArPSBsaW5lX2gKCQoJLS0gY2hvb3NlcnMKCWd1aTphdHRhY2goY3JlYXRlX2Nob29zZXIo
eCwgODAsICJzY3JlZW5zYXZlciIsICIvc3lzdGVtL3NjcmVlbnNhdmVycyIpKQplbmQKCQotLVtb
CgktLSBkb24ndCBuZWVkIC0tIGp1c3QgZG91YmxlIGNsaWNrCglndWk6YXR0YWNoewoJCXg9MjU2
LHk9NjYsd2lkdGg9MTksaGVpZ2h0PTksCgkJZHJhdz1mdW5jdGlvbihzZWxmLG1zZykKCQkJcmVj
dGZpbGwoMCwwLHNlbGYud2lkdGgtMSwgc2VsZi5oZWlnaHQtMSwgMykKCQkJcHJpbnQoIlwwMTR0
ZXN0IiwyLDIsMSkKCQllbmQsCgkJdGFwPWZ1bmN0aW9uKHNlbGYsbXNnKQoJCQktLXByaW50aChz
ZGF0LnNjcmVlbnNhdmVyKQoJCQktLWNyZWF0ZV9wcm9jZXNzKHNkYXQuc2NyZWVuc2F2ZXIpCgkJ
CXNlbmRfbWVzc2FnZSgzLCB7ZXZlbnQ9InRlc3Rfc2NyZWVuc2F2ZXIifSkKCQllbmQJCQoJfQpd
XQoJCmVuZAoKZnVuY3Rpb24gc3RvcmVfc2V0dGluZ3MoKQoJLS1wcmludGgoInN0b3Jpbmcgc2V0
dGluZ3M6ICIuLnBvZChzZGF0KSkKCXN0b3JlKCIvYXBwZGF0YS9zeXN0ZW0vc2V0dGluZ3MucG9k
Iiwgc2RhdCkgLS0gcGVyc2lzdAoJc3RvcmUoIi9yYW0vc3lzdGVtL3NldHRpbmdzLnBvZCIsIHNk
YXQpIC0tIGFwcGx5IGxpdmUgY2hhbmdlcwplbmQKCmZ1bmN0aW9uIF9pbml0KCkKCgl3aW5kb3d7
CgkJd2lkdGg9MjEwLAoJCWhlaWdodD0xNDAsCgkJdGl0bGU9IlN5c3RlbSBTZXR0aW5ncyIsCgkJ
cmVzaXplYWJsZSA9IHRydWUKCX0KCQoJcG9rZSgweDQwMDAsIGdldChmZXRjaCIvc3lzdGVtL2Zv
bnRzL2xpbC5mb250IikpCgkKCXNkYXQgPSBmZXRjaCIvYXBwZGF0YS9zeXN0ZW0vc2V0dGluZ3Mu
cG9kIiBvciB7fQoJc3RvcmUoIi9yYW0vc3lzdGVtL3NldHRpbmdzLnBvZCIsIHNkYXQpCgkKCWdl
bmVyYXRlX2d1aSgpCmVuZAoKZnVuY3Rpb24gX2RyYXcoKQoJY2xzKDcpCgljb2xvcig1KQoJCgls
b2NhbCB5eSA9IDY3Cglsb2NhbCBwcmVmaXggPSAiIi0tIlwxMjhcLWoiCgkKCWlmIChwYWdlID09
IDEpIHRoZW4KCQlwcmludCgiVmlkZW8iLDEwLDUpCgkJcHJpbnQoIkF1ZGlvIiwxMDUsNSkKCQkK
CQkKCQlwcmludChwcmVmaXguLiJUaGVtZSIsMTAseXkpCgkJcHJpbnQocHJlZml4Li4iV2FsbHBh
cGVyIiwxMDUseXkpCgllbHNlCgkJcHJpbnQoIlN5c3RlbSIsMTAsNSkKCQktLXByaW50KCJEZXNr
dG9wIiwxMDUsNSkKCQkKCQktLWxpbmUoMTAsNjAsMjgwLDYwLDYpCgkKCQktLQoJCgkJcHJpbnQo
cHJlZml4Li4iU2NyZWVuc2F2ZXIiLDEwLHl5KQoJCXByaW50KHByZWZpeC4uIkV4cGVyaW1lbnRh
bCIsMTA1LHl5KQoJCQoJZW5kCgkKCWd1aTpkcmF3X2FsbCgpCmVuZAoKZnVuY3Rpb24gX3VwZGF0
ZSgpCglndWk6dXBkYXRlX2FsbCgpCgkKCS0tIGZldGNoIGZyb20gcmFtIGV2ZXJ5IGZyYW1lOyBt
aWdodCBjaGFuZ2Ugd2l0aCBhbHQrZW50ZXIKCXNkYXQgPSBmZXRjaCIvcmFtL3N5c3RlbS9zZXR0
aW5ncy5wb2QiIG9yIHNkYXQgb3Ige30KZW5kCgoKOjogW2VvY10K
:: apps/podtree.p64
b64$cGljb3Ryb24gY2FydHJpZGdlIC8vIHd3dy5waWNvdHJvbi5uZXQKdmVyc2lvbiAyCgo6OiAu
aW5mby5wb2QKYjY0JExTMWJXM0J2WkN4amNtVmhkR1ZrUFNJeU1ESXpMVEV3TFRJeUlERXdPakk0
T2pFeklpeHRiMlJwWm1sbFpEMGlNakF5TkMwdwpOeTB3TmlBeE1UbzBPRG96TmlJc2MzUnZjbVZr
UFNJeU1ESXpMVEkxTFRFNElERXhPakkxT2pJeUlpeDNiM0pyYzNCaFkyVnpQWHQ3CmJHOWpZWFJw
YjI0OUltMWhhVzR1YkhWaElpeDNiM0pyYzNCaFkyVmZhVzVrWlhnOU4zMHNlMnh2WTJGMGFXOXVQ
U0puWm5ndk1DNW4KWm5naUxIZHZjbXR6Y0dGalpWOXBibVJsZUQwNGZYMWRYV3g2TkFBRUFBQUFB
d0FBQURCdWFXdz0KOjogZ2Z4Lwo6OiBnZngvLmluZm8ucG9kCmI2NCRMUzFiVzNCdlpDeGpjbVZo
ZEdWa1BTSXlNREl6TFRFd0xUSXlJREV3T2pJNE9qRXpJaXh0YjJScFptbGxaRDBpTWpBeU5DMHcK
Tnkwd05pQXhNVG8wT0Rvek5pSXNjM1J2Y21Wa1BTSXlNREl6TFRJNExUSXlJREV3T2pJNE9qRXpJ
bDFkYkhvMEFBUUFBQUFEQUFBQQpNRzVwYkE9PQo6OiBnZngvMC5nZngKYjY0JExTMWJXM0J2WkN4
amNtVmhkR1ZrUFNJeU1ESXpMVEExTFRNd0lERXdPakExT2pNeklpeHRiMlJwWm1sbFpEMGlNakF5
TXkweQpOUzB4T0NBeE1Ub3lOVG95TWlJc2NtVjJhWE5wYjI0OU5URmRYV3g2TkFDQUFBQUFCRE1B
QVBFV2Uxc3dYVDE3WW0xd1BYQjRkUUJECklCQVFCUER3TEdac1lXZHpQVEFzY0dGdVgzZzlNZ2dB
MzNrOU1peHpZMkZzWlQwNGZTd3lBQXdUTURJQUV6QXlBQzh4TWpNQS0tLS0KLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1fMlVEMHhN
bjE5Cjo6IG1hcC8KOjogbWFwLy5pbmZvLnBvZApiNjQkTFMxYlczQnZaQ3hqY21WaGRHVmtQU0l5
TURJekxURXdMVEl5SURFd09qSTRPakV6SWl4dGIyUnBabWxsWkQwaU1qQXlOQzB3Ck55MHdOaUF4
TVRvME9Eb3pOaUlzYzNSdmNtVmtQU0l5TURJekxUSTRMVEl5SURFd09qSTRPakV6SWwxZGJIbzBB
QVFBQUFBREFBQUEKTUc1cGJBPT0KOjogbWFwLzAubWFwCmI2NCRMUzFiVzNCdlpDeGpjbVZoZEdW
a1BTSXlNREl6TFRRM0xURTRJREV3T2pRM09qTXpJaXh0YjJScFptbGxaRDBpTWpBeU15MHgKT0Mw
eU1pQXdOVG94T0RveE5TSXNjbVYyYVhOcGIyNDlOMTFkZTJ4aGVXVnlQWHRiTUYwOWUySnRjRDEx
YzJWeVpHRjBZU2dpYVRFMgpJaXd4Tml3eE5pd2lNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3
TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3Ck1EQXdNREF3TURBd01EQXdNREF3
TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXcK
TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdN
REF3TURBd01EQXdNREF3TURBdwpNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdN
REF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3Ck1EQXdNREF3TURBd01EQXdN
REF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01E
QXcKTURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01E
QXdNREF3TURBd01EQXdNREF3TURBdwpNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01E
QXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3Ck1EQXdNREF3TURBd01E
QXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURB
d01EQXcKTURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURB
d01EQXdNREF3TURBd01EQXdNREF3TURBdwpNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURB
d01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3Ck1EQXdNREF3TURB
d01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3
TURBd01EQXcKTURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3
TURBd01EQXdNREF3TURBd01EQXdNREF3TURBdwpNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3
TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3Ck1EQXdNREF3
TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdN
REF3TURBd01EQXcKTURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdN
REF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBdwpNREF3TURBd01EQXdNREF3TURBd01EQXdN
REF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3Ck1EQXdN
REF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01E
QXdNREF3TURBd01EQXcKTURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01E
QXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBdwpNREF3TURBd01DSXBMSEJoYmw5NFBU
QXNjR0Z1WDNrOU1DeHpZMkZzWlQweExIUnBiR1ZmYUQweE5peDBhV3hsWDNjOU1UWjlmWDA9Cjo6
IGRhdC5wb2QKYjY0JExTMWJXM0J2WkN4amNtVmhkR1ZrUFNJeU1ESXpMVEV5TFRFd0lEQTFPakV5
T2pReUlpeHRiMlJwWm1sbFpEMGlNakF5TXkweQpPQzB4TUNBd05Ub3lPRG94TlNJc2NtVjJhWE5w
YjI0OU4xMWRlMlp2YnowaU5pSXNhRzluWlQwaWIydGxlV1J2YTJVaWZRPT0KOjogbWFpbi5sdWEK
LS1bW3BvZF9mb3JtYXQ9InJhdyIsY3JlYXRlZD0iMjAyMy0wMy0zMCAwNTowMzoxMiIsbW9kaWZp
ZWQ9IjIwMjMtMjUtMTggMTE6MjU6MjIiLHJldmlzaW9uPTQ2MTJdXQotLVtbCgoJcGYKCQpdXQoK
bG9jYWwgdG9wX2xhYmVsX21ldGFkYXRhID0gIlttZXRhZGF0YV0iCmxvY2FsIHRvcF9sYWJlbCA9
ICJbY29udGVudF0iCgpsb2NhbCB0ZXh0X2NvbCA9IDYKbG9jYWwgc2Nyb2xsX3kgPSAwCgpsb2Nh
bCBzZWxlY3RlZCA9IC0xCgpsb2NhbCBjb250YWluZXIKbG9jYWwgY29udGVudApsb2NhbCB1bmRv
X3N0YWNrCgotLSB0aGUgcG9kLCBidXQgd3JhcHBlZCBpbiBhIHRhYmxlCi0tIG1lYW5zIGNhbiBy
ZWZlciB0byByb290IGl0ZW1zIHVzaW5nIHAgYXMgcGFyZW50LAotLSBidXQgYWxzbyBjYW4gaGF2
ZSBtZXRhZGF0YSArIGRhdGEgZm9ya3MuCgpwID0gewoJbWV0YWRhdGEgPSB7CgkJdGl0bGUgPSAi
Zm9vIiwKCQlhdXRob3IgPSAiemVwIiwKCQlfc3lzdGVtID0ge19kZXNjPSJhcHAgZGF0YSBnb2Vz
IGhlcmU7IGUuZy4gc2VhcmNoIGJsb29tLCB1bml2ZXJzYWwgZmlsZSBJRCwgbWQ1PyJ9Cgl9LAoJ
Y29udGVudHMgPSB7CgkJY29sb3VycyA9IHsidGhlIiwicXVpY2siLCJicm93biIsImZveCJ9LAoJ
CXRoZW1lID0ge30sCgkJdm9sdW1lID0gMjQsCgkJYXVkaW8gPSB0cnVlLAoJCWZ1bGxzY3JlZW4g
PSBmYWxzZSwKCQl3aW5kb3dfc2NhbGUgPSAyLAoJCWljb24gPSB1c2VyZGF0YSJbZ2Z4XTA4MDg3
NzcwMDAwMDcwNzAwMDAwNzc3MDAwMDAwNzAwNzc3MDA3Nzc3MDcwMDcwMDc3NzAwMDAwMDAwMDAw
MDAwMDAwWy9nZnhdIiwKCQl6c3RyID0gInRoaXMgaXMgYSBzdHJpbmciLAoJCXpzdHIyPSAidGhp
cyBpcyBhIG11bHRpbGluZSBzdHJpbmdcbmxpbmUgMlxubGluZSAzIiwKCQl6c3RyMz0gImFub3Ro
ZXIgc3RyaW5nIiwKCQl6c3RyND0gImFuZCBhbm90aGVyIiwKCX0KfQoKLS0gaGFja3kgbm90ZXRy
ZWUgc2NoZW1lOyBkb2Vzbid0IGhlbHAgbXVjaCB0aG91Z2guCi0tIGRvbid0IHdhbnQgdG8gdHlw
ZSBpbiB0aGUgbnVtYmVycyBtYW51YWxseSEKcDI9ewoJbWV0YWRhdGEgPSB7fSwKCWNvbnRlbnRz
ID0gewoJCVsiMSBUaGUgV29ybGQgaXMgZXZlcnl0aGluZyB0aGF0IGlzIHRoZSBjYXNlIl0gPQoJ
CXsKCQkJWyIxLjEiXSA9ICJmb28iLAoJCQlbIjEuMiJdID0gImJhciIsCgkJfQoJfQp9CgpwMz17
CgltZXRhZGF0YSA9IHt9LAoJY29udGVudHMgPSB7CgkJaG9nZSA9IHsiYSB0YWJsZSBmb3IgdGVz
dGluZyJ9Cgl9Cn0KCmlmIChwLmNvbnRlbnRzLnRoZW1lKSB0aGVuCmZvciBpPTEsNTAgZG8KCWFk
ZChwLmNvbnRlbnRzLnRoZW1lLCAidGhlbWUgIi4uaSkKZW5kCmVuZAoKLS0gdGFibGUgcG9pbnRp
bmcgdG8gZWFjaCBpdGVtLAoKbG9jYWwgcHAgPSB7fSAgICAgICAgICAgICAgICAgICAgICAtLSBw
b2QgcG9pbnRlciAtLSBnZW5lcmF0ZWQgYWxvbmcgd2l0aCBndWkKbG9jYWwgZXhwYW5kID0ge1tw
LmNvbnRlbnRzXT10cnVlfSAtLSB3aGljaCB0YWJsZXMgdG8gZXhwYW5kLiBjb250ZW50cyBzdGFy
dHMgc2hvd24KCgpsb2NhbCBmdW5jdGlvbiBjbG9zZV90ZXh0ZWQoc2F2ZSkKCWlmIChub3QgdGV4
dGVkKSByZXR1cm4KCWlmIChzYXZlKSB0aGVuCgkJZW50ZXJfbmV3X3ZhbHVlKHRhYmxlLmNvbmNh
dCh0ZXh0ZWQ6Z2V0X3RleHQoKSwiXG4iKSkKCWVuZAoJCgllZGl0aW5nX3BhcmVudCA9IG5pbAoJ
dGV4dGVkOmRldGFjaCgpCgl0ZXh0ZWQgPSBmYWxzZQoJd2luZG93e2NhcHR1cmVfZXNjYXBlcyA9
IGZhbHNlfQoJcmVmcmVzaF9ndWkgPSB0cnVlCgllZGl0aW5nX3doaWNoID0gbmlsCgkKZW5kCgoK
bG9jYWwgZnVuY3Rpb24gY29tcChpMCwgaTEpCgoJLS0gdGFibGUgdmFsdWVzIGdvIGZpcnN0IChz
aW1pbGFyIHRvIGZpbGUgbGlzdGluZ3MpCgktLSAoYnV0IG9ubHkgZm9yIG5vbi1udW1iZXIgaW5k
ZXhlcyAtLSBjYW4gaGF2ZSB0YWJsZXMgaW4gYW4gb3JkZXIpCglpZiAodHlwZShpMC52KSA9PSAi
dGFibGUiIGFuZCB0eXBlKGkwLmspICE9ICJudW1iZXIiIGFuZCB0eXBlKGkxLnYpICE9ICJ0YWJs
ZSIpIHJldHVybiB0cnVlCglpZiAodHlwZShpMS52KSA9PSAidGFibGUiIGFuZCB0eXBlKGkxLmsp
ICE9ICJudW1iZXIiIGFuZCB0eXBlKGkwLnYpICE9ICJ0YWJsZSIpIHJldHVybiBmYWxzZQoJCgls
b2NhbCBrMCA9IGkwLmsKCWxvY2FsIGsxID0gaTEuawoJCgktLSBzb3J0IGJ5IGtleSAobm90IHRh
Ymxlcywgb3IgYm90aCB0YWJsZXMpCglpZiAodHlwZShrMCkgIT0gdHlwZShrMSkpIHRoZW4KCQkt
LSBzb3J0IGJ5IGtleSB0eXBlLiBudW1iZXJzIGdvIGxhc3QKCQlpZiAodHlwZShrMCkgPT0gIm51
bWJlciIpIHJldHVybiBmYWxzZQoJCWlmICh0eXBlKGsxKSA9PSAibnVtYmVyIikgcmV0dXJuIHRy
dWUKCQkKCQktLSB1bnVzdWFsIGNhc2U6IGRpZmZlcmVuaW5nIHR5cGVzLCBhbmQgbmVpdGhlciBh
cmUgdGFibGVzIG9yIG51bWJlcnMKCQktLSAtPiBhbHBoYWJldGljYWwgYnkgdHlwZQoJCXJldHVy
biB0eXBlKGswKSA8IHR5cGUoazEpCgllbmQKCQoJcmV0dXJuIGswIDwgazEgLS0gc2FtZSB0eXBl
OiBjYW4gY29tcGFyZSwgSSB0aGluaz8KZW5kCgoKbG9jYWwgZnVuY3Rpb24gZ2V0X2tleV9zdHIo
a2V5LCB2YWwpCglpZiAodHlwZShrZXkpPT0ibnVtYmVyIikgdGhlbiAKCQktLWtleSA9ICJcMDE0
XHxpIi4ua2V5Li4iXHxlXDAxNSIKCQlrZXkgPSAiXF46MDAwMDAwMTgxODAwMDAwMCIKCWVsc2UK
CQlpZiAodHlwZSh2YWwpICE9ICJ0YWJsZSIpIGtleSA9IHRvc3RyKGtleSkuLiI6IgoJZW5kCgkK
CWlmICh2YWwgPT0gcC5tZXRhZGF0YSkga2V5ID0gdG9wX2xhYmVsX21ldGFkYXRhCglpZiAodmFs
ID09IHAuY29udGVudHMpIGtleSA9IHRvcF9sYWJlbAoJCglyZXR1cm4ga2V5CmVuZAoKZnVuY3Rp
b24gZW50ZXJfbmV3X3ZhbHVlKHZhbCkKCglsb2NhbCByZXMgPSB1bmRvX3N0YWNrOmNoZWNrcG9p
bnQoKQoJLS0gcHJpbnRoKCJjaGVja3BvaW50OiAiLi50b3N0cihyZXMpKQoJbG9jYWwgdHlwZTAg
PSB0eXBlKGVkaXRpbmdfcGFyZW50W2VkaXRpbmdfa2V5XSkKCWlmIChlZGl0aW5nX3doaWNoID09
ICJrZXkiKSB0eXBlMCA9IHR5cGUoZWRpdGluZ19rZXkpCgkKCS0tIGtlZXAgbnVtYmVycyBhcyBu
dW1iZXJzCglpZiAodHlwZTAgPT0gIm51bWJlciIpIHRoZW4KCQlsb2NhbCBudW0gPSB0b251bSh2
YWwpCgkJaWYgKG51bSkgdmFsID0gbnVtCgllbmQKCQoJaWYgKGVkaXRpbmdfd2hpY2ggPT0gImtl
eSIpIHRoZW4KCQoJLS0ga2V5IGNoYW5nZWQgLS0_IHNldCBpdAoJaWYgKHZhbCAhPSBlZGl0aW5n
X2tleSkgdGhlbgoJCWlmICh2YWwgPT0gIiIpIHRoZW4KCQkJLS0gaW50IGtleQoJCQllZGl0aW5n
X3BhcmVudFsjZWRpdGluZ19wYXJlbnQrMV0gPSBlZGl0aW5nX3BhcmVudFtlZGl0aW5nX2tleV0K
CQllbHNlCgkJCS0tIHN0cmluZyBrZXkKCQkJZWRpdGluZ19wYXJlbnRbdmFsXSA9IGVkaXRpbmdf
cGFyZW50W2VkaXRpbmdfa2V5XQoJCWVuZAoJCWVkaXRpbmdfcGFyZW50W2VkaXRpbmdfa2V5XSA9
IG5pbAoJZW5kCgkKCWVsc2UKCQoJCWVkaXRpbmdfcGFyZW50W2VkaXRpbmdfa2V5XSA9IHZhbAoK
CWVuZAoJCmVuZAoJCQkJCQoJCgpmdW5jdGlvbiBhZGRfbm9kZShjb250ZW50LCBwYXJlbnQsIGtl
eSwgc3ksIGRlcHRoLCBndWlfbGFiZWwpCgoJLS1wcmludGgoInR5cGUocGFyZW50KSIuLnR5cGUo
cGFyZW50KSkKCQoJbG9jYWwgaXRlbSA9IGFkZChwcCwgewoJCXBhcmVudD1wYXJlbnQsCgkJa2V5
PWtleSwKCQlzeT1zeSwKCQlkZXB0aD1kZXB0aCwKCQlndWlfbGFiZWw9Z3VpX2xhYmVsLAoJfSkK
CQoJbG9jYWwgdmFsID0gcGFyZW50W2tleV0KCQoJLS0gY2FsY3VsYXRlIGl0ZW0gaGVpZ2h0IGJh
c2VkIG9uIGl0ZW0KCWxvY2FsIHN5MCA9IHN5CglfLHN5ID0gcHJpbnQodG9zdHIocGFyZW50W2tl
eV0pLCAxMDAwMDAsIHN5KQoJaXRlbS5oZWlnaHQgPSBzeSAtIHN5MAoJCgoJaWYgKGVkaXRpbmdf
a2V5ID09IGtleSBhbmQgZWRpdGluZ19wYXJlbnQgPT0gcGFyZW50CgkJYW5kIGVkaXRpbmdfd2hp
Y2ggPT0gImtleSIpIHRoZW4KCQktLSBlZGl0IHZhbAoJCQoJCXNlbGVjdGVkID0gI3BwIC0tIGFs
d2F5cyBzZWxlY3QgdGhlIGl0ZW0gYmVpbmcgZWRpdGVkCgkJCgkJbG9jYWwgeHggPSAxMCArIGRl
cHRoICogMTAgLS0gaW5kZW50YXRpb24gY2FsY3VsYXRpb24gZHVwZQoJCWxvY2FsIGtrID0gZ2V0
X2tleV9zdHIoa2V5LCBwYXJlbnRba2V5XSkKCQlsb2NhbCBrdyA9IHByaW50KGtrLDAsLTEwMDAw
KQoJCWxvY2FsIGJ3ID0gdHlwZShwYXJlbnRba2V5XSkgPT0gInRhYmxlIiBhbmQgMjAgb3IgMCAt
LSBidXR0b24gd2lkdGgKCQkKCQlsb2NhbCB4MCA9IHh4ICsgMzAKCQl0ZXh0ZWQgPSBjb250ZW50
OmF0dGFjaF90ZXh0X2VkaXRvcnsKCQkJYmdjb2wgPSAwLAoJCQl4ID0geDAsCgkJCXkgPSBpdGVt
LnN5LTMsIC0tIGZ1ZGdlZCB0byBtYXRjaAoJCQl3aWR0aCA9IGdldF9kaXNwbGF5KCk6d2lkdGgo
KSAtIHgwIC0gMjAsCgkJCWhlaWdodCA9IGl0ZW0uaGVpZ2h0LAoJCQlibG9ja19zY3JvbGxpbmcg
PSB0cnVlLAoJCQlrZXlfY2FsbGJhY2sgPSB7IAoJCQkJZW50ZXIgPSBmdW5jdGlvbiAoKSAKCQkJ
CQktLSBrZWVwIG5ldyB2YWx1ZSBhbmQgY2xvc2UKCQkJCQljbG9zZV90ZXh0ZWQodHJ1ZSkKCQkJ
CWVuZCwKCQkJCWVzY2FwZQkgPSBmdW5jdGlvbigpCgkJCQkJLS0gY2xvc2Ugd2l0aG91dCBrZWVw
aW5nIHZhbHVlCgkJCQkJY2xvc2VfdGV4dGVkKGZhbHNlKQoJCQkJZW5kLAoJCQl9CgkJfQoJCXRl
eHRlZDpzZXRfa2V5Ym9hcmRfZm9jdXModHJ1ZSkKCQl0ZXh0ZWQ6c2V0X3RleHQodG9zdHIoa2V5
KSkKCQl0ZXh0ZWQ6c2V0X2N1cnNvcigxMDAwMCwxKQoJCXRleHRlZDpzZWxlY3RfYWxsKCkKCQl3
aW5kb3d7Y2FwdHVyZV9lc2NhcGVzID0gdHJ1ZX0KCQkKCQlsYXN0X251bV9saW5lcyA9ICN0ZXh0
ZWQ6Z2V0X3RleHQoKQoJCgllbHNlaWYgKGVkaXRpbmdfa2V5ID09IGtleSBhbmQgZWRpdGluZ19w
YXJlbnQgPT0gcGFyZW50KSB0aGVuCgkJLS0gZWRpdCB2YWwKCQkKCQlzZWxlY3RlZCA9ICNwcCAt
LSBhbHdheXMgc2VsZWN0IHRoZSBpdGVtIGJlaW5nIGVkaXRlZAoJCQoJCWxvY2FsIHh4ID0gMTAg
KyBkZXB0aCAqIDEwIC0tIGluZGVudGF0aW9uIGNhbGN1bGF0aW9uIGR1cGUKCQlsb2NhbCBrayA9
IGdldF9rZXlfc3RyKGtleSwgcGFyZW50W2tleV0pCgkJbG9jYWwga3cgPSBwcmludChraywwLC0x
MDAwMCkKCQlsb2NhbCBidyA9IHR5cGUocGFyZW50W2tleV0pID09ICJ0YWJsZSIgYW5kIDIwIG9y
IDAgLS0gYnV0dG9uIHdpZHRoCgkJCgkJbG9jYWwgeDAgPSB4eCArIGJ3ICsga3cgKyAxIC0tIGZ1
ZGdlZCB0byBtYXRjaAoJCXRleHRlZCA9IGNvbnRlbnQ6YXR0YWNoX3RleHRfZWRpdG9yewoJCQli
Z2NvbCA9IDAsCgkJCXggPSB4MCwKCQkJeSA9IGl0ZW0uc3ktMywgLS0gZnVkZ2VkIHRvIG1hdGNo
CgkJCXdpZHRoID0gZ2V0X2Rpc3BsYXkoKTp3aWR0aCgpIC0geDAgLSAyMCwKCQkJaGVpZ2h0ID0g
aXRlbS5oZWlnaHQsCgkJCWJsb2NrX3Njcm9sbGluZyA9IHRydWUsCgkJCWtleV9jYWxsYmFjayA9
IHsgCgkJCQllbnRlciA9IGZ1bmN0aW9uICgpIAoJCQkJCS0tIGhvbGRpbmcgc2hpZnQ6IGxldCBl
ZGl0b3IgaGFuZGxlIHRoZSBlbnRlcgoJCQkJCWlmKGtleSgic2hpZnQiKSkgcmV0dXJuIHRydWUK
CQkJCQkKCQkJCQktLSBrZWVwIG5ldyB2YWx1ZSBhbmQgY2xvc2UKCQkJCQljbG9zZV90ZXh0ZWQo
dHJ1ZSkKCQkJCWVuZCwKCQkJCWVzY2FwZQkgPSBmdW5jdGlvbigpCgkJCQkJLS0gY2xvc2Ugd2l0
aG91dCBrZWVwaW5nIHZhbHVlCgkJCQkJY2xvc2VfdGV4dGVkKGZhbHNlKQoJCQkJZW5kLAoJCQl9
CgkJfQoJCXRleHRlZDpzZXRfa2V5Ym9hcmRfZm9jdXModHJ1ZSkKCQl0ZXh0ZWQ6c2V0X3RleHQo
dG9zdHIodmFsKSkKCQl0ZXh0ZWQ6c2V0X2N1cnNvcigxMDAwMCwxKQoJCXdpbmRvd3tjYXB0dXJl
X2VzY2FwZXMgPSB0cnVlfQoJCQoJCWxhc3RfbnVtX2xpbmVzID0gI3RleHRlZDpnZXRfdGV4dCgp
CgllbmQKCgkKCS0tIG5vIHBhcmVudDogZ3VpIGl0ZW0KCWlmIChub3QgcGFyZW50KSByZXR1cm4g
c3kKCQogICAtLSBkb24ndCBleHBhbmQgcHJldiBlbmNvdW50ZXJlZCB0YWJsZQoJaWYgKGVuY291
bnRlcmVkW3ZhbF0pIHJldHVybiBzeQoJCglpZiAodHlwZSh2YWwpID09ICJ0YWJsZSIgYW5kIGV4
cGFuZFt2YWxdKSB0aGVuCgkJZW5jb3VudGVyZWRbdmFsXSA9IHRydWUKCQkKCQktLSBzb3J0IGNo
aWxkcmVuCgkJbG9jYWwgY2hpbGQgPSB7fQoJCWZvciBrLHYgaW4gcGFpcnModmFsKSBkbwoJCQlh
ZGQoY2hpbGQse2s9ayx2PXZ9KQoJCWVuZAoKCQktLXRhYmxlLnNvcnQoY2hpbGQsIGNvbXApIC0t
IHRvIGRvOiBrZXlzIHNvcnQgcmVwbGFjZW1lbnQKCQkKCQlmb3IgaT0xLCNjaGlsZCBkbwoJCQlz
eSA9IGFkZF9ub2RlKGNvbnRlbnQsIHZhbCwgY2hpbGRbaV0uaywgc3ksIGRlcHRoKzEpCgkJZW5k
CgkJCgkJLS0gc2hvdyB3aGVuIHRhYmxlIGlzIGVtcHR5IChbK10gbmVlZHMgdG8gc29tZXRoaW5n
IHRvIGV4cGFuZCEpCgkJaWYgKCNjaGlsZCA9PSAwKSB0aGVuCgkJCXN5ID0gYWRkX25vZGUoY29u
dGVudCwgdmFsLG5pbCxzeSxkZXB0aCsxLCJ7ZW1wdHl9IikKCQllbmQKCWVuZAoJCglyZXR1cm4g
c3kKZW5kCgoKZnVuY3Rpb24gY3JlYXRlX3BvZF9lZGl0b3IocGFyZW50LCBlbCkKCgktLSBpcyBs
b2NhbCB0byBmaWxlCgljb250YWluZXIgPSBwYXJlbnQ6YXR0YWNoKGVsKQoJCgktLSBuZWVkcyBh
IGRyYXcgZnVuY3Rpb24gaW4gb3JkZXIgdG8gY2xpcAoJZnVuY3Rpb24gY29udGFpbmVyOmRyYXco
KQoJZW5kCgoJLS0gaXMgbG9jYWwgdG8gZmlsZQoJY29udGVudCA9IGNvbnRhaW5lcjphdHRhY2h7
CgkJeD0wLHk9MCwKCQl3aWR0aD1jb250YWluZXIud2lkdGgsCgkJaGVpZ2h0PWNvbnRhaW5lci5o
ZWlnaHQgLS0gd2lsbCBiZSB1cGRhdGVkIGJ5IGdlbmVyYXRlX3BwCgl9CgkKCQoJY29udGFpbmVy
OmF0dGFjaF9zY3JvbGxiYXJzKCkKCQoKCWxvY2FsIGZ1bmN0aW9uIGdlbmVyYXRlX3BwKCkKCQkt
LSBjbG9zZSBhbnkgYWN0aXZlIGVkaXRvcgoJCWlmICh0ZXh0ZWQpIHRleHRlZDpkZXRhY2goKQoJ
CQoJCS0tIGdlbmVyYXRlIGZyb20gc2NyYXRjaCBlYWNoIHRpbWUKCQlwcCA9IHt9CgkJZW5jb3Vu
dGVyZWQgPSB7fSAKCQlwcF9oZWlnaHQgPSBhZGRfbm9kZShjb250ZW50LCBwLCAibWV0YWRhdGEi
LCA3LCAwKQoJCXBwX2hlaWdodCA9IGFkZF9ub2RlKGNvbnRlbnQsIHAsICJjb250ZW50cyIsIHBw
X2hlaWdodCwgMCkKCQoJCS0tIG1pZ2h0IGJlIHJlZ2VuZXJhdGluZyB3aXRob3V0IHJlZnJlc2hp
bmcgZ3VpCgkJaWYgKGNvbnRlbnQpIHRoZW4KCQkJY29udGVudC5oZWlnaHQgPSBtYXgocHBfaGVp
Z2h0ICsgMjAsIGNvbnRhaW5lci5oZWlnaHQpCgkJZW5kCgkKCWVuZAoJCgoJZnVuY3Rpb24gY29u
dGVudDpkcmF3KCkKCQlyZWN0ZmlsbCgwLCAwLCBzZWxmLndpZHRoLTEsIHNlbGYuaGVpZ2h0LTEs
IDEpCgkJCgkJbG9jYWwgc3kgPSAxMAoJCWxvY2FsIGl0ZW1faCA9IDEyCgkJCgkJLS0gdG8gZG86
IHVzZSB5IHRvIHJlbmRlciBvbmx5IG5lZWRlZCBpdGVtcwoJCWZvciBpPTEsI3BwIGRvCgkJCgkJ
CWxvY2FsIGl0ZW0gPSBwcFtpXQoJCQlsb2NhbCBzeCA9IDEwICsgaXRlbS5kZXB0aCAqIDEwCgkJ
CS0tbG9jYWwgc3kgPSAxMCArIChpdGVtLnkgb3IgMCkgIC0tIHkKCQkJbG9jYWwgc3kgPSBpdGVt
LnN5CgkJCQoJCQlsb2NhbCBrZXkgPSBpdGVtLmtleQoJCQlsb2NhbCBwYXJlbnQgPSBpdGVtLnBh
cmVudAoJCQkKCQkJaWYgaSA9PSBzZWxlY3RlZCBhbmQgbm90IGVkaXRpbmdfcGFyZW50IHRoZW4K
CQkJCXJlY3RmaWxsKDAsc3ktMiw0ODAsc3kraXRlbS5oZWlnaHQtMywyKQoJCQllbmQKCQkJCgkJ
CS0tIG1lc3N5OiB1c2UgdGhpcyBsb29wIGZvciBjYWxjdWxhdGluZyBkcmF3biB5IHRvbwoJCQkt
LSB1c2UgZm9yIHBvc2l0aW9uaW5nIGN1cnNvciAvIHRleHQgYm94CgkJCS0taXRlbS5zeSA9IHN5
CgkJCWxvY2FsIHN5ID0gaXRlbS5zeSAKCQkJCgkJCWlmIGl0ZW0uZ3VpX2xhYmVsIHRoZW4KCQkJ
CS0tIGd1aSBsaW5lIChhZGQgaXRlbSkKCQkJCXByaW50KGl0ZW0uZ3VpX2xhYmVsLCBzeCwgc3ks
IDEzKQoJCQkKCQkJZWxzZWlmIGVkaXRpbmdfa2V5ID09IGtleSBhbmQgZWRpdGluZ19wYXJlbnQg
PT0gcGFyZW50IHRoZW4KCQkJCQoJCQkJaWYgKGVkaXRpbmdfd2hpY2ggPT0gImtleSIpIHRoZW4K
CQkJCQlwcmludCgia2V5OiIsIHN4LCBzeSwgMTMpCgkJCQllbHNlCgkJCQkJLS0gZWRpdGluZyBh
IHZhbHVlCgkJCQkJbG9jYWwgbGFiZWwgPSBnZXRfa2V5X3N0cihrZXkpCgkJCQkJcHJpbnQoIlxm
ZSIuLmxhYmVsLi4iIFxmNiIsIHN4LCBzeSwgdGV4dF9jb2wpCgkJCQllbmQKCQkJCQoJCQllbHNl
CgkJCQktLSB2YWx1ZQkKCQkJCWxvY2FsIHZhbCA9IHBhcmVudFtrZXldCgkJCQlpZiAodHlwZSh2
YWwpID09ICJ0YWJsZSIpIHRoZW4KCQkJCQlsb2NhbCBsYWJlbCA9IGdldF9rZXlfc3RyKGtleSx2
YWwpCgkJCQkJCgkJCQkJcHJpbnQoKGV4cGFuZFt2YWxdIGFuZCAiWy1dICIgb3IgIlsrXSAiKS4u
bGFiZWwsIHN4LCBzeSwgdGV4dF9jb2wpCgkJCQllbHNlCgkJCQkJbG9jYWwgbGFiZWwgPSBnZXRf
a2V5X3N0cihrZXkpLi4iICIKCQkJCQlsb2NhbCBjb2wgPSAiXGY2IgoJCQkJCWlmICh0eXBlKHZh
bCkgIT0gInN0cmluZyIpIGNvbCA9ICJcZmMiCgkJCQkJbG9jYWwgeHggPSBwcmludCgiXGZlIi4u
bGFiZWwsc3gsc3ksdGV4dF9jb2wpCgkJCQkJcHJpbnQoY29sLi50b3N0cih2YWwpLCB4eCwgc3ks
IHRleHRfY29sKQoJCQkJCQoJCQkJZW5kCgkJCWVuZAoJCWVuZAoJCQoJZW5kCgkKCWZ1bmN0aW9u
IGNvbnRlbnQ6dGFwKG1zZykKCQktLWxvY2FsIGkgPSAxICsgeSBcIDEyCgkJCgkJY2xvc2VfdGV4
dGVkKHRydWUpCgkJCgkJbG9jYWwgaSA9IDEKCQl3aGlsZSAoaSA8ICNwcCBhbmQgbXNnLm15ID49
IHBwW2ldLnN5ICsgcHBbaV0uaGVpZ2h0KSBkbwoJCQlpICs9IDEKCQllbmQKCQkKCQlpZiAoaSA8
IDEgb3IgaSA_ICNwcCkgcmV0dXJuCgkJCgkJbG9jYWwgc2VsZWN0ZWQwID0gc2VsZWN0ZWQKCQlz
ZWxlY3RlZCA9IGkJCgkJLS1wcmludGgoInNlbGVjdGVkOiAiLi5zZWxlY3RlZCkKCgkJbG9jYWwg
aXRlbSA9IHBwW2ldCgkJbG9jYWwga2V5ID0gaXRlbS5rZXkKCQlsb2NhbCBwYXJlbnQgPSBpdGVt
LnBhcmVudAoJCQkKCQktLSBidXR0b24gKG5vdCBjdXJyZW50bHkgdXNlZCkKCQlpZiAoaXRlbS5n
dWlfbGFiZWwpIHRoZW4KCQkJaWYgKGl0ZW0uZ3VpX2xhYmVsID09ICJbbmV3XSIpIHRoZW4KCQkJ
CWFkZChwYXJlbnQsICJuZXcgaXRlbSBzdHJpbmciKQoJCQkJcmVmcmVzaF9ndWkgPSB0cnVlCgkJ
CQkKCQkJZW5kCgkJCXJldHVybgoJCWVuZAoJCQoJCS0tIGV4cGFuZCB0YWJsZQoJCQoJCS0tIGNs
aWNrIG9uIGl0ZW0gdG8gZXhwYW5kIC8gZWRpdAoJCWxvY2FsIHZhbCA9IHBhcmVudFtrZXldCgkJ
CgkJbG9jYWwgeHggPSAxMCArIGl0ZW0uZGVwdGggKiAxMCAtLSBpbmRlbnRhdGlvbiBjYWxjdWxh
dGlvbiBkdXBlCgkJbG9jYWwga2sgPSBnZXRfa2V5X3N0cihrZXksIHZhbCkKCQlsb2NhbCBrdyA9
IHByaW50KGtrLDAsLTEwMDAwKQoJCWxvY2FsIGJ3ID0gdHlwZSh2YWwpID09ICJ0YWJsZSIgYW5k
IDIwIG9yIDAgLS0gYnV0dG9uIHdpZHRoCgkJCgkJaWYgKHR5cGUodmFsKSA9PSAidGFibGUiIGFu
ZCBtc2cubXggPCB4eCArIGJ3KSB0aGVuCgkJCWV4cGFuZFt2YWxdID0gbm90IGV4cGFuZFt2YWxd
CgkJCXJlZnJlc2hfZ3VpID0gdHJ1ZQoJCWVsc2VpZiBtc2cubXggPCB4eCArIGJ3ICsga3cgdGhl
bgoJCQktLSBlZGl0IGtleQoJCQlpZiAoc2VsZWN0ZWQwID09IGkgb3IgbXNnLmxhc3RfbWIgPiAx
KSBlZGl0X3BwX2tleShpdGVtKQoJCWVsc2UKCQkJLS0gZWRpdCB2YWx1ZSAtLSBpZiBhbHJlYWR5
IHNlbGVjdGVkIAoJCQktLSB0byBkbzogcmlnaHQgY2xpY2sgZm9yIGNvbnRleHQgbWVudT8KCQkJ
aWYgKHNlbGVjdGVkMCA9PSBpIG9yIG1zZy5sYXN0X21iID4gMSkgZWRpdF9wcF92YWx1ZShpKQoJ
CWVuZAoJCQoJZW5kCgkKCS0tIHNvIHRoYXQgY2FuIGRvdWJsZSBjbGljayBvbiBhbiBpdGVtIHRv
IGVkaXQgaXQKCS0tIChvdGhlcndpc2Ugc2Vjb25kIHRhcCB3b24ndCBjb3VudCkKCS0tIHRvIGRv
OiByZXZpZXcgKiogbWF5YmUgYSBwcm9ibGVtIHdpdGggZXZlbnQgYmVoYXZpb3VyICoqCgktLSBj
b250ZW50LmRvdWJsZWNsaWNrID0gY29udGVudC50YXAKCQoKCS0tIGhycm0uLiBjb3VsZCBiZSBh
dXRvbWF0ZWQgYnkgYXR0YWNoX3Njcm9sbGJhcnMsIGJ1dCBzb21lIGN1c3RvbQoJLS0gbG9naWMg
aW4gdGV4dCBlZGl0b3IgdmVyc2lvbgoJZnVuY3Rpb24gY29udGVudDpjbGFtcF9zY3JvbGxpbmco
KQoJCWxvY2FsIG1heF95ID0gbWF4KDAsIGNvbnRlbnQuaGVpZ2h0IC0gY29udGFpbmVyLmhlaWdo
dCkKCQljb250ZW50LnkgPSBtaWQoMCwgY29udGVudC55LCAtbWF4X3kpCgkJY29udGVudC54ID0g
bWluKDAsIGNvbnRlbnQueCkKCWVuZAoJZnVuY3Rpb24gY29udGVudDp1cGRhdGUoKQoKCQlsb2Nh
bCBzZWxlY3RlZF8wID0gc2VsZWN0ZWQKCQlpZiAobm90IGVkaXRpbmdfcGFyZW50KSB0aGVuCgkJ
CWlmIChrZXlwKCJ1cCIpKSBzZWxlY3RlZCA9IG1pZCgxLCBzZWxlY3RlZCAtIDEsICNwcCkKCQkJ
aWYgKGtleXAoImRvd24iKSkgIHNlbGVjdGVkID0gbWlkKDEsIHNlbGVjdGVkICsgMSwgI3BwKQoJ
CWVuZAoJCQoJCWlmIChzZWxlY3RlZCAhPSBzZWxlY3RlZF8wIGFuZCBjb250ZW50KSB0aGVuCgkJ
CWNvbnRlbnQueSA9IG1pZCgtcHBbc2VsZWN0ZWRdLnN5LTYsIGNvbnRlbnQueSwgCgkJCQktcHBb
c2VsZWN0ZWRdLnN5K2NvbnRhaW5lci5oZWlnaHQtMjIpCgkJZW5kCgkKCQljb250ZW50OmNsYW1w
X3Njcm9sbGluZygpCgllbmQKCQoJZnVuY3Rpb24gY29udGFpbmVyOm1vdXNld2hlZWwobXNnKQoJ
CWlmIChrZXkoImN0cmwiKSkgdGhlbgoJCQljb250ZW50LnggKz0gbXNnLndoZWVsX3kgKiAzMiAK
CQllbHNlCgkJCWNvbnRlbnQueSArPSBtc2cud2hlZWxfeSAqIDMyIAoJCWVuZAoJZW5kCgkKCWdl
bmVyYXRlX3BwKCkKCgktLSByZXR1cm4gaW5uZXIgdGhpbmcgLS0gc2FtZSBhcyBjb2RlIGVkaXRv
cgoJcmV0dXJuIGNvbnRlbnQKZW5kCgoKZnVuY3Rpb24gZ2VuZXJhdGVfZ3VpKCkKCWd1aV93ID0g
Z2V0X2Rpc3BsYXkoKTp3aWR0aCgpCglndWlfaCA9IGdldF9kaXNwbGF5KCk6aGVpZ2h0KCkKCQoJ
Z3VpID0gY3JlYXRlX2d1aSgpCgkKCXBlID0gY3JlYXRlX3BvZF9lZGl0b3IoZ3VpLCB7CgkJeD0w
LHk9MCx3aWR0aD1ndWlfdyxoZWlnaHQ9Z3VpX2gKCX0pCgkKCXBlLnkgPSBzY3JvbGxfeQoJCgkt
LSBiYXNlZCBzdGFydGluZyBjdXJzb3IgcG9zaXRpb24gaW4gdGV4dCBlZGl0b3IgKGlmIGl0IGV4
aXN0cykKCS0tIG9uIG1vdXNlIHBvc2l0aW9uLgoJaWYgKHRleHRlZCkgdGV4dGVkOnNldF9jdXJz
b3IoKQoJCgkKZW5kCgotLSBzdG9yZSBleHBhbmRbXSBpbiBhIHdheSB0aGF0IGNhbiBiZSBzdG9y
ZWQgd2l0aG91dAotLSByZWZlcmVuY2luZyB0aGUgbm9kZXMgaW4gcCBkaXJlY3RseSAoZm9yIHVu
ZG9pbmcpCgpmdW5jdGlvbiBzdG9yZV9leHBhbmRfZGF0YShwKQoJLS0gdHJhdmVyc2UgdHJlZSBp
biBvcmRlcgoJbG9jYWwgZXhwID0ge30KCWxvY2FsIGZ1bmN0aW9uIGFkZF9ub2RlKG4pCgkJaWYg
KHR5cGUobikgIT0gInRhYmxlIikgcmV0dXJuCgkJbG9jYWwgb3V0ID0ge19fZXhwYW5kID0gZXhw
YW5kW25dfQoJCWZvciBrLHYgaW4gcGFpcnMobikgZG8KCQkJaWYgKHR5cGUodikgPT0gInRhYmxl
Iikgb3V0W2tdID0gYWRkX25vZGUodikKCQllbmQKCQlyZXR1cm4gb3V0CgllbmQKCXJldHVybiBh
ZGRfbm9kZShwKQplbmQKCmZ1bmN0aW9uIHJlc3RvcmVfZXhwYW5kX2RhdGEocCwgZGF0KQoJZXhw
YW5kID0ge30KCS0tcHJpbnRoKCJAQCBleHBhbmRpbmcgZnJvbTogIi4ucG9kKGRhdCkpCgktLSBy
ZXN0b3JlIHBvZCBub2RlIHBub2RlIGZyb20gbm9kZSBpbiBkYXRhIGRub2RlCglsb2NhbCBmdW5j
dGlvbiByZXN0b3JlX25vZGUocG5vZGUsIGRub2RlKSAKCQlpZiAodHlwZShkbm9kZSkgIT0gInRh
YmxlIikgcmV0dXJuCgkJaWYgKGRub2RlLl9fZXhwYW5kKSBleHBhbmRbcG5vZGVdID0gdHJ1ZQoJ
CWZvciBrLHYgaW4gcGFpcnMoZG5vZGUpIGRvCgkJCXJlc3RvcmVfbm9kZShwbm9kZVtrXSwgZG5v
ZGVba10pCgkJZW5kCgllbmQKCXJlc3RvcmVfbm9kZShwLCBkYXQpCmVuZAoKZnVuY3Rpb24gc2F2
ZV93b3JraW5nX2ZpbGUoKQoJc3RvcmUoY3VycmVudF9maWxlbmFtZSwgcC5jb250ZW50cywgcC5t
ZXRhZGF0YSkKCXByaW50aCgic3RvcmluZyBtZXRhZGF0YTogIi4ucG9kKHAubWV0YWRhdGEpKQoJ
bG9jYWwgZSA9IHN0b3JlX2V4cGFuZF9kYXRhKHApCglsb2FkX3dvcmtpbmdfZmlsZShjdXJyZW50
X2ZpbGVuYW1lKSAtLSB1cGRhdGUgbWV0YWRhdGEhCglyZXN0b3JlX2V4cGFuZF9kYXRhKHAsIGUp
Cglub3RpZnkoInNhdmVkICIuLmN1cnJlbnRfZmlsZW5hbWUpCmVuZAoKCmZ1bmN0aW9uIGxvYWRf
d29ya2luZ19maWxlKGZpbGVuYW1lKQoJCglwcmludGgoImxvYWRfd29ya2luZ19maWxlOiAiLi5m
aWxlbmFtZS4uIiAgcmVzb2x2ZXMgYXM6Ii4uZnVsbHBhdGgoZmlsZW5hbWUpKQoKCWN1cnJlbnRf
ZmlsZW5hbWUgPSBmaWxlbmFtZQoJbG9jYWwgZGF0LCBtZXRhID0gZmV0Y2goZmlsZW5hbWUpCglp
ZiAoZGF0KSB0aGVuCgkJcCA9IHsKCQkJbWV0YWRhdGEgPSBtZXRhLAoJCQljb250ZW50cyA9IGRh
dAoJCX0KCWVsc2UKCQlwID0gewoJCQltZXRhZGF0YSA9IHt9LAoJCQljb250ZW50cyA9IHt9CgkJ
fQoJZW5kCgkKCWV4cGFuZCA9IHtbcC5jb250ZW50c109dHJ1ZX0KZW5kCgpmdW5jdGlvbiBfaW5p
dCgpCgoJcG9rZSgweDQwMDAsZ2V0KGZldGNoKCIvc3lzdGVtL2ZvbnRzL2xpbC5mb250IikpKSAt
LSB2YXJpYWJsZSB3aWR0aAoJcG9rZSgweDU2MDAsZ2V0KGZldGNoKCIvc3lzdGVtL2ZvbnRzL3A4
LmZvbnQiKSkpICAtLSBmb3IgdGlueSBudW1iZXJzCgkKCXVuZG9fc3RhY2sgPSBjcmVhdGVfdW5k
b19zdGFjaygKCQlmdW5jdGlvbigpIAoJCXJldHVybiB7CgkJCXBvZChwKSwKCQkJc2VsZWN0ZWQs
CgkJCXN0b3JlX2V4cGFuZF9kYXRhKHApLAoJCX0gCgkJZW5kLAoJCQoJCWZ1bmN0aW9uKHMpCgkJ
CXAgPSB1bnBvZChzWzFdKQoJCQlzZWxlY3RlZCA9IHNbMl0KCQkJcmVzdG9yZV9leHBhbmRfZGF0
YShwLCBzWzNdKQoJCQktLSBzaG93X2N1cnNvcigpCgkJZW5kCgkpCgkKCWNkKGVudigpLnBhdGgp
CgkKCS0tIGdldF9maWxlbmFtZV9mcm9tX2FyZ3MgbG9naWMKCS0tIGNhbid0IHVzZSB3cmFuZ2xl
X3dvcmtpbmdfZmlsZSBiZWNhdXNlIG5lZWQgdG8gYWxzbyBtYW5hZ2UgbWV0YWRhdGEKCWxvY2Fs
IGZuID0gKGVudigpLmFyZ3YgYW5kIGVudigpLmFyZ3ZbMV0pIG9yICJ1bnRpdGxlZC5wb2QiCglm
biA9IGZ1bGxwYXRoKGZuKQkKCWN1cnJlbnRfZmlsZW5hbWUgPSBmdWxscGF0aChmbikKCQoJbG9h
ZF93b3JraW5nX2ZpbGUoY3VycmVudF9maWxlbmFtZSkKCQoJd2luZG93ewoJCXdpZHRoPTIwMCwK
CQloZWlnaHQ9MjAwLAoJCXVzZXJkYXRhIltnZnhdMDgwODc3NzAwMDAwNzA3MDAwMDA3NzcwMDAw
MDA3MDA3NzcwMDc3NzcwNzAwNzAwNzc3MDAwMDAwMDAwMDAwMDAwMDBbL2dmeF0iCgl9CgkKCglt
ZW51aXRlbXsKCQlpZCA9ICJvcGVuX2ZpbGUiLAoJCWxhYmVsID0gIlxeOjdmNDE0MTQxN2Y2MTY1
MDAgT3BlbiBGaWxlIiwKCQlzaG9ydGN1dCA9ICJDVFJMLU8iLCAtLSBjdHJsLXMgaXMgaGFuZGxl
ZCBieSB3aW5kb3cgbWFuYWdlcgoJCWFjdGlvbiA9IGZ1bmN0aW9uKCkgCgkJCWNyZWF0ZV9wcm9j
ZXNzKCIvc3lzdGVtL2FwcHMvZmlsZW5hdi5wNjQiLCB7d2luZG93X2F0dHJpYnM9e3dvcmtzcGFj
ZSA9ICJjdXJyZW50In19KQoJCWVuZAoJfQoKCW1lbnVpdGVtewoJCWlkID0gInNhdmVfZmlsZSIs
CgkJbGFiZWwgPSAiXF46N2Y0MTQxNDE3ZjYxNjUwMCBTYXZlIEZpbGUiLAoJCXNob3J0Y3V0ID0g
IkNUUkwtUyIsIC0tIGN0cmwtcyBpcyBoYW5kbGVkIGJ5IHdpbmRvdyBtYW5hZ2VyCgkJYWN0aW9u
ID0gZnVuY3Rpb24oKSAKCQkJc2F2ZV93b3JraW5nX2ZpbGUoKQoJCQlub3RpZnkoInNhdmVkICIu
LmN1cnJlbnRfZmlsZW5hbWUpCgkJCXJlZnJlc2hfZ3VpID0gdHJ1ZQoJCQktLXNlbmRfbWVzc2Fn
ZShwaWQoKSwge2V2ZW50ID0gInNhdmVfd29ya2luZ19maWxlIn0pCgkJZW5kCgl9CgoJCmVuZAoK
CmZ1bmN0aW9uIF9kcmF3KCkKCWNscyg1KQoJCglndWk6ZHJhd19hbGwoKQoJCmVuZAoKZnVuY3Rp
b24gZWRpdF9wcF9rZXkoaXRlbSkKCWxvY2FsIHBhcmVudCA9IGl0ZW0ucGFyZW50Cglsb2NhbCBr
ZXkgPSBpdGVtLmtleQoJCgllZGl0aW5nX3BhcmVudCA9IHBhcmVudAoJZWRpdGluZ19rZXkgICAg
PSBrZXkKCWVkaXRpbmdfd2hpY2ggID0gImtleSIKCQkKCXJlZnJlc2hfZ3VpID0gdHJ1ZQplbmQK
CmZ1bmN0aW9uIGVkaXRfcHBfdmFsdWUoaSwgaykKCWxvY2FsIGl0ZW0gPSBwcFtpXQoJbG9jYWwg
cGFyZW50ID0gaXRlbS5wYXJlbnQKCWxvY2FsIGtleSA9IGl0ZW0ua2V5CgkKCQoJCgktLSBleHBh
bmQgLyBjb2xsYXBzZSB0YWJsZQoJaWYgKHR5cGUocGFyZW50W2tleV0pID09ICJ0YWJsZSIpIHRo
ZW4KCQlleHBhbmRbcGFyZW50W2tleV1dID0gbm90IGV4cGFuZFtwYXJlbnRba2V5XV0KCQlyZWZy
ZXNoX2d1aSA9IHRydWUKCQlyZXR1cm4KCWVuZAoJCgktLSB0b2dnbGUgYm9vbGVhbgoJaWYgKHR5
cGUocGFyZW50W2tleV0pID09ICJib29sZWFuIikgdGhlbgoJCXBhcmVudFtrZXldID0gbm90IHBh
cmVudFtrZXldCgkJcmV0dXJuCgllbmQKCQoJaWYgKHR5cGUocGFyZW50W2tleV0pID09ICJudW1i
ZXIiIGFuZCAoaz09ImxlZnQiIG9yIGs9PSJyaWdodCIpKSB0aGVuCgkJaWYgKGs9PSJsZWZ0Iikg
cGFyZW50W2tleV0gLT0gMQoJCWlmIChrPT0icmlnaHQiKSBwYXJlbnRba2V5XSArPSAxCgkJcmV0
dXJuCgllbmQKCQoJLS0gdXNlcmRhdGEgLS0gY2FuJ3QgZWRpdCB5ZXQKCWlmICh0eXBlKHBhcmVu
dFtrZXldKSA9PSAidXNlcmRhdGEiKSB0aGVuCgkJcmV0dXJuCgllbmQKCQoJZWRpdGluZ19wYXJl
bnQgPSBwYXJlbnQKCWVkaXRpbmdfa2V5ICAgID0ga2V5CgllZGl0aW5nX3doaWNoICA9ICJ2YWx1
ZSIKCWVkaXRpbmdfaW5kZXggID0gaQoJcmVmcmVzaF9ndWkgPSB0cnVlCgkKZW5kCgoKZnVuY3Rp
b24gdXBkYXRlX3RleHRlZCgpCglpZiAobm90IHRleHRlZCkgcmV0dXJuCgkKCQlsb2NhbCBudW1f
bGluZXMgPSAjdGV4dGVkOmdldF90ZXh0KCkKCQlpZiAobnVtX2xpbmVzICE9IGxhc3RfbnVtX2xp
bmVzKSB0aGVuCgkJCgkJCS0tIHJlc2l6ZSAod2l0aG91dCByZWZyZXNoaW5nIGd1aSkKCQkJbG9j
YWwgaGgwID0gdGV4dGVkLnBhcmVudC5oZWlnaHQKCQkJbG9jYWwgaGggCgkJCV8saGggPSBwcmlu
dCh0YWJsZS5jb25jYXQodGV4dGVkOmdldF90ZXh0KCksIlxuIiksIDEwMDAwMCwgMCkKCQkJbG9j
YWwgZGggPSBoaCAtIGhoMAoJCQkKCQkJLS0gdXBkYXRlIGhlaWdodCBvZiB0ZXh0IGVkaXRvciBi
b3gKCQkJdGV4dGVkLmhlaWdodCArPSBkaAoJCQl0ZXh0ZWQucGFyZW50LmhlaWdodCArPSBkaAoJ
CQlwcF9oZWlnaHQgKz0gZGgKCQkJaWYgKGNvbnRlbnQpIHRoZW4KCQkJCWNvbnRlbnQuaGVpZ2h0
ID0gbWF4KHBwX2hlaWdodCArIDIwLCBjb250YWluZXIuaGVpZ2h0KQoJCQllbmQKCQkJCgkJCS0t
IHVwZGF0ZSBwb3NpdGlvbnMgb2YgaXRlbXMgYmVsb3cgdGhpcyBvbmUKCQkJcHBbZWRpdGluZ19p
bmRleF0uaGVpZ2h0ICs9IGRoCgkJCWZvciBpPWVkaXRpbmdfaW5kZXgrMSwgI3BwIGRvCgkJCQlw
cFtpXS5zeSArPSBkaAoJCQllbmQKCQkJCgkJZW5kCgkJbGFzdF9udW1fbGluZXMgPSBudW1fbGlu
ZXMKCQkKZW5kCgpmdW5jdGlvbiBuZXdfaXRlbShwcmVmaXgsIG5ld3ZhbCwgZGluZGV4KQoJdW5k
b19zdGFjazpjaGVja3BvaW50KCkKCWRpbmRleCA9IGRpbmRleCBvciAwCglsb2NhbCBpdGVtID0g
cHBbc2VsZWN0ZWRdCgkJbG9jYWwgcGFyZW50ID0gaXRlbS5wYXJlbnRbaXRlbS5rZXldCgkJbG9j
YWwgaW5kZXggPSBuaWwKCQkKCQktLSBsZWFmIG9yIHVuZXhwYW5kZWQgdGFibGUgLT4gb3BlcmF0
ZSBvbiBwYXJlbnQKCQlpZiAodHlwZShwYXJlbnQpICE9ICJ0YWJsZSIgb3Igbm90IGV4cGFuZFtw
YXJlbnRdKSB0aGVuCgkJCXBhcmVudCA9IGl0ZW0ucGFyZW50IAoJCQlpZiAodHlwZShpdGVtLmtl
eSkgPT0gIm51bWJlciIpIGluZGV4ID0gaXRlbS5rZXkgKyBkaW5kZXgKCQllbmQKCQkKCQlpZiAo
dHlwZShpbmRleCkgPT0gIm51bWJlciIpIHRoZW4KCQkJYWRkKHBhcmVudCwgbmV3dmFsLCBpbmRl
eCkKCQkJLS0gZWRpdCBzdHJhaWdodCBhd2F5ICh3aGVuIG5vdCBhIHRhYmxlKQoJCQlpZiAodHlw
ZShuZXd2YWwpICE9ICJ0YWJsZSIpIHRoZW4KCQkJCWVkaXRpbmdfcGFyZW50ID0gcGFyZW50CgkJ
CQllZGl0aW5nX2tleSA9IGluZGV4CgkJCWVuZAoJCWVsc2UKCQkJLS0gbmV3IHN0cmluZyBrZXkK
CQkJbG9jYWwga2V5aSA9IDAKCQkJbG9jYWwga2V5ID0gcHJlZml4Li5rZXlpCgkJCXdoaWxlIHR5
cGUocGFyZW50W2tleV0pICE9ICJuaWwiIGRvCgkJCQlrZXlpICs9IDEKCQkJCWtleSA9IHByZWZp
eC4ua2V5aQoJCQllbmQKCQkJcGFyZW50W2tleV0gPSBuZXd2YWwKCQkJLS0gZWRpdCBpdAoJCQll
ZGl0aW5nX3BhcmVudCA9IHBhcmVudAoJCQllZGl0aW5nX2tleSA9IGtleQoJCQllZGl0aW5nX3do
aWNoID0gImtleSIKCQllbmQKCQkKCQlleHBhbmRbcGFyZW50XSA9IHRydWUgLS0gbWFrZSBzdXJl
IGl0cyB2aXNpYmxlCgkJcmVmcmVzaF9ndWkgPSB0cnVlCmVuZAoKLS1bWwoJImZhbHNlIiA8LS0_
IGZhbHNlCgkiMy41IiAgIDwtLT4gMy41CgkiIiAgICAgIDwtLT4ge30KXV0KZnVuY3Rpb24gdG9n
Z2xlX3R5cGUoKQoJdW5kb19zdGFjazpjaGVja3BvaW50KCkKCWxvY2FsIGl0ZW0gPSBwcFtzZWxl
Y3RlZF0KCWxvY2FsIHBhcmVudCA9IGl0ZW0ucGFyZW50Cglsb2NhbCBrZXkgICAgPSBpdGVtLmtl
eQoJbG9jYWwgdmFsICAgID0gcGFyZW50W2tleV0KCQoJdHlwZTAgPSB0eXBlKHZhbCkKCWlmICh0
eXBlMCA9PSAic3RyaW5nIikgdGhlbgoJCWxvY2FsIG51bSA9IHRvbnVtKHR5cGUwKQoJCWlmICAg
ICB2YWwgPT0gImZhbHNlIiB0aGVuIHBhcmVudFtrZXldID0gZmFsc2UKCQllbHNlaWYgdmFsID09
ICJ0cnVlIiAgdGhlbiBwYXJlbnRba2V5XSA9IHRydWUKCQllbHNlaWYgdmFsID09ICIiICAgICAg
dGhlbiBwYXJlbnRba2V5XSA9IHt9CgkJZWxzZWlmIG51bSAgICAgICAgICAgIHRoZW4gcGFyZW50
W2tleV0gPSBudW0KCQllbmQKCQkKCWVsc2VpZiAodHlwZTAgPT0gImJvb2xlYW4iIG9yIHR5cGUw
ID09ICJudW1iZXIiKSB0aGVuCgkJcGFyZW50W2tleV0gPSB0b3N0cihwYXJlbnRba2V5XSkKCWVs
c2VpZiAodHlwZTAgPT0gInRhYmxlIikgdGhlbgoJCXBhcmVudFtrZXldID0gIiIKCWVuZAoJCmVu
ZAoKCmZ1bmN0aW9uIHVwZGF0ZV9rYmQoKQoKCS0tIHdoZW4gZWRpdGluZyB0ZXh0LCBsZXQgYWxs
IGtleWJvYXJkIGV2ZW50cyBnbyB0aGVyZQoJaWYgKHRleHRlZCkgcmV0dXJuCgkKCS0tIGRlbGV0
ZSBhdCBwb3MKCWlmIChrZXlwKCJkZWwiKSkgdGhlbgoJCXVuZG9fc3RhY2s6Y2hlY2twb2ludCgp
CgkJbG9jYWwgaXRlbSA9IHBwW3NlbGVjdGVkXQoJCWl0ZW0ucGFyZW50W2l0ZW0ua2V5XSA9IG5p
bAoJCXJlZnJlc2hfZ3VpID0gdHJ1ZQoJZW5kCgkKCS0tIGluc2VydCBhdCBwb3MKCWlmIChrZXlw
KCJpbnNlcnQiKSkgdGhlbgoJCW5ld19pdGVtKCJfa2V5XyIsIiIpCgllbmQKCQoJLS0gaW5zZXJ0
IGFmdGVyIHBvcwoJaWYgKGtleXAoImVudGVyIikgYW5kIGtleSgic2hpZnQiKSkgdGhlbgoJCW5l
d19pdGVtKCJfa2V5XyIsIiIsMSkKCQljbGVhcl9rZXkoImVudGVyIikKCWVuZAoJCgktLSB0b2dn
bGUgdHlwZQoJaWYgKGtleXAoInQiKSBhbmQga2V5KCJjdHJsIikpIHRoZW4KCQl0b2dnbGVfdHlw
ZSgpCgllbmQKCQoJLS0gdG8gZG86IGNhbiBhbHNvIHByZXNzIGxlZnQvcmlnaHQgdG8gZXhwYW5k
L2NvbGxhcHNlIHRhYmxlcwoJLS0gYW5kIHRvIGluYy9kZWNyIHZhbHVlcwoJaWYgKChrZXlwKCJl
bnRlciIpIG9yIGtleXAoImxlZnQiKSBvciAKCQkJa2V5cCgicmlnaHQiKSkpIHRoZW4KCQlrID0g
bmlsCgkJaWYgKGtleXAoImxlZnQiKSkgIGsgPSAibGVmdCIKCQlpZiAoa2V5cCgicmlnaHQiKSkg
ayA9ICJyaWdodCIKCQkKCQllZGl0X3BwX3ZhbHVlKHNlbGVjdGVkLCBrKQoJCWNsZWFyX2tleSgi
ZW50ZXIiKSAtLSBkb24ndCBpbW1lZGlhdGVseSBjbG9zZSBhZ2FpbgkKCWVuZAoJCglpZiAoa2V5
KCJjdHJsIikpIHRoZW4KCQlpZiBrZXlwKCJ6IikgdGhlbgoJCQlsb2NhbCByZXMgPSB1bmRvX3N0
YWNrOnVuZG8oKQoJCQktLXByaW50aCgidW5kb2luZzogIi4udG9zdHIocmVzKSkKCQkJcmVmcmVz
aF9ndWkgPSB0cnVlCgkJZW5kCgoJCWlmIGtleXAoInkiKSB0aGVuCgkJCXVuZG9fc3RhY2s6cmVk
bygpCgkJCXJlZnJlc2hfZ3VpID0gdHJ1ZQoJCWVuZAoJCQoJCWlmIGtleXAoInMiKSB0aGVuCgkJ
CXNhdmVfd29ya2luZ19maWxlKCkKCQkJbm90aWZ5KCJzYXZlZCAiLi5jdXJyZW50X2ZpbGVuYW1l
KQoJCQlyZWZyZXNoX2d1aSA9IHRydWUKCQllbmQKCQkKCQlpZiBrZXlwKCJ2IikgdGhlbgoJCQls
b2NhbCBpdGVtID0gcHBbc2VsZWN0ZWRdCgkJCWxvY2FsIHRleHQgPSBnZXRfY2xpcGJvYXJkKCkK
CQkJbG9jYWwgYyxtID0gdW5wb2QodGV4dCkKCQkJaWYgKGMpIHRoZW4KCQkJCWl0ZW0ucGFyZW50
W2l0ZW0ua2V5XSA9IGMKCQkJZWxzZQoJCQkJaXRlbS5wYXJlbnRbaXRlbS5rZXldID0gdGV4dAoJ
CQllbmQKCQkJCgkJZW5kCgkJCgkJaWYga2V5cCgiYyIpIHRoZW4KCQkJbG9jYWwgaXRlbSA9IHBw
W3NlbGVjdGVkXQoJCQlsb2NhbCB2YWwgPSBpdGVtLnBhcmVudFtpdGVtLmtleV0KCQkJaWYgKHR5
cGUodmFsKSA9PSAic3RyaW5nIiBvciB0eXBlKHZhbCkgPT0gIm51bWJlciIpIHRoZW4KCQkJCXNl
dF9jbGlwYm9hcmQodG9zdHIodmFsKSkKCQkJZWxzZQoJCQkJc2V0X2NsaXBib2FyZCh0b3N0cihw
b2QpKQoJCQllbmQKCQllbmQKCQkKCQkKCWVuZAplbmQKCgpmdW5jdGlvbiBfdXBkYXRlKCkKCgl1
cGRhdGVfdGV4dGVkKCkKCXVwZGF0ZV9rYmQoKQoJCglpZiByZWZyZXNoX2d1aSBvcgoJCWd1aV93
ICE9IGdldF9kaXNwbGF5KCk6d2lkdGgoKSBvcgoJCWd1aV9oICE9IGdldF9kaXNwbGF5KCk6aGVp
Z2h0KCkKCXRoZW4KCQlnZW5lcmF0ZV9ndWkoKQoJCXJlZnJlc2hfZ3VpID0gZmFsc2UKCWVuZAoJ
CglndWk6dXBkYXRlX2FsbCgpCgkKCXNjcm9sbF95ID0gcGUueQplbmQKCgoKCgoKCgoKCgoKOjog
W2VvY10K
:: apps/sfx.p64
b64$cGljb3Ryb24gY2FydHJpZGdlIC8vIHd3dy5waWNvdHJvbi5uZXQKdmVyc2lvbiAyCgo6OiAu
aW5mby5wb2QKYjY0JExTMWJXM0J2WkN4dGIyUnBabWxsWkQwaU1qQXlOQzB3Tnkwd05pQXhNVG8w
T0Rvek5pSXNZWFYwYUc5eVBTSjZaWEFpTEdsagpiMjQ5ZFhObGNtUmhkR0VvSW5VNElpd3hOaXd4
Tml3aU1EQXdNREF3TURFd01UQXhNREV3TVRBeE1ERXdNVEF4TURFd01EQXdNREF3Ck1EQXdNREV3
TnpBM01EY3dOekEzTURjd056QTNNRGN3TnpBeE1EQXdNREF3TURFd056QmtNR1F3WkRCa01HUXda
REJrTUdRd1pEQmsKTURjd01UQXdNREV3TnpCa01HUXdaREJrTUdRd1pEQmtNR1F3WkRCa01HUXda
REEzTURFd01UQTNNR1F3TnpBM01EY3dOekJrTUdRdwpaREJrTUdRd1pEQmtNRGN3TVRBeE1EY3da
REEzTURjd056QTNNR1F3WkRCa01HUXdaREJrTUdRd056QXhNREV3TnpCa01EY3daREEzCk1EY3dO
ekEzTURjd1pEQmtNR1F3TnpBM01ERXdNVEEzTUdRd056QTNNRGN3TnpCa01HUXdaREJrTURjd1pE
QTNNRGN3TVRBeE1EY3cKWkRBM01EY3daREJrTURjd1pEQmtNR1F3TnpCa01EY3dOekF4TURFd056
QmtNRGN3TnpCa01HUXdaREEzTUdRd1pEQmtNR1F3WkRBMwpNREV3TVRBM01HUXdaREJrTUdRd1pE
QmtNR1F3WkRCa01HUXdaREJrTURjd01UQXhNRFl3TnpCa01HUXdaREJrTUdRd1pEQmtNR1F3ClpE
QmtNRGN3TmpBeE1ERXdOakEyTURjd056QTNNRGN3TnpBM01EY3dOekEzTURjd05qQTJNREV3TURB
eE1EWXdOakEyTURZd05qQTIKTURZd05qQTJNRFl3TmpBMk1ERXdNREF3TURBd01UQTJNRFl3TmpB
Mk1EWXdOakEyTURZd05qQTJNREV3TURBd01EQXdNREF3TURFdwpNVEF4TURFd01UQXhNREV3TVRB
eE1ERXdNREF3TURBaUtTeHViM1JsY3owaUtHTXBJRXhsZUdGc2IyWm1iR1VnUjJGdFpYTWdURXhR
CklpeGpjbVZoZEdWa1BTSXlNREl6TFRFd0xURTVJREUyT2pVd09qQTNJaXh5WlhacGMybHZiajB3
TEhKMWJuUnBiV1U5Tml4MGFYUnMKWlQwaVVHbGpiM1J5YjI0Z1ZISmhZMnRsY2lJc2RtVnljMmx2
YmowaU1DNHhaaUlzZDI5eWEzTndZV05sY3oxN2UyeHZZMkYwYVc5dQpQU0p0WVdsdUxteDFZU016
TVNJc2QyOXlhM053WVdObFgybHVaR1Y0UFRGOUxIdHNiMk5oZEdsdmJqMGlaM1ZwTG14MVlTTTBN
ak1pCkxIZHZjbXR6Y0dGalpWOXBibVJsZUQweGZTeDdiRzlqWVhScGIyNDlJbWx1YzNRdWJIVmhJ
elE1TUNJc2QyOXlhM053WVdObFgybHUKWkdWNFBURjlMSHRzYjJOaGRHbHZiajBpWlc1MkxteDFZ
U014TWpFaUxIZHZjbXR6Y0dGalpWOXBibVJsZUQweGZTeDdiRzlqWVhScApiMjQ5SW5SeVlXTnJM
bXgxWVNNeE16SWlMSGR2Y210emNHRmpaVjlwYm1SbGVEMHhmU3g3Ykc5allYUnBiMjQ5SW1SbFlu
Vm5MbXgxCllTTXlNQ0lzZDI5eWEzTndZV05sWDJsdVpHVjRQVEY5TEh0c2IyTmhkR2x2YmowaWRY
QmtZWFJsTG14MVlTTTNNaUlzZDI5eWEzTncKWVdObFgybHVaR1Y0UFRGOUxIdHNiMk5oZEdsdmJq
MGlaR0YwWVM1c2RXRWpORElpTEhkdmNtdHpjR0ZqWlY5cGJtUmxlRDB4ZlN4NwpiRzlqWVhScGIy
NDlJbk5tZUM4d0xuTm1lQ0lzZDI5eWEzTndZV05sWDJsdVpHVjRQVFI5ZlYxZGJIbzBBQVFBQUFB
REFBQUFNRzVwCmJBPT0KOjogZ2Z4Lwo6OiBnZngvLmluZm8ucG9kCmI2NCRMUzFiVzNCdlpDeGpj
bVZoZEdWa1BTSXlNREkwTFRBMExUQTVJREF5T2pNMk9qQXhJaXh0YjJScFptbGxaRDBpTWpBeU5D
MHcKTnkwd05pQXhNVG8wT0Rvek5pSXNjbVYyYVhOcGIyNDlNRjFkYkhvMEFBUUFBQUFEQUFBQU1H
NXBiQT09Cjo6IGdmeC8wLmdmeApiNjQkTFMxYlczQnZaQ3hqY21WaGRHVmtQU0l5TURJekxUTXdM
VEl5SURBM09qTXdPakEwSWl4dGIyUnBabWxsWkQwaU1qQXlOQzB3Ck15MHpNQ0F5TURvek5Eb3lN
aUlzY21WMmFYTnBiMjQ5TnprME5DeHpkRzl5WldROUlqSXdNak10TXpZdE1qa2dNRFE2TXpZNk5E
QWkKWFYxc2VqUUFrUVVBQUZRMkFBRHhDbnRiTUYwOWUySnRjRDF3ZUhVQVF5QUZCUVFnQnpBSEFF
Y0dBUEVCTEdac1lXZHpQVEFzY0dGdQpYM2c5TmdnQTJuazlMVFFzZW05dmJUMDRmU3c3QUZjbkFC
Y0FCd1FBSHlkQkFCMi1Cd0EzTUFjZ0J6QTNBQWM3QUIwd0VBY2dmd0JQCkp5QUhRRHNBSDM4d0I0
QUhNQWNRT1FBYVd4QVFCUER3TWdBVE1ESUFIekF4QUFWd0VSY1FGeUFuUU9RQThBTVhNQ2NRRnhB
bjhBUUgKQUFjUUZ4QUhVQ2ZEQVA4QVVBY0FGeUFuOEFRbjRBZmdCLUFzWUFBWklDQVFnUUVBVkFB
UkFGTUFNZ0FISUFvQThRTUhJQWNnRndBbgpFQWNRSnlBSEFDY0FKeEFvQVNBQUZ4QUFQLUQta3NV
QUhSLXdNUUQtRDFJRUJBUUFGOWNCUHdBWEFEb0FHYkVGQlFRQUp3QUhJQmNnCkY2d0JEendBSERf
Z0o2QXlBQngtVUNjUUp4QW5VRFlBSEVCZ0J5QUhYQUlPYmdNUE9nQU5MLUFKTVFDcy13TUlDQVN3
RHhCUUxqQXUKTUE0QURrQWU4QVZ2QUJ3Qk9RRXhRRWRBQ0FBUFBBQWRNVEFITU5NREEyUUZEMEFB
SFNFZ0Z3NEVBRWNBRDNvQUhTQWdaM0FBQURrRQpIeENSQVh0VXlHUUU4UDhCQVBBUWNWSHdzWEh3
cjVId0F5SHdsc0h3QVVId2xPSHdBRUh3UHpId1FIRVFVUXNBZ2o1UjhENXhNRkhnCkNnQWdZVUFL
QU1BOVlmQWhJZkFKVVhCUndGRU5BRkVnUWZBSFlRMEE4QW84WWZBaFFmQUdZWkJCd0VId0p5SHdB
Mkh3SUZId0JsR2cKRUFCUkprSHdBWEVRQUNKQnNCQUFJT0NCRHdDd0IwR3dRYkJSOENaQjBKRVBB
REFJSWNBUEFDQWxVUThBc1VId0dVR3dRZkFtVWNDaApEUUNBVWFCQjhDVmh3SkZuQUpBWlVaQlI4
Q1Zoc0tFMkFDQWFRUTBBSkZIQURRQUFOQUFnc0xFMEFCb2JEUUFRZ0RRQVpLQlJBRUh3CklROEFJ
Rkd3RHdBQU9BQVJVUThBTktCUkVBOEFBRG9BY3FCUkFGSHdIMUZKQUVRbFlaQmhEd0FBTFFCSFla
QlJFRHdBUVdHQVVTQmEKQUFFOEFDUWxjUThBSUJsUlBBQkhjWEJSTUE4QUlHR0FEd0JDR1NGUUlk
a0F0eVJ4Y0ZGQVFmQVlRZkFoRHdEd0Z4ZFI4Q0JSc0VIdwpDWUh3QW5GZ1VWQkI4QlpoOEIteEVz
Q3g4QUZ4VUdGUVFkQWhRSUZRRXdEd0J4U1E0ZUNCVUZGZ1FjRHhBd0NSOENEeEZJRHhBT0FrCkFN
QlJzUEVPOENIeEZIRHhBZEFpQVBBU1VhRHhEdkFpOFJOd2dUQkIwSUZBVVhCQnNQRU44Q0pSMEZI
d0FtRXdZY0NSRXdBUW9CTUEKOEJCaDBFSHdBMEV3Z2NDUk1GR0FRWkJoRVBFQjhDVmg0RUh3QWxF
UWtjQ2hGUUJoZ0hGQW9mQW9MZ0xWQXZFQ3dLRWdVWkJCWUlHZwpVUlFBVUFIQVVRQkJGZ0J3TUxH
Z1VmQW5VV2tDUUFMUjhBQVdBSkpCb0VFUTBhQkI4Q2dXQU1MQjhBQlJFRUVRVWFCQkFORXNBSElD
ClFmQUNrZkFERmdDaDhRU2dVZkFISWZBTVlSZ0F3SEh3QkZFZ1FRQlJzUEVFa0VnQzhRYndDbUh3
QTFId0FXR3dNVUJSSUxIQW9TQkIKWUlFWUFIQlI4QVJSOEFKeGNRR3dNS0hnWVZCQlFKSHdCMUVZ
QVBBSUJVSHdBNEZnVVNCUk1LSHdBRUZnUVNDeDhBWmg4QW0yQXNEdwpBLUVGRUdFd2tmQU44UU11
QUNBSllSVUFZQVR4QXhCaFFCVUFFQUVuQVBNRUNWSHdDRUh3QmZFQklGRlFrZkFPMGZBTFFSY0FN
QWJSCk1IOEFjUkNSOEE4aDhBbFVBUEVuQ0tGUUlZQlI4Qk5oOEN4eDhBcEI4SkZoOEF0UjhKQlI4
QXhSOEpFeDhBNVI4TEpSOExOUjhMSmgKOExKeDhMQ0I4TEJ4OExGaEZRQTZNZkQtQVFBZlpmY0RD
eDR5S0FRUDl3Y2VEekVBLTNVVE1qNElrd0FIVUFjUUp3QW5RRnNHSVBBRgpDUUNERnhBSGNBY2dC
eEFYQUU4QUotQkRZUUFNRHhvQ01BOHhBUC0tbUdNSEJ3UWdGekEyRGdRRUFBQVFBQzlBRjVvSkRD
d3hOa2tBCjhRQU9FQjBBRGdBT0RRQU5EZ0FkRGdBUEFDQU5FQW9BRWlBVkFBRVNBQTlXQUIxamtB
ZFFGeEJYb1FBdkI1QS1BQjBpZ0FmVUFIOEEKVnhBWFVBZWdQd0FkTTNCSEVBSUFIM0E3QUEwUHVn
RWVEekVBLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQotLS0tLS0tLS16
RlFiVDA0ZlgwPQo6OiBtYXAvCjo6IG1hcC8uaW5mby5wb2QKYjY0JExTMWJXM0J2WkN4amNtVmhk
R1ZrUFNJeU1ESTBMVEEwTFRBNUlEQXlPak0yT2pBeElpeHRiMlJwWm1sbFpEMGlNakF5TkMwdwpO
eTB3TmlBeE1UbzBPRG96TmlJc2NtVjJhWE5wYjI0OU1GMWRiSG8wQUFRQUFBQURBQUFBTUc1cGJB
PT0KOjogbWFwLzAubWFwCmI2NCRMUzFiVzNCdlpDeGpjbVZoZEdWa1BTSXlNREl6TFRNd0xUSXlJ
REEzT2pNd09qQTBJaXh5WlhacGMybHZiajAwTWpreUxITjAKYjNKbFpEMGlNakF5TXkwek5pMHlP
U0F3TkRvek5qbzBNQ0pkWFh0c1lYbGxjajE3V3pCZFBYdGliWEE5ZFhObGNtUmhkR0VvSW1reApO
aUlzTVRZc01UWXNJakF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01E
QXdNREF3TURBd01EQXdNREF3Ck1EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01E
QXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXcKTURBd01EQXdNREF3TURBd01E
QXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURB
dwpNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURB
d01EQXdNREF3TURBd01EQXdNREF3Ck1EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURB
d01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXcKTURBd01EQXdNREF3TURB
d01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3
TURBdwpNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3
TURBd01EQXdNREF3TURBd01EQXdNREF3Ck1EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3
TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXcKTURBd01EQXdNREF3
TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdN
REF3TURBdwpNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdN
REF3TURBd01EQXdNREF3TURBd01EQXdNREF3Ck1EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdN
REF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXcKTURBd01EQXdN
REF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01E
QXdNREF3TURBdwpNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01E
QXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3Ck1EQXdNREF3TURBd01EQXdNREF3TURBd01E
QXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXcKTURBd01E
QXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURB
d01EQXdNREF3TURBdwpNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURB
d01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3Ck1EQXdNREF3TURBd01EQXdNREF3TURB
d01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXcKTURB
d01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3
TURBd01EQXdNREF3TURBdwpNREF3TURBd01EQWlLU3h3WVc1ZmVEMHdMSEJoYmw5NVBUQXNjMk5o
YkdVOU1TeDBhV3hsWDJnOU1UWXNkR2xzWlY5M1BURTJmWDE5Cjo6IGFtcC5sdWEKLS1bW3BvZF9m
b3JtYXQ9InJhdyIsY3JlYXRlZD0iMjAyMy0yOS0xNyAxMzoyOTo0OCIscmV2aXNpb249MjU3LHN0
b3JlZD0iMjAyMy0yNy0xOSAyMzoyNzoxNyJdXQotLSBhbXAgZmlsdGVyCgoKCgoKCgoKCgoKCgoK
CgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoK
CgoKOjogZGF0YS5sdWEKLS1bW3BvZF9mb3JtYXQ9InJhdyIsY3JlYXRlZD0iMjAyMy0xMC0yNCAw
MDozNjo1OCIsbW9kaWZpZWQ9IjIwMjQtMDQtMjggMDg6NDI6MDAiLHJldmlzaW9uPTcwNTgsc3Rv
cmVkPSIyMDIzLTM2LTI5IDA0OjM2OjQwIl1dCmZ1bmN0aW9uIGluaXRfZGF0YSgpCgoJLS0gdXNl
IDI1NmsgZnJvbSAweDMwMDAwCgktLSBnaXZlcyAzOTkgU0ZYIGFuZCBtYW5hZ2VtYWJsZSBzaXpl
IGZvciB1bmRvIHN0YXRlIGNvbXBhcmlzb25zCgktLSBpZiBjaGFuZ2UgdGhpcyBuZWVkLCB0byBh
ZGp1c3QgdW5kbyBzdGFjayBzaXplIGFuZCBsb2FkZXIvc2F2ZXIKCQoJbWVtc2V0KDB4MzAwMDAs
IDAsIDB4NDAwMDApCgkKCgktLSBpbmRleCAoMHgzMDAwMCkKCQoJLS0gZmlyc3QgMyB2YWx1ZXMg
YXJlIGFsbW9zdCBtZXRhZGF0YSBvbmx5IC0tIG5vdCBjdXJyZW50bHkKCS0tIGFjdGVkIG9uIGFu
eXdoZXJlLiBwZXJoYXBzIHVzZWZ1bCBpbiBmdXR1cmUgZm9yIGRlY2lkaW5nCgktLSBzY29wZSBv
ZiBjb3B5L3Bhc3RlLCBhbmQgZ3VpIGN1ZXMsIGJ1dCBjYW4gYmUgY2FsY3VsYXRlZAoJLS0gZnJv
bSBjb250ZW50LgoJCglwb2tlMigweDMwMDAwLAoJCTY0LCAgLS0gbnVtX2luc3RydW1lbnRzCgkJ
NTEyLCAtLSBudW1fdHJhY2tzICg2NCBwYXR0ZXJucyAqIDggY2hhbm5lbHMgZm9yIGRlZmF1bHQg
aW5kZXhpbmcpCgkJNjQsICAtLSBudW1fcGF0dGVybnMKCQktLSBmbGFnczogMHgxIHVzZSBkZWZh
dWx0IHRyYWNrIGluZGV4aW5nIChiYXNlKzB4MjAwMDAsIGluY3JlbWVudHMgb2YgMzI4IGJ5dGVz
KQoJCTB4MQoJKQoJcG9rZTQoMHgzMDAxMCwKCQkweDEwMDAwLCAtLSBpbnN0c19hZGRyICAgICAg
KEkzMikgICAgcmVsYXRpdmUgYWRkcmVzcyBvZiBpbnN0cnVtZW50cwoJCTB4MjAwMDAsIC0tIHRy
YWNrc19hZGRyICAgICAoSTMyKSAgICByZWxhdGl2ZSBhZGRyZXNzIG9mIHRyYWNrIGluZGV4CgkJ
MCwgICAgICAgLS0gcGF0dGVybnNfYWRkciAgIChJMzIpICAgIHJlbGF0aXZlIGFkZHJlc3Mgb2Yg
cGF0dGVybiBkYXRhCgkJMCAgICAgICAgLS0gdW51c2VkICAgICAgICAgIChJMzIpICAgIHNob3Vs
ZCBiZSAwCgkpCglwb2tlMigweDMwMDIwLAoJCTAsICAtLSB0aWNrIGxlbiAoMCBmb3IgZGVmYXVs
dCAtLSBjdXN0b20gdmFscyBub3Qgc3VwcG9ydGVkIHlldCkKCQk2NCwgLS0gZGVmYXVsdCB0cmFj
ayBsZW5ndGgKCQkxNiAtLSBkZWZhdWx0IHRyYWNrIHNwZAoJKQoJCgktLSBkZWZhdWx0IHRyYWNr
IHNwZWVkICgrMyB1bnVzZWQpCglwb2tlKDB4MzAwMjYsIDE2LCAwLCAwLCAwKSAKCQoJLS0gcGF0
dGVybiBkYXRhOiBmaXJzdCAxNiBwYXR0ZXJucwoJLS0gd2FudCB0byBrZWVwIGRlZmF1bHQgc2Z4
IGZpbGUgcXVpdGUgdGlueQoJLS0gLi4gc2hvdWxkIGJlIG9rIHRvIHNhdmUgYSB3aG9sZSAuc2Z4
IGZvciBqdXN0IG9uZSBpbnN0IC8gZXhwZXJpbWVudAoJLS0gbGF0ZXI6IGludGVyZmFjZSB0byBn
ZW5lcmF0ZSBtb3JlIGRlZmF1bHQgcGF0dGVybnMKCQoJZm9yIHBwID0gMCwxIGRvCgkJbG9jYWwg
YWRkciA9IDB4MzAxMDAgKyBwcCAqIDIwCgkJZm9yIGkgPSAwLCA3IGRvCgkJCXBva2UoYWRkcitp
LCBwcCo4ICsgaSkKCQllbmQKCQlwb2tlKGFkZHIrOCwgMHgwKSAgLS0gZmxvdyBmbGFncwoJCXBv
a2UoYWRkcis5LCAweGZmKSAtLSBjaGFubmVsIG1hc2sKCQlwb2tlKGFkZHIrMTAsIDAsMCkgLS0g
bGVuZ3RoIChJMTYpCgkJCgllbmQKCQoJCgktLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCgktLSBzaW5nbGUg
aW5zdHJ1bWVudCBhdCAweDQwMDAwIChpbnN0cnVtZW50IDApCgkKCS0tIG5vZGUgMDogcm9vdAoJ
cG9rZSgweDQwMDAwICsgKDAgKiAzMiksIC0tIGluc3RydW1lbnQgMTBub2RlIDAKCQoJCQkwLCAg
ICAtLSBwYXJlbnQgKDB4NykgIG9wICgweGYwKQoJCQkxLCAgICAtLSBraW5kICgweDBmKTogMSBy
b290ICBraW5kX3AgKDB4ZjApOiAwICAtLSB3YXZldGFibGVfaW5kZXgKCQkJMCwgICAgLS0gZmxh
Z3MKCQkJMCwgICAgLS0gdW51c2VkIGV4dHJhCgkJCQkKCQkJLS0gTVZBTHM6ICBraW5kL2ZsYWdz
LCAgdmFsMCwgdmFsMSwgZW52ZWxvcGVfaW5kZXgKCQkJCgkJCTB4MnwweDQsMHgyMCwwLDAsICAt
LSB2b2x1bWU6IG11bHQuIDB4NDAgaXMgbWF4ICgtMHg0MCB0byBpbnZlcnQsIDB4N2YgdG8gb3Zl
cmFtcCkKCQkJMHgxLDAsMCwwLCAgICAgLS0gcGFuOiAgIGFkZC4gY2VudGVyCgkJCTB4MSwwLDAs
MCwgICAgIC0tIHR1bmU6ICswIC0tIDAsNDgsMCwwIGFic29sdXRlIGZvciBtaWRkbGUgYyAoYzQp
IDI2MS42IEh6CgkJCTB4MSwwLDAsMCwgICAgIC0tIGJlbmQ6IG5vbmUKCQkJLS0gZm9sbG93aW5n
IHNob3VsZG4ndCBiZSBpbiByb290CgkJCTB4MCwwLDAsMCwgICAgIC0tIHdhdmU6IHVzZSB3YXZl
IDAgCgkJCTB4MCwwLDAsMCAgICAgIC0tIHBoYXNlIAoJKQoJCgkKCS0tIG5vZGUgMTogc2luZQoJ
cG9rZSgweDQwMDAwICsgKDEgKiAzMiksIC0tIGluc3RydW1lbnQgMCwgbm9kZSAxCgkKCQkJMCwg
ICAgLS0gcGFyZW50ICgweDcpICBvcCAoMHhmMCkKCQkJMiwgICAgLS0ga2luZCAoMHgwZik6IDIg
b3NjICBraW5kX3AgKDB4ZjApOiAwICAtLSB3YXZldGFibGVfaW5kZXgKCQkJMCwgICAgLS0gZmxh
Z3MKCQkJMCwgICAgLS0gdW51c2VkIGV4dHJhCgkJCQkKCQkJLS0gTVZBTHM6ICBraW5kL2ZsYWdz
LCAgdmFsMCwgdmFsMSwgZW52ZWxvcGVfaW5kZXgKCQkJCgkJCTB4MiwweDIwLDAsMCwgIC0tIHZv
bHVtZTogbXVsdC4gMHg0MCBpcyBtYXggKC0weDQwIHRvIGludmVydCwgMHg3ZiB0byBvdmVyYW1w
KQoJCQkweDEsMCwwLDAsICAgICAtLSBwYW46ICAgYWRkLiBjZW50ZXIKCQkJMHgyMSwwLDAsMCwg
ICAgLS0gdHVuZTogKzAgLS0gMCw0OCwwLDAgYWJzb2x1dGUgZm9yIG1pZGRsZSBjIChjNCkgMjYx
LjYgSHoKCQkJICAgICAgICAgICAgICAgLS0gdHVuZSBpcyBxdWFudGl6ZWQgdG8gc2VtaXRvbmVz
IHdpdGggMHgyMAoJCQkweDEsMCwwLDAsICAgICAtLSBiZW5kOiBub25lCgkJCTB4MCwweDQwLDAs
MCwgIC0tIHdhdmU6IHRyaWFuZ2xlCgkJCTB4MCwwLDAsMCAgICAgIC0tIHBoYXNlIAoJKQoJCgkK
CgktLSB3YXZldGFibGUKCWZvciBpPTAsNyBkbwoJcG9rZSgweDQwMDAwICsgMHgxZTAsCgkJMHgw
MCwgLS0gYWRkcmVzcyAobG93KSAgaW4gMjU2IGJ5dGUgaW5jcmVtZW50cwoJCTB4ZjgsIC0tIGFk
ZHJlc3MgKGhpZ2gpIGluIDY0ayBpbmNyZW1lbnRzCgkJMHgwYSwgLS0gc2FtcGxlcyAoMSA8PCBu
KSAxMDI0CgkJMHhmZiwgIC0tIHd0X2hlaWdodCAyNTYoMCk7IHdhdmUgbXZhbCBwb2ludHMgYXQg
b25lIG9mIHRoZSBlbnRyaWVzCgkJCgkJLS0gdG8gZG86IHVwZGF0ZSAoaXMgZ2FyYmFnZSBub3c-
KQoJCTB4ODAsCgkJMHhmNywKCQkweDBkLCAtLSBzYW1wbGVzICgxIDw8IG4pIDgxOTIKCQkweDAx
CgkpCgllbmQKCgktLSBlbnZlbG9wZSAwIGluc3QgMQoJCglwb2tlKDB4NDAwMDAgKyAweDEwMCwK
CQkwLDAsMCwwLCAwLDAsMCwwLAoJCTAsNDAsMjU1LDAgLS0gYWRzcgoJKQoJCgktLSBjb3B5IGRl
ZmF1bHQgaW5zdHJ1bWVudCB0byAxLi4zMQoJZm9yIGk9MSwzMSBkbwoJCW1lbWNweSgweDQwMDAw
ICsgMHgyMDAqaSwgMHg0MDAwMCwgMHgyMDApCgllbmQKCQoJLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KCS0tIFRyYWNrIERhdGEgIDB4NTAwMDAKCS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCgkKCS0tIERl
ZmF1bHQgdHJhY2sgc2l6ZSBpcyA1ICogNjQgcm93cyArIDggPSAzMjggYnl0ZXMKCQoJLS0gaGVh
ZGVyICg4KQoJbG9jYWwgYWRkciA9IDB4NTAwMDAKCXBva2UyKGFkZHIsIDY0KSAtLSBsZW4KCXBv
a2UoYWRkcisyLDE2KSAtLSBzcGQKCXBva2UoYWRkciszLDApICAtLSBsb29wMAoJcG9rZShhZGRy
KzQsMCkgIC0tIGxvb3AxCglwb2tlKGFkZHIrNSwwKSAgLS0gZGVsYXkKCXBva2UoYWRkcis2LDAp
ICAtLSBmbGFncyAoMHgxIG11dGUpCglwb2tlKGFkZHIrNywwKSAgLS0gdW51c2VkCgkKCS0tIHBp
dGNoLCBpbnN0LCB2b2w6IG5vdCBzZXQgKDB4ZmYpCgltZW1zZXQoYWRkcis4LCAweGZmLCA2NCoz
KQoJCgktLSBjb3B5IHRvIG90aGVyIHRyYWNrczogMTI4ayB3b3J0aAoJLS0gKiogb25seSBmaXJz
dCAzOTkgYXJlIHNhdmVkIC8gdW5kb2FibGUgKDB4MjAwMDBcMzI4KSAqKgoJCglmb3IgaT0xLDM5
OCBkbwoJCW1lbWNweSgweDUwMDAwICsgaSozMjgsIDB4NTAwMDAsIDMyOCkKCWVuZAoJCgplbmQK
CgoKCgoKOjogZGVidWcubHVhCi0tW1twb2RfZm9ybWF0PSJyYXciLGNyZWF0ZWQ9IjIwMjQtMDMt
MTMgMDg6MzY6NDUiLG1vZGlmaWVkPSIyMDI0LTA0LTI4IDA4OjQyOjAwIixyZXZpc2lvbj01NDRd
XQoKZnVuY3Rpb24gZHJhd19tdWRvX3N0YXRlKHgseSkKCXJlY3RmaWxsKHgseSx4Kzk5LHkrNjAs
MCkKCQoJZm9yIGk9MCw3IGRvCgkJbG9jYWwgc3ggPSB4ICsgMgoJCWxvY2FsIHN5ID0geSArIGkg
KiA2CQoJCQoJCS0tIGNoYW4tPnBsYXlpbmdfdHJhY2tfaW5kZXgKCQlwcmludCgiXDE0Ii4uc3Rh
dCg0MDAraSwxMiksIHN4LCBzeSwgNykKCQkKCQktLSBjaGFuLT5pbnN0CQkKCQlwcmludCgiXDE0
Ii4uc3RhdCg0MDAraSwxICksIHN4KzMwLCBzeSwgNykKCQkKCQktLSBjaGFuLT50cmFja19yb3cK
CQlwcmludCgiXDE0Ii4uc3RhdCg0MDAraSw5ICksIHN4KzYwLCBzeSwgMTMpCgkJCgllbmQKCXBy
aW50KHN0cmluZy5mb3JtYXQoImNwdTolMy4zZiIsIHN0YXQoMSkpLHgseSs1MiwxMykKCXByaW50
KHRvc3RyKHNvbWV0aGluZ19pc19wbGF5aW5nKSx4KzUwLHkrNTIsMTQpCmVuZAoKOjogZW52Lmx1
YQotLVtbcG9kX2Zvcm1hdD0icmF3IixjcmVhdGVkPSIyMDIzLTEwLTA4IDAzOjMyOjU4Iixtb2Rp
ZmllZD0iMjAyNC0wNC0yOCAwODo0MjowMCIscmV2aXNpb249MjMwMixzdG9yZWQ9IjIwMjMtMzYt
MjkgMDQ6MzY6NDAiXV0KCi0tIGZsYWdzOiBsZXJwLCByYW5kb20gc3RhcnQgcG9zaXRpb24KLS0g
dXNlZCBieSBEQVRBIGVudmVsb3BlCmZ1bmN0aW9uIGNyZWF0ZV9lbnZfZmxhZ190b2dnbGUoYWRk
cixmbGFnLGxhYmVsLHgseSkKCWxvY2FsIGVsID0gewoJCWFkZHIgPSBhZGRyLCBmbGFnID0gZmxh
ZywgbGFiZWw9bGFiZWwsCgkJeCA9IHgsIHkgPSB5LCB3aWR0aCA9IDE4KyNsYWJlbCo0LCBoZWln
aHQgPSA3Cgl9CglmdW5jdGlvbiBlbDpkcmF3KG1zZykKCQlsb2NhbCB5eSA9IChtc2cuaGFzX3Bv
aW50ZXIgYW5kIG1zZy5tYiA_IDApIGFuZCAxIG9yIDAKCQlsb2NhbCB2YWwgPSAoQHNlbGYuYWRk
cikgJiBzZWxmLmZsYWcKCQktLWNsaXAoKQoJCS0tcmVjdGZpbGwoMCwwK3l5LHNlbGYud2lkdGgt
MSw2K3l5LG1zZy5oYXNfcG9pbnRlciBhbmQgMTQgb3IgCgkJLS0JKHZhbD4wIGFuZCA3IG9yIDEz
KSkKCQlsb2NhbCBzdHI9dmFsPjAgYW5kICJbL10gIiBvciAiWyBdICIKCQlpZiAoc2VsZi5mbGFn
ID09IDB4MTApIHN0ciA9ICIiIC0tIEVGX0FEVkFOQ0VEX09QVFMgZG9lc24ndCBoYXZlIGNoZWNr
Ym94CgkJcHJpbnQoc3RyLi5zZWxmLmxhYmVsLDIsMSt5eSwxMykKCWVuZAoJZnVuY3Rpb24gZWw6
Y2xpY2soKQoJCWNoZWNrcG9pbnQoKQoJCWxvY2FsIHZhbCA9IHBlZWsoc2VsZi5hZGRyKQoJCXZh
bCBeXj0gc2VsZi5mbGFnCgkJcG9rZShzZWxmLmFkZHIsIHZhbCkKCQlyZWZyZXNoX2d1aSA9IHRy
dWUKCWVuZAoJCglyZXR1cm4gZWwKZW5kCgoKZW52X3R5cGVfc3RyID0ge1swXT0KCSJhZHNyIiwK
CSJsZm8iLAoJImRhdGEiLAp9CgoKCmZ1bmN0aW9uIGNyZWF0ZV9lbnZfdHlwZV90b2dnbGUoYWRk
cix4LHkpCglsb2NhbCBlbCA9IHsgCgkJYWRkciA9IGFkZHIsCgkJeCA9IHgsIHkgPSB5LCB3aWR0
aCA9IDIwLCBoZWlnaHQgPSA3Cgl9CglmdW5jdGlvbiBlbDpkcmF3KG1zZykKCQlsb2NhbCB5eSA9
IChtc2cuaGFzX3BvaW50ZXIgYW5kIG1zZy5tYiA_IDApIGFuZCAxIG9yIDAKCQlsb2NhbCB2YWwg
PSAoQHNlbGYuYWRkcikgJiAweGYKCQljbGlwKCkKCQktLXBhbCg3LDEpCgkJcmVjdGZpbGwoMCww
K3l5LHNlbGYud2lkdGgtMSw2K3l5LG1zZy5oYXNfcG9pbnRlciBhbmQgMTQgb3IgNikKCQktLXNw
cih2YWwsMSwxK3l5KQoJCXByaW50KGVudl90eXBlX3N0clt2YWxdLDIsMSt5eSwxKQoJCS0tcGFs
KCkKCWVuZAoJZnVuY3Rpb24gZWw6Y2xpY2soKQoJCWNoZWNrcG9pbnQoKQoJCWxvY2FsIHZhbCA9
IHBlZWsoc2VsZi5hZGRyKQoJCXZhbCA9ICh2YWwgKyAxKSAlIDMKCQlwb2tlKHNlbGYuYWRkciwg
KHBlZWsoc2VsZi5hZGRyKSAmIDB4ZjApIHwgKHZhbCAmIDB4MGYpKQoJCXJlZnJlc2hfZ3VpID0g
dHJ1ZQoJZW5kCgkKCXJldHVybiBlbAplbmQKCmZ1bmN0aW9uIGNyZWF0ZV9lbnZfcGx1ZyhpbmRl
eCwgeCwgeSkKCWxvY2FsIGVsID0gewoJCXg9eCx5PXksd2lkdGg9NyxoZWlnaHQ9NyxpbmRleD1p
bmRleCwKCQljbGljaz1jaGVja3BvaW50Cgl9CglmdW5jdGlvbiBlbDpkcmF3KG1zZykKCQljaXJj
ZmlsbCgzLDMsMiwxMykKCQljaXJjKDMsMywyLDEpCgllbmQKCWZ1bmN0aW9uIGVsOnJlbGVhc2Uo
bXNnKQoJCWxvY2FsIHN4PXNlbGYuc3ggKyBtc2cubXgKCQlsb2NhbCBzeT1zZWxmLnN5ICsgbXNn
Lm15CgkJCgkJbG9jYWwgZWwyID0gZ3VpOmVsX2F0X3h5KHN4LHN5KQoJCWlmIChlbDIuZHJvcF9l
bnZfcGx1ZykgZWwyOmRyb3BfZW52X3BsdWd7aW5kZXg9c2VsZi5pbmRleH0KCQkKCWVuZAoJCgly
ZXR1cm4gZWwKZW5kCgoKLS1bWwoJZWRpdCBhbiA4LWJpdCB2YWx1ZSBpbiBtZW1vcnkKXV0KZnVu
Y3Rpb24gY3JlYXRlX3Rpbnlfa25vYihsYWJlbCxhZGRyLHgseSxoYXNfa25vYikKCWxvY2FsIGVs
PXsKCQl4PXgseT15LAoJCXdpZHRoPTE1LGhlaWdodD1oYXNfa25vYiBhbmQgMjQgb3IgMTQsCgkJ
bGFiZWw9bGFiZWwsYWRkcj1hZGRyLAoJCWR2YWw9MCwKCQktLWN1cnNvcj0iZ3JhYiIgLS0gdG8g
ZG86IGRpYWwgc3Bpbm5pbmcgY3Vyc29yIHRoYXQgZGlzYXBwZWFycwoJfQoJCglmdW5jdGlvbiBl
bDpkcmF3KCkKCQlsb2NhbCB2YWw9cGVlayhzZWxmLmFkZHIpCgkJaWYgKGhhc19rbm9iKSB0aGVu
CgkJCWNpcmMoNyw1LDUsMTMpCgkJCWxvY2FsIGFhPS43LXZhbCouOS8yNTUuMAoJCQlsaW5lKDcu
NStjb3MoYWEpLDUuNStzaW4oYWEpLDcuNStjb3MoYWEpKjQsNS41K3NpbihhYSkqNCw3KQoJCWVu
ZAoJCQoJCWNsaXAoKQoJCQoJCS0tIAoJCWxvY2FsIHl5PWhhc19rbm9iIGFuZCAxNCBvciAyCgkJ
cmVjdGZpbGwoMCx5eSwxNCx5eSs2LDApCgkJbG9jYWwgc3RyPXRvc3RyKHZhbCkKCQlwcmludChz
dHIsMTQtI3N0cio0LHl5KzEsMykKCQkKCQlwcmludChzZWxmLmxhYmVsLDktI3NlbGYubGFiZWwq
Mix5eSsxMCwxMykKCgllbmQKCQoJLS0gdHVybiBtb3VzZSBsb2NraW5nIG9uIHdoaWxlIGRyYWdn
aW5nCglmdW5jdGlvbiBlbDpjbGljayhtc2cpCgkJbW91c2Vsb2NrKDB4NHwweDgsIDAuNSwgMC4w
NSkgLS0gMHg0IGxvY2sgMHg4IGF1dG8tcmVsZWFzZSwgZXZlbnQgc3BlZWQsIG1vdmUgc3BlZWQg
CgllbmQKCQoJZnVuY3Rpb24gZWw6ZHJhZyhtc2cpCgkJbG9jYWwgdmFsPXBlZWsoc2VsZi5hZGRy
KQoJCS0tIGFjY3VtdWxhdGUgY2hhbmdlIGF0IDAuNSBwZXIgcGl4ZWwKCQllbC5kdmFsICs9ICht
c2cuZHggLSBtc2cuZHkpICogMC41CgkJaWYgKGVsLmR2YWwgPD0gLTEpIHRoZW4KCQkJdmFsIC09
IGZscigtZWwuZHZhbCkKCQkJZWwuZHZhbCArPSBmbHIoLWVsLmR2YWwpCgkJZW5kCgkJaWYgKGVs
LmR2YWwgPj0gMSkgdGhlbgoJCQl2YWwgKz0gZmxyKGVsLmR2YWwpCgkJCWVsLmR2YWwgJT0gMQoJ
CWVuZAoJCXZhbCA9IG1pZCgwLHZhbCwyNTUpCgkJcG9rZShzZWxmLmFkZHIsIHZhbCkKCWVuZAoJ
Ci0tW1sKCS0tIGFubm95aW5nCgktLSBkb2Vzbid0IG1peCB3aXRoIGRyYWcgY29udHJvbAoJLS0g
cGljby04IGFjdHVhbGx5IHN1ZmZlcnMgZnJvbSB0aGUgc2FtZSBwcm9ibGVtIQoJLS0gKGp1c3Qg
bm90IHByb25vdW5jZWQgYmVjYXVzZSBlYXN5IHRvIGtlZXAgdGhlIGN1cnNvciBzdGlsbCwKCS0t
ICBhbmQgaGFyZCB0byBkcmFnIC0xIG9yICsxIHdoaWxlIHN0YXJ0aW5nIGFuZCBlbmRpbmcgaW5z
aWRlIGVsKQoJCglmdW5jdGlvbiBlbDp0YXAobXNnKQoJCWxvY2FsIHZhbCA9IHBlZWsoc2VsZi5h
ZGRyKQoJCWxvY2FsIG1hZyA9IGtleSgiY3RybCIpIGFuZCA4IG9yIDEKCQl2YWwgKz0gbXNnLmxh
c3RfbWIgPT0gMiBhbmQgLW1hZyBvciBtYWcKCQlwb2tlKHNlbGYuYWRkcixtaWQoMCx2YWwsMjU1
KSkKCWVuZApdXQoJCglyZXR1cm4gZWwKZW5kCgoKZnVuY3Rpb24gY3JlYXRlX2RhdGFfZW52X2Vk
aXRvcihhZGRyLCB4LCB5LCB3aWR0aCwgaGVpZ2h0KQoJbG9jYWwgZWw9ewoJCWFkZHI9YWRkciwK
CQl4PXgseT15LHdpZHRoPXdpZHRoLGhlaWdodD1oZWlnaHQKCX0KCWZ1bmN0aW9uIGVsOmRyYXco
KQoJCXJlY3RmaWxsKDAsMCxzZWxmLndpZHRoLTEsc2VsZi5oZWlnaHQtMSwwKQoJCWxvY2FsIHd3
PXdpZHRoXDE2CgkJbG9jYWwgaGg9c2VsZi5oZWlnaHQKCQlsb2NhbCBsb29wMCA9IEAoYWRkcisz
KQoJCWxvY2FsIGxvb3AxID0gQChhZGRyKzQpCgkJCgkJLS0gc2hvdyBsb29wIHBvaW50cwoJCWZp
bGxwKDB4NWE1YSkKCQljb2wgPSBsb29wMCA8IGxvb3AxIGFuZCA2IG9yIDUKCQlsaW5lKGxvb3Aw
Knd3LTEsMCwgbG9vcDAqd3ctMSxzZWxmLmhlaWdodCxjb2wpCgkJbGluZShsb29wMSp3dy0xLDAs
IGxvb3AxKnd3LTEsc2VsZi5oZWlnaHQsY29sKQoJCWZpbGxwKCkKCQkKCQktLSBzaG93IGRhdGEK
CQlmb3IgaT0wLDE1IGRvCgkJCWxvY2FsIHN4ID0gaSp3dwoJCQlsb2NhbCB2YWwgPSBwZWVrKHNl
bGYuYWRkcitpKzgpCgkJCWxvY2FsIGNvbCA9IGkgPj0gbG9vcDAgYW5kIGkgPCBsb29wMSBhbmQg
MTMgb3IgMTIKCQkJcmVjdGZpbGwoc3gsaGgsc3grd3ctMixoaC12YWwqaGgvMjU1LGNvbCkKCQkJ
cmVjdGZpbGwoc3gsaGgtdmFsKmhoLzI1NSxzeCt3dy0yLGhoLXZhbCpoaC8yNTUsMjgpCgkJZW5k
CgkJCgllbmQKCQoJZnVuY3Rpb24gZWw6ZHJhZyhtc2cpCgkJbG9jYWwgd3c9d2lkdGhcMTYKCQls
b2NhbCBoaD1zZWxmLmhlaWdodAoJCWxvY2FsIHh4PW1pZCgwLG1zZy5teFx3dywxNSkKCQlsb2Nh
bCB5eT0obXNnLm15KSAqIDI1NSAvIHNlbGYuaGVpZ2h0CgkJcG9rZShzZWxmLmFkZHIreHgrOCxt
aWQoMCwyNTUteXksMjU1KSkKCWVuZAoJCglyZXR1cm4gZWwKZW5kCgoKZnVuY3Rpb24gY3JlYXRl
X2Vudl9lZGl0b3IoaW5kZXgsIGFkZHIsIGxhYmVsLCB4LCB5LCB3aWR0aCkKCglsb2NhbCBoZWln
aHQgPSA0NgoJaWYgKEBhZGRyID09IDEpIGhlaWdodCA9IDU0IC0tIGxmbwoJaWYgKEBhZGRyID09
IDIpIGhlaWdodCA9IDg2IC0tIGRhdGEKCQoJbG9jYWwgaGVpZ2h0MCA9IGhlaWdodAoJCglpZiAo
cGVlayhhZGRyKzEpJjB4MTA_MCBhbmQgQGFkZHI8MikgdGhlbgoJCWhlaWdodCArPSAyOAoJZW5k
CgkKCWxvY2FsIHBhbmUgPSBndWk6YXR0YWNoKGNyZWF0ZV9wYW5lKCJcZmgiLi5sYWJlbCwgeCwg
eSwgd2lkdGgsIGhlaWdodCwgMHgwNzAxKSkKCXBhbmUuaW5kZXggPSBpbmRleAoJCgktLSBkb24n
dCBuZWVkIHBsdWchIGp1c3QgZHJhZyB3aG9sZSBwYW5lCgktLXBhbmU6YXR0YWNoKGNyZWF0ZV9l
bnZfcGx1ZyhpbmRleCwyLDEpKQoJCgkKCXBhbmU6YXR0YWNoKGNyZWF0ZV9lbnZfdHlwZV90b2dn
bGUoYWRkciw0NCwxKSkKCQoJCgktLSBhZHNyCglpZiAocGVlayhhZGRyKSA9PSAwKSB0aGVuCgkJ
LS0gbm8gbGFiZWxzOiBpdCdzIGluIHRoZSBuYW1lIG9mIHRoZSBlbnZlbG9wZSEKCQktLWxvY2Fs
IGtub2JfbmFtZT17WzBdPSJhdGsiLCJkY3kiLCJzdXMiLCJyZWwifQoJCWZvciBpPTAsMyBkbwoJ
CQlwYW5lOmF0dGFjaChjcmVhdGVfdGlueV9rbm9iKCIiLGFkZHIrOCtpLDIraSoyMCwxNix0cnVl
KSkKCQllbmQKCWVuZAoJCgktLSBsZm8KCWlmIChwZWVrKGFkZHIpID09IDEpIHRoZW4KCQlwYW5l
OmF0dGFjaChjcmVhdGVfdGlueV9rbm9iKCJmcmVxIixhZGRyKzEyKzAsOCwxNix0cnVlKSkKCQkt
LXBhbmU6YXR0YWNoKGNyZWF0ZV90aW55X2tub2IoImZ1bmMiLGFkZHIrMTMrMCwzMSwyOCxmYWxz
ZSkpCgkJcGFuZTphdHRhY2goY3JlYXRlX3Rpbnlfa25vYigicGhhc2UiLGFkZHIrMTQrMCw1NCwx
Nix0cnVlKSkKCQkKCWVuZAoJCgktLSBkYXRhIGZvb3RlciB0aGluZwoJaWYgKHBlZWsoYWRkcikg
PT0gMiBvciBwZWVrKGFkZHIrMSkmMHgxMD4wKSB0aGVuCgkJCgkJaWYgKHBlZWsoYWRkcikgIT0g
MikgdGhlbgoJCQktLSBub24tZGF0YSBvbmx5IG5lZWRzIHRoZSBzdGFydCBhdCBybmQodDApLCBz
byBjYW4gaGF2ZSBtb3JlIHZlcmJvc2UgdmVyc2lvbgoJCQktLXBhbmU6YXR0YWNoKGNyZWF0ZV9l
bnZfZmxhZ190b2dnbGUoYWRkcisxLDB4OCwicm5kIHN0YXJ0IiwyMCxwYW5lLmhlaWdodC0yNykp
CgkJCXBhbmU6YXR0YWNoKGNyZWF0ZV9lbnZfZmxhZ190b2dnbGUoYWRkcisxLDB4OCwicm5kIiw0
NixwYW5lLmhlaWdodC0yNykpCgkJZW5kCgkJCgkJLS0gc3RhcnRpbmcgZnJvbSBlbnZfZGVmWzFd
ICAtLSBlbnZfZGVmWzBdIGlzIGZsYWdzCgkJbG9jYWwga25vYl9uYW1lPXtbMF09InNwZCIsImxw
MCIsImxwMSIsInQwIn0KCQlmb3IgaT0wLDMgZG8KCQkJcGFuZTphdHRhY2goY3JlYXRlX3Rpbnlf
a25vYihrbm9iX25hbWVbaV0sYWRkcisyK2ksMitpKjIwLAoJCQkJcGFuZS5oZWlnaHQtMjAsZmFs
c2UpKQoJCWVuZAoJCQoJZW5kCgkKCS0tIGRhdGEgZWRpdG9yCglpZiAocGVlayhhZGRyKSA9PSAy
KSB0aGVuCgkJcGFuZTphdHRhY2goY3JlYXRlX2RhdGFfZW52X2VkaXRvcihhZGRyLDAsOSw4MCw0
OCkpCgkKCQktLSBsZXJwLCBybmRfc3RhcnQKCQlwYW5lOmF0dGFjaChjcmVhdGVfZW52X2ZsYWdf
dG9nZ2xlKGFkZHIrMSwweDEsImxlcnAiLDIscGFuZS5oZWlnaHQtMjcpKQoJCXBhbmU6YXR0YWNo
KGNyZWF0ZV9lbnZfZmxhZ190b2dnbGUoYWRkcisxLDB4OCwicm5kIiw0NixwYW5lLmhlaWdodC0y
NykpCgkJCgllbmQKCQoJLS0gc2hvdyBhZHZhbmNlZCBvcHRpb25zIC8gLi4uIGJ1dHRvbgoJaWYg
KHBlZWsoYWRkcikgPCAyKSB0aGVuCgkJbG9jYWwgc3RyPSJcZjVcXjowMDAwMDAxNTAwMDAwMDAw
IiAtLSAuLi4KCQlpZiAocGVlayhhZGRyKzEpJjB4MTA_MCkgc3RyPSJcZjVcXjowMDAwMDQwZTFm
MDAwMDAwIiAtLSB1cCBhcnJvdwoJCXBhbmU6YXR0YWNoKGNyZWF0ZV9lbnZfZmxhZ190b2dnbGUo
YWRkcisxLDB4MTAsc3RyLHdpZHRoLzItNixoZWlnaHQwLTgpKQoJZW5kCgkKCQoJLS0gY2FuIGRy
YWcgYW5kIGRyb3AgYW55d2hlcmUgb24gcGFuZQoJZnVuY3Rpb24gcGFuZTpyZWxlYXNlKG1zZykK
CQlsb2NhbCBzeD1zZWxmLnN4ICsgbXNnLm14CgkJbG9jYWwgc3k9c2VsZi5zeSArIG1zZy5teQoJ
CQoJCWxvY2FsIGVsMiA9IGd1aTplbF9hdF94eShzeCxzeSkKCQlpZiAoZWwyIGFuZCBlbDIuZHJv
cF9lbnZfcGx1ZykgZWwyOmRyb3BfZW52X3BsdWd7aW5kZXg9c2VsZi5pbmRleH0KCQkKCWVuZAoJ
CglyZXR1cm4gcGFuZQplbmQKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoK
CgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCjo6IGd1aS5sdWEKLS1bW3BvZF9mb3Jt
YXQ9InJhdyIsY3JlYXRlZD0iMjAyMy0xMC0yMiAwNzozMjoxMSIsbW9kaWZpZWQ9IjIwMjQtMDQt
MjggMDg6NDI6MDAiLHJldmlzaW9uPTkxMDMsc3RvcmVkPSIyMDIzLTM2LTI5IDA0OjM2OjQwIl1d
CgpmdW5jdGlvbiBjcmVhdGVfcGFuZSh0aXRsZSwgeCwgeSwgdywgaCwgY29sKQoKCWlmIChub3Qg
Y29sKSBjb2wgPSAweDA3MDUgLS0gZGVmYXVsdCBiYWNrCgkKCWxvY2FsIGVsPXsKCQl0aXRsZT10
aXRsZSwKCQl4PXgseT15LHdpZHRoPXcsaGVpZ2h0PWgsCgkJY29sPWNvbAoJfQoJCglmdW5jdGlv
biBlbDpkcmF3KCkKCQoJCWxvY2FsIGNvbCA9IChzZWxmLmNvbCA_PiAwKSAmIDB4ZmYKCQlsb2Nh
bCBoY29sID0gKHNlbGYuY29sID4_IDgpICYgMHhmZgoJCQoJCXJlY3RmaWxsKDEsMCxzZWxmLndp
ZHRoLTIsMCxoY29sKQoJCXJlY3RmaWxsKDAsMSxzZWxmLndpZHRoLDgsaGNvbCkKCQlyZWN0Zmls
bCgwLDksc2VsZi53aWR0aC0xLHNlbGYuaGVpZ2h0LTIsY29sKQoJCXJlY3RmaWxsKDEsc2VsZi5o
ZWlnaHQtMSxzZWxmLndpZHRoLTIsc2VsZi5oZWlnaHQtMSxjb2wpCgkJCgkJLS1wcmludCh0aXRs
ZSwxNCwyLDEpIC0tIGFzc3VtZSBzb21lIGtpbmQgb2YgaWNvbiB0byB0aGUgbGVmdAoJCXByaW50
KHRpdGxlLDYsMiwxKSAtLSBhc3N1bWUgc29tZSBraW5kIG9mIGljb24gdG8gdGhlIGxlZnQKCQkK
CWVuZAoJcmV0dXJuIGVsCmVuZAoKZnVuY3Rpb24gY3JlYXRlX2luc3RydW1lbnRfY2hvb3Nlcihl
bCkKCS0tIGluc3RydW1lbnQgY2hvb3NlcgoJbG9jYWwgY29udGFpbmVyID0gZWw6YXR0YWNoewoJ
CXg9Mix5PTEwLHdpZHRoPWVsLndpZHRoLTIsaGVpZ2h0PWVsLmhlaWdodC0xMSwKCQlkcmF3PWZ1
bmN0aW9uKHNlbGYpCgkJCS0tIHNvbWUgcGFyZW50IHR1cm5lZCBjbGlwcGluZyBvZmY7IGNhbiB0
dXJuIGJhY2sgb24gaGVyZQoJCQljbGlwKHNlbGYuc3gsc2VsZi5zeSxzZWxmLndpZHRoLHNlbGYu
aGVpZ2h0KQoJCWVuZAoJfQoJbG9jYWwgY29udGVudHMgPSBjb250YWluZXI6YXR0YWNoewoJCXg9
MCx5PTAsd2lkdGg9ODYsaGVpZ2h0PTI1NiwKCQlkcmF3PWZ1bmN0aW9uKHNlbGYpCgkJCWZvciBp
PTAsMzEgZG8KCQkJCWlmIChjaSA9PSBpKSByZWN0ZmlsbCgwLGkqOCxzZWxmLndpZHRoLTEsaSo4
KzYsMTYpCgkJCQlwcmludChzdHJpbmcuZm9ybWF0KCIlMDJpIGluc3QgIixpKSwyLDEgKyBpKjgs
NikKCQkJZW5kCgkJZW5kLAoJCWNsaWNrPWZ1bmN0aW9uKHNlbGYsbXNnKQoJCQljaSA9IG1zZy5t
eVw4CgkJCWlmIChrZXkiY3RybCIpIG1vZGUgPSAiaW5zdHJ1bWVudCIKCQkJcmVmcmVzaF9ndWkg
PSB0cnVlCgkJZW5kCgl9Cgljb250YWluZXI6YXR0YWNoX3Njcm9sbGJhcnMoKQoJCgktLSBjZW50
ZXIgKGRvbid0IG5lZWQgdG8gc3RvcmUgc2Nyb2xsaW5nIHBvc2l0aW9uIHdoZW4gZ3VpIHJlZnJl
c2hlZCkKCWNvbnRlbnRzLnkgPSAtY2kgKiA4ICsgMzAKCgktLSBjbGFtcAoJY29udGVudHMueSA9
IG1pZCgwLCBjb250ZW50cy55LCAtIChjb250ZW50cy5oZWlnaHQgLSBjb250YWluZXIuaGVpZ2h0
KSkKZW5kCgpmdW5jdGlvbiBjcmVhdGVfdHJhY2tfY2hvb3NlcihlbCkKCglsb2NhbCBjb250YWlu
ZXIgPSBlbDphdHRhY2h7CgkJeD0yLHk9MTAsd2lkdGg9ZWwud2lkdGgtMixoZWlnaHQ9ZWwuaGVp
Z2h0LTExLAoJCWRyYXc9ZnVuY3Rpb24oc2VsZikKCQkJLS0gc29tZSBwYXJlbnQgdHVybmVkIGNs
aXBwaW5nIG9mZjsgY2FuIHR1cm4gYmFjayBvbiBoZXJlCgkJCWNsaXAoc2VsZi5zeCxzZWxmLnN5
LHNlbGYud2lkdGgsc2VsZi5oZWlnaHQpCgkJZW5kCgl9Cglsb2NhbCBjb250ZW50cyA9IGNvbnRh
aW5lcjphdHRhY2h7CgkJeD0wLHk9MCx3aWR0aD04NixoZWlnaHQ9MzIqMTYsCgkJZHJhdz1mdW5j
dGlvbihzZWxmKQoJCQlmb3IgaT0wLDEyNyBkbwoJCQkJbG9jYWwgeCA9IDAgKyAoaSAlIDQpICog
MTkKCQkJCWxvY2FsIHkgPSAyICsgKGkgXCA0KSAqIDE2CgkJCQlyZWN0ZmlsbCh4LHkseCsxNix5
KzEyLCBjdCA9PSBpIGFuZCAyOSBvciAxOCkKCQkJCXByaW50KHN0cmluZy5mb3JtYXQoIiUwMmki
LGkpLHgrNSx5KzIsMSkKCQkJCWlmIChwbGF5aW5nX3JvdyhpKSkgdGhlbgoJCQkJCWZvciBqPTAs
MiBkbwoJCQkJCQktLWNpcmNmaWxsKHgrNCtqKjQseSsxMCwuOCtjb3MoLWoqLjMrdCgpKjIpLCA3
KQoJCQkJCQlyZWN0ZmlsbCh4KzMraio0LHkrMTEseCs1K2oqNCx5KzExLW1heChjb3MoLWoqLjMr
dCgpKjMpKSoyLDcpCgkJCQkJZW5kCgkJCQllbmQKCQkJZW5kCgkJZW5kLAoJCQoJCXRhcD1mdW5j
dGlvbihzZWxmLCBtc2cpCgkJCWNoZWNrcG9pbnQoKQoJCQljdCA9IG1pZCgwLCBtc2cubXggXCAy
MCwgMykgKyAoKG1zZy5teS0yKSBcIDE2KSAqIDQKCQkJbW9kZSA9ICJ0cmFjayIKCQkJcmVmcmVz
aF9ndWkgPSB0cnVlCgkJZW5kCgl9Cgljb250YWluZXI6YXR0YWNoX3Njcm9sbGJhcnMoKQoJCglj
b250ZW50cy55ID0gLShjdFw0KSAqIDEyICsgMjAKCgktLSBjbGFtcAoJY29udGVudHMueSA9IG1p
ZCgwLCBjb250ZW50cy55LCAtIChjb250ZW50cy5oZWlnaHQgLSBjb250YWluZXIuaGVpZ2h0KSkK
CQplbmQKCmZ1bmN0aW9uIGNyZWF0ZV9wYXR0ZXJuX2Nob29zZXIoZWwpCgoJbG9jYWwgY29udGFp
bmVyID0gZWw6YXR0YWNoewoJCXg9Mix5PTEwLHdpZHRoPWVsLndpZHRoLTIsaGVpZ2h0PWVsLmhl
aWdodC0xMSwKCQlkcmF3PWZ1bmN0aW9uKHNlbGYpCgkJCS0tIHNvbWUgcGFyZW50IHR1cm5lZCBj
bGlwcGluZyBvZmY7IGNhbiB0dXJuIGJhY2sgb24gaGVyZQoJCQljbGlwKHNlbGYuc3gsc2VsZi5z
eSxzZWxmLndpZHRoLHNlbGYuaGVpZ2h0KQoJCWVuZAoJfQoJbG9jYWwgY29udGVudHMgPSBjb250
YWluZXI6YXR0YWNoewoJCXg9MCx5PTAsd2lkdGg9ODYsaGVpZ2h0PTIwMCwKCQlkcmF3PWZ1bmN0
aW9uKHNlbGYpCgkJCWxvY2FsIHBsYXlpbmdfcGF0dGVybiA9IHN0YXQoNDY2KQoJCQlmb3IgaT0w
LDYzIGRvCgkJCQlsb2NhbCB4ID0gMCArIChpICUgNCkgKiAxOQoJCQkJbG9jYWwgeSA9IDIgKyAo
aSBcIDQpICogMTIKCQkJCXJlY3RmaWxsKHgseSx4KzE2LHkrOCwgY3AgPT0gaSBhbmQgMTQgb3Ig
MSkKCQkJCXJlY3QoeCx5LHgrMTYseSs4LCBjcCA9PSBpIGFuZCAxNCBvciAxMykKCQkJCQoJCQkJ
cHJpbnQoc3RyaW5nLmZvcm1hdCgiJTAyaSIsaSkseCs1LHkrMiwgY3AgPT0gaSBhbmQgMSBvciAx
OCkKCQkJCQoJCQkJaWYgKHBsYXlpbmdfcGF0dGVybiA9PSBpKSB0aGVuCgkJCQkJZm9yIGo9MCwy
IGRvCgkJCQkJCXJlY3RmaWxsKHgrMytqKjQseSs5LHgrNStqKjQseSs5LW1heChjb3MoLWoqLjMr
dCgpKjMpKSoyLDcpCgkJCQkJZW5kCgkJCQllbmQKCQkJCQoJCQllbmQKCQllbmQsCgkJCgkJdGFw
PWZ1bmN0aW9uKHNlbGYsIG1zZykKCQkJY2hlY2twb2ludCgpCgkJCWNwID0gbWlkKDAsIG1zZy5t
eCBcIDIwLCAzKSArICgobXNnLm15LTIpIFwgMTIpICogNAoJCQltb2RlID0gInBhdHRlcm4iCgkJ
CXJlZnJlc2hfZ3VpID0gdHJ1ZQoJCWVuZAoJfQoJY29udGFpbmVyOmF0dGFjaF9zY3JvbGxiYXJz
KCkKCQoJY29udGVudHMueSA9IC0oY3BcNCkgKiAxMiArIDIwCgoJLS0gY2xhbXAKCWNvbnRlbnRz
LnkgPSBtaWQoMCwgY29udGVudHMueSwgLSAoY29udGVudHMuaGVpZ2h0IC0gY29udGFpbmVyLmhl
aWdodCkpCgkKZW5kCgpmdW5jdGlvbiBjcmVhdGVfdm9sdW1lX2Nob29zZXIoeCwgeSkKCWxvY2Fs
IGVsID17CgkJeCA9IHgsIHkgPSB5LCB3aWR0aD00MiwgaGVpZ2h0ID0gNywKCQljdXJzb3IgPSAi
cG9pbnRlciIKCX0KCWZ1bmN0aW9uIGVsOmRyYXcoKQoJCWNsaXAoKQoJCXByaW50KCJcMDE0dm9s
IiwtMTUsMSwxKQoJCWZvciBpPTAsNiBkbwoJCQlsb2NhbCBzeCA9IGkgKiA1CgkJCXJlY3RmaWxs
KHN4LDAsc3grNCw2LCAoaSsxKSoweDggPT0gY3ZvbCBhbmQgNiBvciAxMykKCQkJLS1wcmludCgi
XDAxNCIuLihpKzEpLHN4KzEsMSwxMykKCQllbmQKCWVuZAoJZnVuY3Rpb24gZWw6ZHJhZyhtc2cp
CgkJY3ZvbCA9IG1pZCgxLCgxKyhtc2cubXhcNSkpLDcpKjB4OAoJZW5kCgkKCXJldHVybiBlbApl
bmQKCiAKZnVuY3Rpb24gY3JlYXRlX29jdGF2ZV9jaG9vc2VyKHgsIHkpCglsb2NhbCBlbCA9ewoJ
CXggPSB4LCB5ID0geSwgd2lkdGg9NDIsIGhlaWdodCA9IDcsCgkJY3Vyc29yID0gInBvaW50ZXIi
Cgl9CglmdW5jdGlvbiBlbDpkcmF3KCkKCQljbGlwKCkKCQlwcmludCgiXDAxNG9jdCIsLTE1LDEs
MSkKCQlmb3IgaT0wLDYgZG8KCQkJbG9jYWwgc3ggPSBpICogNQoJCQlyZWN0ZmlsbChzeCwwLHN4
KzQsNixpKzEgPT0gY29jdCBhbmQgNiBvciAxMykKCQkJcHJpbnQoIlwwMTQiLi4oaSsxKSxzeCsx
LDEsaSsxID09IGNvY3QgYW5kIDEzIG9yIDEzKQoJCWVuZAoJZW5kCglmdW5jdGlvbiBlbDpkcmFn
KG1zZykKCQljb2N0ID0gbWlkKDEsMSsobXNnLm14XDUpLDcpCgllbmQKCQoJcmV0dXJuIGVsCmVu
ZAoKCmZ1bmN0aW9uIGdlbmVyYXRlX2d1aV90cmFjaygpCgoJbG9jYWwgeHggPSA5MgoJdHJhY2tf
cGFuZSA9IGd1aTphdHRhY2goY3JlYXRlX3BhbmUoIlxmNnNmeCAiLi5jdCx4eCw0LDM4NCw4Miww
eDEwMDEpKQoJCglsb2NhbCB0cmFja19hZGRyID0gMHg1MDAwMCArIGN0ICogMzI4CgktLSBkb24n
dCBleHBvc2UgbGVuZ3RoIGZvciBub3c7IGFsd2F5cyA2NAoJLS0gZnV0dXJlOiB3aGVuIGNoYW5n
ZSBsZW4sIG5lZWQgdG8gdXBkYXRlIHN0cmlkZSB0byBtYXRjaCEKCS0tdHJhY2tfcGFuZTphdHRh
Y2goY3JlYXRlX3RpbnlfbnVtX2ZpZWxkKCJsZW4iLCAgdHJhY2tfYWRkciArIDAsMTAwLDEpKQoJ
Cgl0cmFja19wYW5lOmF0dGFjaChjcmVhdGVfb2N0YXZlX2Nob29zZXIoIDc1LDEpKQoJdHJhY2tf
cGFuZTphdHRhY2goY3JlYXRlX3ZvbHVtZV9jaG9vc2VyKDE0NSwxKSkKCQotLSBpcyBub3QganVz
dCBwbGF5IGxlbmd0aCAtLSBkaWN0YXRlcyBob3cgZGF0YSBpcyBhcnJhbmdlZCAoc3RyaWRlIGJl
dHdlZW4gY29sdW1ucykKLS0JdHJhY2tfcGFuZTphdHRhY2goY3JlYXRlX3RpbnlfbnVtX2ZpZWxk
KCJsZW4iLCAgdHJhY2tfYWRkciArIDAsMjMwLDEsICAxLDY0KSkKCgl0cmFja19wYW5lOmF0dGFj
aChjcmVhdGVfdGlueV9udW1fZmllbGQoInNwZCIsICB0cmFja19hZGRyICsgMiwyNjAsMSkpCgl0
cmFja19wYW5lOmF0dGFjaChjcmVhdGVfdGlueV9udW1fZmllbGQoImxvb3AwIiwgdHJhY2tfYWRk
ciArIDMsMzEwLDEpKQoJdHJhY2tfcGFuZTphdHRhY2goY3JlYXRlX3RpbnlfbnVtX2ZpZWxkKCJs
b29wMSIsdHJhY2tfYWRkciArIDQsMzYwLDEpKQoJCgkKCS0tIDggc2VnbWVudHMgb2Ygc2FtZSB0
cmFjawoJZm9yIGk9MCw3IGRvCgkJdHJhY2tfcGFuZTphdHRhY2goY3JlYXRlX3RyYWNrX3NlZ21l
bnR7CgkJCXg9MiArIGkgKiA0OCwgeT0xMiwgcm93cz04LAoJCQlyb3cwID0gaSo4LAoJCQlpbmRl
eCA9IGN0IC0tIHNmeF9pbmRleAoJCX0pCgllbmQKCQoJZ3VpOmF0dGFjaChjcmVhdGVfcGFuZSgi
XGY2cGl0Y2ggIix4eCw5MCwzODQsODgsMHgxMDAwKSkKCQk6YXR0YWNoKGNyZWF0ZV9waXRjaF9z
Y3JpYmJsZXJ7CgkJCXg9MCx5PTEwLHdpZHRoPTM4NCxoZWlnaHQ9NzYsYWRkcj10cmFja19hZGRy
ICsgOCxzdHJpZGU9NjR9KQoJCglndWk6YXR0YWNoKGNyZWF0ZV9wYW5lKCJcZjZ2b2x1bWUgIix4
eCwxODAsMzg2LDc2LDB4MTAwMCkpCgkJOmF0dGFjaChjcmVhdGVfdm9sdW1lX3NjcmliYmxlcnsK
CQkJeD0wLHk9MTAsd2lkdGg9Mzg0LGhlaWdodD02NixhZGRyPXRyYWNrX2FkZHIgKyA4ICsgMTI4
LHN0cmlkZT02NH0pCgkKZW5kCgpsb2NhbCBmdW5jdGlvbiBjcmVhdGVfZmxvd190b2dnbGUoZWwp
CgllbC53aWR0aCA9IDcKCWVsLmhlaWdodCA9IDcKCWVsLmN1cnNvciA9ICJwb2ludGVyIgoJbG9j
YWwgYWRkciA9IDB4MzAxMDAgKyBjcCoyMCs4CglmdW5jdGlvbiBlbDpkcmF3KCkKCQlwb2tlKDB4
MzAxMDAgKyBjcCoyMCs4KQoJCWxvY2FsIHNlbGVjdGVkID0gKHBlZWsoYWRkcikgJiBlbC5iaXQp
ID4gMAoJCS0tcmVjdGZpbGwoMCwwLDYsNixzZWxlY3RlZCBhbmQgMTAgb3IgMTMpCgkJcGFsKDcs
IHNlbGVjdGVkIGFuZCAxMCBvciAxKQoJCXNwcihlbC5pY29uLDAsMCkKCQlwYWwoKQoJCgllbmQK
CWZ1bmN0aW9uIGVsOnRhcCgpCgkJcG9rZShhZGRyLCBwZWVrKGFkZHIpIF5eIGVsLmJpdCkKCWVu
ZAoJcmV0dXJuIGVsCmVuZAoKZnVuY3Rpb24gZ2VuZXJhdGVfZ3VpX3BhdHRlcm4oKQoKCWxvY2Fs
IHBhbmUgPSBndWk6YXR0YWNoKGNyZWF0ZV9wYW5lKCJcZjZwYXR0ZXJuICIuLmNwLDkyLDQsMzg0
KzQsMjUyLDB4MTAwMSkpCgkKCglwYW5lOmF0dGFjaChjcmVhdGVfb2N0YXZlX2Nob29zZXIoIDc1
LDEpKQoJcGFuZTphdHRhY2goY3JlYXRlX3ZvbHVtZV9jaG9vc2VyKDE0NSwxKSkKCgoKCS0tIHBs
YXliYWNrIGZsb3cgZmxhZyB0b2dnbGVzOiBzdGFydCwgZW5kLCBzdG9wCgkKCXBhbmU6YXR0YWNo
KGNyZWF0ZV9mbG93X3RvZ2dsZXsKCQl4ID0gMzUwLCB5ID0gMSwgYml0ID0gMHgxLCBpY29uID0g
Z2V0X3Nwcig1OCkKCX0pCglwYW5lOmF0dGFjaChjcmVhdGVfZmxvd190b2dnbGV7CgkJeCA9IDM2
MCwgeSA9IDEsIGJpdCA9IDB4MiwgaWNvbiA9IGdldF9zcHIoNTkpCgl9KQoJcGFuZTphdHRhY2go
Y3JlYXRlX2Zsb3dfdG9nZ2xlewoJCXggPSAzNzAsIHkgPSAxLCBiaXQgPSAweDQsIGljb24gPSBn
ZXRfc3ByKDYwKQoJfSkKCQoJCglsb2NhbCBjb250YWluZXIgPSBwYW5lOmF0dGFjaHsKCQl4PTAs
eT0yNCx3aWR0aD1wYW5lLndpZHRoLGhlaWdodD0yMjgsCgkJZHJhdz1mdW5jdGlvbigpCWVuZCAt
LSB0byBnZXQgY2xpcHBpbmcKCX0KCglsb2NhbCBjb250ZW50cyA9IGNvbnRhaW5lcjphdHRhY2h7
CgkJeD0wLCB5PTAsIHdpZHRoPXBhbmUud2lkdGgsIGhlaWdodD01MjAsCgkJZHJhdyA9IGZ1bmN0
aW9uKCkKCQkJLS0gbWFya2VycyBzaG93aW5nIHJvd3MKCQkJLS1bWwoJCQlmaWxscCgweGYwMDAp
CgkJCWZvciBpPTAsNywyIGRvCgkJCQlyZWN0ZmlsbCgwLGkqNjQsIDEwMDAsaSo2NCs2NCwxNitp
LzIpCQoJCQllbmQKCQkJZmlsbHAoKQoJCQldXQoJCWVuZAoJCQoJfQoJCgktLSB3aG9sZSB0cmFj
ayBmb3IgZWFjaCBjaGFubmVsCglsb2NhbCBjaGFuX21hc2sgPSBwZWVrKDB4MzAxMDAgKyBjcCAq
IDIwICsgOSkKCWZvciBpPTAsNyBkbwoJCgkJbG9jYWwgc3ggPSAyICsgaSo0NwoJCWxvY2FsIHN5
ID0gMTMKCQlsb2NhbCB3dyA9IDcKCQkKCQlpZiAoY2hhbl9tYXNrICYgKDEgPDwgaSkgPiAwKSB0
aGVuCgkJCXBhbmU6YXR0YWNoKAoJCQkJY3JlYXRlX3RpbnlfbnVtX2ZpZWxkKCIiLDB4MzAxMDAg
KyBjcCAqIDIwICsgaSwgc3grMTUsIHN5KQoJCQkpCgkJZWxzZQoJCQl3dyA9IDI0CgkJZW5kCgkJ
CgkJLS0gdG9nZ2xlIGNoYW5uZWwgYml0CgkJcGFuZTphdHRhY2h7CgkJCXggPSBzeCs1LCB5ID0g
c3ksCgkJCXdpZHRoPXd3LCBoZWlnaHQgPSA3LAoJCQlkcmF3PWZ1bmN0aW9uKHNlbGYpCgkJCQly
ZWN0KDAsMCw2LDYsNSkKCQkJCWlmIChjaGFuX21hc2sgJiAoMSA8PCBpKSA_IDApIHRoZW4KCQkJ
CQlyZWN0KDAsMCw2LDYsMTYpCgkJCQkJcmVjdGZpbGwoMiwyLDQsNCw2KQoJCQkJZWxzZQoJCQkJ
CXJlY3RmaWxsKDksMCwyNCw3LCAwKQoJCQkJZW5kCgkJCQkKCQkJZW5kLAoJCQl0YXA9ZnVuY3Rp
b24oKQoJCQkJY2hhbl9tYXNrIF5ePSAoMSA8PCBpKQoJCQkJcG9rZSgweDMwMTAwICsgY3AqMjAr
OSwgY2hhbl9tYXNrKQoJCQkJcmVmcmVzaF9ndWkgPSB0cnVlCgkJCWVuZAoJCX0KCQkKCQktLSBl
ZGl0IHRyYWNrCgkJcGFuZTphdHRhY2h7CgkJCXggPSBzeCszMywgeSA9IHN5LAoJCQl3aWR0aD13
dywgaGVpZ2h0ID0gNywgY3Vyc29yPSJwb2ludGVyIiwKCQkJZHJhdz1mdW5jdGlvbihzZWxmKQoJ
CQkJc3ByKDIzLDAsMCkKCQkJZW5kLAoJCQl0YXA9ZnVuY3Rpb24oKQoJCQkJbW9kZT0idHJhY2si
CgkJCQljdD1wZWVrKDB4MzAxMDAgKyBjcCAqIDIwICsgaSkKCQkJCXJlZnJlc2hfZ3VpID0gdHJ1
ZQoJCQllbmQKCQl9CgkKCQkKCQlpZiAoY2hhbl9tYXNrICYgKDEgPDwgaSkgPiAwKSB0aGVuCgkJ
CWNvbnRlbnRzOmF0dGFjaChjcmVhdGVfdHJhY2tfc2VnbWVudHsKCQkJCXg9IHN4LCB5PTAsIHJv
d3M9NjQsCgkJCQlsaXZlX2luZGV4ID0gdHJ1ZSwKCQkJCWNoYW5faSA9IGksCgkJCQlpbmRleCA9
IHBlZWsoMHgzMDEwMCArIGNwICogMjAgKyBpKSAtLSB0cmFjayAoc2Z4KSBpbmRleAoJCQl9KQoJ
CWVsc2UKCQkJLS0gZHVtbXkKCQkJY29udGVudHM6YXR0YWNoewoJCQkJeD1zeCwgeT0wLAoJCQkJ
d2lkdGggPSA0NCwgaGVpZ2h0ID0gNjQgKiA4ICsgMiwgLS0gbWF0Y2ggc2l6ZSBpbiBjcmVhdGVf
dHJhY2tfc2VnbWVudAoJCQkJZHJhdyA9IGZ1bmN0aW9uKHNlbGYpCgkJCQkJcmVjdGZpbGwoMCww
LHNlbGYud2lkdGgtMSxzZWxmLmhlaWdodC0xLCAwKQoJCQkJCS0tcmVjdCgwLDAsc2VsZi53aWR0
aC0xLHNlbGYuaGVpZ2h0LTEsIDUpCgkJCQllbmQKCQkJfQoJCWVuZAoJCQoJCS0tIGp1bXAgdG8g
Y2hhbm5lbCBwZW5jaWwKCWVuZAoJCgljb250YWluZXI6YXR0YWNoX3Njcm9sbGJhcnMoKQoJCQoJ
CgplbmQKCgoKCmZ1bmN0aW9uIGdlbmVyYXRlX2d1aSgpCgkKCWd1aSA9IGNyZWF0ZV9ndWkoKQoK
CS0tIG1vZGUgYnV0dG9ucwoJCglsb2NhbCBtb2RlX2xhYmVsPXtbMF09Imluc3QiLCJzZngiLCJw
YXQifQoJbG9jYWwgbW9kZV9uYW1lID17WzBdPSJpbnN0cnVtZW50IiwidHJhY2siLCJwYXR0ZXJu
In0KCQoJZm9yIGk9MCwyIGRvCgkJZ3VpOmF0dGFjaHsKCQkJeD0yICsgaSoyOSx5PTQsCgkJCXdp
ZHRoPTI3LGhlaWdodD0xNiwKCQkJbGFiZWw9bW9kZV9sYWJlbFtpXSwKCQkJbW9kZT1tb2RlX25h
bWVbaV0sCgkJCWRyYXc9ZnVuY3Rpb24oc2VsZikKCQkJCWxvY2FsIHNlbCA9IHNlbGYubW9kZT09
bW9kZQoJCQkJcmVjdGZpbGwoMCwwLHNlbGYud2lkdGgtMSxzZWxmLmhlaWdodC0xLCBzZWwgYW5k
IDE0IG9yIDEpCgkJCQlwcmludChzZWxmLmxhYmVsLHNlbGYud2lkdGgvMiAtICNzZWxmLmxhYmVs
KjIsIDYsc2VsIGFuZCA3IG9yIDEzKQoJCQllbmQsCgkJCXRhcD1mdW5jdGlvbihzZWxmKQoJCQkJ
Y2hlY2twb2ludCgpCgkJCQltb2RlID0gc2VsZi5tb2RlCgkJCQlyZWFkdGV4dCh0cnVlKSAtLSBj
bGVhciBidWZmZXIKCQkJCXJlZnJlc2hfZ3VpID0gdHJ1ZQoJCQllbmQKCQl9CgllbmQKCQoKCWxv
Y2FsIHl5ID0gMjQgLS0gMjQKCWxvY2FsIHd3ID0gODYgCglsb2NhbCBwY29sID0gbW9kZSA9PSAi
aW5zdHJ1bWVudCIgYW5kIDB4MGUwMSBvciAweDA3MDEKCWxvY2FsIGVsID0gZ3VpOmF0dGFjaChj
cmVhdGVfcGFuZSgiaW5zdHJ1bWVudHMiLDIseXksd3csNzYsIHBjb2wpKQoJY3JlYXRlX2luc3Ry
dW1lbnRfY2hvb3NlcihlbCkKCXl5ICs9IGVsLmhlaWdodCArIDQKCQoJcGNvbCA9IG1vZGUgPT0g
InRyYWNrIiBhbmQgMHgwZTAxIG9yIDB4MDcwMQoJbG9jYWwgZWwgPSBndWk6YXR0YWNoKGNyZWF0
ZV9wYW5lKCJzZngiLDIseXksd3csNzYscGNvbCkpCgljcmVhdGVfdHJhY2tfY2hvb3NlcihlbCkK
CXl5ICs9IGVsLmhlaWdodCArIDQKCQoJcGNvbCA9IG1vZGUgPT0gInBhdHRlcm4iIGFuZCAweDBl
MDEgb3IgMHgwNzAxCglsb2NhbCBlbCA9IGd1aTphdHRhY2goY3JlYXRlX3BhbmUoInBhdHRlcm5z
IiwyLHl5LHd3LDcyLHBjb2wpKQoJY3JlYXRlX3BhdHRlcm5fY2hvb3NlcihlbCkKCQoKCWlmICht
b2RlID09ICJpbnN0cnVtZW50IikgZ2VuZXJhdGVfZ3VpX2luc3RydW1lbnQoKQoJaWYgKG1vZGUg
PT0gInRyYWNrIikgICAgICBnZW5lcmF0ZV9ndWlfdHJhY2soKQoJaWYgKG1vZGUgPT0gInBhdHRl
cm4iKSAgICBnZW5lcmF0ZV9ndWlfcGF0dGVybigpCgkKZW5kCgpmdW5jdGlvbiBnZW5lcmF0ZV9n
dWlfaW5zdHJ1bWVudCgpCgkKCS0tIGFkZCBub2RlcyB0byBhIHNjcm9sbGFibGUgYXJlYQoJCgls
b2NhbCBub2RlX2NvbnRhaW5lciA9IGd1aTphdHRhY2h7CgkKCQl4ID0gOTYsIHkgPSA0LCB3aWR0
aCA9IDI3MiwgaGVpZ2h0ID0gMjUyLAoKCQltb3VzZXdoZWVsID0gZnVuY3Rpb24oc2VsZiwgbXNn
KQoJCQlzZWxmLmNoaWxkWzFdLnkgKz0gbXNnLndoZWVsX3kgKiAxNgoJCQlzZWxmLmNoaWxkWzFd
LnkgPSBtaWQoMCwgc2VsZi5jaGlsZFsxXS55LCBzZWxmLmhlaWdodCAtIHNlbGYuY2hpbGRbMV0u
aGVpZ2h0KQoJCQlsYXN0X25vZGVfY29udGVudF9pbnN0ID0gY2kKCQkJbGFzdF9ub2RlX2NvbnRl
bnRfeSA9IHNlbGYuY2hpbGRbMV0ueQoJCWVuZCwKCQkKCQlkcmFnID0gZnVuY3Rpb24oc2VsZiwg
bXNnKQoJCQlzZWxmLmNoaWxkWzFdLnkgKz0gbXNnLmR5CgkJCXNlbGYuY2hpbGRbMV0ueSA9IG1p
ZCgwLCBzZWxmLmNoaWxkWzFdLnksIHNlbGYuaGVpZ2h0IC0gc2VsZi5jaGlsZFsxXS5oZWlnaHQp
CgkJCWxhc3Rfbm9kZV9jb250ZW50X2luc3QgPSBjaQoJCQlsYXN0X25vZGVfY29udGVudF95ID0g
c2VsZi5jaGlsZFsxXS55CgkJZW5kLAoJCQoJCXVwZGF0ZSA9IGZ1bmN0aW9uKHNlbGYpCgkJCS0t
aWYgKHNlbGYuY2hpbGRbMV0pIHNlbGYuY2hpbGRbMV0ueSArPSAxCgkJZW5kCgl9CgkKCWxvY2Fs
IG5vZGVfY29udGVudCA9IG5vZGVfY29udGFpbmVyOmF0dGFjaHsKCQl4PTAseT0wLHdpZHRoPTIw
MCxoZWlnaHQ9MzAwCgl9CgoJbG9jYWwgeXkgPSAwCglub2RlX2RlcHRoPXt9CgkKCWZvciBpPTAs
NyBkbwoJCgkJbG9jYWwgaW5zdF9hZGRyID0gMHg0MDAwMCArIGNpKjB4MjAwCgkJbG9jYWwgbm9k
ZV9hZGRyID0gaW5zdF9hZGRyICsgaSoweDIwCgkJbG9jYWwgbm9kZV90eXBlID0gcGVlayhub2Rl
X2FkZHIrMSkgJiAweGYKCQlsb2NhbCBub2RlX3BhcmVudCA9IHBlZWsobm9kZV9hZGRyKzApICYg
MHg3CgkJCgkJbm9kZV9kZXB0aFtpXSA9IG5vZGVfZGVwdGhbbm9kZV9wYXJlbnRdIGFuZCBub2Rl
X2RlcHRoW25vZGVfcGFyZW50XSsxIG9yIDAKCQlpZiAobm9kZV90eXBlID09IDApIG5vZGVfZGVw
dGhbaV0gPSAtMQoJCQoJCWxvY2FsIHgwID0gbm9kZV9kZXB0aFtpXSAqIDgKCQoJCWlmIChub2Rl
X3R5cGUgPiAwKSB0aGVuCgkJCWxvY2FsIG4gPSBub2RlX2NvbnRlbnQ6YXR0YWNoKGNyZWF0ZV9u
b2RlX2VkaXRvcihpLCB4MCwgeXkpKQoJCQlpZiAoaSA9PSAwKSB0aGVuCgkJCQluOmF0dGFjaChj
cmVhdGVfb2N0YXZlX2Nob29zZXIoODAsMSkpCgkJCQluOmF0dGFjaChjcmVhdGVfdm9sdW1lX2No
b29zZXIoMTQ1LDEpKQoJCQllbmQKCQkJeXkgKz0gbi5oZWlnaHQgKyA0CgkJZW5kCgkJCgkJbm9k
ZV9jb250ZW50LmhlaWdodCA9IG1heCh5eSArIDE2LCBub2RlX2NvbnRhaW5lci5oZWlnaHQpCgkJ
CgkJCgllbmQKCQoJCgkKCgktLSBlbnZlbG9wZXMKCWxvY2FsIGVudl9jb250ZW50ID0gZ3VpOmF0
dGFjaHsKCQl4PTM5Nix5PTAsd2lkdGg9MTAwLGhlaWdodD0zMDAKCX0KCWxvY2FsIHl5ID0gNAoJ
Zm9yIGk9MCwzIGRvCgkJbG9jYWwgaW5zdF9hZGRyID0gMHg0MDAwMCArIGNpKjB4MjAwCgkJbG9j
YWwgZW52X2FkZHIgPSBpbnN0X2FkZHIgKyAyNTYgKyBpICogMjQKCQlsb2NhbCBlID0gZW52X2Nv
bnRlbnQ6YXR0YWNoKGNyZWF0ZV9lbnZfZWRpdG9yKGksZW52X2FkZHIsImVudi0iLi5pLDAseXks
ODApKQoJCXl5ICs9IGUuaGVpZ2h0ICsgNAoJZW5kCgkKCQoJLS0gcHJlc2VydmUgbm9kZSBjb250
ZW50IHNjcm9sbCBwb3NpdGlvbgoJLS0gdG8gZG86IGZpbmQgYSBsZXNzIHNpbGx5IHdheSB0byBk
byB0aGlzCglpZiAobGFzdF9ub2RlX2NvbnRlbnRfaW5zdCA9PSBjaSkgdGhlbgoJCW5vZGVfY29u
dGVudC55ID0gbGFzdF9ub2RlX2NvbnRlbnRfeQoJZW5kCgkKZW5kCgoKOjogaW5zdC5sdWEKLS1b
W3BvZF9mb3JtYXQ9InJhdyIsY3JlYXRlZD0iMjAyMy0xMC0yNyAxODoxNjozOCIsbW9kaWZpZWQ9
IjIwMjQtMDQtMjggMDg6NDI6MDAiLHJldmlzaW9uPTM1NjFdXQoKLS0gMHgxNzAyCmxvY2FsIG5v
ZGVfdHlwZV9jb2wgPSB7CglbMF09MHgxLDB4MGUwNSwweDA3MDUsMHg1LAoJMCwwLDAsMCwKCTB4
MGMwNSwweDBjMDUsMHgwYzA1LDB4MGMwNSwKCS0tMHgxMTA1LDB4MGMwNSwweDE5MDUsMHgwODA1
LAp9CgotLSBsYWJlbHM6IG1heCA1IGNoYXJzICg0IHByZWZlcnJlZCkKCmZ1bmN0aW9uIGNyZWF0
ZV9tdmFsX2tub2IobGFiZWwsbm9kZV90eXBlLG12YWxfaW5kZXgsYWRkcix4LHkpCgoJbG9jYWwg
ZWwgPSB7CgkJeCA9IHgsIHkgPSB5LCAKCQl3aWR0aCA9IDU0LCAtLSBpbmNsdWRlcyB0aGUgbnVt
YmVyIGJveDsgYW5kIGVudmVsb3BlIGNvbm5lY3Rpb24KCQloZWlnaHQgPSAyMCwKCQlsYWJlbD1s
YWJlbCwKCQlhZGRyPWFkZHIsCgkJbXZhbF9pbmRleD1tdmFsX2luZGV4LAoJCXYwID0gLTEyOCwg
djEgPSAxMjcsIC0tIGVkaXRhYmxlIHJhbmdlIGZvciBzaWduZWQgdmFsdWVzCgkJdnogPSAwLCAt
LSAiemVybyIgLS0gd2hlcmUgdG8gZmlsbCBwaWUgZnJvbSAvIHVudGlsCgkJYWMgPSAxLCAtLSBh
bmdsZSBjb2VmZmljaWVudCAobm90Y2ggYW5nbGUpCgkJYTAgPSAwLjAsCgkJLS0gY3Vyc29yID0g
ImdyYWIiLCAtLSB0byBkbzogc2hvdWxkbid0IHNldCBjdXJzb3Igd2hpbGUgZHJhZyBvdXRzaWRl
IG9mIGVsZW1lbnQKCQlub2RlX2NvbCA9IG5vZGVfdHlwZV9jb2xbbm9kZV90eXBlXSwKCQljbGlj
ayA9IGNoZWNrcG9pbnQsCgkJZHZhbCA9IDAsCgkJLS1jdXJzb3I9ImdyYWIiIC0tIHRvIGRvOiBk
aWFsIHNwaW5uaW5nIGN1cnNvciB0aGF0IGRpc2FwcGVhcnMKCX0KCQoJaWYgKGxhYmVsID09ICJ2
b2wiKSBlbC52MCwgZWwudjEgPSAwLCA2NAoJCgktLSBtYXliZSBsYXRlcgoJLS1pZiAobGFiZWwg
PT0gInR1bmUiKSBlbC52MCxlbC52MSA9IC0xMjAsIDEyMCBlbC5hYyA9IDIwIGVsLmEwID0gMC41
CglpZiAobGFiZWwgPT0gIndhdmUiKSBlbC52MCxlbC52MSA9IDAsIDI1NQoJCgktLSBmeCBwYXJh
bWV0ZXJzIGFyZSBhbGwgMC4uMjU1IChmbGFnIDB4OCBpcyBub3Qgc2V0KQoJaWYgKG5vZGVfdHlw
ZSA_PSA4KSBlbC52MCxlbC52MSA9IDAsIDI1NQoJCQoJLS0gZ2FpbiBtaXg7IGNhbiB1c2UgKjgg
aWYgd2FudCB0byBvdmVyIG1peCEKCWlmIChsYWJlbCA9PSAibWl4IikgZWwudjAsIGVsLnYxID0g
MCwgNjQKCQoJCgkKCWZ1bmN0aW9uIGVsOmRyb3BfZW52X3BsdWcobXNnKQoJCS0tcHJpbnRoKCJz
ZXR0aW5nICIuLnBvZChtc2cpKQoJCXBva2UoYWRkciszLCBtc2cuaW5kZXgpCgkJLS1zZXQgb2Jz
ZXJ2ZV9lbnZlbG9wZSBiaXQKCQlwb2tlKGFkZHIsIHBlZWsoYWRkcikgfCAweDQpCgllbmQKCQoJ
CglmdW5jdGlvbiBlbDpkcmF3KCkKCQoJCS0tcmVjdGZpbGwoMCwwLDEwMDAsMTAwMCw4K2FkZHIv
NCkKCQkJCgkJbG9jYWwgeHgseXkgPSA4LjUsNi41CgkJCgkJY2lyY2ZpbGwoeHgtMSx5eSsxLDcs
KHNlbGYubm9kZV9jb2wmMHg1ID09IDUpIGFuZCAxIG9yIDIxKQoJCWNpcmNmaWxsKHh4LHl5LDcs
MCkKCQkKCQktLSBkcmF3IG12YWwJCgkJbG9jYWwgZmxhZ3MsdmFsMSx2YWwwLGVudiA9IHBlZWso
YWRkciw0KQoJCWxvY2FsIG51bSA9IDEgKyB2YWwxICUgMTYKCQlsb2NhbCBkZW4gPSAxICsgdmFs
MSBcIDE2CgkJCgkJCgkJaWYgKGVsLnYxIDwgMTI4KSB0aGVuIC0tIHNpZ25lZCBpbnQ4J3MKCQkJ
aWYgKHZhbDEgPj0gMTI4KSB2YWwxIC09IDI1NgoJCQlpZiAodmFsMCA_PSAxMjgpIHZhbDAgLT0g
MjU2CgkJZW5kCgkJCgkJbG9jYWwgcmFuZ2UgPSBzZWxmLnYxIC0gc2VsZi52MAoJCQoJCS0tIDAu
NyAtIDAuOSAqIC4uCgkJLS1sb2NhbCBwMCxwMSA9IDAuNywwLjkgLS0gd2VkZ2UgYXQgYm90dG9t
CgkJbG9jYWwgcDAsIHAxID0gMC43NSwgMS4wIAoJCQoJCQoJCWxvY2FsIGEwID0gc2VsZi5hMCAr
IHAwIC0gcDEgKiAodmFsMSAtIHNlbGYudjApICogc2VsZi5hYyAvIHJhbmdlCgkJCgkJbG9jYWwg
YTEgPSBwMCAtIHAxICogKHZhbDAgLSBzZWxmLnYwKSAvIHJhbmdlCgkJCgkJCgkJLS1sb2NhbCBh
MSA9IHNlbGYuYTAgKyBwMCAtIChzZWxmLnZ6IC0gc2VsZi52MCkgKiBzZWxmLmFjICogcDEgLyBy
YW5nZQoJCgkJLS0gc2hvdyByYW5nZSAodG8gZG86IGRlY2lkZSBvbiBmbGFncyBmb3IgdGhhdCkK
CQljb2xvciAocGVlayhzZWxmLmFkZHIpICYgMHg0ID4gMCBhbmQgMTIgb3IgMTQpCgkJCgkJLS0g
KiogdG8gZG86IG9wdGltaXNlICoqCgkJaWYgKGZhbHNlKSB0aGVuICAKCQkJZm9yIGs9MCwxLDEv
KGFicyhhMS1hMCkqMzIpIGRvCgkJCQlsb2NhbCBhYSA9IGExKyhhMC1hMSkqawoJCQkJbGluZSh4
eCx5eSx4eCtjb3MoYWEpKjYsIHl5K3NpbihhYSkqNikKCQkJZW5kCgkJZW5kCgkJCgkJLS0gZG90
dHkgYXJjIHZlcnNpb24KCgkJbG9jYWwgYWEwLGFhMSA9IGEwLCBhMQoJCWlmIChhYTAgPiBhYTEp
IGFhMCxhYTEgPSBhYTEsYWEwCgkJZm9yIGFhID0gLS4yNSwgLjc1LCAxLzMyIGRvCgkJCWlmIChh
YSA_PSBhYTAgYW5kIGFhIDw9IGFhMSkgdGhlbgoJCQkJcHNldCh4eCtjb3MoYWEpKjUsIHl5K3Np
bihhYSkqNSkKCQkJZW5kCgkJZW5kCQkKCQkKCQlsaW5lKHh4K2NvcyhhMCkqMiwgeXkrc2luKGEw
KSoyLCB4eCtjb3MoYTApKjYsIHl5K3NpbihhMCkqNiwgNykKCgkJY2xpcCgpCgkJcHJpbnQoc2Vs
Zi5sYWJlbCwgLTIwLDQsNikKCQkKCQlyZWN0ZmlsbCh4eCs3LDIseHgrMzYsMTAsMCkKCQkKCQkt
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCgkJLS0gICBlbnZlbG9w
ZSBhc3NpZ25tZW50IHBsdWcgdG8gcmlnaHQgICAtLQoJCS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0KCQkKCQlpZiAocGVlayhzZWxmLmFkZHIpICYgMHg0ID4gMCkg
dGhlbgoJCQlyZWN0ZmlsbCh4eCszNywyLHh4KzQ0LDEwLDcpCgkJCXJlY3RmaWxsKHh4KzM3LDMs
eHgrNDUsOSw3KQoJCQkKCQkJaWYgKHBlZWsoc2VsZi5hZGRyKSAmIDB4OCA_IDApIHRoZW4KCQkJ
CXByaW50KHBlZWsoc2VsZi5hZGRyKzMpJjB4ZiwgeHgrNDAsIDMsIDEyKQoJCQkJcHJpbnQoIlxe
OjE1MDAwMDAwMDAwMDAwMDAiLHh4KzM5LDksMTIpIC0tIDMgZG90cwoJCQllbHNlCgkJCQlwcmlu
dChwZWVrKHNlbGYuYWRkciszKSYweGYsIHh4KzQwLCA0LCAxMikKCQkJZW5kCgkJZWxzZQoJCQkt
LSBjaG9vc2UgcmFuZG9tbHkgZnJvbSByYW5nZQoJCQlpZiAocGVlayhzZWxmLmFkZHIpICYgMHgx
MCA_IDApIHRoZW4KCQkJCXJlY3RmaWxsKHh4KzM3LDIseHgrNDQsMTAsMTQpCgkJCQlyZWN0Zmls
bCh4eCszNywzLHh4KzQ1LDksMTQpCgkJCQlwcmludCgiciIsIHh4KzQwLCA0LCA3KQoJCQllbmQK
CQllbmQKCQkKCQktLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCgkJ
LS0gICAgICBzY2FsZSB1bmRlcm5lYXRoIGF0IHJpZ2h0ICAgICAgICAtLQoJCS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KCQkKCQlsb2NhbCBzdmFsID0gcGVlayhz
ZWxmLmFkZHIrMykKCQkKCQlpZiAoc3ZhbCAmIDB4YzAgPiAwKSB0aGVuCgoJCQlzdHIyID0gKHN2
YWwgJiAweDIwID09IDApIGFuZCAKCQkJCSJcXjo1MDIwNTAwMDAwMDAwMDAwIiBvciAgLS0gKgoJ
CQkJIlxeOjQwMjAxMDAwMDAwMDAwMDAiICAgICAtLSAvCgkJCQoJCQlpZiAoc3ZhbCAmIDB4YzAg
PT0gMHg0MCkgc3RyMiAuLj0gIlxeOjUwNzA0MDAwMDAwMDAwMDAiIC0tIDQKCQkJaWYgKHN2YWwg
JiAweGMwID09IDB4ODApIHN0cjIgLi49ICJcXjoxMzcyNzcwMDAwMDAwMDAwIiAtLSAxNgoJCQlp
ZiAoc3ZhbCAmIDB4YzAgPT0gMHhjMCkgc3RyMiAuLj0gIlxeOjUxNzc0NzAwMDAwMDAwMDAiIC0t
IDY0CgkJCQoJCQktLXJlY3RmaWxsKHh4KzI0LDExLHh4KzM2LDE1LDEzKQoJCQlwcmludChzdHIy
LCB4eCsyMCwxMiw3KQoJCWVuZAoJCQoJCS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0KCQktLSAgICAgdmFsdWUgYW5kIHBhcmVudCByZWxhdGlvbnNoaXAgICAgIC0t
CgkJLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQoJCQoJCWlmIChm
bGFncyAmIDB4MyA_IDApIHRoZW4KCQkJbG9jYWwgbGV0dGVyID0gIj8iCgkJCWlmIChmbGFncyAm
IDB4MyA9PSAweDEpIGxldHRlciA9ICIrIgoJCQlpZiAoZmxhZ3MgJiAweDMgPT0gMHgyKSBsZXR0
ZXIgPSAiKiIKCQkJcHJpbnQobGV0dGVyLDM1LTQqNCw0LDMpCgkJZW5kCgkJCgkJLS0gc2hvdyB2
YWx1ZQoJCWxvY2FsIHN0ciA9IHRvc3RyKHZhbDEpCgkJCgkJaWYgKGZsYWdzICYgMHgzID09IDIg
YW5kIGxhYmVsPT0idHVuZSIpIHRoZW4KCQkJLS0gbXVsdGlwbHkgYnkgcmF0aW8KCQkJLS0gb25s
eSBtYWtlcyBzZW5zZSBmb3IgcGl0Y2gKCQkJc3RyID0gbnVtLi4iLyIuLmRlbgoJCWVuZAoJCQoJ
CS0tIGV2ZXJ5dGhpbmcgZWxzZTogc2hvdyByYXcgdmFsdWUKCQlwcmludChzdHIsIHh4KzM1LSNz
dHIqNCwgNCwgMjcpCgkJCgkJY2lyYyh4eCx5eSw3LDEzKS0tc2VsZi5ub2RlX2NvbCYweGZmKQoJ
CS0tY2lyYyh4eCx5eSw4LG5vZGVfY29sJjB4ZmYpCgkJCgkJCgllbmQKCQoJLS0gdHVybiBtb3Vz
ZSBsb2NraW5nIG9uIHdoaWxlIGRyYWdnaW5nCglmdW5jdGlvbiBlbDpjbGljayhtc2cpCgkJbW91
c2Vsb2NrKDB4NHwweDgsIDAuNSwgMC4wNSkgLS0gMHg0IGxvY2sgMHg4IGF1dG8tcmVsZWFzZSwg
ZXZlbnQgc3BlZWQsIG1vdmUgc3BlZWQgCgllbmQKCQoJZnVuY3Rpb24gZWw6ZHJhZyhtc2cpCgkJ
bG9jYWwgZmxhZ3MsdmFsMSx2YWwwLGVudiA9IHBlZWsoYWRkciw0KQoJCgkJbG9jYWwgZHZhbCA9
IChtc2cuZHggLSBtc2cuZHkpCgkJCgkJaWYgKHNlbGYubGFiZWw9PSJ0dW5lIiBhbmQgKGZsYWdz
ICYgMykgPT0gMikgdGhlbgoJCQktLSBzcGVjaWFsIGNhc2U6IHVzZSB1OCBmb3IgaW50ZWdlciBm
cmFjdGlvbiBtb2RlCgkJCXZhbDEgPSBtaWQoMCwgdmFsMSArIGR2YWwsIDI1NSkKCQllbHNlCgkJ
CS0tIHNpZ25lZCBpbnQ4IGJlaGF2aW91cgoJCQlpZiAoZWwudjEgPCAxMjgpIHRoZW4gCgkJCQlp
ZiAodmFsMD49MTI4KSB2YWwwIC09IDI1NgoJCQkJaWYgKHZhbDE_PTEyOCkgdmFsMSAtPSAyNTYK
CQkJZW5kCgkJCQoJCQlpZiAobXNnLm1iID4gMSkgdGhlbgoJCQkJLS0gZHJhZyB2YWwwIChzdGFy
dCBvZiByYW5nZSkKCQkJCXZhbDAgPSBtaWQoc2VsZi52MCwgdmFsMCArIGR2YWwsIHNlbGYudjEp
CgkJCWVsc2UKCQkJCS0tIHJlZ3VsYXIgd2hpdGUgbmVlZGxlIGRyYWdnaW5nCgkJCQl2YWwxID0g
bWlkKHNlbGYudjAsIHZhbDEgKyBkdmFsLCBzZWxmLnYxKQoJCQllbmQJCgkJCgkJZW5kCgkJCgkJ
cG9rZShhZGRyKzEsdmFsMSkKCQlwb2tlKGFkZHIrMix2YWwwKQoJCXJldHVybiAxIC0tIGRvbid0
IGRyYWcgdGhlIG5vZGUgY29udGVudAoJZW5kCgkKCWZ1bmN0aW9uIGVsOnRhcChtc2cpCgkJY2hl
Y2twb2ludCgpCgkJbG9jYWwgZmxhZ3MsdmFsMSx2YWwwLGVudiA9IHBlZWsoYWRkciw0KQoJCQoJ
CS0tIHVzZSBzYW1lIGd1aSBlbCAvIGNhbiBzdGlsbCBncmFiIGFuZCBkcmFnIHZhbHVlIHdpdGhv
dXQKCQktLSBoYXZpbmcgdG8gYXZvaWQgdGhlIG9wZXJhdG9yIGFyZWEuIHVzdWFsbHkgb3BlcmF0
b3Igc3RheXMKCQktLSB1bnRvdWNoZWQsIHNvIHByZWZlcmFibGUgdG8gaGF2ZSBhIGxpdHRsZSBm
cmljdGlvbiB0byBjaGFuZ2UgaXQuCgkJCgkJaWYgKG1zZy5teSA_IDExIGFuZCBtc2cubXggPiAz
NCkgdGhlbgoJCQktLSBjaGFuZ2Ugc2NhbGUgYml0cwoJCQlsb2NhbCBjdHJsX2hlbGQgPSBrZXko
ImN0cmwiKQoJCQlsb2NhbCB2YWwgPSBwZWVrKGFkZHIrMykgJiAweGUwCgkJCWlmICh2YWwgPT0g
MCkgICAgICAgIHRoZW4gdmFsID0gMHgwMCB8IDB4NDAgLS0gKjQKCQkJZWxzZWlmICh2YWwgPT0g
MHg0MCkgdGhlbiB2YWwgPSAweDIwIHwgMHg0MCAtLSAvNAoJCQllbHNlaWYgKHZhbCA9PSAweDYw
IGFuZCBjdHJsX2hlbGQpIHRoZW4gdmFsID0gMHgwMCB8IDB4ODAgLS0gKjE2CgkJCWVsc2VpZiAo
dmFsID09IDB4ODAgYW5kIGN0cmxfaGVsZCkgdGhlbiB2YWwgPSAweDIwIHwgMHg4MCAtLSAvMTYK
CQkJZWxzZWlmICh2YWwgPT0gMHhhMCBhbmQgY3RybF9oZWxkKSB0aGVuIHZhbCA9IDB4MDAgfCAw
eGMwIC0tICo2NAoJCQllbHNlaWYgKHZhbCA9PSAweGMwIGFuZCBjdHJsX2hlbGQpIHRoZW4gdmFs
ID0gMHgyMCB8IDB4YzAgLS0gLzY0CgkJCWVsc2UgdmFsID0gMCBlbmQKCQkJcG9rZShhZGRyKzMs
KHBlZWsoYWRkciszKSAmIH4weGUwKSB8IHZhbCkKCQllbHNlaWYgKG1zZy5teCA_PSAxOCBhbmQg
bXNnLm14IDw9IDI0KSB0aGVuCgkJCgkJCS0tIGNoYW5nZSBwYXJlbnQgb3BlcmF0b3IKCQkJCgkJ
CWlmIG5vZGVfdHlwZSA_PSA4IHRoZW4KCQkJCS0taWYgbm9kZV90eXBlID49IDggYW5kIChub2Rl
X3R5cGUhPTEwIG9yIChzZWxmLm12YWxfaW5kZXghPTMpKSB0aGVuCgkJCQktLSBmeCBmaWx0ZXJz
IHNob3VsZG4ndCBoYXZlIGFueSBwYXJlbnQgb3BlcmF0b3JzCgkJCQktLSAoZXhjZXB0IGdhaW4o
MTApOm1peCgzKSkgLS0gdXBkYXRlOiBub3QgYSB1c2VmdWwgZXhjZXB0aW9uOyBkZWxldGVtZQoJ
CQkJcG9rZShhZGRyLCBmbGFncyAmIH4weDMpCgkJCWVsc2VpZiAoZmxhZ3MgJiAweDMgPiAwKSB0
aGVuCgkJCQlpZiAoc2VsZi5sYWJlbCA9PSAidHVuZSIpIHRoZW4KCQkJCQlwb2tlKGFkZHIsIChm
bGFncyAmIH4weDMpIHwgKChmbGFncyAmIDIgPiAwKSBhbmQgMCBvciAyKSkKCQkJCWVsc2UKCQkJ
CQlwb2tlKGFkZHIsIGZsYWdzICYgfjB4MykgLS0gY2xlYXIgYWRkIC8gbXVsdCBiaXQKCQkJCWVu
ZAoJCQllbHNlCgkJCQlpZiAoc2VsZi5sYWJlbCA9PSAidm9sIiBvciBzZWxmLmxhYmVsID09ICJt
aXgiKSB0aGVuCgkJCQkJLS0gc2V0IGJpdDogbXVsdCBwYXJlbnQKCQkJCQlwb2tlKGFkZHIsIGZs
YWdzIHwgMHgyKQoJCQkJZWxzZQoJCQkJCS0tIHNldCBiaXQ6IGFkZCBwYXJlbnQKCQkJCQlwb2tl
KGFkZHIsIGZsYWdzIHwgMHgxKQoJCQkJZW5kCgkJCWVuZAoJCWVsc2VpZiAobXNnLm14ID49IDQ1
KSB0aGVuCgkJCS0tIHRvZ2dsZSBlbnZlbG9wZSBhc3NpZ25tZW50IGJpdAoJCQktLSBtYjIgdG8g
dG9nZ2xlIGNvbnRpbnVhdGlvbgoJCQlpZiAocGVlayhhZGRyKSAmIDB4NCA_IDAgb3IgbXNnLmxh
c3RfbWIgPT0gMSkgdGhlbgoJCQkJcG9rZShhZGRyLCBwZWVrKGFkZHIpIF5eIChtc2cubGFzdF9t
YiA9PSAxIGFuZCAweDQgb3IgMHg4KSkKCQkJZWxzZQoJCQkJLS0gdG9nZ2xlIHJuZAoJCQkJcG9r
ZShhZGRyLCBwZWVrKGFkZHIpIF5eIDB4MTApCgkJCWVuZAoJCWVsc2UKCQkJLS0gc2V0IHZhbDAg
dG8gdmFsPwoJCQktLSBuYWggLS0ganVzdCBhbHdheXMgZHJhZyBtYjIKCQkJLS0gcG9rZShhZGRy
KzIsdmFsMSkKCQllbmQKCWVuZAoJCgkKCXJldHVybiBlbAplbmQKCmZ1bmN0aW9uIGdldF9tdmFs
X3NjYWxlKGFkZHIpCglsb2NhbCB2YWwgPSBAYWRkcgoJbG9jYWwgYml0cyA9IDAKCWlmICh2YWwg
JiAweGMwID09IDApIHJldHVybiAxCglpZiAodmFsICYgMHg0MCA_ICAwKSBiaXRzICs9IDIKCWlm
ICh2YWwgJiAweDgwID4gIDApIGJpdHMgKz0gMgoJcmV0dXJuICh2YWwgJiAweDIwKSA_IDAgYW5k
IDEvKDE8PGJpdHMpIG9yICgxPDxiaXRzKQplbmQKCgotLSBhZGRyZXNzIGlzIG9mIHRoZSB3YXZl
dGFibGVzCmZ1bmN0aW9uIGNyZWF0ZV9zY29wZShhZGRyLCBub2RlX2luZGV4LCB4LCB5LCB3LCBo
KQoJbG9jYWwgZWwgPSBndWk6YXR0YWNoewoJCXg9eCx5PXksCgkJd2lkdGg9dywgaGVpZ2h0PWgs
CgkJYWRkcj1hZGRyCgl9CglmdW5jdGlvbiBlbDpjbGljayhtc2cpCgkJY2hlY2twb2ludCgpCgkJ
bG9jYWwgaW5zdF9hZGRyID0gMHg0MDAwMCArIGNpKjB4MjAwCgkJbG9jYWwgbm9kZV9hZGRyID0g
aW5zdF9hZGRyICsgbm9kZV9pbmRleCoweDIwCgkJbG9jYWwgd3RfaW5kZXggPSBwZWVrKG5vZGVf
YWRkcisxKT4_NAoJCQoJCWlmIChtc2cubXggPCAxOCBhbmQgbXNnLm15IDwgMTApIHRoZW4KCQkJ
d3RfaW5kZXggPSAod3RfaW5kZXggKyAxKSAlIDQKCQkJcG9rZShub2RlX2FkZHIrMSwgKHBlZWso
bm9kZV9hZGRyKzEpICYgfjB4ZjApIHwgKHd0X2luZGV4IDw8IDQpKQoJCWVuZAoJZW5kCgkKCWZ1
bmN0aW9uIGVsOmRyYXcobXNnKQoJCXJlY3RmaWxsKDAsMCxzZWxmLndpZHRoLHNlbGYuaGVpZ2h0
LDApCgkJLS1pZiAoMSkgcmV0dXJuCgkJCgkJLS0gZ3JhYiBpbnN0cnVtZW50IGF0dHJpYnV0ZXMK
CQlsb2NhbCBpbnN0X2FkZHIgPSAweDQwMDAwICsgY2kqMHgyMDAKCQlsb2NhbCBub2RlX2FkZHIg
PSBpbnN0X2FkZHIgKyBub2RlX2luZGV4KjB4MjAKCQlsb2NhbCBub2RlX3R5cGUgPSBwZWVrKG5v
ZGVfYWRkcisxKSAmIDB4ZgoJCWxvY2FsIHdhdmVfYWRkciA9IG5vZGVfYWRkciArIDQgKyA0KjQK
CQlsb2NhbCB3YXZlX3ZhbCAgPSBwZWVrKHdhdmVfYWRkcisxKQoJCQoJCS0tIHdhdmV0YWJsZQoJ
CWxvY2FsIHd0X2luZGV4ID0gKHBlZWsobm9kZV9hZGRyKzEpPj40KQoJCWxvY2FsIHd0X2FkZHIg
PSBlbC5hZGRyICsgd3RfaW5kZXggKiA0CgkJbG9jYWwgYWRkcjAsIGFkZHIxLCB3aWR0aF9iaXRz
LCB3dF9oZWlnaHQgPSBwZWVrKHd0X2FkZHIsNCkKCQlsb2NhbCBkYXRfYWRkciA9IChhZGRyMCA8
PCA4KSB8IChhZGRyMSA8PCAxNikKCQlsb2NhbCB3dF93aWR0aCA9IDEgPDwgd2lkdGhfYml0cwoJ
CQoJCWRhdF9hZGRyICs9ICh3YXZlX3ZhbCAqIHd0X2hlaWdodCA_PiA4KSAqIHd0X3dpZHRoKjIK
CQkKCQlsb2NhbCBwaGFzZV9hZGRyID0gbm9kZV9hZGRyICsgNCArIDUqNAoJCWxvY2FsIHBoYXNl
X3ZhbCAgPSAocGVlayhwaGFzZV9hZGRyKzEpICsgMTI4KSAlIDI1NiAtIDEyOAoJCgkJbG9jYWwg
c3RyZXRjaF9hZGRyID0gbm9kZV9hZGRyICsgNCArIDUqNAoJCWxvY2FsIHN0cmV0Y2hfdmFsICA9
IDAtLXBlZWsoc3RyZXRjaF9hZGRyKzEpCgkJCgkJaWYgKHN0cmV0Y2hfdmFsID49IDEyOCkgc3Ry
ZXRjaF92YWwgLT0gMjU2CgkJc3RyZXRjaF92YWwgPSAoc3RyZXRjaF92YWwgKyAxMjgpIC8gMTI4
IC0tIDAuLjIKCQkKCQoJCWxvY2FsIHZvbF9hZGRyID0gbm9kZV9hZGRyICsgNCArIDAqNAoJCWxv
Y2FsIHZvbF92YWwgID0gcGVlayh2b2xfYWRkcisxKQoJCQoJCS0tIG9zYyB3aGVuIG5vdGhpbmcg
aXMgcGxheWluZzogdmlzdWFsaXNlIHdhdmVmb3JtCgkJaWYgKG5vZGVfdHlwZSA9PSAyIGFuZCBu
b3Qgc29tZXRoaW5nX2lzX3BsYXlpbmcpIHRoZW4KCQkJbGluZSgpCgkJCWZvciBpID0gMCxzZWxm
LndpZHRoLTEsIC41IGRvCgkJCQlsb2NhbCBzYW14ID0gaSAvIHNlbGYud2lkdGgKCQkJCXNhbXgg
Kz0gcGhhc2VfdmFsLzI1NgoJCQkJc2FteCA9IChzYW14ICogc3RyZXRjaF92YWwpICUgMQoJCQkJ
CgkJCQlsb2NhbCBpMiA9IGZscihzYW14ICogd3Rfd2lkdGgpCgkJCQlsb2NhbCB2YWwgPSBwZWVr
MihkYXRfYWRkciArIGkyKjIpCgkJCQl2YWwgKj0gKHZvbF92YWwvMHg0MCkKCQkJCQoJCQkJbG9j
YWwgeHggPSBpCgkJCQlsb2NhbCB5eSA9IHNlbGYuaGVpZ2h0LzIgLSB2YWwgKiBzZWxmLmhlaWdo
dC83MjAwMAoJCQkJLS1saW5lKHh4LHl5LDExKQoJCQkJcHNldCh4eCx5eSwgcGdldCh4eCx5eSkg
PT0gMyBhbmQgMTEgb3IgMykKCQkJZW5kCgkJCQoJCQlwcmludCgid3QtIi4ud3RfaW5kZXgsMiwy
LDMpCgkJCXJldHVybgoJCWVuZAoJCQoJCS0tIGZpbHRlcjogYWx3YXlzIHNob3cgdmlzdWFsaXNh
dGlvbgoJCWlmIChub2RlX3R5cGUgPT0gOCkgdGhlbgoJCQlsb2NhbCBsb3cgICAgPSBwZWVrKG5v
ZGVfYWRkciArIDQgKyAwKjQgKyAxKSAvIDI1NS4wCgkJCWxvY2FsIGhpZ2ggICA9IHBlZWsobm9k
ZV9hZGRyICsgNCArIDEqNCArIDEpIC8gMjU1LjAKCQkJbG9jYWwgcmVzICAgID0gcGVlayhub2Rl
X2FkZHIgKyA0ICsgMio0ICsgMSkgLyAyNTUuMAoJCQkKCQkJLS0gdG8gZG86IGNhbGN1bGF0ZSBj
dXRvZmYgaW4gSHogb3Igc29tZXRoaW5nPwoJCgkJCXJldHVybgoJCWVuZAoJCQoJCgkJLS0gZGVs
YXk6IGFsd2F5cyBzaG93IHZpc3VhbGlzYXRpb24KCQlpZiAobm9kZV90eXBlID09IDkpIHRoZW4K
CQkJbG9jYWwgZGVsYXkgICA9IHBlZWsobm9kZV9hZGRyICsgNCArIDAqNCArIDEpCgkJCWxvY2Fs
IHZvbCAgICAgPSBwZWVrKG5vZGVfYWRkciArIDQgKyAxKjQgKyAxKSAvIDI1NS4wCgkJCWxvY2Fs
IHd3ID0gc2VsZi53aWR0aCBcIDcKCQkJbG9jYWwgaGggPSBzZWxmLmhlaWdodCAtIDQKCQkJZm9y
IGk9MCw2IGRvCgkJCQkgbG9jYWwgeHg9Mit3dyppCgkJCQkgcmVjdGZpbGwoeHgrMSxzZWxmLmhl
aWdodC0yLHh4K3d3LTIsc2VsZi5oZWlnaHQtMi1oaCwxMikKCQkJCSBoaCAqPSB2b2wKCQkJZW5k
CgkJCXJldHVybgoJCWVuZAoJCQoJCQoJCS0tIGdhaW46IGFsd2F5cyBzaG93IHZpc3VhbGlzYXRp
b24KCQlpZiAobm9kZV90eXBlID09IDEwKSB0aGVuCgkJCgkJCWxvY2FsIGdhaW4gID0gcGVlayhu
b2RlX2FkZHIgKyA0ICsgMCo0ICsgMSkgKiA3LjAgLyAyNTUuMAoJCQlnYWluID0gMS4wICsgZ2Fp
biAqIGdldF9tdmFsX3NjYWxlKG5vZGVfYWRkciArIDQgKyAzKQoJCQkKCQkJbG9jYWwgZWxib3cg
PSBwZWVrKG5vZGVfYWRkciArIDQgKyAxKjQgKyAxKSAvIDI1NS4wCgkJCWVsYm93ICo9IGdldF9t
dmFsX3NjYWxlKG5vZGVfYWRkciArIDQgKyAxKjQgKyAzKQoJCQkKCQkJbG9jYWwgY3V0ICAgPSAx
LjAgLSBwZWVrKG5vZGVfYWRkciArIDQgKyAyKjQgKyAxKSAvIDI1NS4wCgkJCWxvY2FsIG1peCAg
ID0gcGVlayhub2RlX2FkZHIgKyA0ICsgMyo0ICsgMSkKCQkJbG9jYWwgd3cgPSBzZWxmLndpZHRo
CgkJCWxvY2FsIGhoID0gc2VsZi5oZWlnaHQKCQkJCgkJCQoJCQlmaWxscCgweDU1NTUpCgkJCWxp
bmUoMCwgaGggLSBjdXQgKiBoaCwgd3csIGhoIC0gY3V0ICogaGgsIDEzKQoJCQlmaWxscCgpCgkJ
CQoJCQlsb2NhbCBlbGJvd195ID0gY3V0CgkJCWxvY2FsIGVsYm93X3ggPSBlbGJvd195IC8gZ2Fp
bgoJCQlsb2NhbCBzbG9wZSA9IDAKCQkJCgkJCWlmIChlbGJvd194ID09IDEuMCkgdGhlbgoJCQkJ
c2xvcGUgPSAwCgkJCWVsc2VpZiAoZWxib3cgPCAwLjUpIHRoZW4KCQkJCgkJCQlsb2NhbCB0dCA9
IGVsYm93ICogMgoJCQkJbG9jYWwgc2xvcGUwID0gKGdhaW4tZWxib3dfeSkgLyAoMS1lbGJvd194
KQoJCQkJbG9jYWwgc2xvcGUxID0gKDEtZWxib3dfeSkgLyAoMS1lbGJvd194KQoJCQkJc2xvcGUg
PSAoMS10dCkgKiBzbG9wZTAgKyAodHQgKiBzbG9wZTEpCgkJCWVsc2UKCQkJCWxvY2FsIHR0ID0g
KGVsYm93LS41KSoyCgkJCQlsb2NhbCBzbG9wZTAgPSAoMS1lbGJvd195KSAvICgxLWVsYm93X3gp
CgkJCQlzbG9wZSA9ICgxLXR0KSAqIHNsb3BlMAoJCQllbmQKCQkJCgkJCWZvciBpID0gMCxzZWxm
LndpZHRoLTEsIC41IGRvCgkJCQlsb2NhbCB0dCA9IGkgLyBzZWxmLndpZHRoCgkJCQlsb2NhbCB2
YWw9MAoJCQkJCgkJCQlpZiB0dCA8IGVsYm93X3ggdGhlbgoJCQkJCXZhbCA9IHR0KmdhaW4KCQkJ
CWVsc2UKCQkJCQlpZiBlbGJvdyA8IDEgdGhlbgoJCQkJCQl2YWwgPSBlbGJvd195ICsgKHR0LWVs
Ym93X3gpKnNsb3BlCgkJCQkJZWxzZQoJCQkJCQktLSBmb2xkYmFjayBcbS8KCQkJCQkJbG9jYWwg
ZTIgPSBlbGJvdy0xCgkJCQkJCWxvY2FsIGgyID0gZWxib3dfeSAvIDIKCQkJCQkJdmFsID0gaDIg
KyBjb3MoKHR0LWVsYm93X3gpKmUyKSAqIGgyCgkJCQkJZW5kCgkJCQllbmQKCQkJCQoJCQkJbG9j
YWwgeHggPSBpCgkJCQlsb2NhbCB5eSA9IHNlbGYuaGVpZ2h0IC0gdmFsICogc2VsZi5oZWlnaHQK
CQkJCgkJCQlwc2V0KHh4LHl5LCBwZ2V0KHh4LHl5KSA9PSAzIGFuZCAxMSBvciAzKQoJCQllbmQK
CQkJCgkJCS0tW1sKCQkJZWxib3dfeCAqPSBzZWxmLndpZHRoCgkJCWVsYm93X3kgPSBjdXQgKiBz
ZWxmLmhlaWdodAoJCQlsaW5lKDAsaGgtMSxlbGJvd194LGhoLWVsYm93X3ksIDcpCgkJCWlmIChl
bGJvdyA8IC41KSB0aGVuCgkJCQktLSBubyBjdXQgICAtLT4gIHNvZnQgY3V0CgkJCQlsb2NhbCB0
dCA9IGVsYm93ICogMgoJCQkJbGluZSh3dywgaGggLSAoZ2FpbipoaCAqICgxLXR0KSArIGhoKnR0
KSApCgkJCWVsc2UKCQkJCS0tIHNvZnQgY3V0IC0tPiAgaGFyZCBjdXQKCQkJCWxvY2FsIHR0ID0g
KGVsYm93LS41KSAqIDIKCQkJCWxpbmUod3csIGhoIC0gKGhoICogKDEtdHQpICsgaGgqY3V0KnR0
KSApCgkJCWVuZAoJCgkJCWxpbmUod3csMCkKCQkJXV0KCQkJCgkJCXJldHVybgoJCWVuZAoJCQoJ
CS0tLS0tLS0tLSBsaXZlIG91dHB1dCAtLS0tLS0tLS0tCgkJCgkJY2lfY2hhbm5lbCA9IDggLS0g
KiogYXNzdW1lIGNoYW5uZWwgMAoJCQoJCWlmIChjaV9jaGFubmVsIDwgMCkgcmV0dXJuIC0tIGRv
bid0IGtub3cgd2hpY2ggY2hhbm5lbCBbeWV0P10gLS0gc2tpcAoJCQoJCS0tIHRpY2tfbGVuIGlz
IG5ldmVyIGxhcmdlciB0aGFuIDRrCgkJbG9jYWwgdGlja19hZGRyID0gMHgyMDAwMDAgKyBub2Rl
X2luZGV4ICogODE5MgoJCQoJCWxvY2FsIHRpY2tfbGVuID0gc3RhdCg0MDAgKyBjaV9jaGFubmVs
LCA4KQoKCQktLSBncmFiIGF0IDE1ZnBzIChwZXJmICsgc28gaXMgcmVhZGJsZSkKCQktLWlmICgo
Z2xvYmFsX3QgKyBub2RlX2luZGV4KSAmIDMgPT0gMCBhbmQgKG5vdCBtc2cuaGFzX3BvaW50ZXIg
b3IgbXNnLm1iPT0wKSkgCgkJaWYgKHRydWUpCgkJdGhlbgoJCQl0aWNrX2xlbiA9IHN0YXQoNDAw
ICsgY2lfY2hhbm5lbCwgMjAgKyBub2RlX2luZGV4LCB0aWNrX2FkZHIpCgkJZW5kCgkJCgkJZm9y
IGkgPSAwLHNlbGYud2lkdGgtMSwgLjUgZG8KCQkJbG9jYWwgaTIgPSBpXC41IC0tIDIgc2FtcGxl
cyBwZXIgcGl4ZWwKCQkJbG9jYWwgdmFsID0gcGVlazIodGlja19hZGRyICsgaTIqMikKCQkJbG9j
YWwgeXkgPSBzZWxmLmhlaWdodC8yIC0gdmFsICogc2VsZi5oZWlnaHQvNzIwMDAKCQkJcHNldChp
LHl5LCBwZ2V0KGkseXkpID09IDMgYW5kIDExIG9yIDMpCgkJZW5kCgkJCgkJLS1wcmludCh0aWNr
X2xlbiwgMjAsIDIwLCAxMSkKCQkKCWVuZAoJcmV0dXJuIGVsCmVuZAkKCgpmdW5jdGlvbiBjcmVh
dGVfbXV0ZWRfbm9kZV90b2dnbGUoYWRkcix4LHkpCglsb2NhbCBlbCA9IHsgCgkJYWRkciA9IGFk
ZHIsCgkJeCA9IHgsIHkgPSB5LCB3aWR0aCA9IDcsIGhlaWdodCA9IDcKCX0KCWZ1bmN0aW9uIGVs
OmRyYXcobXNnKQoJCWxvY2FsIHl5ID0gKG1zZy5oYXNfcG9pbnRlciBhbmQgbXNnLm1iID4gMCkg
YW5kIDEgb3IgMAoJCWxvY2FsIHZhbCA9IChAc2VsZi5hZGRyKSAmIDB4MgoJCWNsaXAoKQoJCXBh
bCg3LDEpCgkJc3ByKCh2YWwgJiAweDIgPiAwKSBhbmQgNTcgb3IgNTYsMCwwK3l5KQoJCXBhbCgp
CgllbmQKCWZ1bmN0aW9uIGVsOnRhcCgpCgkJY2hlY2twb2ludCgpCgkJbG9jYWwgdmFsID0gcGVl
ayhzZWxmLmFkZHIpCgkJdmFsIF5ePSAweDIKCQlwb2tlKHNlbGYuYWRkciwgdmFsKQoJCS0tcmVm
cmVzaF9ndWkgPSB0cnVlCgllbmQKCQoJcmV0dXJuIGVsCmVuZAoKZnVuY3Rpb24gZGVsZXRlX25v
ZGUoaW5kZXgpCglsb2NhbCBpbnN0X2FkZHIgPSAweDQwMDAwICsgY2kqMHgyMDAKCS0tIG1vdmUg
ZXZlcnl0aGluZyB1cAoJZm9yIGo9aW5kZXgsIDcgZG8KCQltZW1jcHkoaW5zdF9hZGRyICsgaiAq
IDB4MjAsIGluc3RfYWRkciArIChqKzEpICogMHgyMCwgMHgyMCkKCWVuZAoJbWVtc2V0KGluc3Rf
YWRkciArIDcgKiAweDIwLCAwLCAweDIwKQoJcmVmcmVzaF9ndWkgPSB0cnVlCmVuZAoKZnVuY3Rp
b24gY3JlYXRlX2NoaWxkX25vZGUocGFyZW50X2luZGV4LCBub2RlX3R5cGUsIGlzX21vZHVsYXRv
cikKCWNoZWNrcG9pbnQoKQoJbG9jYWwgaW5zdF9hZGRyID0gMHg0MDAwMCArIGNpKjB4MjAwCgkK
CS0tIGZpbmQgc2xvdCBhZnRlciBzdWItdHJlZSBlbmRzCglsb2NhbCBjaGlsZF9pbmRleCA9IHBh
cmVudF9pbmRleAoJZm9yIGkgPSBwYXJlbnRfaW5kZXgrMSwgNyBkbwoJCWlmIChub2RlX2RlcHRo
W2ldIGFuZCBub2RlX2RlcHRoW2ldID4gbm9kZV9kZXB0aFtwYXJlbnRfaW5kZXhdKQoJCXRoZW4K
CQkJLS0gcHJpbnRoKHBvZHtpLG5vZGVfZGVwdGhbaV0sbm9kZV9kZXB0aFtwYXJlbnRfaW5kZXhd
fSkKCQkJY2hpbGRfaW5kZXggPSBpIC0tIHN0aWxsIGluIHN1Yi10cmVlCgkJZW5kCgllbmQKCWNo
aWxkX2luZGV4ICs9IDEgLS0gc2xvdCBhZnRlciBzdWItdHJlZQoJCglpZiAoaXNfbW9kdWxhdG9y
KSB0aGVuCgkKCQljaGlsZF9pbmRleCA9IHBhcmVudF9pbmRleCArIDEKCQkKCQlsb2NhbCBub2Rl
X2FkZHIgPSBpbnN0X2FkZHIgKyBjaGlsZF9pbmRleCoweDIwCgkJbG9jYWwgbm9kZV90eXBlID0g
cGVlayhub2RlX2FkZHIrMSkgJiAweGYKCQoJCS0tIGFscmVhZHkgYSBub2RlIHdpdGggYSBtb2R1
bGF0aW5nIG9wZXJhdG9yOiByZWZ1c2UgdG8gY3JlYXRlCgkJaWYgKHBlZWsobm9kZV9hZGRyKT4_
NCkgPiAwIHRoZW4KCQkJcmV0dXJuCgkJZW5kCgkJCgllbmQKCQoJLS1wcmludGgoIkBAIGluc2Vy
dGluZyBjaGlsZCBhdCAiLi5jaGlsZF9pbmRleCkJCgkKCWlmIChjaGlsZF9pbmRleCA_PSA4KSBy
ZXR1cm4gLS0gbm8gc3BhY2UhIQoJCglsb2NhbCBub2RlX2FkZHIgPSBpbnN0X2FkZHIgKyBjaGls
ZF9pbmRleCoweDIwCgkKCS0tIHNodW50IGV2ZXJ5dGhpbmcgZWxzZSBkb3duCglmb3Igaj03LGNo
aWxkX2luZGV4KzEsIC0xIGRvCgkJbWVtY3B5KGluc3RfYWRkciArIGogKiAweDIwLCBpbnN0X2Fk
ZHIgKyAoai0xKSAqIDB4MjAsIDB4MjApCgllbmQKCQkKCS0tIGluaXQgcmVzdCBvZiBub2RlIHRv
IHNvbWV0aGluZyBzZW5zaWJsZS4KCQoJbWVtc2V0KG5vZGVfYWRkciwgMCwgMHgyMCkKCQoJaWYg
KG5vZGVfdHlwZSA9PSAweDIgYW5kIGlzX21vZHVsYXRvcikgdGhlbgoJCXBva2Uobm9kZV9hZGRy
LAoJCQlwYXJlbnRfaW5kZXggfCAxNiwgbm9kZV90eXBlLCAwLCAwLAoJCQkweDAsMHgyMCwwLDAs
ICAtLSB2b2x1bWU6YWJzb2x1dGUKCQkJMHgwLDAsMCwwLCAgICAgLS0gcGFuOiAgbm90IHVzZWQK
CQkJMHgxLDAsMCwwLCAgICAgLS0gdHVuZTogcGFyZW50KzAgLS0gbm90IHF1YW50aXplZAoJCQkw
eDEsMCwwLDAsICAgICAtLSBiZW5kOiBwYXJlbnQrMAoJCQkwLDAsMCwwLCAgICAgICAtLSB3YXZl
Zm9ybQoJCQkweDAsMCwwLDAgICAgICAtLSBwaGFzZQoJCSkKCWVsc2VpZiAobm9kZV90eXBlID09
IDB4MikgdGhlbgoJCXBva2Uobm9kZV9hZGRyLAoJCQlwYXJlbnRfaW5kZXgsIG5vZGVfdHlwZSwg
MCwgMCwKCQkJMHgyLDB4MjAsMCwwLCAgLS0gdm9sdW1lOiBtdWx0LiAweDQwIGlzIG1heCAoLTB4
NDAgdG8gaW52ZXJ0LCAweDdmIHRvIG92ZXJhbXApCgkJCTB4MSwwLDAsMCwgICAgIC0tIHBhbjog
IHBhcmVudCswCgkJCTB4MjEsMCwwLDAsICAgIC0tIHR1bmU6IHBhcmVudCswICAgMHgyMCBxdWFu
dGl6ZWQ7CgkJCTB4MSwwLDAsMCwgICAgIC0tIGJlbmQ6IHBhcmVudCswCgkJCTAsMCwwLDAsICAg
ICAgIC0tIHdhdmVmb3JtCgkJCTB4MCwwLDAsMCAgICAgIC0tIHBoYXNlCgkJKQoJCQoJZWxzZQoJ
CS0tIGZ4OiBubyBwYXJlbnQgb3BzCgkJcG9rZShub2RlX2FkZHIsCgkJCXBhcmVudF9pbmRleCwg
bm9kZV90eXBlLCAwLCAwCgkJCS0tIGFsbCB6ZXJvOiBmeCBrbm9icyBhcmUgYWxsIHVpbnQ4LCBz
byBkb24ndCBuZWVkIDB4OCBmbGFncyBzZXQKCQkpCgllbmQKCQoJcmVmcmVzaF9ndWkgPSB0cnVl
CmVuZAoKCmxvY2FsIG5vZGVfb3Bfc3RyPXsKCVswXT0iY2FycmllciIsImZtIG1vZCIsInJpbmcg
bW9kIiwgInhvciIsIm9yIgp9CmZ1bmN0aW9uIGNyZWF0ZV9vcF90b2dnbGUoYWRkcix4LHkpCgls
b2NhbCBlbCA9IHsgCgkJYWRkciA9IGFkZHIsIGN1cnNvcj0icG9pbnRlciIsCgkJeCA9IHgsIHkg
PSB5LCB3aWR0aCA9IDQwLCBoZWlnaHQgPSA3Cgl9CglmdW5jdGlvbiBlbDpkcmF3KG1zZykKCQls
b2NhbCB5eSA9IChtc2cuaGFzX3BvaW50ZXIgYW5kIG1zZy5tYiA_IDApIGFuZCAxIG9yIDAKCQls
b2NhbCB2YWwgPSAoQHNlbGYuYWRkcikgPj4gNAoJCWNsaXAoKQoJCXBhbCg3LDEpCgkJcmVjdGZp
bGwoMCwwK3l5LHNlbGYud2lkdGgtMSw2K3l5LG1zZy5oYXNfcG9pbnRlciBhbmQgMTQgb3IgNikt
LTYrdmFsKjMpCgkJLS1zcHIodmFsLDEsMSt5eSkKCQlwcmludChub2RlX29wX3N0clt2YWxdLDIs
MSt5eSwxKQoJCXBhbCgpCgllbmQKCWZ1bmN0aW9uIGVsOmNsaWNrKCkKCQljaGVja3BvaW50KCkK
CQlsb2NhbCB2YWwgPSBwZWVrKHNlbGYuYWRkcikgPj4gNAoJCWlmICh2YWwgPiAwKSB0aGVuCgkJ
CXZhbCA9IHZhbCA9PSAxIGFuZCAyIG9yIDEKCQkJcG9rZShzZWxmLmFkZHIsIChwZWVrKHNlbGYu
YWRkcikgJiAweGYpIHwgKHZhbCA8PCA0KSkKCQllbmQKCQktLXJlZnJlc2hfZ3VpID0gdHJ1ZQoJ
ZW5kCgkKCXJldHVybiBlbAplbmQKCmxvY2FsIG5vZGVfZnhfc3RyPXsKCVs4XT0iZmlsdGVyIixb
OV09ImVjaG8iLFsxMF09InNoYXBlIiwgWzExXT0iY3J1c2giCn0KZnVuY3Rpb24gY3JlYXRlX2Z4
X3R5cGVfdG9nZ2xlKGFkZHIseCx5KQoJbG9jYWwgZWwgPSB7IAoJCWFkZHIgPSBhZGRyLAoJCXgg
PSB4LCB5ID0geSwgd2lkdGggPSA0MCwgaGVpZ2h0ID0gNwoJfQoJZnVuY3Rpb24gZWw6ZHJhdyht
c2cpCgkJbG9jYWwgeXkgPSAobXNnLmhhc19wb2ludGVyIGFuZCBtc2cubWIgPiAwKSBhbmQgMSBv
ciAwCgkJbG9jYWwgdmFsID0gKEBzZWxmLmFkZHIpICYgMHhmCgkJY2xpcCgpCgkJcGFsKDcsMSkK
CQlyZWN0ZmlsbCgwLDAreXksc2VsZi53aWR0aC0xLDYreXksbXNnLmhhc19wb2ludGVyIGFuZCAx
NCBvciA2KQoJCS0tc3ByKHZhbCwxLDEreXkpCgkJcHJpbnQobm9kZV9meF9zdHJbdmFsXSwyLDEr
eXksMSkKCQlwYWwoKQoJZW5kCglmdW5jdGlvbiBlbDpjbGljaygpCgkJY2hlY2twb2ludCgpCgkJ
bG9jYWwgdmFsID0gcGVlayhzZWxmLmFkZHIpCgkJdmFsID0gOCArICgoKHZhbC04KSArIDEpICUg
MykgLS0gb25seSBuZWVkIGZpbHRlciwgZWNobywgZ2FpbgoJCXBva2Uoc2VsZi5hZGRyLCAocGVl
ayhzZWxmLmFkZHIpICYgMHhmMCkgfCAodmFsICYgMHgwZikpCgkJcmVmcmVzaF9ndWkgPSB0cnVl
CgllbmQKCQoJcmV0dXJuIGVsCmVuZAoKCmxvY2FsIG5vZGVfdHlwZV9zdHI9ewpbMF09Im5vbmUi
LCAiaW5zdHJ1bWVudCIsIm9zYzoiLCJhbGlhcyIsCiIiLCIiLCIiLCIiLAoiZng6IiwiZng6Iiwi
Zng6IiwiZng6Igp9Cgpsb2NhbCBtdmFsX2RhdCA9IHsKCXsidm9sIiwicGFuIiwidHVuZSIsImJl
bmQiLCJwMCIsInAxIn0sCgl7InZvbCIsInBhbiIsInR1bmUiLCJiZW5kIiwid2F2ZSIsInBoYXNl
In0sCgluaWwsCgluaWwsbmlsLG5pbCxuaWwsCgktLSByZWFsbHkgd2FudCBmeCBib3hlcyB0byBi
ZSB0aW55IGFuZCBzcGVjaWFsaXplZAoJLS0gKGFuZCB0byBjb3N0IG5vZGVzISAtLSB0aGV5IGFy
ZSBnZW5lcmFsbHkgZXhwZW5zaXZlIG9uIGhvc3QpCgktLSB0byBkbzogc3RhbmRhcmQgImNsaXAi
IGZvciBhbGwgZnggbm9kZXMKCS0tIDAuLjEyNyBtZWFucyBjbGlwIHRvIG1heC4ub3NjX3ZvbCAg
MTI4Li4yNTUgbWVhbnMgY2xpcCB0byBvc2Nfdm9sLi4wCgl7ImxvdyIsImhpZ2giLCJyZXMifSwK
CXsiZGVsYXkiLCJ2b2wifSwKCXsiZ2FpbiIsImVsYm93IiwiY3V0IiwibWl4In0sCgl7InJlc3gi
LCJyZXN5IiwibHBmIn0sIC0tIGNhbiBhZGp1c3QgdGhlIHNhbXBsZSByYXRlLCBzYW1wbGUgcHJl
Y2lzaW9uCn0KCgpmdW5jdGlvbiBjcmVhdGVfbm9kZV9lZGl0b3Iobm9kZV9pbmRleCwgeCwgeSkK
Cglsb2NhbCBpbnN0X2FkZHIgPSAweDQwMDAwICsgY2kqMHgyMDAKCWxvY2FsIG5vZGVfYWRkciA9
IGluc3RfYWRkciArIG5vZGVfaW5kZXgqMHgyMAoJbG9jYWwgbm9kZV90eXBlID0gcGVlayhub2Rl
X2FkZHIrMSkgJiAweGYKCWxvY2FsIG5vZGVfb3AgPSBwZWVrKG5vZGVfYWRkcikgPj4gNAoJCgls
b2NhbCBsYWJlbHMgPSBtdmFsX2RhdFtub2RlX3R5cGVdIG9yIHt9CgkKCWxvY2FsIHdpZHRoID0g
MjQwCgkKCWxvY2FsIHJvd3MgPSAzCglpZiAobm9kZV90eXBlID09IDEpIHJvd3M9MgoJaWYgKG5v
ZGVfdHlwZSA_PSA4KSByb3dzPTIgLS13aWR0aCA9IDExOAoJCglsb2NhbCBoZWlnaHQgPSAyMCAr
IHJvd3MgKiAxNgoJCgkKCQoJbG9jYWwgZGVzYyA9IG5vZGVfdHlwZV9zdHJbbm9kZV90eXBlXSBv
ciAiPz8iCgktLWlmIChub2RlX3R5cGUgPT0gMikgZGVzYyAuLj0gIiAiLi4obm9kZV9vcF9zdHJb
bm9kZV9vcF0gb3IgIj8-IikKCQoJbG9jYWwgaGVhZF9jb2wgPSBub2RlX3R5cGVfY29sW25vZGVf
dHlwZV0KCWlmIChub2RlX3R5cGUgPT0gMiBhbmQgbm9kZV9vcCA_IDApIGhlYWRfY29sID0gMHhk
MDUKCglsb2NhbCBlbCA9IGd1aTphdHRhY2goY3JlYXRlX3BhbmUoIiAgIi4uZGVzYywgeCwgeSwg
d2lkdGgsIGhlaWdodCwgaGVhZF9jb2wpKQoJCQoJLS0gYWN0aXZlIC8gbm90IGFjdGl2ZSB0b2dn
bGUKCWVsOmF0dGFjaChjcmVhdGVfbXV0ZWRfbm9kZV90b2dnbGUobm9kZV9hZGRyKzIsIDMsMSkp
CgkKCS0tIG9wZXJhdG9yIGJ1dHRvbiBmb3Igb3NjaWxsYXRvciBjaGlsZHJlbgoJaWYgKG5vZGVf
dHlwZSA9PSAyKSB0aGVuCgkJZWw6YXR0YWNoKGNyZWF0ZV9vcF90b2dnbGUobm9kZV9hZGRyLCAz
NCwxKSkKCWVuZAoJCglpZiAobm9kZV90eXBlID49IDgpIHRoZW4KCQllbDphdHRhY2goY3JlYXRl
X2Z4X3R5cGVfdG9nZ2xlKG5vZGVfYWRkcisxLCAzMCwxKSkKCWVuZAoJCgkKCS0tIGNoaWxkIGNy
ZWF0aW9uIGJ1dHRvbnMgZm9yIG9zY2lsbGF0b3JzIC8gcm9vdAoJaWYgKG5vZGVfdHlwZSA8IDQp
IHRoZW4KCQlsb2NhbCB4eD1lbC53aWR0aC03MgoJCWlmIChub2RlX3R5cGUgPT0gMSkgeHggKz0g
MzAKCQkKCQlpZiAobm9kZV90eXBlID09IDIpIHRoZW4gLS0gK21vZCBvbmx5IGZvciBjYXJyaWVy
IG9zYwoJCXh4ICs9IGVsOmF0dGFjaHsKCQkJeD14eCx5PTEsd2lkdGg9MTksaGVpZ2h0PTcsY3Vy
c29yPSJwb2ludGVyIiwKCQkJZHJhdyA9IGZ1bmN0aW9uKHRoaXMsbXNnKQoJCQkJcmVjdGZpbGwo
MCwwLHRoaXMud2lkdGgsdGhpcy5oZWlnaHQsbXNnLmhhc19wb2ludGVyIGFuZCAyMyBvciA2KSAK
CQkJCXByaW50KCIrbW9kIiwyLDEsNSkKCQkJZW5kLAoJCQl0YXAgPSBmdW5jdGlvbigpIGNyZWF0
ZV9jaGlsZF9ub2RlKG5vZGVfaW5kZXgsMix0cnVlKSBlbmQKCQl9LndpZHRoKzIKCQllbmQKCQl4
eCs9ZWw6YXR0YWNoewoJCQl4PXh4LHk9MSx3aWR0aD0xOSxoZWlnaHQ9NyxjdXJzb3I9InBvaW50
ZXIiLAoJCQlkcmF3ID0gZnVuY3Rpb24odGhpcyxtc2cpCgkJCQlyZWN0ZmlsbCgwLDAsdGhpcy53
aWR0aCx0aGlzLmhlaWdodCxtc2cuaGFzX3BvaW50ZXIgYW5kIDIzIG9yIDYpIAoJCQkJcHJpbnQo
Iitvc2MiLDIsMSw1KQoJCQllbmQsCgkJCXRhcCA9IGZ1bmN0aW9uKCkgY3JlYXRlX2NoaWxkX25v
ZGUobm9kZV9pbmRleCwyKSBlbmQKCQl9LndpZHRoKzIKCQkKCQl4eCs9ZWw6YXR0YWNoewoJCQl4
PXh4LHk9MSx3aWR0aD0xNSxoZWlnaHQ9NyxjdXJzb3I9InBvaW50ZXIiLAoJCQlkcmF3ID0gZnVu
Y3Rpb24odGhpcyxtc2cpCgkJCQlyZWN0ZmlsbCgwLDAsdGhpcy53aWR0aCx0aGlzLmhlaWdodCxt
c2cuaGFzX3BvaW50ZXIgYW5kIDIzIG9yIDYpIAoJCQkJcHJpbnQoIitmeCIsMiwxLDUpCgkJCWVu
ZCwKCQkJdGFwID0gZnVuY3Rpb24oKSBjcmVhdGVfY2hpbGRfbm9kZShub2RlX2luZGV4LDgpIGVu
ZAoJCX0ud2lkdGgrMgoJZW5kCgkKCS0tIGRlbGV0ZSBub2RlCglpZiAobm9kZV90eXBlID4gMSkg
dGhlbgoJZWw6YXR0YWNoewoJCXg9ZWwud2lkdGgtMTAseT0xLHdpZHRoPTgsaGVpZ2h0PTcsY3Vy
c29yPSJwb2ludGVyIiwKCQlkcmF3ID0gZnVuY3Rpb24odGhpcyxtc2cpCgkJCXJlY3RmaWxsKDAs
MCx0aGlzLndpZHRoLHRoaXMuaGVpZ2h0LG1zZy5oYXNfcG9pbnRlciBhbmQgOCBvciA2KSAKCQkJ
cHJpbnQoIlgiLDIsMSw1KQoJCWVuZCwKCQl0YXAgPSBmdW5jdGlvbigpIGRlbGV0ZV9ub2RlKG5v
ZGVfaW5kZXgpIGVuZAoJfQoJZW5kCgkKCQoJLS0ga25vYnMKCQoJZm9yIHk9MCxyb3dzLTEgZG8g
Zm9yIHg9MCx5PT0yIGFuZCByb3dzLTEgb3IgMSBkbwoJCWxvY2FsIG12YWxfaW5kZXggPSB5KjIg
KyB4CgkJbG9jYWwgbGFiZWwgPSBsYWJlbHNbbXZhbF9pbmRleCsxXSBvciAiPz8iCgkJaWYgKG12
YWxfaW5kZXggPCAjbGFiZWxzIGFuZCBsYWJlbCB_PSAicGFuIikgdGhlbiAtLSB0dXJuIG9mZiBw
YW5uaW5nIGZvciBub3chCgkJCWVsOmF0dGFjaChjcmVhdGVfbXZhbF9rbm9iKGxhYmVsLCBub2Rl
X3R5cGUsIG12YWxfaW5kZXgsCgkJCQlub2RlX2FkZHIgKyA0ICsgbXZhbF9pbmRleCo0LCAyNiAr
IHgqODAsIDEzICsgeSoxOCkpCgkJZW5kCgllbmQgZW5kCgkKCWVsOmF0dGFjaChjcmVhdGVfc2Nv
cGUoaW5zdF9hZGRyKzB4MWUwLG5vZGVfaW5kZXgsMTY0LDE0LCA2OSwgZWwuaGVpZ2h0LTE5KSkK
CglyZXR1cm4gZWwKZW5kCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoK
CgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgo6OiBtYWluLmx1YQotLVtbcG9kX2Zvcm1hdD0icmF3
IixjcmVhdGVkPSIyMDIzLTEwLTIyIDA3OjMwOjA0Iixtb2RpZmllZD0iMjAyNC0wNC0yOCAwODo0
MjowMCIscmV2aXNpb249ODUyMyxzdG9yZWQ9IjIwMjMtMzYtMjkgMDQ6MzY6NDAiXV0KLS1bWwoJ
UGljb3Ryb24gVHJhY2tlcgoJKGMpIExleGFsb2ZmbGUgR2FtZXMgTExQCl1dCgppbmNsdWRlICJk
YXRhLmx1YSIKaW5jbHVkZSAiaW5zdC5sdWEiCmluY2x1ZGUgInRyYWNrLmx1YSIKaW5jbHVkZSAi
ZW52Lmx1YSIKaW5jbHVkZSAicGF0Lmx1YSIKaW5jbHVkZSAiZ3VpLmx1YSIKaW5jbHVkZSAidXBk
YXRlLmx1YSIKaW5jbHVkZSAidW5kby5sdWEiCgppbmNsdWRlICJkZWJ1Zy5sdWEiCgpmdW5jdGlv
biBfaW5pdCgpCgkKCXBva2UoMHg0MDAwLCBnZXQoZmV0Y2giL3N5c3RlbS9mb250cy9wOC5mb250
IikpCgkKCXdpbmRvd3sKCQl0YWJiZWQ9dHJ1ZSwKCQlpY29uID0gdXNlcmRhdGEiW2dmeF0wODA4
MDA3Nzc3NzcwMDcwMDAwNzAwNzAwMDA3MDA3MDAwMDcwMDcwMDc3Nzc3NzAwNzc3Nzc3MDAwMDAw
MDAwMDAwMFsvZ2Z4XSIsCgkJdGl0bGU9InNmeCIKCX0KCQoJbWtkaXIgIi9yYW0vY2FydC9zZngi
CgkKCXdyYW5nbGVfd29ya2luZ19maWxlKAoJCWZ1bmN0aW9uKCkKCQkJbG9jYWwgdWQgPSB1c2Vy
ZGF0YSgidTgiLDB4NDAwMDApCgkJCWZvciBpPTAsMHgzZiBkbwoJCQkJc2V0KHVkLCBpICogMHgx
MDAwLCBwZWVrKDB4MzAwMDAgKyBpICogMHgxMDAwLCAweDEwMDApKQoJCQllbmQKCQkJcmV0dXJu
IHVkCgkJZW5kLAoJCWZ1bmN0aW9uICh1ZCkKCQkJaWYgKHR5cGUodWQpfj0idXNlcmRhdGEiKSB0
aGVuCgkJCQlpbml0X2RhdGEoKQoJCQllbHNlCgkJCQlmb3IgaT0wLDB4M2YgZG8KCQkJCQlwb2tl
KDB4MzAwMDAgKyBpICogMHgxMDAwLCBnZXQodWQsIGkgKiAweDEwMDAsIDB4MTAwMCkpCgkJCQll
bmQKCQkJZW5kCgkJCXRkYXQ9e30KCQkJaW5pdF91bmRvKCkKCQllbmQsCgkJIi9yYW0vY2FydC9z
ZngvMC5zZngiCgkpCgkKCQoKCS0tIGN1cnJlbnQgaW5zdHJ1bWVudCwgbm9kZSwgcGF0dGVybiwg
dHJhY2sKCWNpID0gMQoJY24gPSAwCgljcCA9IDAKCWN0ID0gMAoJCgljdm9sID0gMHgyMAoJY29j
dCA9IDQKCQoJbW9kZSA9ICJ0cmFjayIKCQoJaW5pdF91bmRvKCkKCQplbmQKCi0tIGZvciBtb2Nr
aW5nIHVwCmZ1bmN0aW9uIGRyYXdfcGFuZSh0aXRsZSwgeCwgeSwgdywgaCwgY29sKQoJY29sID0g
Y29sIG9yIDUKCXkgPSB5ICsgMgoJcmVjdGZpbGwoeCx5LHgrdy0xLHkraC0xLGNvbCkKCXJlY3Rm
aWxsKHgseSx4K3ctMSx5KzYsNykKCXByaW50KHRpdGxlLHgrNCx5KzEsMSkKCQoJLS1wc2V0KHgs
eSwwKSBwc2V0KHgrdy0xLHksMCkKCS0tcHNldCh4LHkraC0xLDApCXBzZXQoeCt3LTEseStoLTEs
MCkKZW5kCgoKZnVuY3Rpb24gZHJhd19ub2RlX2F0dHIobGFiZWwsIHgsIHkpCgotLQlyZWN0Zmls
bCh4LCB5LCB4KzYwLCB5KzgsIDYpCgoKCXJlY3RmaWxsKHgrMzAseSx4KzcwLHkrOCwwKQoKCS0t
ICoyLjArMSBtZWFucyAqMi4wIHJlbGF0aXZlIHRvIHBhcmVudCwgICsxIHNlbWl0b25lCgktLSBz
cGVjaWFsIGZvciB0dW5lLiBjbGljayBsYWJlbCB0byB0b2dnbGUgYmV0d2VlbiAqMi4wKzEgYW5k
ICsxCgktLSBvdGhlciBhdHRyaWJ1dGVzOiBjbGljayBsYWJlbCB0byB0b2dnbGUgYmV0d2VlbiAx
LjAgYW5kICoxLjAKCglpZiAobGFiZWwgPT0gInR1bmUiKSB0aGVuCgkJcHJpbnQoIioyLjAwKzEi
LHgrNDIseSsyLCAxMykKCWVsc2UKCQlwcmludCgiMS4wMDAiLHgrNDcseSsyLCAxMykKCWVuZAoK
CWNpcmNmaWxsKHgrMzAseSs0LDcsMCkKCWNpcmMgICAgKHgrMzAseSs0LDcsNykKCQoJCglwcmlu
dChsYWJlbCwgeCsyLCB5KzIsIDYpCgplbmQKCmZ1bmN0aW9uIF9kcmF3KCkKCgoJLS1maWxscCgx
KQoJLS1maWxscCh_MHg4MTNkKQoJZmlsbHAofjB4ODIzOSkgLS0gYnJ1c2hlZCBtZXRhbD8gc29t
ZXRoaW5nIGluZHVzdHJpYWwKCXJlY3RmaWxsKDAsMCw0ODAsMjcwLDMyIHwgKDMzKjI1NikpCglm
aWxscCgpCgkKCS0tcmVjdGZpbGwoMzY4LDAsNDgwLDI3MCw1KQoJLS1yZWN0ZmlsbCgwLDAsMTA4
LDI3MCw1KQoJCi0tW1sKCWRyYXdfcGFuZSgic29uZyBpbmZvIiwgMiwyLDk2LDU2LDEpCglkcmF3
X3BhbmUoImluc3RydW1lbnRzIiwyLDYyLDk2LDk4LDEpCgktLWRyYXdfcGFuZSgibXVkbyBzdGF0
ZSIsMiwxNjQsOTYsOTAsMCkKXV0KCQoJCgktLSBvcGVyYXRpb25zIGR1cmluZyBfdXBkYXRlIGNh
biByZXF1ZXN0IGEKCS0tIGd1aSB1cGRhdGUgYmVmb3JlIGl0IGlzIG5leHQgZHJhdyAoYXZvaWQg
ZmxpY2tlcikKCWlmIChyZWZyZXNoX2d1aSBvciBub3QgZ3VpKSB0aGVuCgkJcmVhZHRleHQodHJ1
ZSkgLS0gY2xlYXIgdGV4dCBpbnB1dCBidWZmZXIKCQlnZW5lcmF0ZV9ndWkoKQoJCS0tIGd1aTpk
cmF3X2FsbCgpIGV4cGVjdHMgOnVwZGF0ZV9hbGwoKSBjYWxsZWQgZmlyc3Qgb24gY3VycmVudCBz
dGF0ZSBvZiBndWkKCQlndWk6dXBkYXRlX2FsbCgpCgkJcmVmcmVzaF9ndWkgPSBmYWxzZQoJZW5k
CgkKCWd1aTpkcmF3X2FsbCgpCgkKCS0tIGN1c3RvbSBkaXNwbGF5IHBhbGV0dGUKCS0tIGF0IGVu
ZC4uIHNvbWV0aGluZyBpbiA6ZHJhd19hbGwoKSBwcm9iYWJseSBjYWxscyBwYWwoKQoJcG9rZTQo
MHg1MDAwKzMyKjQsIDB4MjAyMDIwKQoJCgktLXBva2U0KDB4NTAwMCszMio0LCAweGYwMjBmMCkg
LS0gZGVidWcgZmxhc2hpbmcKCQoJLS0gcHJpbnQoc3RyaW5nLmZvcm1hdCgiY3B1OiUzLjNmIixz
dGF0KDEpKSw0NDAsMjUwLDcpCgktLWRyYXdfbXVkb19zdGF0ZSgzODAsMjAwKQoJCgkKZW5kCgoK
Cjo6IHBhdC5sdWEKLS1bW3BvZF9mb3JtYXQ9InJhdyIsY3JlYXRlZD0iMjAyNC0yNS0wOSAwMjoy
NToyNiIsbW9kaWZpZWQ9IjIwMjQtMzMtMDkgMDI6MzM6MjMiLHJldmlzaW9uPTU1XV0KCgo6OiB0
cmFjay5sdWEKLS1bW3BvZF9mb3JtYXQ9InJhdyIsY3JlYXRlZD0iMjAyMy0xMC0yNyAxODo0OTox
OCIsbW9kaWZpZWQ9IjIwMjQtMDQtMjggMDg6NDI6MDAiLHJldmlzaW9uPTQ0MzhdXQotLVtbCgoJ
dHJhY2sgZWRpdG9yCgpdXQoKCmZ1bmN0aW9uIGNyZWF0ZV90aW55X251bV9maWVsZChsYWJlbCxh
ZGRyLHgseSwgIHZtaW4sIHZtYXgpCglsb2NhbCBlbD17CgkJeD14LHk9eSwKCQl3aWR0aD0xNSxo
ZWlnaHQ9MTQsCgkJbGFiZWw9bGFiZWwsYWRkcj1hZGRyLAoJCXZtaW49dm1pbiwgdm1heD12bWF4
Cgl9CgkKCWZ1bmN0aW9uIGVsOmRyYXcoKQoJCWxvY2FsIHZhbD1wZWVrKHNlbGYuYWRkcikKCQlp
ZiAoaGFzX2tub2IpIHRoZW4KCQkJY2lyYyg3LDUsNSwxMykKCQkJbG9jYWwgYWE9LjctdmFsKi45
LzI1NS4wCgkJCWxpbmUoNy41K2NvcyhhYSksNS41K3NpbihhYSksNy41K2NvcyhhYSkqNCw1LjUr
c2luKGFhKSo0LDcpCgkJZW5kCgkJCgkJY2xpcCgpCgkJCgkJLS0gCgkJbG9jYWwgeXk9IDAKCQly
ZWN0ZmlsbCgwLHl5LDE0LHl5KzYsMCkKCQlsb2NhbCBzdHI9dG9zdHIodmFsKQoJCXByaW50KHN0
ciwxNC0jc3RyKjQseXkrMSwzKQoJCQoJCWxvY2FsIGxhYmVsID0gc2VsZi5sYWJlbAoJCWlmIChs
YWJlbCA9PSAibG9vcDAiIGFuZCBwZWVrKHNlbGYuYWRkcisxKSA8PSB2YWwpIGxhYmVsID0gImxl
biIKCQlwcmludChsYWJlbCwtKDIrI2xhYmVsKjQpLHl5KzEsNikKCgllbmQKCQoJZnVuY3Rpb24g
ZWw6Y2xpY2sobXNnKQoJCW1vdXNlbG9jaygweDR8MHg4LCAwLjI1LCAwLjA1KSAtLSAweDQgbG9j
ayAweDggYXV0by1yZWxlYXNlLCBldmVudCBzcGVlZCwgbW92ZSBzcGVlZCAKCWVuZAoJCgkKCWZ1
bmN0aW9uIGVsOmRyYWcobXNnKQoJCWxvY2FsIHZhbD1wZWVrKHNlbGYuYWRkcikKCQl2YWwgKz0g
bXNnLmR4IC0gbXNnLmR5CgkJbG9jYWwgdm1pbiA9IGVsLnZtaW4gb3IgMAoJCWxvY2FsIHZtYXgg
PSBlbC52bWF4IG9yIDI1NQoJCQoJCXZhbCA9IG1pZCh2bWluLHZhbCx2bWF4KQoJCXBva2Uoc2Vs
Zi5hZGRyLCB2YWwpCgllbmQKCQoJcmV0dXJuIGVsCmVuZAoKCmN1cl94ID0gMApjdXJfeSA9IDB4
NTAwMDAgKyA4Cgpsb2NhbCBub3RlX25hbWUgPSB7WzBdPQoiYyAiLCJjIyIsImQgIiwiZCMiLCJl
ICIsImYgIiwiZiMiLCJnICIsImcjIiwiYSAiLCJhIyIsImIgIgp9CmxvY2FsIHZhbF90b19zdHJf
MHhmZiA9IHt9CmxvY2FsIHZhbF90b19zdHJfMHgwMCA9IHt9CmxvY2FsIHZhbF90b19ub3RlICAg
ICA9IHt9Cgpmb3IgaT0wLDI1NSBkbwoJdmFsX3RvX3N0cl8weGZmW2ldID0gc3RyaW5nLmZvcm1h
dCgiJTAyeCIsaSkgCgl2YWxfdG9fc3RyXzB4MDBbaV0gPSBzdHJpbmcuZm9ybWF0KCIlMDJ4Iixp
KSAKCXZhbF90b19ub3RlW2ldID0gbm90ZV9uYW1lW2klMTJdLi4oaVwxMikKZW5kCgotLXZhbF90
b19zdHJfMHgwMFsweDAwXSA9ICIuLiIKdmFsX3RvX3N0cl8weGZmWzB4ZmZdID0gIi4uIgp2YWxf
dG9fbm90ZSAgICBbMHhmZl0gPSAiLi4uIgoKbG9jYWwgZnVuY3Rpb24gcmVuZGVyX3JvdyhhZGRy
LCBzdHJpZGUpCgkKCWxvY2FsIGZyZXEgPSBAYWRkciBhZGRyICs9IHN0cmlkZQoJbG9jYWwgaW5z
dCA9IEBhZGRyIGFkZHIgKz0gc3RyaWRlCglsb2NhbCB2b2wgID0gQGFkZHIgYWRkciArPSBzdHJp
ZGUKCWxvY2FsIGZ4ICAgPSBAYWRkciBhZGRyICs9IHN0cmlkZQoJbG9jYWwgZnhwICA9IEBhZGRy
CgoJLS0gdG8gZG86IGNwdSBjb3N0IGZvciBzdHJpbmcuZm9ybWF0CgktLSBjb3VsZCBrZWVwIGEg
bGFyZ2UgY2FjaGUgYnkgaW50NjQgaGFzaCBvZiBpbnB1dAoJcmV0dXJuIHN0cmluZy5mb3JtYXQo
IiVzXC1oXGZlJXNcLWhcZmMlc1wtaFxmZCVzXGY2JXMiLAoJCXZhbF90b19ub3RlW2ZyZXFdLAoJ
CXZhbF90b19zdHJfMHhmZltpbnN0XSwgdmFsX3RvX3N0cl8weGZmW3ZvbF0sCgkJZnggPT0gMCBh
bmQgIi4iIG9yIGNocihmeCksCgkJZnggPT0gMCBhbmQgIi4uIiBvciB2YWxfdG9fc3RyXzB4MDBb
ZnhwXQoJKQoJCmVuZAoKbG9jYWwgZnVuY3Rpb24gcmVuZGVyX3NlbGVjdGlvbih4MCwgeDEpCgoJ
bG9jYWwgc3RyPSIiCglsb2NhbCBzdHIxID0gIiAgIgoJZm9yIGk9MCw4IGRvCgkJaWYgKHgwIDw9
IGkgYW5kIHgxID49IGkpIHRoZW4KCQkJc3RyLi49ICJcXmkiLi5zdHIxLi4iXF4taSIKCQllbHNl
CgkJCXN0ci4uPSBzdHIxCgkJZW5kCgkJc3RyMSA9ICIgIiAtLSBzdWJzZXF1ZW50IGl0ZW1zIGFy
ZSBhIHNpbmdsZSBjaGFyYWN0ZXIKCQlpZiAoaSA9PSAwIG9yIGkgPT0gMiBvciBpID09IDQpIHN0
cjEgLi49ICJcLWgiIC0tIDFweCBzcGFjZQoJZW5kCgkKCglyZXR1cm4gc3RyCi0tW1sKCXJldHVy
biBzdHJpbmcuZm9ybWF0KCIlcyVzXC1oJXNcLWglc1wtaCVzJXMiLAoJCSh4MCA8PSAwIGFuZCB4
MSA_PSAwKSBhbmQgIlxeaSAgXF4taSIgb3IgIiAgIiwKCQkoeDAgPD0gMSBhbmQgeDEgPj0gMSkg
YW5kICJcXmkgXF4taSIgb3IgIiAiLAoJCSh4MCA8PSAyIGFuZCB4MSA_PSAyKSBhbmQgIlxeaSAg
XF4taSIgIG9yICIgICIsCgkJKHgwIDw9IDMgYW5kIHgxID49IDMpIGFuZCAiXF5pICBcXi1pIiAg
b3IgIiAgIiwKCQkoeDAgPD0gNCBhbmQgeDEgPj0gNCkgYW5kICJcXmkgXF4taSIgICBvciAiICIs
CgkJKHgwIDw9IDUgYW5kIHgxID49IDUpIGFuZCAiXF5pICBcXi1pIiAgb3IgIiAgIgoJKQpdXQpl
bmQKCi0tIGJ5IHNmeF9pbmRleDsgY291bGQgZG8gYnkgY2hhbm5lbCBsYXRlciBlc3AKLS0gaWYg
cGxheWluZyBzYW1lIHNmeCBvbiB0d28gZGlmZnJlbnQgY2hhbm5lbHMKZnVuY3Rpb24gcGxheWlu
Z19yb3coc2Z4X2luZGV4KQoKCWlmIChzdGF0KDQ2NCk9PTApIHJldHVybiBuaWwgLS0gbm90aGlu
ZyBwbGF5aW5nCgkKCWZvciBpPTAsNyBkbwoJCWlmIChzdGF0KDQwMCArIGksIDEyKSA9PSBzZnhf
aW5kZXgpIHRoZW4KCQkJLS1wcmludGgoInBsYXlpbmdfcm93IGZvciBzZnggIi4uc2Z4X2luZGV4
Li4iOiAiLi5zdGF0KDQwMCArIGksIDkpKQoJCQlyZXR1cm4gc3RhdCg0MDAgKyBpLCA5KQoJCWVu
ZAoJZW5kCmVuZAoKZnVuY3Rpb24gY3JlYXRlX3RyYWNrX3NlZ21lbnQoZWwpCgoJbG9jYWwgcm93
X2ggPSA4CgkKCWVsLnggPSBlbC54IG9yIDAKCWVsLnkgPSBlbC55IG9yIDAKCWVsLnJvd3MgICAg
PSBlbC5yb3dzIG9yIDMyCgllbC53aWR0aCAgID0gNDQgLS0gYWx3YXlzIDQ4CgllbC5oZWlnaHQg
ID0gZWwuaGVpZ2h0IG9yIGVsLnJvd3MgKiByb3dfaCArIDIKCWVsLnJvdzAgICAgPSBlbC5yb3cw
IG9yIDAKCWVsLmluZGV4ICAgPSBlbC5pbmRleCBvciBjdCAtLSBzZnggaW5kZXgKCQoJZWwucm93
c3RyPXt9CgkKCQoJaWYgKG5vdCB0ZGF0W2VsLmluZGV4XSkgdGRhdFtlbC5pbmRleF0gPSB7fQoJ
bG9jYWwgZGRhdCA9IHRkYXRbZWwuaW5kZXhdIC0tIGRlY29yYXRpb24gZGF0YQoJCgktLSByZWNh
bGwgcGVyLXNmeCBjdXJzb3IKCWlmIChkZGF0LmN1cikgdGhlbgoJCWN1cl94ID0gZGRhdC5jdXIu
eAoJCWN1cl95ID0gZGRhdC5jdXIueQoJZW5kCgkKCS0tdGRhdFtlbC5pbmRleF0uc2VsPXt4MD0w
LHkwPTAseDE9Myx5MT01fQoKCS0tIGUuZy4gMHg1MDAwOCBmb3IgZmlyc3QgZWxlbWVudCBvbiBm
aXJzdCByb3cgb2YgZmlyc3QgdHJhY2sKCS0tIGFkZCArIGVsLnJvdzAgdG8gZ2V0IGFkZHJlc3Mg
b2YgZmlyc3Qgcm93IGluIHNlZ21lbnQJCglsb2NhbCBiYXNlX2FkZHIgPSAweDUwMDAwICsgKGVs
LmluZGV4ICogMzI4KSArIDgKCQoJZnVuY3Rpb24gZWw6dXBkYXRlKCkKCQlpZiAoZWwubGl2ZV9p
bmRleCkgdGhlbgoJCQllbC5pbmRleCA9IHBlZWsoMHgzMDEwMCArIGNwICogMjAgKyBlbC5jaGFu
X2kpCgkJCWJhc2VfYWRkciA9IDB4NTAwMDAgKyAoZWwuaW5kZXggKiAzMjgpICsgOAoJCWVuZAoJ
CWRkYXQuY3VyPXt4PWN1cl94LHk9Y3VyX3l9IC0tIHN0b3JlIHBlci1zZnggY3Vyc29yCgllbmQK
CQoKCWZ1bmN0aW9uIGVsOmRyYXcoKQoJCgkJbG9jYWwgc2VsID0gZGRhdC5zZWwKCQkKCQlyZWN0
ZmlsbCgwLDAsMTAwMCwxMDAwLDApCgkJCQkKCQlmb3IgaSA9IDAsIHNlbGYucm93cy0xIGRvCgkJ
CgkJCWlmIChpJTggPT0gMCBhbmQgc2VsZi5yb3dzID4gOCkgdGhlbgoJCQkJcmVjdGZpbGwoMCxp
KnJvd19oLCBzZWxmLndpZHRoLTEsaSpyb3dfaCtyb3dfaCwgaSA9PSAzMiBhbmQgMiBvciAyMSkK
CQkJZW5kCgkJCQoJCQlpZiAoaSArIHNlbGYucm93MCA9PSBwbGF5aW5nX3JvdyhlbC5pbmRleCkp
IHRoZW4KCQkJCXJlY3RmaWxsKDAsaSpyb3dfaCwgc2VsZi53aWR0aC0xLGkqcm93X2grcm93X2gs
IDE4KQoJCQllbmQKCQkKCQkJLS0gbm90ZSgzKSBpbnN0KDIpIHZvbCgyKSBlZmZlY3QoMykKCQkJ
CgkJCS0tcHJpbnQoImMgM1wtaFxmZS4uXC1oXGZjLi5cLWhcZmQuLjAiLCAxLCAxK2kqNywgNikK
CQkJCgkJCS0tIHNlbGVjdGVkCgkJCWlmIChzZWwgYW5kIGkgKyBlbC5yb3cwID49IHNlbC55MCBh
bmQgIGkgKyBlbC5yb3cwIDw9IHNlbC55MSBhbmQKCQkJCXNlbC55MCB_PSBzZWwueTEpIAoJCQl0
aGVuCgkJCQlwcmludChyZW5kZXJfc2VsZWN0aW9uKHNlbC54MCwgc2VsLngxKSwgMSwgMStpKnJv
d19oLCAxMCkKCQkJZW5kCgkJCQoJCQktLSBzaW5nbGUKCQkJCgkJCWlmIChjdXJfeSA9PSBiYXNl
X2FkZHIgKyBpICsgZWwucm93MCkgdGhlbgoJCQkJcHJpbnQocmVuZGVyX3NlbGVjdGlvbihjdXJf
eCwgY3VyX3gpLCAxLCAxK2kqcm93X2gsIDEwKQoJCQllbmQKCQkJCgkJCXByaW50KHJlbmRlcl9y
b3coYmFzZV9hZGRyICsgaSArIGVsLnJvdzAsIDY0KSwgMSwgMitpKnJvd19oLCA2KQoJCQkKCQll
bmQKCQkKCQktLXJlY3RmaWxsKDQzLDAsNDUsc2VsZi5yb3dzKjctMywxNikKCQkKCWVuZAoJCglm
dW5jdGlvbiBlbDpjbGljayhtc2cpCgkKCQljaGVja3BvaW50KCkKCQkKCQlsb2NhbCBpPShtc2cu
bXktMilccm93X2gKCQljdXJfeSA9IGJhc2VfYWRkciArIGkgKyBlbC5yb3cwCgkJY3QgPSBlbC5p
bmRleAoJCQoJCS0tCXByaW50aChzdHJpbmcuZm9ybWF0KCJiYXNlX2FkZHI6ICV4IGk6ICVkIiwg
YmFzZV9hZGRyLCBpKSkKCQkKCQkKCQlsb2NhbCBjb2xfeCA9IHtbMF09MCw4LDEzLDE3LDIyLDI2
LDMxLDM1LDM5fQoJCWZvciBpPTAsOCBkbwoJCQlpZiAobXNnLm14ID49IGNvbF94W2ldKSBjdXJf
eCA9IGkKCQllbmQKCgkJaWYgKGtleSJzaGlmdCIpIHRoZW4KCQkJZGRhdC5zZWw9ZGRhdC5zZWwg
b3Ige3gwPWN1cl94LCB5MD1pICsgZWwucm93MCwgeDE9Y3VyX3gsIHkxPWkgKyBlbC5yb3cwfQoJ
CQlkZGF0LnNlbC54MSA9IGN1cl94CgkJCWRkYXQuc2VsLnkxID0gaSArIGVsLnJvdzAKCQllbHNl
CgkJCWRkYXQuc2VsID0ge3gwPWN1cl94LCB5MD1pICsgZWwucm93MCwgeDE9Y3VyX3gsIHkxPWkg
KyBlbC5yb3cwfQoJCWVuZAoJCQoJCgllbmQKCQoJZnVuY3Rpb24gZWw6ZHJhZyhtc2cpCgkJbG9j
YWwgaT0obXNnLm15LTIpXHJvd19oCgkJY3VyX3kgPSBiYXNlX2FkZHIgKyBpICsgZWwucm93MAoJ
CWxvY2FsIGNvbF94ID0ge1swXT0wLDgsMTMsMTcsMjIsMjYsMzEsMzUsMzl9CgkJZm9yIGk9MCw4
IGRvCgkJCWlmIChtc2cubXggPj0gY29sX3hbaV0pIGN1cl94ID0gaQoJCWVuZAoJCWRkYXQuc2Vs
LngxID0gY3VyX3gKCQlkZGF0LnNlbC55MSA9IGkgKyBlbC5yb3cwCgkKCWVuZAoJCglyZXR1cm4g
ZWwKZW5kCgoKZnVuY3Rpb24gY3JlYXRlX3BpdGNoX3NjcmliYmxlcihlbCkKCWVsLmluZGV4IAk9
IGVsLmluZGV4IG9yIGN0CgllbC5jbGljayAJPSBjaGVja3BvaW50Cglsb2NhbCB5X29mZnNldCA9
IDEyCglmdW5jdGlvbiBlbDpkcmF3KCkKCQlsaW5lKDAsc2VsZi5oZWlnaHQtMSxzZWxmLndpZHRo
LHNlbGYuaGVpZ2h0LTEsMSkKCQlmb3IgaT0wLDYzIGRvCgkJCWxvY2FsIHZhbCA9IChAKGVsLmFk
ZHIgKyBpKSkKCQkJaWYgKHZhbCB_PSAweGZmKSB0aGVuCgkJCQlsb2NhbCB4eCA9IGkgKiA2CgkJ
CQlsb2NhbCBpbnN0ID0gQChlbC5hZGRyICsgaSArIGVsLnN0cmlkZSkKCQkJCWxvY2FsIHl5ID0g
ZWwuaGVpZ2h0IC0gdmFsIC0gMSArIHlfb2Zmc2V0CgkJCQlyZWN0ZmlsbCh4eCsxLCB5eSwgeHgg
KyA0LCBlbC5oZWlnaHQsIGk9PXBsYXlpbmdfcm93KGVsLmluZGV4KSBhbmQgMTIgb3IgMSkKCQkJ
CXJlY3RmaWxsKHh4KzEsIHl5LCB4eCArIDQsIHl5KzEgLCA4ICsgaW5zdCUyNCkKCQkJZW5kCgkJ
ZW5kCgkJbG9jYWwgdHJhY2tfYWRkciA9IDB4NTAwMDAgKyBjdCAqIDMyOAoJCWxvY2FsIHh4ID0g
cGVlayh0cmFja19hZGRyKzMpKjYKCQlpZiAoeHg_MCkgbGluZSh4eCwwLHh4LHNlbGYuaGVpZ2h0
LDEyKQoJCWxvY2FsIHh4MSA9IHBlZWsodHJhY2tfYWRkcis0KSo2CgkJaWYgKHh4MT54eCkgbGlu
ZSh4eDEsMCx4eDEsc2VsZi5oZWlnaHQsMTQpCgllbmQKCQoJZnVuY3Rpb24gZWw6ZHJhZyhtc2cp
CgkJbG9jYWwgeHggID0gbWlkKDAsIG1zZy5teCBcIDYsIDYzKQoJCWxvY2FsIHZhbCA9IG1pZCgw
LCBlbC5oZWlnaHQgLSBtc2cubXkgKyB5X29mZnNldCwgMjU1KQoJCXBva2UoZWwuYWRkciArIHh4
LCB2YWwpCgkJcG9rZShlbC5hZGRyICsgeHggKyBlbC5zdHJpZGUsIGNpKSAtLSBzZXQgaW5zdHJ1
bWVudAoJCWxvY2FsIHZvbF9hZGRyID0gZWwuYWRkciArIHh4ICsgZWwuc3RyaWRlKjIKCQlpZiAo
QHZvbF9hZGRyID09IDB4ZmYpIHBva2Uodm9sX2FkZHIsIDMyKSAtLSBzZXQgdm9sdW1lIHdoZW4g
dW5kZWZpbmVkCgllbmQKCQoJcmV0dXJuIGVsCmVuZAoKCi0tIGR1cGUKZnVuY3Rpb24gY3JlYXRl
X3ZvbHVtZV9zY3JpYmJsZXIoZWwpCgllbC5pbmRleCAJPSBlbC5pbmRleCBvciBjdAoJZWwuY2xp
Y2sgIAk9IGNoZWNrcG9pbnQKCWZ1bmN0aW9uIGVsOmRyYXcoKQoJCWxpbmUoMCxzZWxmLmhlaWdo
dC0xLHNlbGYud2lkdGgsc2VsZi5oZWlnaHQtMSwxKQoJCWZvciBpPTAsNjMgZG8KCQkJbG9jYWwg
dmFsID0gQChlbC5hZGRyICsgaSkKCQkJaWYgKHZhbCB_PSAweGZmKSB0aGVuCgkJCWxvY2FsIHh4
ID0gaSAqIDYKCQkJbG9jYWwgeXkgPSBlbC5oZWlnaHQgLSB2YWwgLSAxCgkJCXJlY3QoeHgrMSwg
eXksIHh4ICsgNCwgeXksIGk9PXBsYXlpbmdfcm93KGVsLmluZGV4KSBhbmQgNyBvciAxMikKCQkJ
ZW5kCgkJZW5kCgllbmQKCQoJZnVuY3Rpb24gZWw6ZHJhZyhtc2cpCgkJbG9jYWwgeHggID0gbWlk
KDAsIG1zZy5teCBcIDYsIDYzKQoJCWxvY2FsIHZhbCA9IG1pZCgwLCBlbC5oZWlnaHQgLSBtc2cu
bXksIDk5KQoJCXBva2UoZWwuYWRkciArIHh4LCB2YWwpCgllbmQKCQoJcmV0dXJuIGVsCmVuZAoK
CmZ1bmN0aW9uIHVwZGF0ZV90cmFja19lZGl0b3IoKQoJCglsb2NhbCByb3cwX2FkZHIgPSAweDUw
MDAwICsgKGN0ICogMzI4KSArIDgKCWxvY2FsIHN0cmlkZSA9IDY0Cglsb2NhbCBtYXhfYWRkciA9
IHJvdzBfYWRkciArIDYzCgkKCS0tIGNhbiBwbGF5IGV2ZW4gd2hlbiBjdXJzb3IgaXMgbm90IGlu
IHJhbmdlCglpZiAoa2V5cCgic3BhY2UiKSkgdGhlbgoJCWlmIChzb21ldGhpbmdfaXNfcGxheWlu
ZykgdGhlbgoJCQktLSBzdG9wIGFsbCBhdWRpbyB3aGVuIHNvbWV0aGluZyB3YXMgcGxheWluZwoJ
CQlub3RlKCkKCQllbHNlCgkJCgkJCWxvY2FsIHN0YXJ0X3JvdyA9IDAKCQkJLS0gdG8gZG86IHNl
dHRpbmcgdG8gcGxheSBmcm9tIGN1cnNvciBpbnN0ZWFkIG9mIGdyb3VwIG9mIDgKCQkJaWYgKGtl
eSJzaGlmdCIpIHRoZW4KCQkJCS0tIHNhZmV0eTsgY29uZGl0aW9uIGFsd2F5cyB0cnVlCgkJCQlp
ZiAoY3VyX3kgPiByb3cwX2FkZHIpIHN0YXJ0X3JvdyA9IChjdXJfeS1yb3cwX2FkZHIpICYgfjB4
NwoJCQllbmQKCQkJCgkJCS0tIHBsYXkgb24gY2hhbm5lbCAwCgkJCWlmIChtb2RlID09ICJ0cmFj
ayIpIHNmeChjdCwgMCwgc3RhcnRfcm93LCAwKQoJCQlpZiAobW9kZSA9PSAicGF0dGVybiIpIG11
c2ljKGNwKQoJCWVuZAoJZW5kCgkKCS0tIHNlbGVjdAoJCglpZiAoa2V5KCJjdHJsIikgYW5kIGtl
eXAoImEiKSkgdGhlbgoJCWNoZWNrcG9pbnQoKQoJCXRkYXRbY3RdLnNlbCA9IHt4MD0wLHkwPTAs
eDE9OCx5MT02M30KCWVuZAoJCgktLSBwYXN0ZSBub3RlcwoJaWYga2V5KCJjdHJsIikgYW5kIGtl
eXAoInYiKSB0aGVuCgkJY2hlY2twb2ludCgpCgkJbG9jYWwgZGF0ID0gdW5wb2QoZ2V0X2NsaXBi
b2FyZCgpKQoJCWlmIChkYXQgYW5kIHR5cGUoZGF0Lm5vdGVzKSA9PSAidXNlcmRhdGEiKSB0aGVu
CgkJCWxvY2FsIHgwPXRvbnVtKGRhdC54MCkgb3IgMAoJCQlsb2NhbCB4MT10b251bShkYXQueDEp
IG9yIDgKCQkJbG9jYWwgbWF4eSA9IG1pbihkYXQubm90ZXM6aGVpZ2h0KCktMSwgNjMtKGN1cl95
LXJvdzBfYWRkcikpCgkJCW5vdGlmeShzdHJpbmcuZm9ybWF0KCJwYXN0aW5nICVkICVkICVkIix4
MCwgeDEsIG1heHkpKQoJCQlmb3IgeT0wLG1heHkgZG8KCQkJCWlmICh4MDw9MSkgcG9rZShjdXJf
eSt5LGRhdC5ub3RlczpnZXQoMCx5KSkKCQkJCWlmICh4MDw9MyBhbmQgeDE_PTIpIHBva2UoY3Vy
X3kreSs2NCxkYXQubm90ZXM6Z2V0KDEseSkpCgkJCQlpZiAoeDA8PTUgYW5kIHgxPj00KSBwb2tl
KGN1cl95K3krMTI4LGRhdC5ub3RlczpnZXQoMix5KSkKCQkJCWlmICh4MDw9NiBhbmQgeDE_PTYp
IHBva2UoY3VyX3kreSsxOTIsZGF0Lm5vdGVzOmdldCgzLHkpKQoJCQkJaWYgKHgwPD04IGFuZCB4
MT49NykgcG9rZShjdXJfeSt5KzI1NixkYXQubm90ZXM6Z2V0KDQseSkpCgkJCWVuZAoJCWVsc2UK
CQkJbm90aWZ5KCJjb3VsZCBub3QgZmluZCBub3RlIGRhdGEgdG8gcGFzdGUiKQoJCWVuZAoJZW5k
CgkKCS0tIG9wZXJhdGlvbnMgb24gc2VsZWN0aW9ucwoJCglpZiAodGRhdFtjdF0gYW5kIHRkYXRb
Y3RdLnNlbCBhbmQgdGRhdFtjdF0uc2VsLnkwIH49IHRkYXRbY3RdLnNlbC55MSkgdGhlbgoJCWxv
Y2FsIHNlbCA9IHRkYXRbY3RdLnNlbAoJCWxvY2FsIHgwLHkwLHgxLHkxID0gc2VsLngwLHNlbC55
MCxzZWwueDEsc2VsLnkxCgkJCgkJLS0gcmVtb3ZlIHNlbGVjdGlvbgoJCWlmIChrZXlwKCJlbnRl
ciIpKSB0ZGF0W2N0XS5zZWwgPSBuaWwgcmV0dXJuCgkJCgkJbG9jYWwgZGlkX2N1dCA9IGZhbHNl
CgkJCgkJLS0gY29weSBub3RlIGRhdGEKCQktLSBhbHdheXMgYWxsIHZhbHMgYnV0IHJlY29yZCBy
YW5nZSB0byB3cml0ZSBvbiBwYXN0ZQoJCWlmIGtleSgiY3RybCIpIGFuZCAoa2V5cCgieCIpIG9y
IGtleXAoImMiKSkgdGhlbgoJCQlkaWRfY3V0ID0ga2V5cCgieCIpCgkJCWxvY2FsIHVkID0gdXNl
cmRhdGEoInU4Iiw1LHkxLXkwKzEpCgkJCWZvciB4PTAsNCBkbwoJCQkJZm9yIHk9eTAseTEgZG8K
CQkJCQl1ZDpzZXQoeCx5LXkwLHBlZWsocm93MF9hZGRyK3gqNjQreSkpCgkJCQllbmQKCQkJZW5k
CgkJCXNldF9jbGlwYm9hcmQocG9kKHsKCQkJCW5vdGVzPXVkLAoJCQkJeDA9eDAsIHgxPXgxCgkJ
CX0sNyx7cG9kX3R5cGU9Im5vdGVzIn0pKQoJCQlub3RpZnkoImNvcGllZCAiLi4oeTEteTArMSku
LiIgbm90ZXMiKQoJCWVuZAoJCQoJCS0tIGNsZWFyIChhbHNvIHVzZSBhZnRlciBjdXR0aW5nKQoJ
CS0tIHRvIGRvOiBhbGxvdyBjbGVhcmluZyBhdCB0aGUgbmliYmxlIGxldmVsCgkJaWYgKGtleXAo
ImJhY2tzcGFjZSIpIG9yIGtleXAoImRlbGV0ZSIpIG9yIGRpZF9jdXQpIHRoZW4KCQkJY2hlY2tw
b2ludCgpCgkJCWZvciB5PXkwLCB5MSBkbwoJCQkJaWYgKHgwPD0xKSBwb2tlKHJvdzBfYWRkcit5
LDB4ZmYpCgkJCQlpZiAoeDA8PTMgYW5kIHgxPj0yKSBwb2tlKHJvdzBfYWRkcit5KzY0LDB4ZmYp
CgkJCQlpZiAoeDA8PTUgYW5kIHgxPj00KSBwb2tlKHJvdzBfYWRkcit5KzEyOCwweGZmKQoJCQkJ
aWYgKHgwPD02IGFuZCB4MT49NikgcG9rZShyb3cwX2FkZHIreSsxOTIsMCkKCQkJCWlmICh4MDw9
OCBhbmQgeDE_PTcpIHBva2Uocm93MF9hZGRyK3krMjU2LDApCQkJCQoJCQllbmQKCQllbmQKCQkK
CQkJCgkJLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KCQlyZWFkdGV4dCh0
cnVlKSAtLSBkaXNjYXJkIGFueSBsZWZ0b3ZlciBrZXlwcmVzc2VzCgkJcmV0dXJuCQoJCS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCgllbmQKCQoJLS0gbWlnaHQgc3RpbGwg
Y29weSBwYXR0ZXJuCglpZiAobW9kZSA9PSAicGF0dGVybiIgYW5kIGtleSJjdHJsIiBhbmQga2V5
cCJjIikgdGhlbgoJCWxvY2FsIGFkZHIgPSAweDMwMTAwICsgY3AqMjAKCQlsb2NhbCB1ZD11c2Vy
ZGF0YSgidTgiLDIwKQoJCXVkOnNldCgwLHBlZWsoYWRkciwgMjApKQoJCXNldF9jbGlwYm9hcmQo
cG9kKHsKCQkJcGF0dGVybj11ZAoJCX0sNyx7cG9kX3R5cGU9InBhdHRlcm4ifSkpCgkJbm90aWZ5
KCJjb3BpZWQgcGF0dGVybiIpCgllbmQKCQoJaWYgKG1vZGUgPT0gInBhdHRlcm4iIGFuZCBrZXki
Y3RybCIgYW5kIGtleXAidiIpIHRoZW4KCQljaGVja3BvaW50KCkKCQlsb2NhbCBkYXQgPSB1bnBv
ZChnZXRfY2xpcGJvYXJkKCkpCgkJaWYgKGRhdCBhbmQgdHlwZShkYXQucGF0dGVybikgPT0gInVz
ZXJkYXRhIikgdGhlbgoJCQlwb2tlKDB4MzAxMDAgKyBjcCoyMCwgZ2V0KGRhdC5wYXR0ZXJuLCAw
LCAyMCkpCgkJCW5vdGlmeSgicGFzdGVkIHBhdHRlcm4iKQoJCQlyZWZyZXNoX2d1aSA9IHRydWUK
CQllbHNlCgkJCW5vdGlmeSgiY291bGQgbm90IHBhc3RlIHBhdHRlcm4gb3IgdHJhY2sgZGF0YSIp
CgkJZW5kCgllbmQKCQoJLS0gdG8gZG86IGN1cl95IHBlciB0cmFjawoJLS0gY3Vyc29yIGlzbid0
IGluIGN1cnJlbnQgdHJhY2s7IGRvbid0IGFsbG93IGVkaXRpbmcKCQoJaWYgKGN1cl95IDwgcm93
MF9hZGRyIG9yIGN1cl95ID49IHJvdzBfYWRkciArIDY0KSB0aGVuCgkKCQlyZWFkdGV4dCh0cnVl
KSAtLSBjb25zdW1lIChhbmQgaWdub3JlKSBhbnkgdGV4dCBlbnRyeQoKCQktLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQoJCXJldHVybgkgCgkJLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0KCWVuZAoJCgoJCglpZiBrZXkiY3RybCIgdGhlbgoJCgkJcmVh
ZHRleHQodHJ1ZSkgLS0gY2xlYXIgYnVmZmVyCgkJCgkJLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0KCQlyZXR1cm4gLS0gbm90aGluZyBlbHNlIHRvIHByb2Nlc3MKCQktLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQoJZW5kCgkKCWlmIChrZXlwKCJsZWZ0
IikpICBjdXJfeCAtPSAxCglpZiAoa2V5cCgicmlnaHQiKSkgY3VyX3ggKz0gMQoJaWYgKGtleXAo
InVwIikpICAgIGN1cl95IC09IDEKCWlmIChrZXlwKCJkb3duIikpICBjdXJfeSArPSAxCglpZiAo
a2V5cCgicGFnZXVwIikpICAgIGN1cl95IC09IDQKCWlmIChrZXlwKCJwYWdlZG93biIpKSAgY3Vy
X3kgKz0gNAoJCi0tW1sKCXRvIGRvOiBob3cgdG8gaGFuZGxlIGxpbWl0cz8gdHJhY2sgdnMgcGF0
dGVybgoJd2hpbGUgKGN1cl95IDwgIDB4NTAwMDgrY3QqMzI4KzAwKSBjdXJfeSArPSA2NAoJd2hp
bGUgKGN1cl95ID49IDB4NTAwMDgrY3QqMzI4KzY0KSBjdXJfeSAtPSA2NApdXQoJLS1wcmludGgo
c3RyaW5nLmZvcm1hdCgiJXgiLGN1cl95KSkKCQoJLS0gZ29pbmcgb3ZlciBtZWFucyBkaWZmcmVu
dCB0aGluZ3MgZGVwZW5kaW5nIG9uIGxheW91dAoJLS0ganVzdCB3cmFwIGZvciBub3cKCWN1cl94
ICU9IDkKCQoJLS0gZW50ZXIgZGF0YQoJCglsb2NhbCBxID0gNjQgLS0gc3RyaWRlCgkKCS0tIGtl
eV9waXRjaDogdXNlIHNjYW5jb2RlcyByYXRoZXIgdGhhbiB0ZXh0aW5wdXQKCQoJaWYgKGN1cl94
ID09IDApIHRoZW4KCQlmb3IgaT0xLCNrZXlfcGl0Y2ggZG8KCQkJaWYga2V5cChzdWIoa2V5X3Bp
dGNoLGksaSkpIHRoZW4KCQkJCXBva2UoY3VyX3ksIDM1K2kgKyAoY29jdCoxMi00OCkpCgkJCQlp
ZiAocGVlayhjdXJfeStxKSAgID09IDB4ZmYpIHBva2UoY3VyX3kgKyBxLCAgIGNpKSAgIC0tIHNl
dCBpbnN0CgkJCQlpZiAocGVlayhjdXJfeStxKjIpID09IDB4ZmYpIHBva2UoY3VyX3kgKyBxKjIs
IGN2b2wpIC0tIHNldCB2b2x1bWUKCQkJCQoJCQkJLS0gcGxheSB0aGUgdHJhY2sgZnJvbSB0aGF0
IG5vdGUKCQkJCXNmeChjdCwgMCwgY3VyX3ktcm93MF9hZGRyLCAxKQoJCQkJY3VyX3kgKz0gMQoJ
CQllbmQKCQllbmQKCWVuZAoJCglpZiAoa2V5cCgiZGVsIikgb3IgKGtleXAoImJhY2tzcGFjZSIp
IGFuZCBjdXJfeSA_IHJvdzBfYWRkcikpIHRoZW4KCQljaGVja3BvaW50KCkKCQlpZiAoa2V5cCgi
YmFja3NwYWNlIikpIGN1cl95IC09IDEKCQlmb3IgYWRkciA9IGN1cl95LCBtYXhfYWRkci0xIGRv
CgkJCWZvciBqPTAsNCBkbwoJCQkJcG9rZShhZGRyICsgaipzdHJpZGUsIHBlZWsoYWRkcitqKnN0
cmlkZSsxKSkKCQkJZW5kCgkJZW5kCgkJZm9yIGo9MCw0IGRvCgkJCXBva2UobWF4X2FkZHIgKyBq
ICogc3RyaWRlLCBqID4gMiBhbmQgMCBvciAweGZmKSAtLSBibGFuayBsYXN0IGxpbmUKCQllbmQK
CWVuZAoJCglpZiAoa2V5cCgiZW50ZXIiKSBhbmQgY3VyX3kgPCBtYXhfYWRkcikgdGhlbgoJCWNo
ZWNrcG9pbnQoKQoJCWZvciBhZGRyID0gbWF4X2FkZHIsIGN1cl95KzEsIC0xIGRvCgkJCWZvciBq
PTAsNCBkbwoJCQkJcG9rZShhZGRyICsgaipzdHJpZGUsIHBlZWsoYWRkcitqKnN0cmlkZS0xKSkK
CQkJZW5kCgkJZW5kCgkJZm9yIGo9MCw0IGRvCgkJCXBva2UoY3VyX3kgKyBqICogc3RyaWRlLCBq
ID4gMiBhbmQgMCBvciAweGZmKSAtLSBibGFuayBjdXJyZW50IGxpbmUKCQllbmQKCQljdXJfeSAr
PSAxCgllbmQKCQoJLS0tLS0KCQoJd2hpbGUgcGVla3RleHQoKSBkbwoJCgkJbG9jYWwgYyA9IHJl
YWR0ZXh0KCkKCQoJCWNoZWNrcG9pbnQoKQoJCQkKCQktLSBmeAoJCWlmIChjdXJfeCA_PSA2KSB0
aGVuCgkJCQoJCQktLSBvbmx5IFBJQ08tOCBlZmZlY3RzCgkJCS0tW1sKCQkJaWYgKGMgPj0gIjAi
IGFuZCBjIDw9ICI3Iikgb3IgYz09Ii4iIHRoZW4KCQkJCXBva2UoY3VyX3kgKyBxKjMsIChjID09
ICIuIiBvciBjID09ICIwIikgYW5kIDAgb3Igb3JkKGMpKQoJCQkJY3VyX3kgKz0gMQoJCQllbmQK
CQkJXV0KCQkJbm90aWZ5KCJbdHJhY2tlciBlZmZlY3RzIGNvbWluZyBzb29uIV0iKQoJCWVsc2UK
CgkJCWxvY2FsIG51bSA9IG5pbAoJCQkKCQkJaWYgKGMgPj0gImEiIGFuZCBjIDw9ICJmIikgbnVt
ID0gMTAgKyBvcmQoYykgLSBvcmQoImEiKQoJCQlpZiAoYyA_PSAiQSIgYW5kIGMgPD0gIkYiKSBu
dW0gPSAxMCArIG9yZChjKSAtIG9yZCgiQSIpCgkJCWlmIChjID49ICIwIiBhbmQgYyA8PSAiOSIp
IG51bSA9IDAwICsgb3JkKGMpIC0gb3JkKCIwIikKCQkJCgkJCWlmIChudW0pIHRoZW4KCQkJCWlm
IChjdXJfeCA9PSAxKSBwb2tlKGN1cl95LCBudW0qMTIgKyBwZWVrKGN1cl95KSAlIDEyKQoJCQoJ
CQkJaWYgKGN1cl94ID49IDIgYW5kIGN1cl94IDw9IDMgYW5kIHBlZWsoY3VyX3krcSkgPT0gMHhm
ZikgcG9rZShjdXJfeStxLDApCgkJCQlpZiAoY3VyX3ggPT0gMikgcG9rZShjdXJfeSArIHEsIHBl
ZWsoY3VyX3kgKyBxKSAlIDE2ICsgbnVtICogMTYpCgkJCQlpZiAoY3VyX3ggPT0gMykgcG9rZShj
dXJfeSArIHEsIHBlZWsoY3VyX3kgKyBxKSAmfjE1IHwgbnVtICkKCQkKCQkJCS0tIHZvbHVtZQoJ
CQkJaWYgKGN1cl94ID49IDQgYW5kIGN1cl94IDw9IDUgYW5kIHBlZWsoY3VyX3krcSoyKSA9PSAw
eGZmKSBwb2tlKGN1cl95K3EqMiwwKQoJCQkJaWYgKGN1cl94ID09IDQpIHBva2UoY3VyX3kgKyBx
KjIsIHBlZWsoY3VyX3kgKyBxKjIpICUgMTYgKyBudW0gKiAxNikKCQkJCWlmIChjdXJfeCA9PSA1
KSBwb2tlKGN1cl95ICsgcSoyLCBwZWVrKGN1cl95ICsgcSoyKSAmfjE1IHwgbnVtICkKCQkKCQkJ
CS0tIGZ4cDogY29tbWVudGVkIHVudGlsIHRoZSBtaXhlciBjYW4gZGVhbCB3aXRoIHRoZW0hCgkJ
CQktLVtbCgkJCQlpZiAoY3VyX3ggPj0gNyBhbmQgY3VyX3ggPD0gOCBhbmQgcGVlayhjdXJfeStx
KjQpID09IDB4ZmYpIHBva2UoY3VyX3krcSo0LDApCgkJCQlpZiAoY3VyX3ggPT0gNykgcG9rZShj
dXJfeSArIHEqNCwgcGVlayhjdXJfeSArIHEqNCkgJSAxNiArIG51bSAqIDE2KQoJCQkJaWYgKGN1
cl94ID09IDgpIHBva2UoY3VyX3kgKyBxKjQsIHBlZWsoY3VyX3kgKyBxKjQpICZ_MTUgfCBudW0g
KQoJCQkJaWYgKGN1cl94ID4gMCkgY3VyX3kgKz0gMQoJCQkJXV0KCQkJCQoJCQkJLS1jdXJfeSAr
PSAxCgkJCQlpZiAoY3VyX3ggPiAwKSBjdXJfeSArPSAxCgkJCWVuZAoJCQkKCQkJLS0gLiBidXR0
b24gdG8gc2V0IHdob2xlIGJ5dGUgZm9yIAoJCQlpZiAoYyA9PSAiLiIpIHRoZW4KCQkJCWlmIChj
dXJfeCA9PSAwIG9yIGN1cl94ID09IDEpIHBva2UoY3VyX3kgKyBxKjAsIDB4ZmYpIGN1cl95ICs9
IDEKCQkJCWlmIChjdXJfeCA9PSAyIG9yIGN1cl94ID09IDMpIHBva2UoY3VyX3kgKyBxKjEsIDB4
ZmYpCgkJCQlpZiAoY3VyX3ggPT0gNCBvciBjdXJfeCA9PSA1KSBwb2tlKGN1cl95ICsgcSoyLCAw
eGZmKQoJCQkJLS1pZiAoY3VyX3ggPT0gNikgICAgICAgICAgICAgICBwb2tlKGN1cl95ICsgcSoz
LCAwKSAtLSBoYW5kbGVkIGFib3ZlCgkJCQlpZiAoY3VyX3ggPiAgNikgICAgICAgICAgICAgICBw
b2tlKGN1cl95ICsgcSo0LCAwKQoJCQkJaWYgKGN1cl94ID4gMCkgY3VyX3kgKz0gMQoJCQllbmQK
CQkJCgkJZW5kCgkKCWVuZAoJCQplbmQKCQoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoK
CgoKCjo6IHVuZG8ubHVhCi0tW1twb2RfZm9ybWF0PSJyYXciLGNyZWF0ZWQ9IjIwMjQtMDMtMzAg
MTk6MDM6MTkiLG1vZGlmaWVkPSIyMDI0LTA0LTI4IDA4OjQwOjIwIixyZXZpc2lvbj00NTFdXQot
LVtbCgoJc2luZ2xlIHVuZG8gc3RhY2sgZm9yIHdob2xlIC5zZnggZmlsZQoKXV0KCmZ1bmN0aW9u
IGluaXRfdW5kbygpCgoJdW5kb19zdGFjayA9IGNyZWF0ZV91bmRvX3N0YWNrKAoJCWZ1bmN0aW9u
KCkKCQkJbG9jYWwgbWVtID0gdXNlcmRhdGEoInU4IiwweDQwMDAwKQoJCQlmb3IgaT0wLDMgZG8K
CQkJCXNldChtZW0saSoweDEwMDAwLHBlZWsoMHgzMDAwMCtpKjB4MTAwMDAsIDB4MTAwMDApKQoJ
CQllbmQKCQkJcmV0dXJuIHttZW0sdGRhdCxtb2RlLGNpLGN0LGNwfQoJCWVuZCwKCQlmdW5jdGlv
bihzdGF0ZSkKCQkJZm9yIGk9MCwzIGRvCgkJCQlwb2tlKDB4MzAwMDAraSoweDEwMDAwLCBnZXQo
c3RhdGVbMV0saSoweDEwMDAwLDB4MTAwMDApKQoJCQllbmQKCQkJdGRhdCxtb2RlLGNpLGN0LGNw
PXN0YXRlWzJdLHN0YXRlWzNdLHN0YXRlWzRdLHN0YXRlWzVdLHN0YXRlWzZdCgkJZW5kLAkJCgkJ
LS0gdXNlIHJhdyBiaW5hcnkgZW5jb2Rpbmcgc3VpdGFibGUgZm9yIGZpeGVkIHNpemUgbWVtb3J5
IGJsb2NrIChzYW1lIGFzIGdmeCkKCQktLT4gZmFzdGVyIGVuY29kaW5nLCAgc21hbGxlciBwYXRj
aGVzCgkJMHgxMSAtLSAoMHgxIGJpbmFyeSAgMHgxMCBweHUgcmF3KQoJKQoJCmVuZAoKZnVuY3Rp
b24gY2hlY2twb2ludCgpCgl1bmRvX3N0YWNrOmNoZWNrcG9pbnQoKQplbmQKCmZ1bmN0aW9uIHVu
ZG8oKQoJdW5kb19zdGFjazp1bmRvKCkKCXJlZnJlc2hfZ3VpID0gdHJ1ZQplbmQKCmZ1bmN0aW9u
IHJlZG8oKQoJdW5kb19zdGFjazpyZWRvKCkKCXJlZnJlc2hfZ3VpID0gdHJ1ZQplbmQKOjogdXBk
YXRlLmx1YQotLVtbcG9kX2Zvcm1hdD0icmF3IixjcmVhdGVkPSIyMDIzLTEwLTIyIDA3OjMyOjEx
Iixtb2RpZmllZD0iMjAyNC0wNC0yOCAwODo0MjowMCIscmV2aXNpb249ODI3NSxzdG9yZWQ9IjIw
MjMtMzYtMjkgMDQ6MzY6NDAiXV0KZ2xvYmFsX3QgPSAwCgotLSBtYXAga2V5Ym9hcmQgbGV0dGVy
cyB0byBwaXRjaGVzCgprZXlfcGl0Y2g9InpzeGRjdmdiaG5qbXEydzNlcjV0Nnk3dWk5bzBwIgoK
c29tZXRoaW5nX2lzX3BsYXlpbmcgPSBmYWxzZQoKZnVuY3Rpb24gX3VwZGF0ZSgpCgoJLS0gZmlu
ZCBvdXQgd2hpY2ggY2hhbm5lbCBjdXJyZW50IGluc3RydW1lbnQgaXMgYmVpbmcgcGxheWVkIG9u
CgljaV9jaGFubmVsID0gLTEKCWZvciBpPTAsMzEgZG8KCQlpZiAoY2lfY2hhbm5lbCA9PSAtMSBh
bmQgc3RhdCg0MDAraSwxKSA9PSBjaSkgdGhlbgoJCQljaV9jaGFubmVsID0gaQoJCWVuZAoJZW5k
CgkKCS0tIHVwZGF0ZTogc29tZXRoaW5nX2lzX3BsYXlpbmcKCXNvbWV0aGluZ19pc19wbGF5aW5n
ID0gZmFsc2UKCWZvciBpPTAsMTUgZG8KCQlpZiAoc3RhdCg0MDAraSwxMikgIT0gLTEpIHNvbWV0
aGluZ19pc19wbGF5aW5nID0gdHJ1ZSAtLSBzZngKCQlpZiAoc3RhdCg0MDAraSwxICkgIT0gLTEp
IHNvbWV0aGluZ19pc19wbGF5aW5nID0gdHJ1ZSAtLSBpbnN0CgllbmQKCQoJLS0gb3IgaWYgdGhl
cmUgaXMgW3JlY2VudGx5XSBzb21lIGdsb2JhbCBvdXRwdXQgKGUuZy4gZWNobyBvciByb2d1ZSBu
b2RlKQoJbGVuID0gc3RhdCg0NjUsMCwweGUwMDAwKQoJbG9jYWwgZm91bmRfc2lnbmFsCglmb3Ig
aT0wLGxlbi03LDggZG8KCQlpZiAocGVlazgoMHhlMDAwMCtpKSAhPSAwKSBmb3VuZF9zaWduYWwg
PSB0cnVlCgllbmQKCWlmIChmb3VuZF9zaWduYWwpIGxhc3RfZm91bmRfc2lnbmFsX3QgPSB0KCkK
CWlmIChsYXN0X2ZvdW5kX3NpZ25hbF90IGFuZCBsYXN0X2ZvdW5kX3NpZ25hbF90ID4gdCgpLTAu
MSkgdGhlbgoJCXNvbWV0aGluZ19pc19wbGF5aW5nID0gdHJ1ZQoJZW5kCgkKCglpZiAoZ3VpKSBn
dWk6dXBkYXRlX2FsbCgpCgkKCWlmIChrZXkiY3RybCIpIHRoZW4KCQktLSBjYW4ndCBwbGF5IG5v
dGUgd2hlbiBob2xkaW5nIGNvbnRyb2wKCQkKCQlpZiAoa2V5cCJ6IikgdW5kbygpCgkJaWYgKGtl
eXAieSIpIHJlZG8oKQoJCgllbHNlaWYgKGtleXAic3BhY2UiKSB0aGVuCgkJLS0gaW5zdCBtb2Rl
OmFsd2F5cyBraWxsIGFsbCBhdWRpbwoJCWlmIG1vZGUgPT0gImluc3RydW1lbnQiIHRoZW4gLS0g
dHJhY2sgaGFzIG93biBoYW5kbGluZwoJCQlub3RlKCkgLS0ga2lsbCBhbGwgY2hhbm5lbHMKCQll
bmQKCWVsc2VpZiBtb2RlID09ICJpbnN0cnVtZW50IiB0aGVuCQoJCQoJCWxvY2FsIHBpdGNoID0g
LTEKCQktLWlmIChrZXlwKCJzcGFjZSIpKSBwaXRjaCA9IDQ4IC0tIG1pZGRsZSBjCgkJaWYgKGtl
eXAoIiwiKSkgcGl0Y2ggPSA2MCAtLSB0byBkbwoJCQoJCWZvciBpPTEsI2tleV9waXRjaCBkbwoJ
CQlpZiBrZXkoc3ViKGtleV9waXRjaCxpLGkpKSB0aGVuCgkJCQlwaXRjaCA9IDM1ICsgaSArIChj
b2N0KjEyLTQ4KQoJCQllbmQKCQllbmQKCQkKCQlpZiAocGl0Y2ggPj0gMCkgdGhlbgoJCQlub3Rl
KAoJCQkJcGl0Y2gsIC0tIHBpdGNoCgkJCQljaSwgICAgLS0gaW5zdAoJCQkJY3ZvbCwgICAgLS0g
dm9sdW1lCgkJCQkwLDAsICAgLS0gZWZmZWN0LCBlZmZlY3RfcAoJCQkJOCwgICAgIC0tIGNoYW5u
ZWwgaW5kZXggLS0gOCBzbyB0aGF0IGNhbiBwbGF5IHdpdGggbXVzaWMKCQkJCWZhbHNlICAtLSBk
b24ndCBmb3JjZSByZXRyaWdnZXIgKHJldHJpZ2dlciB3aGVuIHBpdGNoL2luc3QgY2hhbmdlcykJ
CQoJCQkJKQoJCWVsc2UKCQkJLS0gcmVsZWFzZQoJCQktLWlmIHN0YXQoNDY0KSA9PSAwIHRoZW4g
LS0gbm90IHBsYXlpbmcgYSBzZnggb24gYW55IGNoYW5uZWwKCQkJCW5vdGUoMHhmZiwgMHhmZiwg
MHhmZiwgMHhmZiwgMHhmZiwgOCkKCQkJLS1lbmQKCQllbmQKCQkKCWVuZAoJCgoJaWYgKG1vZGUg
PT0gInRyYWNrIiBvciBtb2RlID09ICJwYXR0ZXJuIikgdGhlbgoJCXVwZGF0ZV90cmFja19lZGl0
b3IoKQoJZW5kCgkKCS0tIGNvcHkgYW5kIHBhc3RlIGluc3RydW1lbnRzCglpZiAoa2V5ImN0cmwi
IGFuZCBtb2RlID09ICJpbnN0cnVtZW50IikgdGhlbgoJCWlmIChrZXlwImMiKSB0aGVuCgkJCWxv
Y2FsIHVkID0gdXNlcmRhdGEoInU4IiwweDIwMCkKCQkJc2V0KHVkLDAscGVlaygweDQwMDAwK2Np
KjB4MjAwLDB4MjAwKSkKCQkJc2V0X2NsaXBib2FyZChwb2QoewoJCQkJaW5zdHJ1bWVudD11ZAoJ
CQl9LDcse3BvZF90eXBlPSJpbnN0cnVtZW50In0pKQoJCQlub3RpZnkoImNvcGllZCBpbnN0cnVt
ZW50IikKCQllbmQKCQkKCQlpZiBrZXkoImN0cmwiKSBhbmQga2V5cCgidiIpIHRoZW4KCQkJY2hl
Y2twb2ludCgpCgkJCWxvY2FsIGRhdCA9IHVucG9kKGdldF9jbGlwYm9hcmQoKSkKCQkJCgkJCWlm
IChkYXQgYW5kIHR5cGUoZGF0Lmluc3RydW1lbnQpID09ICJ1c2VyZGF0YSIpIHRoZW4KCQkJCXBv
a2UoMHg0MDAwMCtjaSoweDIwMCwgZ2V0KGRhdC5pbnN0cnVtZW50LDAsMHgyMDApKQoJCQkJbm90
aWZ5KCJwYXN0ZWQgaW5zdHJ1bWVudCIpCgkJCQlyZWZyZXNoX2d1aSA9IHRydWUKCQkJZWxzZQoJ
CQkJbm90aWZ5KCJjb3VsZCBub3QgZmluZCBpbnN0cnVtZW50IGRhdGEgdG8gcGFzdGUiKQoJCQll
bmQKCQllbmQKCQoJZW5kCgkKCWdsb2JhbF90ICs9IDEKCQplbmQKCgoKCgoKCgoKCgoKCgoKCgoK
CgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCjo6
IFtlb2NdCg==
:: demos/bells.p64
b64$cGljb3Ryb24gY2FydHJpZGdlIC8vIHd3dy5waWNvdHJvbi5uZXQKdmVyc2lvbiAyCgo6OiAu
aW5mby5wb2QKYjY0JExTMWJXM0J2WkN4amNtVmhkR1ZrUFNJeU1ESTBMVEEwTFRNd0lERTVPakE1
T2pNeklpeHRiMlJwWm1sbFpEMGlNakF5TkMwdwpOeTB3TmlBeE1UbzBPRG96TmlJc2MzUnZjbVZr
UFNJeU1ESTBMVEF6TFRJeElEQTRPalF5T2pVeUlpeDNiM0pyYzNCaFkyVnpQWHQ3CmJHOWpZWFJw
YjI0OUltMWhhVzR1YkhWaEl6TWlMSGR2Y210emNHRmpaVjlwYm1SbGVEMHhmU3g3Ykc5allYUnBi
MjQ5SW1kbWVDOHcKTG1kbWVDSXNkMjl5YTNOd1lXTmxYMmx1WkdWNFBUSjlMSHRzYjJOaGRHbHZi
ajBpYldGd0wyMWhjREF1YldGd0lpeDNiM0pyYzNCaApZMlZmYVc1a1pYZzlNMzBzZTJ4dlkyRjBh
Vzl1UFNKelpuZ3ZjMlo0TUM1elpuZ2lMSGR2Y210emNHRmpaVjlwYm1SbGVEMDBmWDFkClhXeDZO
QUFFQUFBQUF3QUFBREJ1YVd3PQo6OiBnZngvCjo6IGdmeC8uaW5mby5wb2QKYjY0JExTMWJXM0J2
WkN4amNtVmhkR1ZrUFNJeU1ESXpMVEF3TFRNd0lERTVPakF3T2pFNUlpeHRiMlJwWm1sbFpEMGlN
akF5TkMwdwpOeTB3TmlBeE1UbzBPRG96TmlJc2MzUnZjbVZrUFNJeU1ESXpMVEF3TFRNd0lERTVP
akF3T2pFNUlsMWRiSG8wQUFRQUFBQURBQUFBCk1HNXBiQT09Cjo6IGdmeC8wLmdmeApiNjQkTFMx
YlczQnZaQ3hqY21WaGRHVmtQU0l5TURJekxUQXdMVE13SURFNU9qQXdPakl3SWl4dGIyUnBabWxs
WkQwaU1qQXlOQzB3Ck15MHlNU0F3T0RvME1qbzFNaUlzY21WMmFYTnBiMjQ5TmpRNVhWMXNlalFB
YlFBQUFBVXhBQUR6Rkh0Yk1GMDllMkp0Y0Qxd2VIVUEKUXlBUUVBVHc4Q3htYkdGbmN6MHdMSEJo
Ymw5NENBRFBlVDB3TEhwdmIyMDlPSDBzTVFELS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQotLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1uVUcwOU9IMTkKOjogbWFwLwo6OiBt
YXAvLmluZm8ucG9kCmI2NCRMUzFiVzNCdlpDeGpjbVZoZEdWa1BTSXlNREl6TFRBd0xUTXdJREU1
T2pBd09qRTVJaXh0YjJScFptbGxaRDBpTWpBeU5DMHcKTnkwd05pQXhNVG8wT0Rvek5pSXNjM1J2
Y21Wa1BTSXlNREl6TFRBd0xUTXdJREU1T2pBd09qRTVJbDFkYkhvMEFBUUFBQUFEQUFBQQpNRzVw
YkE9PQo6OiBtYXAvbWFwMC5tYXAKYjY0JExTMWJXM0J2WkN4amNtVmhkR1ZrUFNJeU1ESXpMVEF3
TFRNd0lERTVPakF3T2pJd0lpeHRiMlJwWm1sbFpEMGlNakF5TkMwdwpNeTB5TVNBd09EbzBNam8x
TWlJc2NtVjJhWE5wYjI0OU5qVTVYVjFzZWpRQWFBQUFBRmdRQUFEd0NIdDdZbTF3UFhWelpYSmtZ
WFJoCktDSnBNVFlpTERNeUF3QXZJakFCQVAtLS0tLS0tLS0tLS0tLS0tLS0tLXZ4Q0NJcExHaHBa
R1JsYmoxbVlXeHpaU3h3WVc1ZmVEMHcKQ0FEU2VUMHdMSFJwYkdWZmFEMHhOZ29BRUhjS0FJQjZi
Mjl0UFRGOWZRPT0KOjogc2Z4Lwo6OiBzZngvLmluZm8ucG9kCmI2NCRMUzFiVzNCdlpDeGpjbVZo
ZEdWa1BTSXlNREl6TFRBd0xUTXdJREU1T2pBd09qRTVJaXh0YjJScFptbGxaRDBpTWpBeU5DMHcK
Tnkwd05pQXhNVG8wT0Rvek5pSXNjM1J2Y21Wa1BTSXlNREl6TFRBd0xUTXdJREU1T2pBd09qRTVJ
bDFkYkhvMEFBUUFBQUFEQUFBQQpNRzVwYkE9PQo6OiBzZngvc2Z4MC5zZngKYjY0JExTMWJXM0J2
WkN4amNtVmhkR1ZrUFNJeU1ESXpMVEF3TFRNd0lERTVPakF3T2pJd0lpeHRiMlJwWm1sbFpEMGlN
akF5TkMwdwpNeTB5TVNBd09EbzBNam8xTWlJc2NtVjJhWE5wYjI0OU56WXpYVjFzZWpRQWFBRUFB
SG9IQUFEZmNIaDFBQU1vQUFBREFBVHctd0VBCjdQQk84UUVRQmc4Z0VBRWdBUXdRQWZBQUFoQUNE
aEFCSUE4aElBRXdEeHVRRHhFQ0lBNVFBUThXRUFId253SUFCa0FQMUFfdkQ0OFAKZWc5ZkQwb1BP
Zzh2RHlvZkh3OGFIeFVQRHdYd3VRLTRDZy0tRDRBUDl3OE5BZkFKQVJBR1N3QkpDUXdGQUZrQWtB
a1BHUS1hQWlBQwpjRjBBLXpBUEZsQUJELXNHQUFFQURfLUFBUWdnRDNkZ0R4dndnZ0lCQ0VBUDlB
LXBEOWtQeVFfRUQyb1BXZzlGRHo4Zkx4OGxEeG9QCkZROFA4QWdCb0E4WThKUnlBQUlzQVNESkFH
QkFrQThSRWhESkFOSDBFQUV3RHlxUUFRSVFBZzh0SUFBQUV3RFFEODRnRHphUUR4TUMKSUE4T1VB
a0JVQThQSUE2UWp3Q1FHbUFQSGZCQ0FnQUpfZ0FSdWZvQThBQmtEMW9QU2c4LUR6VVBMdzhsRHhf
UkFEOEs4THFLQUJXUAo4TU1QS0EtLThNWXdBTG9mLXdFQTNQSUZfQTlBQUE4UVFBOHctLTh2QWYw
dkR2MHY4SEFUQUMtOXNBb0EtLTljSC04QkFKZFEtLS0tCi14OD0KOjogbWFpbi5sdWEKLS1bW3Bv
ZF9mb3JtYXQ9InJhdyIsY3JlYXRlZD0iMjAyMy0wMC0zMCAxOTowMDoyMCIsbW9kaWZpZWQ9IjIw
MjQtMDMtMjEgMDg6NDI6NTIiLHJldmlzaW9uPTg0Ml1dCi0tW1sKCWJlbGxzIGRlbW8gYnkgemVw
CglhCQpdXQpubj17fQpmdW5jdGlvbiBwaWNrX25vdGUoKQoJaWYgKCNubiA9PSAwKSBubiA9IHs1
MCw1Myw1NSw1Nyw2MCwgNjIsNjUsNjcsNjksNzJ9CglyZXR1cm4gZGVsKG5uLHJuZChubikpCmVu
ZAoKZnVuY3Rpb24gX2luaXQoKQoKCQoJbG9jYWwgc2Z4ZGF0ID0gZmV0Y2gic2Z4L3NmeDAuc2Z4
IgoJCgltZW1tYXAoMHgzMDAwMCwgc2Z4ZGF0KQoKLS1bWwoJLS0gdG8gZG86IG5pY2VyIHdheSB0
byB0cmFuc2ZlciBsYXJnZSBhbW91bnRzIG9mIGRhdGEgZnJvbSB1c2VyZGF0YSAtPiByYW0KCS0t
IGNhbid0IGZldGNoKGdldChmb28pKSBsYXJnZSBibG9ja3MgYmVjYXVzZSBvZiBzdGFjayBsaW1p
dAoJZm9yIGk9MCwyIGRvCgkJcG9rZSgweDMwMDAwICsgKGk8PDE2KSwgZ2V0KHNmeGRhdCwoaTw8
MTYpLDB4MTAwMDApKQoJZW5kCl1dCgoJYmVsbD17fQoJZm9yIHk9LTEsNSBkbwoJCWZvciB4PS0x
LDUgZG8KCQkJbG9jYWwgc3ggPSAxNDIreCo0MCArICh5JjEpICogMjAKCQkJbG9jYWwgc3kgPSA3
MCt5KjMwCgkJCWxvY2FsIG9jdCA9IDAKCQkJbG9jYWwgaW5zdCA9IHkgPCAyIGFuZCAwIG9yIDEK
CQkJaWYgKHkgPT0gLTEpIG9jdCA9IDEKCQkJaWYgKHkgPT0gNCkgb2N0ID0gLTEKCQkJaWYgKHkg
PT0gNSkgb2N0ID0gLTEgaW5zdCA9IDIKCQkJCgkJCWFkZChiZWxsLHsKCQkJCXggPSBzeCwgeSA9
IHN5LAoJCQkJcSA9IDAsCgkJCQluID0gcGlja19ub3RlKCkgKyBvY3QqMTIsCgkJCQlpbnN0ID0g
aW5zdAoJCQl9KQoJCWVuZAoJZW5kCmVuZAoKCmZ1bmN0aW9uIF9kcmF3KCkKCWNscygpCglmb3Ig
YiBpbiBhbGwoYmVsbCkgZG8KCQkKCQlmb3IgaT0wLDIgZG8KCQkJbG9jYWwgcnIgPSBiLnEgKiAo
aS0xKS8yCgkJCWNpcmMoYi54LCBiLnksIDE1ICsgcnIsIDcraStiLnkvMjApCgkJZW5kCgkJCgkJ
bG9jYWwgdHQ9Yi5xLzMwCgkJdHQqPXR0CgkJY2lyYyhiLngsIGIueSwgMTUgKyB0dCozMCwgNykK
CQkKCWVuZAoJLS1wcmludChzdGF0KDEpLDIsMiw4KQplbmQKCmNoYW4gPSAwCmZ1bmN0aW9uIF91
cGRhdGUoKQoJbG9jYWwgbXgsIG15ID0gbW91c2UoKQoJZm9yIGIgaW4gYWxsKGJlbGwpIGRvCgkJ
CgkJbG9jYWwgZHggPSBteCAtIGIueAoJCWxvY2FsIGR5ID0gbXkgLSBiLnkKCQlpZiBzcXJ0KGR4
KmR4K2R5KmR5KSA8IDE1IHRoZW4KCQkJLS0gcGxheSBiZWxsCgkJCWlmIChub3QgYi5hY3RpdmUp
IHRoZW4KCQkJCWIucSA9IDMwCgkJCQktLSBwaXRjaCwgaW5zdCwgdm9sICgwLi42NCksIGVmZmVj
dCwgZWZmZWN0X3AsIGNoYW5faW5kZXgKCQkJCS0tIChlZmZlY3RzIG5vdCBpbXBsZW1lbnRlZCB5
ZXQpCgkJCQlub3RlKGIubixiLmluc3QsNjQsMCwwLGNoYW4pIAoJCQkJY2hhbj0oY2hhbisxKSU4
IC0tIHJvdGF0ZSBhcm91bmQgZmlyc3QgOCBjaGFubmVscwoJCQllbmQKCQkJYi5hY3RpdmUgPSB0
cnVlCgkJZWxzZQoJCQliLmFjdGl2ZSA9IGZhbHNlCgkJZW5kCgkJaWYgKGIucSA_IDApIGIucSAt
PSAxCgllbmQKZW5kCgoKCjo6IFtlb2NdCg==
:: apps/themed.p64
b64$cGljb3Ryb24gY2FydHJpZGdlIC8vIHd3dy5waWNvdHJvbi5uZXQKdmVyc2lvbiAyCgo6OiAu
aW5mby5wb2QKYjY0JExTMWJXM0J2WkN4dWIzUmxjejBpSWl4aGRYUm9iM0k5SW5wbGNDSXNjM1J2
Y21Wa1BTSXlNREkwTFRBekxUQTVJREV3T2pNeQpPakV3SWl4cFkyOXVQWFZ6WlhKa1lYUmhLQ0ox
T0NJc01UWXNNVFlzSWpBd01EQXdNREF3TURBd01EQXdNREV3TVRBd01EQXdNREF3Ck1EQXdNREF3
TURBd01EQXdNREF3TURBd01ERXdOekEzTURFd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdN
REF3TVRBM01EY3cKTVRBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNVEEzTURjd056QTNN
REV3TURBd01EQXdNREF3TURFd01UQXhNREV3TVRBeApNRGN3TnpBM01EY3dNVEF4TURFd01UQXhN
REV3TVRBM01EY3dOekEzTURjd056QTNNRGN3TnpBM01EY3dOekEzTURjd01UQXhNRFl3Ck56QTNN
RGN3WkRBM01EY3dOekEzTUdRd056QTNNRGN3TmpBeE1ERXdOakEyTURjd056QmtNRGN3TnpBM01E
Y3daREEzTURjd05qQTIKTURFd01EQXhNRFl3TmpBM01EY3dOekEzTURjd056QTNNRGN3TmpBMk1E
RXdNREF3TURBd01UQTJNRGN3TnpBM01HUXdaREEzTURjdwpOekEyTURFd01EQXdNREF3TURBd01E
RXdOekEzTURjd056QTNNRGN3TnpBM01ERXdNREF3TURBd01EQXdNREV3TnpBM01EY3dOekEyCk1E
WXdOekEzTURjd056QXhNREF3TURBd01EQXdNVEEzTURjd05qQTJNRFl3TmpBMk1EWXdOekEzTURF
d01EQXdNREF3TURBeE1EY3cKTmpBMk1EWXdNVEF4TURZd05qQTJNRGN3TVRBd01EQXdNREF3TURF
d05qQTJNREV3TVRBd01EQXdNVEF4TURZd05qQXhNREF3TURBdwpNREF3TVRBeE1ERXdNREF3TURB
d01EQXdNREF3TVRBeE1ERXdNREF3SWlrc2RHbDBiR1U5SWxSb1pXMWxJRVZrYVhSdmNpSXNZM0ps
CllYUmxaRDBpTWpBeU15MHhNQzB4TnlBd05Ub3hOVG8wTUNJc2JXOWthV1pwWldROUlqSXdNalF0
TURjdE1EWWdNVEU2TkRnNk16WWkKTEhabGNuTnBiMjQ5SWlJc2QyOXlhM053WVdObGN6MTdlMnh2
WTJGMGFXOXVQU0p0WVdsdUxteDFZU0lzZDI5eWEzTndZV05sWDJsdQpaR1Y0UFRGOWZWMWRiSG8w
QUFRQUFBQURBQUFBTUc1cGJBPT0KOjogZ2Z4Lwo6OiBnZngvLmluZm8ucG9kCmI2NCRMUzFiVzNC
dlpDeGpjbVZoZEdWa1BTSXlNREl6TFRFd0xURTNJREExT2pFMU9qUXdJaXh0YjJScFptbGxaRDBp
TWpBeU5DMHcKTnkwd05pQXhNVG8wT0Rvek5pSXNjM1J2Y21Wa1BTSXlNREl6TFRFMUxURTNJREEx
T2pFMU9qUXdJbDFkYkhvMEFBUUFBQUFEQUFBQQpNRzVwYkE9PQo6OiBnZngvMC5nZngKYjY0JExT
MWJXM0J2WkN4amNtVmhkR1ZrUFNJeU1ESXpMVFF6TFRJNElEQXlPalF6T2pVNUlpeHRiMlJwWm1s
bFpEMGlNakF5TXkwegpNUzB5TWlBeE9Eb3pNVG96TUNJc2NtVjJhWE5wYjI0OU5EVXpMSE4wYjNK
bFpEMGlNakF5TXkweU5TMHlPU0F3T1RveU5UbzFNQ0pkClhXeDZOQURKQVFBQWdqUUFBUEVHZTFz
d1hUMTdZbTF3UFhCNGRRQkRJQWdJQkFjQUFnQVNrQWdBR1pjT0FQTUFoeXhtYkdGbmN6MHcKTEhC
aGJsOTRDQURxZVQwd0xITmpZV3hsUFRFeWZTeE9BRk1YSUFjUUJ3UUFKeGNRQkFCUVFCY2dCd0FF
QUE5VEFCNy1CQ0FYUUFlZwpCd0FIVUJkUUJ3QUhvQWRBRnlCRUFCNnpBQWNnQnlBbkFGY0FKeUNl
QUFZT0FBX1NBQi0tQkJBSEVBY1FWeUJYSUdjQVJ5QVhZQmRnCkZ4QkVBQjZWQnlBSFFBY2dCLUFC
Q1FBUFF3QWVJQ0FIRVFFUk1Lc0JNeEFIQUFnQUFHY0JYMEFIY0FkdzF3QWd2MUFuTUVmd0FRZFEK
TnlBM1B3QWZyNEFIY0Fmd0N3ZFFCNUE3QUJ1Z0RBd0U4QW9Ya0Jmd01BVUFId285QUI0UVotZ0FF
bUFBQVE4TUFBVVBIZ0FMQWd3QQpEN1lBSDBBWUI3QVhSUUJRRUFkd0J4Qk5BRjhYc0Fmd0dFZ0FI
djhENEFlQUo1QW5nQWZ3R1FlZ0ozQW5vQWZRUXdBZVVBQVhBQmRRCmxnS2hCMEFIUUFkUUJ5QUhj
TVlEMy1BQkI0QkhjQ2VBQndBSDhBbFdBQjRRUjFFQUlBQTNCZ0F4RURjQTlRSUJFZ0JCQnhBSGtB
SUEKQ0FnQUg0QmZBQnRmRUJBRThQQXpBUC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLQotLS0tLS0tLS13dFFQVEV5ZlgwPQo6OiBtYXAvCjo6IG1h
cC8uaW5mby5wb2QKYjY0JExTMWJXM0J2WkN4amNtVmhkR1ZrUFNJeU1ESXpMVEV3TFRFM0lEQTFP
akUxT2pRd0lpeHRiMlJwWm1sbFpEMGlNakF5TkMwdwpOeTB3TmlBeE1UbzBPRG96TmlJc2MzUnZj
bVZrUFNJeU1ESXpMVEUxTFRFM0lEQTFPakUxT2pRd0lsMWRiSG8wQUFRQUFBQURBQUFBCk1HNXBi
QT09Cjo6IG1hcC8wLm1hcApiNjQkTFMxYlczQnZaQ3hqY21WaGRHVmtQU0l5TURJekxUUXpMVEk0
SURBeU9qUXpPalU1SWl4dGIyUnBabWxsWkQwaU1qQXlNeTAxCk5TMHpNU0F3TmpvMU5UbzFPU0lz
Y21WMmFYTnBiMjQ5TXpFekxITjBiM0psWkQwaU1qQXlNeTB5TlMweU9TQXdPVG95TlRvMU1DSmQK
WFd4Nk5BQmRBQUFBV0FRQUFQQVRlMnhoZVdWeVBYdGJNRjA5ZTJKdGNEMTFjMlZ5WkdGMFlTZ2lh
VEUySWl3eE5nTUFMeUl3QVFELQotLS12b1NJcExIQmhibDk0UFRBSUFQSUdlVDB3TEhOallXeGxQ
VEVzZEdsc1pWOW9QVEUyQ2dCd2R6MHhObjE5Cjo6IHNmeC8KOjogc2Z4Ly5pbmZvLnBvZApiNjQk
TFMxYlczQnZaQ3hqY21WaGRHVmtQU0l5TURJekxURXdMVEUzSURBMU9qRTFPalF3SWl4dGIyUnBa
bWxsWkQwaU1qQXlOQzB3Ck55MHdOaUF4TVRvME9Eb3pOaUlzYzNSdmNtVmtQU0l5TURJekxURTFM
VEUzSURBMU9qRTFPalF3SWwxZGJIbzBBQVFBQUFBREFBQUEKTUc1cGJBPT0KOjogbWFpbi5sdWEK
LS1bW3BvZF9mb3JtYXQ9InJhdyIsY3JlYXRlZD0iMjAyMy00My0yOCAwMjo0Mzo1OSIsbW9kaWZp
ZWQ9IjIwMjMtMjgtMDUgMDg6Mjg6NDgiLHJldmlzaW9uPTU5NyxzdG9yZWQ9IjIwMjMtMjUtMjkg
MDk6MjU6NTAiXV0KLS0gdGhlbWVkOiBUaGVtZSBFZGl0b3IKCmxvY2FsIGN1cnJlbnRfayA9ICJk
ZXNrMCIKCmZ1bmN0aW9uIF9pbml0KCkKCXBva2UoMHg0MDAwLCBnZXQoZmV0Y2giL3N5c3RlbS9m
b250cy9saWwuZm9udCIpKQoJCgl3aW5kb3d7CgkJd2lkdGg9MjQwLAoJCWhlaWdodD0xMzIsCgkJ
cmVzaXplYWJsZT1mYWxzZSwgLS0gdG8gZG8KCQl0aXRsZT0iVGhlbWUgRWRpdG9yIgoJfQoJCgl0
ZGF0ID0gCgkJZmV0Y2giL3JhbS9zaGFyZWQvdGhlbWUucG9kIiBvcgoJCWZldGNoIi9hcHBkYXRh
L3N5c3RlbS90aGVtZS5wb2QiIG9yCgkJe30KCQkKCWlmICh0eXBlKHRkYXQuZGVza3RvcF9wYXR0
ZXJuKSE9InVzZXJkYXRhIikgdGhlbgoJCXRkYXQuZGVza3RvcF9wYXR0ZXJuID0gdXNlcmRhdGEo
InU4IiwgOCw4KQoJZW5kCgoJCi0tZnVuY3Rpb24gd3JhbmdsZV93b3JraW5nX2ZpbGUoc2F2ZV9z
dGF0ZSwgbG9hZF9zdGF0ZSwgdW50aXRsZWRfZmlsZW5hbWUpCgoJd3JhbmdsZV93b3JraW5nX2Zp
bGUoCgkJZnVuY3Rpb24oKQoJCQlwcmludGgoIkBAIHNhdmluZyB0aGVtZSIpCgkJCXJldHVybiB1
bnBvZChwb2QodGRhdCkpCgkJZW5kLAoJCQoJCS0tIGxvYWQKCQlmdW5jdGlvbih0ZGF0MCkKCQkJ
LS0gcHJpbnRoKCJAQCBsb2FkaW5nIHRoZW1lIikKCQkJdGRhdCA9IHRkYXQwCgkJCWlmIChub3Qg
dGRhdCkgdGhlbiB0ZGF0ID0gCgkJCQlmZXRjaCIvcmFtL3NoYXJlZC90aGVtZS5wb2QiIG9yCgkJ
CQlmZXRjaCIvYXBwZGF0YS9zeXN0ZW0vdGhlbWUucG9kIiBvcgoJCQkJe30KCQkJZW5kCgkJCXN0
b3JlX2xpdmVfY2hhbmdlcygpCgkJZW5kLAoJCSIvYXBwZGF0YS9zeXN0ZW0vdGhlbWUucG9kIiAt
LSBlZGl0IHRoZSBkZWZhdWx0IGN1c3RvbSB0aGVtZSBieSBkZWZhdWx0CgkpCgkKCWdlbmVyYXRl
X2d1aSgpCmVuZApsb2NhbCBjYXRlZ29yeT17Cgl7WzBdPSJEZXNrdG9wIiwgImRlc2t0b3AwIiwi
ZGVza3RvcDEiLCJkZXNrdG9wX3NoYWRvdyJ9LAoJe1swXT0iSWNvbiIsICAgICJpY29uMCIsImlj
b24xIiwiaWNvbjIiLCJpY29uMyJ9LAoJe1swXT0iV2luZG93IiwgICJ3aW5kb3dfZnJhbWUiLCJ3
aW5kb3dfdGl0bGUiLCJ3aW5kb3dfYnV0dG9uIiwid2luZG93X2JvcmRlciJ9LAoJe1swXT0iRG9y
bWFudCIsICJkb3JtYW50X2ZyYW1lIiwiZG9ybWFudF90aXRsZSIsImRvcm1hbnRfYnV0dG9uIiwi
ZG9ybWFudF9ib3JkZXIifSwKCXtbMF09IlRvb2xiYXIiLCAidG9vbGJhcl9iYWNrIiwidG9vbGJh
cl9pdGVtIiwidG9vbGJhcl9zZWxlY3RlZCJ9LAp9CgkKcGNvbHMgPSB7WzBdID0KCTAsMjAsNCwz
MSwxNSw4LDI0LDIsCgkyMSw1LDIyLDYsNywyMywxNCwzMCwKCTEsMTYsMTcsMTIsMjgsMjksMTMs
MTgsCgkxOSwzLDI3LDExLDI2LDEwLDksMjUsCn0KZnVuY3Rpb24gc3RvcmVfbGl2ZV9jaGFuZ2Vz
KCkKCXN0b3JlKCIvcmFtL3NoYXJlZC90aGVtZS5wb2QiLHRkYXQpCmVuZAoJCQoJCmZ1bmN0aW9u
IGNyZWF0ZV9jb2xib3goZWwpCglsb2NhbCBlbCA9IGd1aTphdHRhY2goZWwpCglmdW5jdGlvbiBl
bDpkcmF3KCkKCQlsb2NhbCBrID0gc2VsZi5rCgkJcmVjdGZpbGwoMCwwLHNlbGYud2lkdGgtMSxz
ZWxmLmhlaWdodC0xLDApCgkJaWYgKGs9PWN1cnJlbnRfayBhbmQgaykgdGhlbgoJCQlyZWN0KDAs
MCxzZWxmLndpZHRoLTEsc2VsZi5oZWlnaHQtMSw3KQoJCQlyZWN0KDEsMSxzZWxmLndpZHRoLTIs
c2VsZi5oZWlnaHQtMiwwKQoJCWVuZAoJCQoJCXJlY3RmaWxsKDEsMSxzZWxmLndpZHRoLTIsc2Vs
Zi5oZWlnaHQtMix0b251bSh0ZGF0W2tdKSBvciAwKQoJZW5kCgkKCWZ1bmN0aW9uIGVsOmNsaWNr
KCkKCQljdXJyZW50X2sgPSBzZWxmLmsKCWVuZAoJCglyZXR1cm4gZWwKZW5kCmZ1bmN0aW9uIGNy
ZWF0ZV9wYXR0ZXJuX2VkaXRvcihlbCkKCWZ1bmN0aW9uIGVsOmRyYXcoKQoJCXJlY3RmaWxsKDAs
MCwxMDAwLDEwMDAsMCkKCQlzc3ByKHRkYXQuZGVza3RvcF9wYXR0ZXJuLDAsMCxuaWwsbmlsLDAs
MCxzZWxmLndpZHRoLHNlbGYuaGVpZ2h0KQoJZW5kCgkKCWZ1bmN0aW9uIGVsOmNsaWNrKG1zZykK
CQlsb2NhbCB4ID0gbXNnLm14ICogdGRhdC5kZXNrdG9wX3BhdHRlcm46d2lkdGgoKSAvIHNlbGYu
d2lkdGgKCQlsb2NhbCB5ID0gbXNnLm15ICogdGRhdC5kZXNrdG9wX3BhdHRlcm46aGVpZ2h0KCkg
LyBzZWxmLmhlaWdodAoJCWRyYXdfY29sID0gdGRhdC5kZXNrdG9wX3BhdHRlcm46Z2V0KHgseSkg
IT0gMCBhbmQgMCBvciA3CgllbmQKCQoJZnVuY3Rpb24gZWw6ZHJhZyhtc2cpCgkJbG9jYWwgeCA9
IG1zZy5teCAqIHRkYXQuZGVza3RvcF9wYXR0ZXJuOndpZHRoKCkgLyBzZWxmLndpZHRoCgkJbG9j
YWwgeSA9IG1zZy5teSAqIHRkYXQuZGVza3RvcF9wYXR0ZXJuOmhlaWdodCgpIC8gc2VsZi5oZWln
aHQKCQlzZXQodGRhdC5kZXNrdG9wX3BhdHRlcm4sIHgsIHksIGRyYXdfY29sKQoJCXN0b3JlX2xp
dmVfY2hhbmdlcygpCgkJCgllbmQKCQoJCglyZXR1cm4gZWwKZW5kCmZ1bmN0aW9uIGNyZWF0ZV9w
YWxldHRlX2Nob29zZXIoZWwpCglmdW5jdGlvbiBlbDpkcmF3KG1zZykKCQlyZWN0ZmlsbCgwLDAs
c2VsZi53aWR0aC0xLHNlbGYuaGVpZ2h0LTEsMCkKCQlsb2NhbCB3dz1zZWxmLndpZHRoXDgKCQls
b2NhbCBoaD1zZWxmLmhlaWdodFw0CgkJZm9yIHk9MCwzIGRvCgkJCWZvciB4PTAsNyBkbwoJCQkJ
bG9jYWwgc3g9eCp3dwoJCQkJbG9jYWwgc3k9eSpoaAoJCQkJcmVjdGZpbGwoc3grMSxzeSsxLHN4
K3d3LTEsc3kraGgtMSxwY29sc1t4K3kqOF0pCgkJCWVuZAoJCWVuZAoJZW5kCgkKCWZ1bmN0aW9u
IGVsOmNsaWNrKG1zZykKCQlsb2NhbCB4eD1taWQoMCxtc2cubXggKiA4IC8gc2VsZi53aWR0aCwg
IDcpXDEKCQlsb2NhbCB5eT1taWQoMCxtc2cubXkgKiA0IC8gc2VsZi5oZWlnaHQsIDMpXDEKCQlp
ZiAocGNvbHNbeHggKyB5eSAqIDhdKSB0ZGF0W2N1cnJlbnRfa10gPSBwY29sc1t4eCArIHl5ICog
OF0KCQlzdG9yZV9saXZlX2NoYW5nZXMoKQoJZW5kCglyZXR1cm4gZWwKZW5kCmZ1bmN0aW9uIGdl
bmVyYXRlX2d1aSgpCglndWkgPSBjcmVhdGVfZ3VpKCkKCQoJLS0gcGFsZXR0ZQoJZ3VpOmF0dGFj
aChjcmVhdGVfcGFsZXR0ZV9jaG9vc2VyewoJCXg9MTIwLHk9Nix3aWR0aD0xMTMsaGVpZ2h0PTQx
Cgl9KQoJCgktLSBwYXR0ZXJuIGVkaXRvcgoJCglndWk6YXR0YWNoKGNyZWF0ZV9wYXR0ZXJuX2Vk
aXRvcnsKCQl4ID0gMTIwLCB5ID0gNTIsIHdpZHRoID0gNzIsIGhlaWdodCA9IDcyfSkKCS0tIGNv
bG91ciBib3hlcwoJZm9yIGk9MSwjY2F0ZWdvcnkgZG8KCQlsb2NhbCBzeCxzeT02LDYrKGktMSkq
MTIKCQkKCQlndWk6YXR0YWNoewoJCQl4ID0gc3gsIHkgPSBzeSwgd2lkdGg9NTAsIGhlaWdodD0x
MCwKCQkJbGFiZWwgPSBjYXRlZ29yeVtpXVswXSwKCQkJZHJhdyA9IGZ1bmN0aW9uKHNlbGYpIHBy
aW50KHNlbGYubGFiZWwsIDAsMCw3KSBlbmQKCQl9CgkJZm9yIGo9MSwjY2F0ZWdvcnlbaV0gZG8K
CQkJY3JlYXRlX2NvbGJveHt4PXN4KzQwK2oqMTIseT1zeSx3aWR0aD05LGhlaWdodD05LGs9Y2F0
ZWdvcnlbaV1bal19CgkJZW5kCgllbmQKCQoJLS0gcGF0dGVybiBwcmVzZXRzCglmb3IgeT0wLDQg
ZG8KCQlmb3IgeD0wLDIgZG8KCQkJbG9jYWwgc3gsc3kgPSAxOTYgKyB4ICogMTIsIDUyICsgeSAq
IDEyCgkJCWd1aTphdHRhY2h7CgkJCQl4ID0gc3gsIHkgPSBzeSwgd2lkdGg9MTIsIGhlaWdodD0x
MiwKCQkJCWluZGV4ID0geCArIHkgKiAzLAoJCQkJZHJhdyA9IGZ1bmN0aW9uKHNlbGYsIG1zZykK
CQkJCQlyZWN0ZmlsbCgwLDAsMTEsMTEsMCkKCQkJCQlsb2NhbCBibXA9Z2V0X3NwcihzZWxmLmlu
ZGV4KQoJCQkJCXNwcihzZWxmLmluZGV4LCA2LWJtcDp3aWR0aCgpLzIsIDYtYm1wOmhlaWdodCgp
LzIpCgkJCQllbmQsCgkJCQl0YXAgPSBmdW5jdGlvbihzZWxmLCBtc2cpCgkJCQkJdGRhdC5kZXNr
dG9wX3BhdHRlcm4gPSBnZXRfc3ByKHNlbGYuaW5kZXgpOmNvcHkoKQoJCQkJCXN0b3JlX2xpdmVf
Y2hhbmdlcygpCgkJCQllbmQKCQkJfQoJCWVuZAoJZW5kCgkKCS0tIGJ1dHRvbnMKCWxvY2FsIHh4
LCB5eSA9IDEwLCAxMTAKCWxvY2FsIHNwYWNpbmcgPSA1CgkKCXh4Kz0gZ3VpOmF0dGFjaF9idXR0
b257CgkJeD14eCx5PXl5LAoJCWxhYmVsID0gIlNldCBhcyBEZWZhdWx0IiwKCQljbGljayA9IGZ1
bmN0aW9uKCkKCQkJc3RvcmUoIi9hcHBkYXRhL3N5c3RlbS90aGVtZS5wb2QiLCB0ZGF0KQoJCQls
b2NhbCBzZGF0ID0gZmV0Y2giL2FwcGRhdGEvc3lzdGVtL3NldHRpbmdzLnBvZCIKCQkJLS0gY2hh
bmdlIGVudHJ5IGluIHN5c3RlbSBzZXR0aW5ncwoJCQlpZiAoc2RhdCkgdGhlbgoJCQkJc2RhdC50
aGVtZSA9ICIvYXBwZGF0YS9zeXN0ZW0vdGhlbWUucG9kIgoJCQkJc3RvcmUoIi9hcHBkYXRhL3N5
c3RlbS9zZXR0aW5ncy5wb2QiLCBzZGF0KQoJCQllbmQKCQkJbm90aWZ5KCJzdG9yZWQgdG8gL2Fw
cGRhdGEvc3lzdGVtL3RoZW1lLnBvZCIpCgkJCgkJZW5kCgl9LndpZHRoK3NwYWNpbmcKCi0tW1sK
CXh4Kz0gZ3VpOmF0dGFjaF9idXR0b257CgkJeD14eCx5PXl5LAoJCWxhYmVsID0gIlJldmVydCIs
CgkJY2xpY2sgPSBmdW5jdGlvbigpCgkJCWZjb3B5KCIvYXBwZGF0YS9zeXN0ZW0vdGhlbWUucG9k
IiwiL3JhbS9zaGFyZWQvdGhlbWUucG9kIikKCQkJdGRhdCA9IGZldGNoIi9yYW0vc2hhcmVkL3Ro
ZW1lLnBvZCIKCQkJaWYgKHR5cGUodGRhdC5kZXNrdG9wX3BhdHRlcm4pIT0idXNlcmRhdGEiKSB0
aGVuCgkJCQl0ZGF0LmRlc2t0b3BfcGF0dGVybiA9IHVzZXJkYXRhKCJ1OCIsIDgsOCkKCQkJZW5k
CgkJZW5kCgl9LndpZHRoK3NwYWNpbmcKCQpdXQoKCmVuZAoKZnVuY3Rpb24gX2RyYXcoKQoJY2xz
KDEpCgkKCWd1aTpkcmF3X2FsbCgpCmVuZApmdW5jdGlvbiBfdXBkYXRlKCkKCWd1aTp1cGRhdGVf
YWxsKCkKZW5kCgoKCgoKCgoKCgoKCgoKCgoKCjo6IFtlb2NdCg==
:: demos/hexopus.p64
b64$cGljb3Ryb24gY2FydHJpZGdlIC8vIHd3dy5waWNvdHJvbi5uZXQKdmVyc2lvbiAyCgo6OiAu
aW5mby5wb2QKYjY0JExTMWJXM0J2WkN4amNtVmhkR1ZrUFNJeU1ESTBMVEF6TFRFeUlERTRPakV6
T2pVeklpeHRiMlJwWm1sbFpEMGlNakF5TkMwdwpOeTB3TmlBeE1UbzBPRG96TmlJc2MzUnZjbVZr
UFNJeU1ESTBMVEF6TFRFeUlERTRPakV6T2pVeklsMWRiSG8wQUFRQUFBQURBQUFBCk1HNXBiQT09
Cjo6IF9tZXRhLwo6OiBfbWV0YS8uaW5mby5wb2QKYjY0JExTMWJXM0J2WkN4amNtVmhkR1ZrUFNJ
eU1ESTBMVEF6TFRFeUlERTRPakV6T2pVeklpeHRiMlJwWm1sbFpEMGlNakF5TkMwdwpOeTB3TmlB
eE1UbzBPRG96TmlJc2MzUnZjbVZrUFNJeU1ESTBMVEF6TFRFeUlERTRPakV6T2pVeklsMWRiSG8w
QUFRQUFBQURBQUFBCk1HNXBiQT09Cjo6IF9tZXRhL3dvcmtzcGFjZXMucG9kCmI2NCRMUzBnY0ds
amIzUnliMjRnYjJKcVpXTjBJR1JoZEdFS2UzdGpjSEp2YWw5bWFXeGxQU0p0WVdsdUxteDFZU0lz
ZDI5eWEzTncKWVdObFgybHVaR1Y0UFRGOWZRPT0KOjogbWFpbi5sdWEKLS0gZmxleGluZyBoZXhv
cHVzCi0tIGJ5IHplcApmdW5jdGlvbiBkcmF3X3NlZ21lbnQoeCx5LHIsYSxjKQoJCglsaW5lKCkK
CWZvciBpPTAsNiBkbwoJCWxvY2FsIHggPSB4ICsgY29zKGEraS82KSAqIHIKCQlsb2NhbCB5ID0g
eSArIHNpbihhK2kvNikgKiByCgkJbGluZSh4LHksYykKCWVuZAoJCmVuZApsb2NhbCBkYSA9IDAK
ZnVuY3Rpb24gX2RyYXcoKQoJZGEgKz0gMC4wMDIKCWNscygxKQoJY2xpcCgxMCwxMCw0NjAsIDI1
MCkKCWNhbWVyYSgpCglyZWN0ZmlsbCgwLDAsNDgwLDI3MCwzMikKCQoJY2FtZXJhKDAsMCkKCQoJ
LS0gdG8gZG86IGNsaXBwaW5nIC8gY29vcmRpbmF0ZXMgb3V0c2lkZSBpMTYgcmFuZ2UKCS0tIHE9
MTAwMDAwCgktLSBsaW5lKDI0MC1xLDEzNS1xLzIsMjQwK3EsMTM1K3EvMiwxMCkKCQoJZm9yIGog
PSAwLDUgZG8KCWxvY2FsIHgseSA9IDI0MCwgMTM1Cglsb2NhbCByICAgPSAyMgoJbG9jYWwgYSAg
ID0gai82ICsgdGltZSgpLzgKCQoJZGEgPSBjb3ModGltZSgpLzUpLzEyCglmb3IgaSA9IDEsMjAg
ZG8KCQlkcmF3X3NlZ21lbnQoeCwgeSwgciouOSwgYSwgOCArIChpJTkpKQoJCXggKz0gY29zKGEp
ICogcgoJCXkgKz0gc2luKGEpICogcgoJCWEgKz0gZGEKCQlyICo9IGkgPCAxMCBhbmQgMC44IG9y
IDAuOQoJCXggKz0gY29zKGEpICogcgoJCXkgKz0gc2luKGEpICogcgoJZW5kCgllbmQKCWNsaXAo
KQoJcHJpbnQoc3RyaW5nLmZvcm1hdCgiJS41ZiIsIHN0YXQoMSkpLCAxMiwyLDE3KQplbmQKOjog
W2VvY10K
:: demos/carpet.p64
b64$cGljb3Ryb24gY2FydHJpZGdlIC8vIHd3dy5waWNvdHJvbi5uZXQKdmVyc2lvbiAyCgo6OiAu
aW5mby5wb2QKYjY0JExTMWJXM0J2WkN4amNtVmhkR1ZrUFNJeU1ESTBMVEV3TFRBNUlEQXlPalV3
T2pRMUlpeHRiMlJwWm1sbFpEMGlNakF5TkMwdwpOeTB3TmlBeE1UbzBPRG96TmlJc2MzUnZjbVZr
UFNJeU1ESTBMVEE1TFRBeUlERTNPakE1T2pVM0lpeDNiM0pyYzNCaFkyVnpQWHQ3CmJHOWpZWFJw
YjI0OUltMWhhVzR1YkhWaElpeDNiM0pyYzNCaFkyVmZhVzVrWlhnOU1YMTlYVjFzZWpRQUJBQUFB
QU1BQUFBd2JtbHMKOjogX21ldGEvCjo6IF9tZXRhLy5pbmZvLnBvZApiNjQkTFMxYlczQnZaQ3hq
Y21WaGRHVmtQU0l5TURJMExURXdMVEE1SURBeU9qVXdPalExSWl4dGIyUnBabWxsWkQwaU1qQXlO
QzB3Ck55MHdOaUF4TVRvME9Eb3pOaUlzYzNSdmNtVmtQU0l5TURJMExUVXdMVEE1SURBeU9qVXdP
alExSWwxZGJIbzBBQVFBQUFBREFBQUEKTUc1cGJBPT0KOjogX21ldGEvd29ya3NwYWNlcy5wb2QK
YjY0JExTMWJXM0J2WkN4amNtVmhkR1ZrUFNJeU1ESXpMVEk0TFRJeUlEQTVPakk0T2pNeUlpeHRi
MlJwWm1sbFpEMGlNakF5TXkwegpOaTB3TkNBd05qb3pOam95T0NJc2NtVjJhWE5wYjI0OU5EVTNO
bDFkYkhvMEFDMEFBQUFyQUFBQThCeDdlMk53Y205cVgyWnBiR1U5CkltMWhhVzR1YkhWaElpeDNi
M0pyYzNCaFkyVmZhVzVrWlhnOU1YMTkKOjogbWFpbi5sdWEKLS1bW3BvZF9mb3JtYXQ9InJhdyIs
Y3JlYXRlZD0iMjAyMy0yOS0yMiAwOToyOTozMyIsbW9kaWZpZWQ9IjIwMjQtMDktMDIgMTc6MDk6
NTciLHJldmlzaW9uPTI4MTddXQotLVs9WwoKVHJhbnNmb3JtYXRpb24gbWF0cmljZXMgaW4gUGlj
b3Ryb24gY2FuIGJlIGNvbnN0cnVjdGVkIGFzIDN4NCB1c2VyZGF0YSwgYW5kIHRoZW4KYXBwbGll
ZCB0byB2ZWN0b3JzICgzeDEgdXNlcmRhdGEpIG9yIG90aGVyIG1hdHJpY2VzIHVzaW5nIDptYXRt
dWwzZCgpCgp2ICAgICAgPSB2ZWMoMS4wLCAwLjAsIDAuMCkgICAgICAgICAgICAgICAtLSBjcmVh
dGUgYW4geHl6IHZlY3RvciAoYSBwb2ludCBpbiBzcGFjZSkKdiAgICAgID0gdjptYXRtdWwzZCht
KSAgICAgICAgICAgICAgICAgICAgLS0gdHJhbnNmb3JtIHYgYnkgbWF0cml4IG0KdiAgICAgID0g
djptYXRtdWwzZChvcF9hKTptYXRtdWwzZChvcF9iKSAgLS0gdHJhbnNmb3JtIHYgYnkgMiBtYXRy
aWNlcyAoYSB0aGVuIGIpCm9wX2FiICA9IG9wX2E6bWF0bXVsM2Qob3BfYikgICAgICAgICAgICAg
IC0tIGNvbWJpbmUgdHdvIG9wZXJhdGlvbnMgaW50byBvbmUgbWF0cml4CgpUaGUgMTIgdmFsdWVz
IGluIGEgM2QgdHJhbnNmb3JtYXRpb24gbWF0cml4IGxvb2sgbGlrZSB0aGlzOgotLVtbcG9kX3R5
cGU9ImltYWdlIl1ddW5wb2QoImI2NDpiSG8wQUlVQ0FBQUJBd0FBOENsd2VIVUFnQUFBQUUwQUFB
QUJBQUFBQXdUdy0tX0dfQ0R3TlBndThERDRBUEFjV1BBdFNQQXJTUEFxT1BBTEZoQVc4QTFJOENr
b01Bb0FFUUlGQUtCV1lDandLUmhRTnZBRER3RHdCQVVXZ0Nqd0tCaGdGdkFGUnZBRUZxQVk4Q2dj
QU1JSEZ2QURGckFZOEFSODhBdzlBQkFHT3dEeFBJQVk4QWtjOEEwNDhBdzI4QklZOEFnYzhBODQ4
REFvOEFjYzhCSDROdkFHSFBBVF9EUHdBRHdnSFBCcEhCQjg4R01NQUF6d0ctc3I4QVlNRUF6d0d2
c3Y4QUlNOEIwNzhDaGI0QWdBRUFsYUFEQU1POUFOQUJjUW93Q0ZVQ3V3RFBBZUt6Q2xBSU53RzZB
TThCOGJVS2NBZzRBYmtBendJQnRBcVFDRmtCdUFEUEFoS3lDb0FQRndZQnR3RFBBaU8tQUxOdkFQ
SzJBTThDUkw4Q3M3WUJmd0pIdndEUHNPY0JjNDhDTDdMNEFMUUhqd0FRandEUHNQOEJVTHdIaVFD
UEJQQy1BRmVDQUlFQmd3R1BCRUMtQU5TQkFZRUJqd0Mtd2I0QXZ3RUFnd09LRDhMN0FMOEE4SVVC
aWctQWJ3Rmx5UUMtQU9DRkE0Z0R6d0xFeUFDLUFUR0JBWWNDendESGNCdUR4d0MtQVNHREFZVUN4
QTJnQm1QR0FMOENBc2Z3RWdjQ3dSQUNNY2NOb0FJWkFjRHdBVFlOb0FFYUFQQUNZc1FOb0FBUzhB
WUR6d0RUYndFQXNBUUNFczhDOXFBUEVUSWp6d0tseUFDLUFqdlBBVy1BQ1FDLUFsLUMzQUMtQXQt
Qm53Q1F2d2J3dndjQVlBOEE4ai1TandCQXZ3SXYwczhBRUxNQnNnRy1BV1BmQWxYY0FMQUFzQUN4
QVFBSUVWUGZBb1hiQXJJQXdBVWkzd0swMndLQUJBRlIzd0RZWUFRQXN0OEFFUUFDZ1VMZGNBaGpB
dDhBRmI4QlF0MkFDRVFDM3dCUnZ3RkIzWkFDRmdIUkFBRkMxZEFoSndFQUFXUFYwQ1VFQWQ4QUZM
a0FEd0RndzI4QTB0OEM0OThDbE44QzlkOENDZDhETDlLLUE0LVNQdy0tX3oiKQpUaGUgdG9wIDN4
MyBhcmVhIGNhbiBiZSB0aG91Z2h0IG9mIGFzIGEgY29vcmRpbmF0ZSBzcGFjZSB0aGF0IHRyYW5z
Zm9ybWVkIHBvaW50IHdpbGwKYmUgc2NhbGVkIGFuZCByb3RhdGVkIGludG8uIFNvLCB2LnggbWVh
bnMgImhvdyBmYXIgdG8gdHJhdmVsIGFsb25nIHRoZSByZWQgdmVjdG9yIGluCm0iLiBUaGUgbGFz
dCByb3cgaXMgYSB0cmFuc2xhdGlvbiB2ZWN0b3IgZS5nLiAyLDAsMCBtZWFucyBtb3ZlIHRoZSBy
ZXN1bHQgcmlnaHQgYnkgMi4KCl09XQoKZnVuY3Rpb24gaWRlbnRpdHlfbWF0cml4KCkKCWxvY2Fs
IG0gPSB1c2VyZGF0YSgiZjY0IiwzLDQpCglzZXQobSwgMCwgMCwKCQkxLCAwLCAwLCAKCQkwLCAx
LCAwLCAKCQkwLCAwLCAxLCAKCQkwLCAwLCAwCgkpCglyZXR1cm4gbQplbmQKCgotLSByb3RhdGUg
cG9pbnQgeCx5IGFyb3VuZCBvcmlnaW4gYnkgYW5nbGUgYQpmdW5jdGlvbiByb3QyZCh4LHksYSkK
CXJldHVybiBjb3MoYSkqeCAtIHNpbihhKSp5LCBjb3MoYSkqeSArIHNpbihhKSp4CmVuZAoKLS0g
Y3JlYXRlIGEgdHJhbnNmb3JtYXRpb24gbWF0cml4IHRoYXQgcm90YXRlcyBhcm91bmQgYSBnaXZl
biBheGlzIGJ5IGFuZ2xlCi0tIGF4aXMgaXMgYSBzdHJpbmc6ICJ4IiwgInkiLCAieiIKZnVuY3Rp
b24gcm90YXRpb25fbWF0cml4KGF4aXMsIGFuZ2xlKQoJCgktLSBjb21wb25lbnQgb2Zmc2V0cyBk
ZXBlbmQgb24gd2hpY2ggYXhpcyB0byByb3RhdGUgYXJvdW5kCglsb2NhbCBkYXQgPSB7eD17Myw2
fSwgeT17MCw2fSwgej17MCwzfX0KCWxvY2FsIGMwLGMxID0gZGF0W2F4aXNdWzFdLCBkYXRbYXhp
c11bMl0KCQoJbG9jYWwgbSA9IGlkZW50aXR5X21hdHJpeCgpCgkKCS0tIHJvdGF0ZSB0aGUgY29t
cG9uZW50IHZlY3RvcnMgKGVhY2ggb25lIGlzIGEgY29sdW1uIGZyb20gcm93cyAwLi4yKQoJZm9y
IGNvbHVtbj0wLDIgZG8KCQltW2NvbHVtbiArIGMwXSwgbVtjb2x1bW4gKyBjMV0gPSByb3QyZCht
W2NvbHVtbiArIGMwXSwgbVtjb2x1bW4gKyBjMV0sIGFuZ2xlKQoJZW5kCglyZXR1cm4gbQplbmQK
CgpmdW5jdGlvbiBfaW5pdCgpCgoJLS0gbWFrZSAzMTM2IHBvaW50cwoJcD17fSBuID0gNDAKCWZv
ciB6ID0gLW4sbiwyIGRvCgkJZm9yIHggPSAtbixuLDIgZG8KCQkJbG9jYWwgeSA9IHNpbih6KmNv
cyh4LzE5KS8xMDAwKSArIHNpbih6LzUyKSAtIGNvcyh6LzM1KSpzaW4oeC83NykqMiArIDMKCQkJ
CS0tIHgsIHksIHosIGNvbG91cgoJCQkJLS0gbm90ZTogd2UgY2FuIHN0b3JlIHRoZSBjb2xvdXIg
aGVyZSwgYmVjYXVzZSBtYXRtdWwzZAoJCQkJLS0gb25seSBjYXJlcyBhYm91dCB0aGUgZmlyc3Qg
MyB2YWx1ZXMgb2YgZWFjaCByb3chCgkJCQlwWyNwKzFdID0gdmVjKHgsIHksIHosIDEwK3kqMS41
KSAKCQllbmQKCWVuZAoJCgktLSBjcmVhdGUgYSB1c2VyZGF0YSB0aGUgc2FtZSBzaXplLCB1c2Vk
IGZvciB6LXNvcnRpbmcKCW9yZGVyID0gdXNlcmRhdGEoImY2NCIsIDIsICNwKQoJZm9yIGk9MCwj
cC0xIGRvCgkJc2V0KG9yZGVyLCAwLCBpLCBpKzEpIC0tIHN0YXJ0aW5nIHNjb3JlCgkJc2V0KG9y
ZGVyLCAxLCBpLCBpKzEpIC0tIGluZGV4CgllbmQKCQplbmQJCgoKCmZ1bmN0aW9uIF9kcmF3KCkK
CWNscygpCglsb2NhbCB3dyA9IDI0MC4wCgkKCS0tIGNyZWF0ZSAzIG1hdHJpY2VzIHRoYXQgbW9k
aWZ5IHRoZSBvcmllbnRhdGlvbiBhbmQgcG9zaXRpb24gb2YKCS0tIHRoZSBsYW5kc2NhcGUgKGlu
IHRoaXMgZGVtbywgdGhlcmUgaXMgbm8gY29uY2VwdCBvZiBhIGNhbWVyYSkKCQoJc3Bpbl9hcm91
bmQgPSByb3RhdGlvbl9tYXRyaXgoInkiLHQoKS8yMCkgICAgICAgIAoJdGlsdCAgICAgICAgPSBy
b3RhdGlvbl9tYXRyaXgoIngiLDAuMDYpICAgICAgICAgIC0tIDAgdG8gc3RheSBmbGF0CglzaGlm
dF96ICAgICA9IGlkZW50aXR5X21hdHJpeCgpIHNoaWZ0X3pbMTFdID0gNzAgLS0gdHJ5IDIwIGZv
ciBjbG9zZSB1cAoJCgktLSBtYXRtdWwzZCgpIGlzIHVzZWQgdG8gbXVsdGlwbHkgM3g0IG1hdHJp
Y2VzCgktLSBoZXJlIHRoZSAzIHRyYW5zZm9ybWF0aW9ucyB3aWxsIGJlIGFwcGxpZWQgZnJvbSBs
ZWZ0IHRvIHJpZ2h0CgkKCW0gPSBzcGluX2Fyb3VuZDptYXRtdWwzZCh0aWx0KTptYXRtdWwzZChz
aGlmdF96KQoJCgktLSAodGhpcyBnaXZlcyB0aGUgc2FtZSByZXN1bHQgYXMgYXBwbHlpbmcgZWFj
aCBtYXRyaXggc2VwYXJhdGVseSBpbiB0aGUKCS0tIGlubmVyIGxvb3A6IHYgPSB2Om1hdG11bDNk
KHNwaW5hcm91bmQpIHYgPSBtYXRtdWwzZCh0aWx0KSBldGMpCgkKCS0tLS0tLS0tIHNvcnQgLS0t
LS0tLS0tCgoJLS0gKHVzaW5nIGNhbWVyYSB6IHZhbHVlcyBmcm9tIGxhc3QgZnJhbWUhKQoJCglv
cmRlcjpzb3J0KCkKCQoJLS0tLS0tLS0gZHJhdyAtLS0tLS0tLS0KCQoJbG9jYWwgdiA9IHZlYygw
LDAsMCkgLS0gcmV1c2VkIGZvciBldmVyeSB0cmFuc2Zvcm1lZCBwb2ludAoJCglsb2NhbCB2MCA9
IHZlYygwLDAsMCwwKQoJZm9yIGk9MCwjb3JkZXItMSwyIGRvCgkJYmxpdChwW29yZGVyW2krMV1d
LHYwKSAtLSBncmFiIGZyb20gdGhlIHNvcnRlZCBsaXN0CgkJCgkJdjAueSArPSBjb3ModCgpKi41
Kyh2MC54K3YwLnkpKi4wMSkqNQoKCQktLSBhcHBseSB0aGUgMyB0cmFuc2Zvcm1hdGlvbnMgdXNp
bmcgYSBzaW5nbGUgbWF0cml4CgkJLS0gKG0gbWVhbnMgc3BpbiBhcm91bmQsIHRpbHQsIGFuZCB0
aGVuIHNoaWZ0IGFsb25nIHopCgkJLS0gd3JpdGUgdGhlIG91dHB1dCB0byB2IGluc3RlYWQgb2Yg
Y3JlYXRpbmcgYSBuZXcgdXNlcmRhdGEgCgkJLS0gKCBmYXN0ZXIgdGhhbiBlLmcuIHYgPSBtYXRt
dWwzZChtLCB2MCkgKQoJCXYwOm1hdG11bDNkKG0sIHYpCgkJCgkJbG9jYWwgc3ogPSB2LnoKCQkK
CQlvcmRlcltpXSA9IC1zeiAtLSBzZXQgdGhlIHNjb3JlIGZvciBzb3J0aW5nIG5leHQgZnJhbWUg
KGRyYXcgZnVydGhlc3QgZmlyc3QpCgoJCWlmIChzeiA_IDAuMDEpIHRoZW4KCQkJLS0gaW4gZnJv
bnQgb2Ygdmlld3BsYW5lOyBkcmF3IGl0CgkJCWxvY2FsIHd3X2Rpdl9zeiA9IHd3IC8gc3oJCQoJ
CQlsb2NhbCBzeCA9IDI0MC4wICsgdi54ICogd3dfZGl2X3N6CgkJCWxvY2FsIHN5ID0gMTM1ICsg
di55ICogd3dfZGl2X3N6CgkJCS0tcHNldChzeCxzeSx2MC51KQoJCQljaXJjZmlsbChzeCxzeS01
MCwgMjUwL3N6LCB2MFszXSkKCQllbmQKCWVuZAoJCQoJLS1wcmludChzdHJpbmcuZm9ybWF0KCJj
cHU6ICUzLjNmICglZGZwcykiLCBzdGF0KDEpLCBzdGF0KDcpKSwgMTAsIDEwLCAxKQoJCmVuZAoK
Cgo6OiBbZW9jXQo=
:: demos/proggy.p64
b64$cGljb3Ryb24gY2FydHJpZGdlIC8vIHd3dy5waWNvdHJvbi5uZXQKdmVyc2lvbiAyCgo6OiAu
aW5mby5wb2QKYjY0JExTMWJXM0J2WkN4amNtVmhkR1ZrUFNJeU1ESTBMVEEwTFRNd0lERTVPakE1
T2pNeklpeHRiMlJwWm1sbFpEMGlNakF5TkMwdwpOeTB3TmlBeE1UbzBPRG96TmlJc2MzUnZjbVZr
UFNJeU1ESTBMVE0xTFRBeElERXhPak0xT2pFMElpeDNiM0pyYzNCaFkyVnpQWHQ3CmJHOWpZWFJw
YjI0OUltMWhhVzR1YkhWaElpeDNiM0pyYzNCaFkyVmZhVzVrWlhnOU1YMHNlMnh2WTJGMGFXOXVQ
U0p6Ym1sd2NHVjAKY3k5d1lXbHVkQzVzZFdFaUxIZHZjbXR6Y0dGalpWOXBibVJsZUQweGZTeDdi
RzlqWVhScGIyNDlJbk51YVhCd1pYUnpMM1p3WVdsdQpkQzVzZFdFaUxIZHZjbXR6Y0dGalpWOXBi
bVJsZUQweGZTeDdiRzlqWVhScGIyNDlJbk51YVhCd1pYUnpMMlJ2Ym5WMExteDFZU0lzCmQyOXlh
M053WVdObFgybHVaR1Y0UFRGOUxIdHNiMk5oZEdsdmJqMGljMjVwY0hCbGRITXZkMmhsWld3dWJI
VmhJaXgzYjNKcmMzQmgKWTJWZmFXNWtaWGc5TVgwc2UyeHZZMkYwYVc5dVBTSnpibWx3Y0dWMGN5
OXdkV3h6WlM1c2RXRWlMSGR2Y210emNHRmpaVjlwYm1SbAplRDB4ZlgxZFhXeDZOQUFFQUFBQUF3
QUFBREJ1YVd3PQo6OiBfbWV0YS8KOjogX21ldGEvLmluZm8ucG9kCmI2NCRMUzFiVzNCdlpDeGpj
bVZoZEdWa1BTSXlNREkwTFRFd0xUQXhJREV4T2pNME9qTTNJaXh0YjJScFptbGxaRDBpTWpBeU5D
MHcKTnkwd05pQXhNVG8wT0Rvek5pSXNjM1J2Y21Wa1BTSXlNREkwTFRNMExUQXhJREV4T2pNME9q
TTNJbDFkYkhvMEFBUUFBQUFEQUFBQQpNRzVwYkE9PQo6OiBfbWV0YS93b3Jrc3BhY2VzLnBvZApi
NjQkTFMxYlczQnZaQ3hqY21WaGRHVmtQU0l5TURJekxUSTVMVEV5SURBMk9qSTVPakV4SWl4dGIy
UnBabWxsWkQwaU1qQXlNeTB3Ck15MHdNaUF5TXpvd016bzBOQ0lzYlc5a2FXWnBaV1JmZEhNOUlq
SXdNREF0TURFdE1ERWdNREE2TURBNk1EQWlMSEpsZG1semFXOXUKUFRFNE5EWmRYV3g2TkFCNUFB
QUFNQUVBQVBrY2UzdGpjSEp2YWw5bWFXeGxQU0p0WVdsdUxteDFZU0lzZDI5eWEzTndZV05sWDJs
dQpaR1Y0UFRGOUxDb0E3M051YVhCd1pYUnpMM0JoYVc1ME5BQURIekkwQUFVZmRqVUFDQjh6TlFB
RlQyUnZiblUwQUFRZk5EUUFCVjkzCmFHVmxiRFFBQXg4MTBRQUdUM1ZzYzJVMEFBRlFlRDAyZlgw
PQo6OiBzbmlwcGV0cy8KOjogc25pcHBldHMvLmluZm8ucG9kCmI2NCRMUzFiVzNCdlpDeGpjbVZo
ZEdWa1BTSXlNREkwTFRFd0xUQXhJREV4T2pNME9qTTNJaXh0YjJScFptbGxaRDBpTWpBeU5DMHcK
Tnkwd05pQXhNVG8wT0Rvek5pSXNjM1J2Y21Wa1BTSXlNREkwTFRNMExUQXhJREV4T2pNME9qTTNJ
bDFkYkhvMEFBUUFBQUFEQUFBQQpNRzVwYkE9PQo6OiBzbmlwcGV0cy9kb251dC5sdWEKLS1bW3Bv
ZF9mb3JtYXQ9InJhdyIsY3JlYXRlZD0iMjAyMy01Mi0yMCAxMDo1MjoyNCIsbW9kaWZpZWQ9IjIw
MjQtMzUtMDEgMTE6MzU6MTQiLHJldmlzaW9uPTQ4XV0KY2xzKCkKCmZvciB5PS0yMCwyNjAsMTIg
ZG8KCWZvciB4PS0yMCwyNjAsIDQgZG8KCQlsb2NhbCBkeCA9IHgtMTIwCgkJbG9jYWwgZHkgPSB5
LTEyMAoJCWxvY2FsIGRkID0gc3FydChkeCpkeCtkeSpkeSkKCQlsb2NhbCBxID0gc2luKGRkLzE2
MC10aW1lKCkvNCkqMTYKCQlpZiAocT4wKSB0aGVuCgkJCWNpcmNmaWxsKHgrcSx5LXEsMSw4Kyhk
ZC84KSU4KQoJCWVuZAoJZW5kCmVuZAo6OiBzbmlwcGV0cy9kb3RzM2QubHVhCi0tW1twb2RfZm9y
bWF0PSJyYXciLGNyZWF0ZWQ9IjIwMjMtMzUtMTIgMDY6MzU6MjEiLG1vZGlmaWVkPSIyMDIzLTEy
LTAxIDAwOjEyOjU0IixyZXZpc2lvbj0yMjldXQotLSAzZCBkb3QgcGFydHkKLS0gYnkgemVwCmNs
cygpCgppZiAobm90IHB0KSB0aGVuCgktLSBtYWtlIHNvbWUgcG9pbnRzCglwdD17fQoJZm9yIHk9
LTEsMSwxLzIgZG8KCQlmb3IgeD0tMSwxLDEvMiBkbwoJCQlmb3Igej0tMSwxLDEvMiBkbwoJCQkJ
cD17fQoJCQkJcC54PXggcC55PXkgcC56PXoKCQkJCXAuY29sPTggKyBmbHIoeCoyK3kqMyklMTAK
CQkJCWFkZChwdCxwKQoJCQllbmQKCQllbmQKCWVuZAplbmQKCi0tIHJvdGF0ZSBwb2ludCB4LHkg
YnkgYQotLSAocm90YXRlcyBhcm91bmQgMCwwKQpmdW5jdGlvbiByb3QoeCx5LGEpCglsb2NhbCB4
MD14Cgl4ID0gY29zKGEpKnggLSBzaW4oYSkqeQoJeSA9IGNvcyhhKSp5ICsgc2luKGEpKngwIC0t
ICp4IGlzIHdyb25nIGJ1dCBraW5kYSBuaWNlIHRvbwoJcmV0dXJuIHgseQplbmQKCQoJCglmb3Ig
cCBpbiBhbGwocHQpIGRvCgkJLS10cmFuc2Zvcm06CgkJLS13b3JsZCBzcGFjZSAtPiBjYW1lcmEg
c3BhY2UKCQkKCQlwLmN4LHAuY3o9cm90KHAueCxwLnosdCgpLzgpCgkJcC5jeSxwLmN6PXJvdChw
LnkscC5jeix0KCkvNykKCQkKCQlwLmN6ICs9IDIgKyBjb3ModCgpLzYpCgllbmQKCQoJLS0gc29y
dCBmdXJ0aGVzdCAtPiBjbG9zZXN0CgktLSAoc28gdGhhdCB0aGluZ3MgaW4gZGlzdGFuY2UKCS0t
IGFyZW4ndCBkcmF3biBvdmVyIHRoaW5ncwoJLS0gaW4gdGhlIGZvcmVncm91bmQpCgkKCWZvciBw
YXNzPTEsNCBkbwoJZm9yIGk9MSwjcHQtMSBkbwoJCWlmIHB0W2ldLmN6IDwgcHRbaSsxXS5jeiB0
aGVuCgkJCS0tc3dhcAoJCQlwdFtpXSxwdFtpKzFdPXB0W2krMV0scHRbaV0KCQllbmQKCWVuZAoJ
Zm9yIGk9I3B0LTEsMSwtMSBkbwoJCWlmIHB0W2ldLmN6IDwgcHRbaSsxXS5jeiB0aGVuCgkJCS0t
c3dhcAoJCQlwdFtpXSxwdFtpKzFdPXB0W2krMV0scHRbaV0KCQllbmQKCWVuZAoJZW5kCgkKCXJh
ZDEgPSA1K2Nvcyh0KCkvNCkqNAoJZm9yIHAgaW4gYWxsKHB0KSBkbwoJCS0tdHJhbnNmb3JtOgoJ
CS0tY2FtZXJhIHNwYWNlIC0_IHNjcmVlbiBzcGFjZQoJCXN4ID0gMTIwICsgcC5jeCo2NC9wLmN6
CgkJc3kgPSAxMjAgKyBwLmN5KjY0L3AuY3oKCQlyYWQ9IHJhZDEvcC5jegoJCS0tIGRyYXcKCQkK
CQlpZiAocC5jeiA_IC4xKSB0aGVuCgkJCWNpcmNmaWxsKHN4LHN5LHJhZCxwLmNvbCkKCQkJY2ly
Y2ZpbGwoc3grcmFkLzMsc3ktcmFkLzMscmFkLzMsNykKCQllbmQKCWVuZAoKOjogc25pcHBldHMv
anVtYmxlLmx1YQotLVtbcG9kX2Zvcm1hdD0icmF3IixjcmVhdGVkPSIyMDIzLTMyLTMxIDIyOjMy
OjAxIixtb2RpZmllZD0iMjAyMy01NS0zMSAyMzo1NTo0NSIscmV2aXNpb249MTFdXQotLSBqdW1i
bGUgcGl4ZWxzCgpmb3IgaT0wLDI1MDAgZG8KCgktLSBjaG9vc2UgYSByYW5kb20gcG9pbnQKCWxv
Y2FsIHk9cm5kKDI0MCkKCWxvY2FsIHg9cm5kKDI0MCkKCQoJLS0gY2hvb3NlIGEgcmFuZG9tIG5l
aWdoYm91cgoJbG9jYWwgYT0ocm5kKDQpXDEpLzQKCWxvY2FsIHgyLHkyID0geCtjb3MoYSkseStz
aW4oYSkKCQoJLS0gc3dhcCB0aGUgdHdvIHBpeGVscwoJbG9jYWwgYz1wZ2V0KHgseSkKCXBzZXQo
eCx5LHBnZXQoeDIseTIpKQoJcHNldCh4Mix5MixjKQplbmQKCjo6IHNuaXBwZXRzL21hZ25ldC5s
dWEKLS1bW3BvZF9mb3JtYXQ9InJhdyIsY3JlYXRlZD0iMjAyMy0yMS0zMSAyMjoyMTozMCIsbW9k
aWZpZWQ9IjIwMjMtNTYtMzEgMjM6NTY6MDEiLHJldmlzaW9uPTQ4XV0KY2xzKCkKCmZvciB5PTAs
MjQwLDEwIGRvCmZvciB4PTAsMjQwLDEwIGRvCgoJLS0gYW5nbGUgYmV0d2VlbiBtb3VzZSBhbmQg
cG9pbnQKCWxvY2FsIGEgPSBhdGFuMihteCAtIHgsIG15IC0geSkKCQoJLS0gZHJhdyBhIGxpbmUg
aW4gdGhhdCBkaXJlY3Rpb24KCWxpbmUoeCx5LCB4K2NvcyhhKSo3LCB5K3NpbihhKSo3LCAxNCkK
CmVuZAplbmQKCjo6IHNuaXBwZXRzL3BhaW50Lmx1YQotLVtbcG9kX2Zvcm1hdD0icmF3IixjcmVh
dGVkPSIyMDIzLTM0LTEyIDA2OjM0OjUzIixtb2RpZmllZD0iMjAyNC0zNS0wMSAxMTozNToxNCIs
cmV2aXNpb249ODJdXQotLQlwYWludCBvbiB0aGUgb3V0cHV0IGltYWdlCgppZiBtYiA_IDAgdGhl
bgoJY2lyY2ZpbGwobXgsIG15LCAxMCwgOCArICh0KCkqMTApJTgpCmVuZAo6OiBzbmlwcGV0cy9w
dWxzZS5sdWEKLS1bW3BvZF9mb3JtYXQ9InJhdyIsY3JlYXRlZD0iMjAyMy0zMS0yMCAxMDozMTo1
MSIsbW9kaWZpZWQ9IjIwMjQtMzUtMDEgMTE6MzU6MTQiLHJldmlzaW9uPTU3XV0KY2xzKCkKY2ly
YygxMjAsMTIwLDQwK2Nvcyh0KCkpKjEwLDcpCgo6OiBzbmlwcGV0cy9zYW5kLmx1YQotLVtbcG9k
X2Zvcm1hdD0icmF3IixjcmVhdGVkPSIyMDIzLTMyLTIwIDEwOjMyOjA0Iixtb2RpZmllZD0iMjAy
My0xMi0wMSAwMDoxMjo1OCIscmV2aXNpb249MjBdXQpxID0gcSBhbmQgKHErMiklOSBvciAwCgpm
b3IgeT0yMzktcSUzLDAsLTMgZG8KZm9yIHg9MCtxXDMsMjM5LDMgZG8KCWlmIChwZ2V0KHgseSk9
PTApIHRoZW4KIAkJcHNldCh4LHkscGdldCh4LHktMSkpCiAJCXBzZXQoeCx5LTEsMCkKIAllbmQK
ZW5kCmVuZAoKOjogc25pcHBldHMvdnBhaW50Lmx1YQotLVtbcG9kX2Zvcm1hdD0icmF3IixjcmVh
dGVkPSIyMDIzLTM0LTEyIDA2OjM0OjUzIixtb2RpZmllZD0iMjAyNC0zNS0wMSAxMTozNToxNCIs
cmV2aXNpb249ODJdXQotLSB2YXBvcml6ZSB0aGUgb3V0cHV0IGJpdG1hcApmb3IgaT0xLDIwMDAg
ZG8KCWxvY2FsIHgseSA9IHJuZCgyNDApLHJuZCgyNDApCgljaXJjZmlsbCh4LHkscm5kKDEuNSle
MiwKCQltYXgoMCxwZ2V0KHgseSs1KSouOCkpCmVuZAoKY29sID0gY29sIG9yIDAKaWYgbWIgPiAw
IHRoZW4KIAljb2wgPSAoY29sICsgMS8yKSAlIDEwCgktLSBsZXJwCglmb3IgaT0wLDEsMS8xNiBk
bwoJCWNpcmNmaWxsKAoJCQlsYXN0X214KmkgKyBteCooMS1pKSwgCgkJCWxhc3RfbXkqaSArIG15
KigxLWkpLCAKCQkJMTAsIDggKyBjb2wpCgllbmQKZW5kCmxhc3RfbXgsIGxhc3RfbXksIGxhc3Rf
bWIgPSBteCxteSxtYgo6OiBzbmlwcGV0cy93aGVlbC5sdWEKLS1bW3BvZF9mb3JtYXQ9InJhdyIs
Y3JlYXRlZD0iMjAyMy0xOS0wMSAwMDoxOTozOCIsbW9kaWZpZWQ9IjIwMjQtMzUtMDEgMTE6MzU6
MTQiLHJldmlzaW9uPTQxXV0KY2xzKCkKZm9yIGk9MzEsMSwtMSBkbwoJY2lyY2ZpbGwoCgkJMTIw
ICsgY29zKHQoKStpLzUpKjUsCgkJMTIwICsgc2luKHQoKStpLzUpKjUsCgkJaSozLCBpKQplbmQK
Cgo6OiBtYWluLmx1YQotLVtbcG9kX2Zvcm1hdD0icmF3IixjcmVhdGVkPSIyMDIzLTMwLTEyIDA2
OjMwOjAxIixtb2RpZmllZD0iMjAyNC0zNS0wMSAxMTozNToxNCIscmV2aXNpb249NzE4XV0KLS1b
WwoJcHJvZ2d5OiBkZW1vbnN0cmF0ZSBsaXZlIGNvZGUgbG9hZGluZyBhbmQgZWRpdG9yIGd1aQoK
CXRvIHZpZXcgdGhlIHNuaXBwZXRzOgoJCgkJY2QgL3JhbS9jYXJ0L3NuaXBwZXRzCgkJbHMKCQll
ZGl0IGZvby5sdWEKXV0KCmZ1bmN0aW9uIF9pbml0KCkKCWcgPSBjcmVhdGVfZ3VpKCkKCWNlID0g
ZzphdHRhY2hfdGV4dF9lZGl0b3J7eD04LHk9MjAsd2lkdGg9MjE1LGhlaWdodD0yMDAsCgkJbWFy
a3VwPXRydWUsZW1iZWRfcG9kcz10cnVlLHN5bnRheF9oaWdobGlnaHRpbmc9dHJ1ZX0KCWNlOmF0
dGFjaF9zY3JvbGxiYXJze2F1dG9oaWRlPXRydWV9CgljZTpzZXRfdGV4dHsiY2xzKCkiLCJjaXJj
KDEyMCwxMjAsNDArY29zKHQoKSkqMTAsNykifQoKCWJtcCA9IHVzZXJkYXRhKCJ1OCIsMjQwLCAy
NDApCgkKCWNyZWF0ZV9zbmlwcGV0X2J1dHRvbnMoKQoJCmVuZAoKCmZ1bmN0aW9uIF9kcmF3KCkK
CWNscyg1KQoJCQoJZzp1cGRhdGVfYWxsKCkKCgkKCS0tIHJlY29tcGlsZSBieXRlY29kZSBldmVy
eSBmcmFtZSEKCS0tIGlmIHRoZXJlIGlzIGEgc3ludGF4IGVycm9yLCBuZXdmdW5jIHdpbGwgYmUg
bmlsIGFuZCB3ZSBjYW4gaWdub3JlIGl0Cglsb2NhbCBwcm9nID0gdGFibGUuY29uY2F0KGNlOmdl
dF90ZXh0KCksIlxuIikKCWxvY2FsIG5ld2Z1bmMgPSBsb2FkKHByb2cpCglpZiAobmV3ZnVuYykg
ZnVuYyA9IG5ld2Z1bmMKCQoJLS0gc29tZSBnbG9iYWxzIGZvciB0aGUgcHJvZ2xldCB0byB1c2UK
CW14LG15LG1iID0gbW91c2UoKQoJbXggLT0gMjMyICBteSAtPSAyMAoJCgktLSBkcmF3IGNvZGUg
ZWRpdG9yCglnOmRyYXdfYWxsKCkgCgkKCS0tIHJ1biB0aGUgcHJvZ2xldCBhbmQgc2hvdyB0aGUg
b3V0cHV0CglzZXRfZHJhd190YXJnZXQoYm1wKQoJaWYgKGZ1bmMpIGNvcmVzdW1lKGNvY3JlYXRl
KGZ1bmMpKQoJc2V0X2RyYXdfdGFyZ2V0KCkKCWJsaXQoYm1wLCBuaWwsIDAsIDAsIDIzMiwgMjAp
CgkKCS0tIHNob3cgZnBzCglwcmludChzdHJpbmcuZm9ybWF0KCJjcHU6JS4zZiIsc3RhdCgxKSks
IDQyMCw1LDEzKQplbmQKCmZ1bmN0aW9uIGNyZWF0ZV9zbmlwcGV0X2J1dHRvbnMoKQoKCXNuaXBw
ZXQ9bHMoInNuaXBwZXRzIikKCS0tIHRhYmxlLnNvcnQoc25pcHBldCkgLS0gcGVyaGFwcyB3b24n
dCBiZSBzdXBwb3J0ZWQgKHJlcXVpcmVzIGMgY2FsbCBib3VuZGFyeSkKCQoJbG9jYWwgeHggPSAx
MAoJbG9jYWwgeXkgPSAyMzAKCWZvciBpPTEsI3NuaXBwZXQgZG8KCQlsb2NhbCBlbCA9IGc6YXR0
YWNoX2J1dHRvbih7eD14eCx5PXl5LGxhYmVsPXN1YihzbmlwcGV0W2ldLDEsLTUpLCAKCQkJYmdj
b2w9MHgwNzA2LCBmZ2NvbD0weDA5MGQsCgkJCXRhcD1mdW5jdGlvbigpCgkJCQlsb2NhbCB0ZXh0
ID0gZmV0Y2goInNuaXBwZXRzLyIuLnNuaXBwZXRbaV0pCgkJCQljZTpzZXRfdGV4dChzcGxpdCh0
ZXh0LCJcbiIpKQoJCQllbmR9KQoJCXh4ICs9IGVsLndpZHRoICsgNAoJCWlmICh4eCA_IDIwMCkg
dGhlbgoJCQl4eCA9IDEwCgkJCXl5ICs9MTYKCQllbmQKCWVuZAoJCmVuZAoKOjogW2VvY10K
:: demos/highway.p64
b64$cGljb3Ryb24gY2FydHJpZGdlIC8vIHd3dy5waWNvdHJvbi5uZXQKdmVyc2lvbiAyCgo6OiAu
aW5mby5wb2QKYjY0JExTMWJXM0J2WkN4amNtVmhkR1ZrUFNJeU1ESXpMVEV3TFRFMUlEQTFPakkz
T2pFM0lpeHRiMlJwWm1sbFpEMGlNakF5TkMwdwpOeTB3TmlBeE1UbzBPRG96TmlKZFhXeDZOQUFF
QUFBQUF3QUFBREJ1YVd3PQo6OiBfbWV0YS8KOjogX21ldGEvLmluZm8ucG9kCmI2NCRMUzFiVzNC
dlpDeGpjbVZoZEdWa1BTSXlNREl6TFRFd0xURTFJREExT2pJM09qRTNJaXh0YjJScFptbGxaRDBp
TWpBeU5DMHcKTnkwd05pQXhNVG8wT0Rvek5pSmRYV3g2TkFBRUFBQUFBd0FBQURCdWFXdz0KOjog
X21ldGEvd29ya3NwYWNlcy5wb2QKYjY0JExTMWJXM0J2WkN4amNtVmhkR1ZrUFNJeU1ESXpMVEkz
TFRFMUlEQTFPakkzT2pFM0lpeHRiMlJwWm1sbFpEMGlNakF5TXkwMApOeTB4TlNBd056bzBOem8w
TVNJc2NtVjJhWE5wYjI0OU1qRTNYVjFzZWpRQUxRQUFBQ3NBQUFEd0hIdDdZM0J5YjJwZlptbHNa
VDBpCmJXRnBiaTVzZFdFaUxIZHZjbXR6Y0dGalpWOXBibVJsZUQweGZYMD0KOjogbWFpbi5sdWEK
LS1bW3BvZF9mb3JtYXQ9InJhdyIsY3JlYXRlZD0iMjAyMy0yNy0xNSAwNToyNzoyNCIsbW9kaWZp
ZWQ9IjIwMjMtNDctMTUgMDc6NDc6NDEiLHJldmlzaW9uPTg1MF1dCi0tW1sKCXRsaW5lM2QgdGVz
dAoJY2FuIGRvIGFyb3VuZCAzIHNjcmVlbnMgcGVyIGZyYW1lIGF0IDYwZnBzIHdoZW4gdXNpbmcg
ZmFzdCBwYXRoOgoJbWFza3MgYXJlIGFsbCAweDNmIGFuZCBmaWxsIHBhdHRlcm4gaXMgMApdXQpm
dW5jdGlvbiBfaW5pdCgpCglwbD17ZD0uMSwgeD0wLCB5PTUsIHo9MCwgZHg9MSwgZHk9MX0KCQoJ
LS0gY3JlYXRlIGEgdGV4dHVyZSBiaXRtYXAgYW5kIGRyYXcgc29tZXRoaW5nIG9uIGl0CglzcyA9
IHVzZXJkYXRhKCJ1OCIsMzIsMzIpCgkKCXNldF9kcmF3X3RhcmdldChzcykKCS0tY2lyYygxNiwx
Niw0LDcpCglsaW5lKDAsMCwzMSwwLDEpCglsaW5lKDAsMCwwLDMxLDEpCglzZXRfZHJhd190YXJn
ZXQoKQoJCglmb3IgeSA9IDAsNyBkbwoJCWZvciB4PTAsNyBkbwoJCQlzZXQoc3MsIHgsIHksIDgr
eC8zK3kvMykKCQllbmQKCWVuZAoJCmVuZApmdW5jdGlvbiBfZHJhdygpCgljbHMoKQoJbG9jYWwg
dj17fQoJdi54MCA9IGNvcyhwbC5kKzAuMSkgCiAJdi55MCA9IHNpbihwbC5kKzAuMSkKIAl2Lngx
ID0gY29zKHBsLmQtMC4xKQogCXYueTEgPSBzaW4ocGwuZC0wLjEpCgkKCWZvciB6ej0zLDEsLTEg
ZG8KCQoJZm9yIGk9MCw0IGRvCgkJcGFsKDgraSwgOCtpICsgKHp6LTEpKjIpCgllbmQKCQoJZmls
bHAoMCkKCgktLSBzbG93CgktLWlmICh6ej09MikgZmlsbHAoMHg1YTVhKQoJLS1pZiAoeno9PTMp
IGZpbGxwKDB4MWY0ZikKCQoJCglsb2NhbCB2eCA9IHYueDAKCWxvY2FsIHZ5ID0gdi55MAoJbG9j
YWwgZHZ4ID0gKHYueDEgLSB2LngwKSAvIDQ4MC4wCglsb2NhbCBkdnkgPSAodi55MSAtIHYueTAp
IC8gNDgwLjAKCWxvY2FsIHowID0genogKiA1MC4wCglsb2NhbCB6MSA9IHp6ICogNTAwLjAKCWxv
Y2FsIHg9cGwueAogCWxvY2FsIHk9cGwueQogCWxvY2FsIHo9cGwuei0yMCAtLSAxIHVuaXQgaGln
aAogCQoJZm9yIHN4PTAsNDc5LDEgZG8KCQkKCQl0bGluZTNkKHNzLCAgIHN4LCAyNzAsIHN4LCAz
MCwgIAoJCQkoeCt2eCp6MCkvejAsICh5K3Z5KnowKS96MCwgCgkJCSh4K3Z4KnoxKS96MSwgKHkr
dnkqejEpL3oxLCAgCgkJCTEuMC96MCwgMS4wL3oxKQoJCQkKCQl2eCArPSBkdngKCQl2eSArPSBk
dnkKCQkKCQktLWxpbmUoc3gsIDI2OSwgc3gsIDAsIHJuZCgzKSkKCWVuZAoJZW5kCgkKCWZpbGxw
KCkKCXByaW50KHN0cmluZy5mb3JtYXQoIiUuNGYgJWRmcHMiLHN0YXQoMSksIHN0YXQoNykpLDIs
Miw1KQoJCmVuZAoKZnVuY3Rpb24gX3VwZGF0ZSgpCglpZiAoYnRuKDApKSB0aGVuIHBsLmQ9KHBs
LmQrMC4wMDUpJTEgZW5kCglpZiAoYnRuKDEpKSB0aGVuIHBsLmQ9KHBsLmQrMC45OTUpJTEgZW5k
CglpZiAoYnRuKDIpIG9yIGJ0bigzKSkgdGhlbgoJCWxvY2FsIGFjY2VsID0gLjEKCQlpZiAoYnRu
KDMpKSBhY2NlbCA9IC1hY2NlbAoJCXBsLmR4ICs9IGNvcyhwbC5kKSAqIGFjY2VsCgkJcGwuZHkg
Kz0gc2luKHBsLmQpICogYWNjZWwKCWVuZAoJcGwueCArPSBwbC5keAoJcGwueSArPSBwbC5keQoJ
cGwuZHggKj0gLjk4CglwbC5keSAqPSAuOTgKZW5kCjo6IFtlb2NdCg==
:: demos/spiral.p64
b64$cGljb3Ryb24gY2FydHJpZGdlIC8vIHd3dy5waWNvdHJvbi5uZXQKdmVyc2lvbiAyCgo6OiAu
aW5mby5wb2QKYjY0JExTMWJXM0J2WkN4amNtVmhkR1ZrUFNJeU1ESTBMVEEwTFRNd0lERTVPakE1
T2pNeklpeHRiMlJwWm1sbFpEMGlNakF5TkMwdwpOeTB3TmlBeE1UbzBPRG96TmlKZFhXeDZOQUFF
QUFBQUF3QUFBREJ1YVd3PQo6OiBfbWV0YS8KOjogX21ldGEvLmluZm8ucG9kCmI2NCRMUzFiVzNC
dlpDeGpjbVZoZEdWa1BTSXlNREkwTFRBMExUTXdJREU1T2pBNU9qTXpJaXh0YjJScFptbGxaRDBp
TWpBeU5DMHcKTnkwd05pQXhNVG8wT0Rvek5pSmRYV3g2TkFBRUFBQUFBd0FBQURCdWFXdz0KOjog
X21ldGEvd29ya3NwYWNlcy5wb2QKYjY0JExTMGdjR2xqYjNSeWIyNGdiMkpxWldOMElHUmhkR0VL
ZTN0M2IzSnJjM0JoWTJWZmFXNWtaWGc5TVN4amNISnZhbDltYVd4bApQU0p0WVdsdUxteDFZU0o5
ZlE9PQo6OiBtYWluLmx1YQotLSBzcGlyYWwKLS0gYnkgemVwCmZ1bmN0aW9uIF9kcmF3KCkKCWNs
cygpCglmb3IgaT0xLDE1MCwyIGRvCgkJbG9jYWwgc3ggPSAyNDAgKyBjb3MoLXQoKS8yK2kvMzAp
KjkKCQlsb2NhbCBzeSA9IDEzNSArIHNpbigtdCgpLzIraS8zMCkqOQoJCWxvY2FsIHI9MitpKjMK
CQkKCQljaXJjKHN4LCBzeSwgciwgMTIpCgllbmQKCXByaW50KHN0cmluZy5mb3JtYXQoIiUuNWYi
LHN0YXQoMSkpLDIsMiw3KQplbmQKOjogW2VvY10K
:: screensavers/breach.p64
b64$cGljb3Ryb24gY2FydHJpZGdlIC8vIHd3dy5waWNvdHJvbi5uZXQKdmVyc2lvbiAyCgo6OiAu
aW5mby5wb2QKYjY0JExTMWJXM0J2WkN4amNtVmhkR1ZrUFNJeU1ESTBMVEEwTFRNd0lERTVPakE1
T2pNeklpeHRiMlJwWm1sbFpEMGlNakF5TkMwdwpOeTB3TmlBeE1UbzBPRG96TmlJc2MzUnZjbVZr
UFNJeU1ESTBMVFV5TFRBeUlESXdPalV5T2pJM0lpeDNiM0pyYzNCaFkyVnpQWHQ3CmJHOWpZWFJw
YjI0OUltMWhhVzR1YkhWaElpeDNiM0pyYzNCaFkyVmZhVzVrWlhnOU1YMHNlMnh2WTJGMGFXOXVQ
U0puWm5ndk1DNW4KWm5naUxIZHZjbXR6Y0dGalpWOXBibVJsZUQweWZTeDdiRzlqWVhScGIyNDlJ
bTFoY0M5dFlYQXdMbTFoY0NJc2QyOXlhM053WVdObApYMmx1WkdWNFBUTjlMSHRzYjJOaGRHbHZi
ajBpYzJaNEwzTm1lREF1YzJaNElpeDNiM0pyYzNCaFkyVmZhVzVrWlhnOU5IMTlYVjFzCmVqUUFC
QUFBQUFNQUFBQXdibWxzCjo6IGdmeC8KOjogZ2Z4Ly5pbmZvLnBvZApiNjQkTFMxYlczQnZaQ3hq
Y21WaGRHVmtQU0l5TURJMExURXdMVEF5SURJd09qTTFPakl4SWl4dGIyUnBabWxsWkQwaU1qQXlO
QzB3Ck55MHdOaUF4TVRvME9Eb3pOaUlzYzNSdmNtVmtQU0l5TURJMExUTTFMVEF5SURJd09qTTFP
akl4SWwxZGJIbzBBQVFBQUFBREFBQUEKTUc1cGJBPT0KOjogZ2Z4LzAuZ2Z4CmI2NCRMUzFiVzNC
dlpDeGpjbVZoZEdWa1BTSXlNREkwTFRNMUxUQXlJREl3T2pNMU9qSXhJaXh0YjJScFptbGxaRDBp
TWpBeU5DMDEKTWkwd01pQXlNRG8xTWpveU55SXNjbVYyYVhOcGIyNDlNVEUxWFYxc2VqUUFjUUFB
QUFVekFBRHpGSHRiTUYwOWUySnRjRDF3ZUhVQQpReUFRRUFUdzhDeG1iR0ZuY3owd0xIQmhibDk0
Q0FEdmVUMHdMSE5qWVd4bFBURXlmU3d6QVAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tCi0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tNTFBOU1USjlmUT09Cjo6IG1hcC8K
OjogbWFwLy5pbmZvLnBvZApiNjQkTFMxYlczQnZaQ3hqY21WaGRHVmtQU0l5TURJMExURXdMVEF5
SURJd09qTTFPakl4SWl4dGIyUnBabWxsWkQwaU1qQXlOQzB3Ck55MHdOaUF4TVRvME9Eb3pOaUlz
YzNSdmNtVmtQU0l5TURJMExUTTFMVEF5SURJd09qTTFPakl4SWwxZGJIbzBBQVFBQUFBREFBQUEK
TUc1cGJBPT0KOjogbWFwL21hcDAubWFwCmI2NCRMUzFiVzNCdlpDeGpjbVZoZEdWa1BTSXlNREkw
TFRNMUxUQXlJREl3T2pNMU9qSXhJaXh0YjJScFptbGxaRDBpTWpBeU5DMDEKTWkwd01pQXlNRG8x
TWpveU55SXNjbVYyYVhOcGIyNDlNVEUwWFYxc2VqUUFhUUFBQUtNSUFBRHdFM3RzWVhsbGNqMTdX
ekJkUFh0aQpiWEE5ZFhObGNtUmhkR0VvSW1reE5pSXNNVFlEQUM4aU1BRUEtLS0tNzZFaUtTeHdZ
VzVmZUQwd0NBRHlCbms5TUN4elkyRnNaVDB4CkxIUnBiR1ZmYUQweE5nb0FiM2M5TVRaOUxFc0Ut
LS0tLXpoUU1UWjlmWDA9Cjo6IHNmeC8KOjogc2Z4Ly5pbmZvLnBvZApiNjQkTFMxYlczQnZaQ3hq
Y21WaGRHVmtQU0l5TURJMExURXdMVEF5SURJd09qTTFPakl4SWl4dGIyUnBabWxsWkQwaU1qQXlO
QzB3Ck55MHdOaUF4TVRvME9Eb3pOaUlzYzNSdmNtVmtQU0l5TURJMExUTTFMVEF5SURJd09qTTFP
akl4SWwxZGJIbzBBQVFBQUFBREFBQUEKTUc1cGJBPT0KOjogc2Z4L3NmeDAuc2Z4CmI2NCRMUzFi
VzNCdlpDeGpjbVZoZEdWa1BTSXlNREkwTFRNMUxUQXlJREl3T2pNMU9qSXlJaXh0YjJScFptbGxa
RDBpTWpBeU5DMDEKTWkwd01pQXlNRG8xTWpveU55SXNjbVYyYVhOcGIyNDlNVEV6WFYxc2VqUUFF
QUVBQUZFSEFBRHdKM0I0ZFFBREtBQUFBd0FFRDBBUQpBZzRBQWFBQklBS2dEZ0FQRUFBTjhNb0JB
Z01FQlFZSEFRLS1rQWdKQ2dzUERBOE5EdzRQRHhBQThBQU5EeEVQRWc4VER4UVBGUThXCkR4Y1RB
UEVCRHhnUEdROGFEeHNQSEE4ZER4NFBIeFFBOFFBZ0R5RVBJZzhqRHlRUEpROG1EeWNVQVBFQUtB
OHBEeW9QS3c4c0R5MFAKTGc4dkZBRHhBREFQTVE4eUR6TVBOQTgxRHpZUE54UUEtd1U0RHprUE9n
ODdEendQUFE4X0R6OEJELS13LXdFQTYtOG5XZ0VRQmc4ZwpFQUVnQVNBQjhBQUNFQUlNRUFFZ0R5
RWdBVEFQUVBERER5Z1AtLURHRC1nS0QtOFBnQS0zRHcwQjhBa0JFQVlNTUFELU9SLS1BUURjCnYt
Z1BRQUFOUVAtLXNQQndDZ0QtLTJRZi13RUFsMUQtLS0tLUh3PT0KOjogbWFpbi5sdWEKLS1bW3Bv
ZF9mb3JtYXQ9InJhdyIsY3JlYXRlZD0iMjAyNC0zNS0wMiAyMDozNToyMSIsbW9kaWZpZWQ9IjIw
MjQtNTItMDIgMjA6NTI6MjciLHJldmlzaW9uPTE5MV1dCgpsb2NhbCB0dD0wCgoKZnVuY3Rpb24g
X2RyYXcoKQoJY2xzKCkKCWxvY2FsIHJyPSAzMAoJCglmb3IgaT0wLDgsMiBkbyB0dCs9MC4wMQoJ
CglteCA9IDI0MCtjb3ModHQvMTcpKjEyMAoJbXkgPSAxMzUrc2luKHR0LzEyKSo4MCArIHNpbih0
dC8xNykqNTAKCQoJCglmb3IgeD0wLDIzIGRvCgkJZm9yIHk9MjIsNDUgZG8JCgkJCWxvY2FsIHN4
ID0gIHgqNiozICsgKHklMikqOQoJCQlsb2NhbCBzeSA9ICB5KjQKCQkJbG9jYWwgZHgsZHkgPSBt
eC1zeCwgbXktc3kKCQkJZHgvPTggZHkvPTgKCQkJbG9jYWwgYWEgPSBhdGFuMihkeCwgZHkpCgkJ
CWxvY2FsIHEgPSBzcXJ0KGR4KmR4LGR5KmR5KQoJCQkKCQkJc3ggLT0gY29zKGFhKSo0NQoJCQlz
eSAtPSBzaW4oYWEpKjQ1CgkJCXBzZXQoc3gsc3ksMTIraSkKCQllbmQKCQlsb2NhbCBhYT14LzI0
LXR0LzgKCQkKCQlwc2V0KG14K2NvcyhhYSkqcnIsbXkrc2luKGFhKSpyciw4KygoeCthYSoxMikl
OSkpCgllbmQKCgllbmQKCQoJLS1wcmludChzdGF0KDEpLDQwMCwyLDcpCgktLWNpcmMobXgsbXks
cnIvMiw3KQplbmQKCjo6IFtlb2NdCg==
:: screensavers/bunny.p64
b64$cGljb3Ryb24gY2FydHJpZGdlIC8vIHd3dy5waWNvdHJvbi5uZXQKdmVyc2lvbiAyCgo6OiAu
aW5mby5wb2QKYjY0JExTMWJXM0J2WkN4amNtVmhkR1ZrUFNJeU1ESXpMVEV3TFRBeUlESXlPalUx
T2pRMUlpeHRiMlJwWm1sbFpEMGlNakF5TkMwdwpOeTB3TmlBeE1UbzBPRG96TmlJc2MzUnZjbVZr
UFNJeU1ESTBMVFE0TFRBMUlEQTRPalE0T2pBNElpeDNiM0pyYzNCaFkyVnpQWHQ3CmJHOWpZWFJw
YjI0OUltMWhhVzR1YkhWaElpeDNiM0pyYzNCaFkyVmZhVzVrWlhnOU1YMHNlMnh2WTJGMGFXOXVQ
U0puWm5ndk1DNW4KWm5naUxIZHZjbXR6Y0dGalpWOXBibVJsZUQweWZYMWRYV3g2TkFBRUFBQUFB
d0FBQURCdWFXdz0KOjogX21ldGEvCjo6IF9tZXRhLy5pbmZvLnBvZApiNjQkTFMxYlczQnZaQ3hq
Y21WaGRHVmtQU0l5TURJekxURXdMVEF5SURJeU9qVTFPalExSWl4dGIyUnBabWxsWkQwaU1qQXlO
QzB3Ck55MHdOaUF4TVRvME9Eb3pOaUlzYzNSdmNtVmtQU0l5TURJekxUVTFMVEF5SURJeU9qVTFP
alExSWwxZGJIbzBBQVFBQUFBREFBQUEKTUc1cGJBPT0KOjogX21ldGEvd29ya3NwYWNlcy5wb2QK
YjY0JExTMGdjR2xqYjNSeWIyNGdiMkpxWldOMElHUmhkR0VLZTN0M2IzSnJjM0JoWTJWZmFXNWta
WGc5TVN4amNISnZhbDltYVd4bApQU0p0WVdsdUxteDFZU0o5ZlE9PQo6OiBnZngvCjo6IGdmeC8u
aW5mby5wb2QKYjY0JExTMWJXM0J2WkN4amNtVmhkR1ZrUFNJeU1ESTBMVEV3TFRBMUlEQTNPakk0
T2pJd0lpeHRiMlJwWm1sbFpEMGlNakF5TkMwdwpOeTB3TmlBeE1UbzBPRG96TmlJc2MzUnZjbVZr
UFNJeU1ESTBMVEk0TFRBMUlEQTNPakk0T2pJd0lsMWRiSG8wQUFRQUFBQURBQUFBCk1HNXBiQT09
Cjo6IGdmeC8wLmdmeApiNjQkTFMxYlczQnZaQ3hqY21WaGRHVmtQU0l5TURJMExUSTRMVEExSURB
M09qSTRPakl3SWl4dGIyUnBabWxsWkQwaU1qQXlOQzAwCk9DMHdOU0F3T0RvME9Eb3dPQ0lzY21W
MmFYTnBiMjQ5TXpVd1hWMXNlalFBc3dBQUFGb3pBQUQtRkh0Yk1GMDllMkp0Y0Qxd2VIVUEKUXlB
UUVBUVFKMUFuSUVjd1J4QUhMZ2N3Qnk0SENBQVdtZGNRMXhBWEVGY1FGd1lBOHdmWElFY1FSMENY
SUN4bWJHRm5jejB3TEhCaApibDk0Q0FEbmVUMHdMSE5qWVd4bFBURXlmU3lJQUY4SUNBVHdNRE1B
LS0tLS0tOU9YeEFRQlBEd013Q0dELThBdVFfWUFmOGdEek1BCi0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tMTFBOU1USjlmUT09Cjo6IG1hcC8K
OjogbWFwLy5pbmZvLnBvZApiNjQkTFMxYlczQnZaQ3hqY21WaGRHVmtQU0l5TURJMExURXdMVEEx
SURBM09qSTRPakl3SWl4dGIyUnBabWxsWkQwaU1qQXlOQzB3Ck55MHdOaUF4TVRvME9Eb3pOaUlz
YzNSdmNtVmtQU0l5TURJMExUSTRMVEExSURBM09qSTRPakl3SWwxZGJIbzBBQVFBQUFBREFBQUEK
TUc1cGJBPT0KOjogbWFwLzAubWFwCmI2NCRMUzFiVzNCdlpDeGpjbVZoZEdWa1BTSXlNREl6TFRV
MExUQXpJREEwT2pVME9qSTNJaXh0YjJScFptbGxaRDBpTWpBeU15MDEKT0Mwd015QXdORG8xT0Rv
d01TSXNjbVYyYVhOcGIyNDlNelZkWFd4Nk5BQnBBQUFBb3dnQUFQQVRlMnhoZVdWeVBYdGJNRjA5
ZTJKdApjRDExYzJWeVpHRjBZU2dpYVRFMklpd3hOZ01BTHlJd0FRRC0tLS12b1NJcExIQmhibDk0
UFRBSUFQSUdlVDB3TEhOallXeGxQVEVzCmRHbHNaVjlvUFRFMkNnQnZkejB4Tm4wc1N3VC0tLS0t
T0ZBeE5uMTlmUT09Cjo6IG1hcC9tYXAwLm1hcApiNjQkTFMxYlczQnZaQ3hqY21WaGRHVmtQU0l5
TURJMExUSTRMVEExSURBM09qSTRPakl3SWl4dGIyUnBabWxsWkQwaU1qQXlOQzB5Ck5TMHdOU0F3
T0RveU5UbzBOU0lzY21WMmFYTnBiMjQ5TWpFNFhWMXNlalFBWFFBQUFGZ0VBQUR3RTN0c1lYbGxj
ajE3V3pCZFBYdGkKYlhBOWRYTmxjbVJoZEdFb0lta3hOaUlzTVRZREFDOGlNQUVBLS0tLTc2RWlL
U3h3WVc1ZmVEMHdDQUR5Qm5rOU1DeHpZMkZzWlQweApMSFJwYkdWZmFEMHhOZ29BY0hjOU1UWjlm
WDA9Cjo6IHNmeC8KOjogc2Z4Ly5pbmZvLnBvZApiNjQkTFMxYlczQnZaQ3hqY21WaGRHVmtQU0l5
TURJMExURXdMVEExSURBM09qSTRPakl3SWl4dGIyUnBabWxsWkQwaU1qQXlOQzB3Ck55MHdOaUF4
TVRvME9Eb3pOaUlzYzNSdmNtVmtQU0l5TURJMExUSTRMVEExSURBM09qSTRPakl3SWwxZGJIbzBB
QVFBQUFBREFBQUEKTUc1cGJBPT0KOjogc2Z4LzAuc2Z4CmI2NCRMUzFiVzNCdlpDeGpjbVZoZEdW
a1BTSXlNREl6TFRVMExUQXpJREEwT2pVME9qSTNJaXh0YjJScFptbGxaRDBpTWpBeU15MDEKTnkw
d015QXdORG8xTnpvME1pSXNjbVYyYVhOcGIyNDlNelJkWFd4Nk5BQnZBQUFBN1FZQUFOOXdlSFVB
QXlnQUFBTUFCUEQtQVFEcwoteWZ4QVJBR0R5QVFBU0FCSUFId0FBSVFBZzRRQVNBUElTQUJNQTlB
OE1NUEtBLS04TVlQX0FvUC13X0FELWNQRFFId0NRRVFCZzR3CkFQODVILThCQU56UF9BOUFBQThR
UVAtLXNQQndDd0QtLTZNZi13RUFsMUQtLS0tLUh3PT0KOjogc2Z4L3NmeDAuc2Z4CmI2NCRMUzFi
VzNCdlpDeGpjbVZoZEdWa1BTSXlNREkwTFRJNExUQTFJREEzT2pJNE9qSXdJaXh0YjJScFptbGxa
RDBpTWpBeU5DMHkKTlMwd05TQXdPRG95TlRvME5TSXNjbVYyYVhOcGIyNDlNakUxWFYxc2VqUUFF
QUVBQUZFSEFBRHdKM0I0ZFFBREtBQUFBd0FFRDBBUQpBZzRBQWFBQklBS2dEZ0FQRUFBTjhNb0JB
Z01FQlFZSEFRLS1rQWdKQ2dzUERBOE5EdzRQRHhBQThBQU5EeEVQRWc4VER4UVBGUThXCkR4Y1RB
UEVCRHhnUEdROGFEeHNQSEE4ZER4NFBIeFFBOFFBZ0R5RVBJZzhqRHlRUEpROG1EeWNVQVBFQUtB
OHBEeW9QS3c4c0R5MFAKTGc4dkZBRHhBREFQTVE4eUR6TVBOQTgxRHpZUE54UUEtd1U0RHprUE9n
ODdEendQUFE4X0R6OEJELS13LXdFQTYtOG5XZ0VRQmc4ZwpFQUVnQVNBQjhBQUNFQUlNRUFFZ0R5
RWdBVEFQUVBERER5Z1AtLURHRC1nS0QtOFBnQS0zRHcwQjhBa0JFQVlNTUFELU9SLS1BUURjCnYt
Z1BRQUFOUVAtLXNQQndDZ0QtLTJRZi13RUFsMUQtLS0tLUh3PT0KOjogYm9uZXMubHVhCi0tW1tw
b2RfZm9ybWF0PSJyYXciLGNyZWF0ZWQ9IjIwMjQtMzItMDUgMDc6MzI6MzgiLG1vZGlmaWVkPSIy
MDI0LTI1LTA1IDA4OjI1OjQ1IixyZXZpc2lvbj0yNDRdXQotLVtbCgoJCgpdXQoKZnVuY3Rpb24g
Ym9uZSh4LHksYSkKIGxvY2FsIGwgPTcKIGxvY2FsIGI9NjYKIAogYSs9MS8yOAogYSU9MQogbG9j
YWwgcT0gZmxyKGEqNCkgLS0gMC4uMyAtLSB3aGljaCBncm91cCBvZiA3CiBsb2NhbCBvZnM9e1sw
XT0KICAxLDUsIDUsNSwgNSwxLCAxLDEKIH0KIAogLS1saW5lKHgseSx4K2NvcyhhKSpsLHkrc2lu
KGEpKmwsIDE0KQoKIGxvY2FsIGk9ZmxyKChhJTAuMjUpKjI4KQogYiA9IGZscihhKjI4KQogeC09
b2ZzW3EqMiswXQogeS09b2ZzW3EqMisxXQoKIHNwcihiLHgseSkKIAplbmQKCgpmdW5jdGlvbiBk
cmF3X3NrZWxseShzKQoKCWxvY2FsIGE9cy5wb3NlCglsb2NhbCBzeD0wCglsb2NhbCBzeT0wCgls
b2NhbCB4LHkKCWxvY2FsIGw9NwoJbG9jYWwgbGw9OCAtLSBsZWcgbGVuZ3RoCgoJcGRhdD17WzBd
PQoJCXs3LC02LDd9LAoJCXstOCwtNiw3fSwKCQl7Myw2LDh9LAoJCXstNCw2LDh9Cgl9CgoJLS1j
aXJjZmlsbChzLngsIHMueSwgMiw4KQoJCgktLSBjYWxjIGxvd2VzdCBmb290CgoJbHggPSAwCgls
eSA9IHN5ICsgMTAgLS0gaGlwIGJvbmUKCWxpID0gMAoJZm9yIGk9MiwzIGRvCgkJbG9jYWwgZD1w
ZGF0W2ldCgkJbG9jYWwgeD1zeCtkWzFdIAoJCWxvY2FsIHk9c3krZFsyXSswIC0tIGhpcAoKCQl4
Kz1jb3MoYVtpKjJdKSpkWzNdIAoJCXkrPXNpbihhW2kqMl0pKmRbM10KCQl4Kz1jb3MoYVtpKjIr
MV0pKmRbM10gCgkJeSs9c2luKGFbaSoyKzFdKSpkWzNdCgoJCWx5ID0gbWF4KGx5LHkpCgkJaWYg
KGk9PTIgb3IgbHk9PXkpIHRoZW4KCQkJbHg9eAoJCQlsaT1pCgkJZW5kCgllbmQKIAoJLS0gYWRq
dXN0CglzeSAtPSAobHkgLSAyMikKCgoJaWYgKG5vdCBzLmxseCkgcy5sbHg9MAoJaWYgKHMuY2kg
IT0gbGkpIHRoZW4KCQktLSBwbGFudCBhbmNob3IgZm9vdCAKCQktLSAuY3ggbWVhbnMgYW5jaG9y
IHJlbGF0aXZlIHRvIHN0YXJ0aW5nIHBvc2l0aW9uIChub3QgJ2NlbnRlcicpCgkJcy5jeCA9IGx4
ICsgKHMuY3ggLSBzLmxseCkKCQlzLmNpID0gbGkKCWVuZAoJIAoJcy5sbHg9bHggLS0gbGFzdCBs
b3dlc3QgeAoJc3ggLT0gKGx4IC0gcy5jeCkKCXN4ICs9IHMueAoJc3kgKz0gcy55CiAKCgktLSBi
b2R5CglzcHIoNDAsc3gtOCwgc3ktOCkKCgktLSByZWd1bGFyIGhlYWQKCXNwcigzMixzeC0zK3Mu
aHgsc3ktMTQrcy5oeSkKCgktLSBidW5ueSBoZWFkIChlYXN0ZXIpCgktLXNwcig0MyxzeC0zK3Mu
aHgsc3ktMTQrcy5oeS04LDEuMjUsMikKCQoJZm9yIGk9MCwzIGRvCgkJbG9jYWwgZD1wZGF0W2ld
CgkJeD1zeCtkWzFdIHk9c3krZFsyXQoKCQlib25lKHgseSxhW2kqMl0saSoyKzApCgoJCXgrPWNv
cyhhW2kqMl0pKmRbM10gCgkJeSs9c2luKGFbaSoyXSkqZFszXQoKCQlib25lKHgseSxhW2kqMisx
XSxpKjIrMSkKCgllbmQKCmVuZAoKCgo6OiBtYWluLmx1YQotLVtbcG9kX2Zvcm1hdD0icmF3Iixj
cmVhdGVkPSIyMDIzLTA1LTI4IDA3OjA1OjEyIixtb2RpZmllZD0iMjAyNC00OC0wNSAwODo0ODow
OCIscmV2aXNpb249MTcwXV0KLS0gZGlzY28gc2t1bGwgMgotLSBieSB6ZXAKLS0gc2t1bGwgc3By
aXRlCmRhdGE9ezI1MiwyNTQsMjU1LDI1NSwyMzEsMTk1LDE5NSwxOTUsMTk5LDI1NSwxMjcsMTI2
LDI0OCwyNDgsMTUyLDE1Mn0KLS0gMmQgcm90YXRpb24KbG9jYWwgZnVuY3Rpb24gcm90KHgseSxh
KQoJcmV0dXJuIGNvcyhhKSp4LXNpbihhKSp5LCBjb3MoYSkqeSt4KnNpbihhKQplbmQKCmZ1bmN0
aW9uIF9kcmF3KCkKCS0tcHJpbnRoKCJfZHJhdygpIHN0YXJ0ICIuLnN0YXQoMSkpCgljbHMoKQoJ
Cglsb2NhbCB0dD10KCkKCWxvY2FsIHIwID0gNStjb3ModHQvNSkqNAoJbG9jYWwgeV9vZmZzZXQg
PSAuNStjb3ModHQqLjExKSouNQoJCQoJZm9yIGk9MCw1IGRvCgkJcD1pXDMKCQkKCQktLSBkZWNp
ZGUgd2hpY2ggYml0cGxhbmVzIHRvIHJlYWQvd3JpdGUKCQktLXBva2UoMHg1NTA5LCAoMTw8aSUz
KSB8ICgweDEwICogcCkpCgkJbG9jYWwgcGxhbmVzID0gICgxPDxpJTMpIHwgKDB4MTAgKiBwKQoJ
CQoJCWEyPXQoKS1pJTYvMjAKCQkKCQlsb2NhbCBibXAgPSBnZXRfc3ByKDApCgkJZm9yIGk9MCwy
NTUgZG8KCQkJbG9jYWwgeD1pJjE1CgkJCWxvY2FsIHk9aVwxNgoJCQktLSBpJTE2IGlzIHRoZSBz
cHIgcGl4ZWwgeAoJCQktLSBpLzE2IGlzIHRoZSBzcHIgcGl4ZWwgeQoJCQktLWlmKHg_NykgeD0g
MTUteCAtLSByaHMgb2Ygc3ByaXRlCgkJCS0taWYgZGF0YVsxK2lcMTZdJigxPDx4KT4wIHRoZW4K
CQkJCgkJCWxvY2FsIGNvbCA9IGJtcDpnZXQoeCx5KQoJCQlpZiAoY29sID09IDE0KSB0aGVuCgkJ
CQlwb2tlKDB4NTUwOSwgcGxhbmVzIHwgMHg4KQoJCQllbHNlCgkJCQlwb2tlKDB4NTUwOSwgcGxh
bmVzKQoJCQllbmQKCQkJCgkJCWlmIGNvbCA_IDAgdGhlbgoJCQkJLS0gcm90YXRlIGluIG9iamVj
dCBzcGFjZQoJCQkJbG9jYWwgeCx6PXJvdChpJTE2LzgtMSwwLGEyLzQpCgkJCQlsb2NhbCB4LHk9
cm90KHgsaS8xMjgtMSxjb3ModHQqLjEpKi4wODMzKQoJCQkJeS09IHlfb2Zmc2V0CgkJCQktLSBt
b3ZlIAoJCQkJeiArPSAyK2Nvcyh0dCouMTQyKQoJCQkJCgkJCQktLSBkb3QgaXMgYWJvdmUgc3Vy
ZmFjZQoJCQkJaWYgeTwuNSB0aGVuCgkJCQkKCQkJCQktLSBvbiByZWZsZWN0aW9uIHBhc3MsIHJl
ZmxlY3QKCQkJCQktLSB0aHJvdWdoIGdyb3VuZCBwbGFuZSAoYXQgMSkKCQkJCQlpZiAocD09MCkg
eSA9IDEteQoJCQkJCQoJCQkJCS0tIHBlcnNwZWN0aXZlIHByb2plY3Rpb24gaW50byBzY3JlZW5z
cGFjZSAoc3gsc3kpCgkJCQkJbG9jYWwgc3ggPSAyNDAgKyB4ICogMTI4IC8gegoJCQkJCWxvY2Fs
IHN5ID0gMTM1ICsgeSAqIDEyOCAvIHoKCQkJCQkKCQkJCQktLSByOiByYWRpdXMgb2YgZG90CgkJ
CQkJLS0gaSUxNi85K2kvOTkgZm9yIHN0cmlwZXMKCQkJCQktLSArYTIgdG8gdmFyeSBzdHJpcGVz
IG9mZnNldAoJCQkJCWxvY2FsIHIgPSAocjArY29zKGklMTYvOStpLzk5K2EyKSoyKSAvIHoKCQkJ
CQkKCQkJCQktLSBkcmF3IHRoZSBkb3QKCQkJCQljaXJjZmlsbChzeCxzeSxyLDMxKQoJCQkJCQoJ
CQkJCS0tY2lyYyhzeCxzeSxyKjEuNSwxNSkKCQkJCWVuZAoJCQllbmQgCgkJZW5kCgllbmQKCS0t
cmVjdGZpbGwoMCwwLDUwLDEwLDE2KQoJLS1wcmludChzdHJpbmcuZm9ybWF0KCIlLjNmICglZCBm
cHMpIixzdGF0KDEpLCBzdGF0KDcpKSwyLDIsMTUpCgktLXByaW50aCgiX2RyYXcoKSBlbmQgIi4u
c3RhdCgxKSkKZW5kCmZ1bmN0aW9uIF9pbml0KCkKCS0tIHBhbGV0dGUKCWZvciBpPTAsMzEgZG8K
CQoJCWxvY2FsIHIgPSAoaT4_MCkmMQoJCWxvY2FsIGcgPSAoaT4_MSkmMQoJCWxvY2FsIGIgPSAo
aT4_MikmMQoJCWxvY2FsIHAgPSAoaT4_MykmMQoJCWxvY2FsIHEgPSAoaT4_NCkmMQoJCQoJCXEw
ID0gKHEgKiAxLjUpICsgMC41ICAtLSAwLjUgb3IgMi4wCgkJcTEgPSAocSAqIDEuMCkgKyAxLjAg
IC0tIDEuMCBvciAyLjAKCQkKCQlpZiAocCA_IDApIHRoZW4KCQkJbG9jYWwgdHQgPSAwLjMKCQkJ
ciA9IDEuMCAqIHR0ICsgciAqICgxLXR0KQoJCQlnID0gMC4zICogdHQgKyBnICogKDEtdHQpCgkJ
CWIgPSAwLjggKiB0dCArIGIgKiAoMS10dCkJCgkJZW5kCgkJCgkJCgkJdmFsID0gIGZscihiICog
MTI3ICogcTEpCgkJdmFsICs9IGZscihnICogMTI3ICogcTApIDw8IDgKCQl2YWwgKz0gZmxyKHIg
KiAxMjcgKiBxMCkgPDwgMTYKCQkKCQlwb2tlNCgweDUwMDAgKyBpICogNCwgdmFsKQoJCQoJCS0t
IHNjYW5saW5lIGNvbG91cgoJCXZhbCA9ICBmbHIoYiAqIDExMCAqIHExKQoJCXZhbCArPSBmbHIo
ZyAqIDEwMCAqIHEwKSA8PCA4CgkJdmFsICs9IGZscihyICogMTAwICogcTApIDw8IDE2CgkJCgkJ
cG9rZTQoMHg1MTAwICsgaSAqIDQsdmFsKQoJCQoJZW5kCgkKCS0tIHNjYW5saW5lcwoJZm9yIGk9
MCw2OCBkbwoJCXBva2UoMHg1NDAwK2ksMHgxMSkKCWVuZAoJCmVuZAoKCgo6OiBwb3NlLmx1YQot
LVtbcG9kX2Zvcm1hdD0icmF3IixjcmVhdGVkPSIyMDI0LTQ5LTA1IDA3OjQ5OjU3Iixtb2RpZmll
ZD0iMjAyNC0yNS0wNSAwODoyNTo1MCIscmV2aXNpb249MTgwXV0KCgpmdW5jdGlvbiBkZWZwb3Nl
KCkKCXJldHVybiB7WzBdPQoJICAwLjcsMC45LAoJICAtMC4zLC0wLjQsCgkgIDAuODUsMC43NSwK
CSAgMC42NSwwLjc1LAoJICAwCgkgfQplbmQKCmZ1bmN0aW9uIG1ha2Vwb3NlKG4pCgogbj1mbHIo
bikKIAoKCWxvY2FsIHBkYXQ9e1swXT0KCQoJIC0tIGRlZgoJIHtbMF09CgkJICAwLjg1LDAuNzUs
CgkJICAtMC4zLDAuNzUsCgkJICAwLjg1LDAuNywKCQkgIDAuNjUsMC43LAoJCSAgMAoJCSB9LAoJ
CSAKCSAtLSAxLiBhcm1zIGRvd24KCQl7WzBdPQoJCSAgMC44MCwwLjkwLAoJCSAgMC43MCwwLjYw
LAoJCSAgMC45NSwwLjk1LAoJCSAgMC41NSwwLjg1LAoJCSAgMAoJCSB9LCAKCQkgCgkJLS0gMiBy
dXNzaWFuCgkJLS0gKGFybXMgd2F2ZSkKCQl7WzBdPQoJCSAgMC4yMCwwLjM1LAoJCSAgMC40NSww
LjYwLAoJCSAgMC45NSwwLjk1LAoJCSAgMC41NSwwLjg1LAoJCSAgMAoJCSB9LCAKCQkKCQktLSAz
IHN0b21weQoJCS0tIChhcm1zIG9wZW4gLS0gaGV5IGhvKQoJCXtbMF09CgkJICAwLjAsMC4xNSwK
CQkgIDAuMzUsMC4yNSwKCQkgIDAuNzUsMC43NSwKCQkgIDAuNDUsMC42NSwKCQkgIDAKCQkgfSwK
CQkgCgkJLS0gNCBhcm1zIHVwCgkJe1swXT0KCQkgIDAuMjUsMC4zNSwKCQkgIDAuMjUsMC4xNSwK
CQkgIDAuNzUsMC43NSwKCQkgIDAuNiwwLjYsCgkJICAwCgkJIH0sCgkJIAoJCQoJfQoJCgluPW4l
KCNwZGF0KzEpCgogbG9jYWwgcD17fQogZm9yIGk9MCw4IGRvCiAgcFtpXT1wZGF0W25dW2ldCiBl
bmQKCglyZXR1cm4gcAplbmQKCgoKLS0gY2hhc2UgcG9zZQpmdW5jdGlvbiBjaHBvc2UocDAscDEs
cSkKIGZvciBpPTAsNyBkbwogIGxvY2FsIGEwPXAwW2ldCiAgbG9jYWwgYTE9cDFbaV0KICBhMCU9
MSBhMSU9MQogIGlmIChhYnMoYTAtYTEpPjAuNSkgdGhlbgogICBhMCs9c2duKGExLWEwKQogIGVu
ZAogIGEwPWEwKigxLXEpK2ExKnEKICBwMFtpXT1hMCUxCiBlbmQKIAogLS0gaGVhZAogcDBbOF09
cDBbOF0qKDEtcSkrcDFbOF0qcQplbmQKCgpmdW5jdGlvbiBmbGlwX3Bvc2UocCkKIGZvciBqPTAs
MSBkbwogIGZvciBpPTAsMSBkbwogICBwW2oqNCtpKzBdLHBbaio0K2krMl09CiAgIHBbaio0K2kr
Ml0scFtqKjQraSswXQogIGVuZAogZW5kCiBmb3IgaT0wLDcgZG8KICBwW2ldPSgwLjUtcFtpXSkl
MQogZW5kCiAKLS0gcFs4XSo9LTEKIHBbOF09MHgwLmZmZmYtcFs4XQogCmVuZAoKCgo6OiBbZW9j
XQo=
:: screensavers/snake.p64
b64$cGljb3Ryb24gY2FydHJpZGdlIC8vIHd3dy5waWNvdHJvbi5uZXQKdmVyc2lvbiAyCgo6OiAu
aW5mby5wb2QKYjY0JExTMWJXM0J2WkN4amNtVmhkR1ZrUFNJeU1ESTBMVEEwTFRNd0lERTVPakE1
T2pNeklpeHRiMlJwWm1sbFpEMGlNakF5TkMwdwpOeTB3TmlBeE1UbzBPRG96TmlJc2MzUnZjbVZr
UFNJeU1ESTBMVEF6TFRFeUlERTNPalE0T2pNeElpeDNiM0pyYzNCaFkyVnpQWHQ3CmJHOWpZWFJw
YjI0OUltMWhhVzR1YkhWaEl6Z3hJaXgzYjNKcmMzQmhZMlZmYVc1a1pYZzlNWDBzZTJ4dlkyRjBh
Vzl1UFNKblpuZ3YKTUM1blpuZ2lMSGR2Y210emNHRmpaVjlwYm1SbGVEMHlmU3g3Ykc5allYUnBi
MjQ5SW0xaGNDOXRZWEF3TG0xaGNDSXNkMjl5YTNOdwpZV05sWDJsdVpHVjRQVE45TEh0c2IyTmhk
R2x2YmowaWMyWjRMM05tZURBdWMyWjRJaXgzYjNKcmMzQmhZMlZmYVc1a1pYZzlOSDE5ClhWMXNl
alFBQkFBQUFBTUFBQUF3Ym1scwo6OiBnZngvCjo6IGdmeC8uaW5mby5wb2QKYjY0JExTMWJXM0J2
WkN4amNtVmhkR1ZrUFNJeU1ESTBMVEF6TFRBMklERTFPakEwT2pReklpeHRiMlJwWm1sbFpEMGlN
akF5TkMwdwpOeTB3TmlBeE1UbzBPRG96TmlJc2MzUnZjbVZrUFNJeU1ESTBMVEF6TFRBMklERTFP
akEwT2pReklsMWRiSG8wQUFRQUFBQURBQUFBCk1HNXBiQT09Cjo6IGdmeC8wLmdmeApiNjQkTFMx
YlczQnZaQ3hqY21WaGRHVmtQU0l5TURJMExUQXpMVEEySURFMU9qQTBPalF6SWl4dGIyUnBabWxs
WkQwaU1qQXlOQzB3Ck15MHhNaUF4TnpvME9Eb3pNQ0lzY21WMmFYTnBiMjQ5TkRNNFhWMXNlalFB
WGdJQUFPWXpBQUR6Rkh0Yk1GMDllMkp0Y0Qxd2VIVUEKUXlBUUVBVHc4Q3htYkdGbmN6MHdMSEJo
Ymw5NENBRExlVDB3TEhwdmIyMDlPSDBzTVFELUdSWTVrSGxnbVZCWkZ4bEFhUmNwTUxrdwpEeG1a
RGpBZWVSNUFubEFPTHc1ZVlBNHRQcEFfOEJaWUFEZi1BdzhPSGprdVVBNFBGdzhPYm1BT0RROFhE
V0VBRXctcUFFYy1Mamt1CjdBQkVBRm9Bang0ZkhWNWdEaDFPNVFCU0R6RUFIdjhrRVI2UUhoQWVr
QjR3WGhjZVFHNFhMakNfTUI0QlhnRWVNQThURGdGZUFRNE4KTUEyZURUQWRmaDFBSFY0ZFlIMkFY
ZkFWbEFBZUR6RUEtMFAtS3lBYVlCcEFLa0FxWUFvNUFBcHdDUXBKQ21DWlVKbEF1VEE1QndFNQpC
d0V3RHhrcEVUa1JNQTRwQVE4UU9RRU5RQTZKVUE1NURtQU9XUTZKQWlBd01CcEFid0FoR25CdEFB
LXRBZ1Z2U1I1UW5tQl9Yd0FnCkZTQmZBRThBT1FxQVh3QUVQeDVKTGw4QUpCVVFLd0VBWHdCRENr
a0tDU3NCLXhZQkJ6a0JCemt3RVRrUktROFpNQThRQVRrT0FTa1AKR1VDSkRWQ0pEV0FOV1EyUVBm
QVdfZ0VlRHpFQXNBUFNCQTVQQWlNZUdVOENJeTVwTXdVZUxETUZEM2NHZ2c5WUFESVBOUUlGLXdB
WgpIeGxBYVMxUURTOE9YV0FOTEQwM0F1VC1OcUFmRzVBVUFBNERIb0FFRHhRUEV3TXVrQThVa0E4
WUtCOFVLQThZUUExNEJ3OE9EVEI0Ckp3Z3dlQXdIR0RDNE1BMElESWhBQ0J4b0RVQVlIRmhnZUlB
WUhSandGWFFBTWY4Y0F5c2RLd05BQTNzSER4b0RNSHNuQ3pCN0RBY2IKTUxzd0F3c01pMEFMSEdz
RFFCc2NXMkI3Z0JzVEc4OEdJQTh4QVAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLQotLS0tLS0tLS0tLS0tLS0tLTRCUWJUMDRmWDA9Cjo6IG1hcC8KOjogbWFwLy5pbmZvLnBv
ZApiNjQkTFMxYlczQnZaQ3hqY21WaGRHVmtQU0l5TURJMExUQXpMVEEySURFMU9qQTBPalF6SWl4
dGIyUnBabWxsWkQwaU1qQXlOQzB3Ck55MHdOaUF4TVRvME9Eb3pOaUlzYzNSdmNtVmtQU0l5TURJ
MExUQXpMVEEySURFMU9qQTBPalF6SWwxZGJIbzBBQVFBQUFBREFBQUEKTUc1cGJBPT0KOjogbWFw
L21hcDAubWFwCmI2NCRMUzFiVzNCdlpDeGpjbVZoZEdWa1BTSXlNREkwTFRBekxUQTJJREUxT2pB
ME9qUXpJaXh0YjJScFptbGxaRDBpTWpBeU5DMHcKTXkweE1pQXhOem8wT0Rvek1DSXNjbVYyYVhO
cGIyNDlNemc0WFYxc2VqUUFWQUFBQUVRUUFBRHdDSHQ3WW0xd1BYVnpaWEprWVhSaApLQ0pwTVRZ
aUxETXlBd0F2SWpBQkFQLS0tLS0tLS0tLS0tLS0tLS0tLS11aElpa3NjR0Z1WDNnOU1BZ0Ewbms5
TUN4MGFXeGxYMmc5Ck1UWUtBR0IzUFRFMmZYMD0KOjogc2Z4Lwo6OiBzZngvLmluZm8ucG9kCmI2
NCRMUzFiVzNCdlpDeGpjbVZoZEdWa1BTSXlNREkwTFRBekxUQTJJREUxT2pBME9qUXpJaXh0YjJS
cFptbGxaRDBpTWpBeU5DMHcKTnkwd05pQXhNVG8wT0Rvek5pSXNjM1J2Y21Wa1BTSXlNREkwTFRB
ekxUQTJJREUxT2pBME9qUXpJbDFkYkhvMEFBUUFBQUFEQUFBQQpNRzVwYkE9PQo6OiBzZngvc2Z4
MC5zZngKYjY0JExTMWJXM0J2WkN4amNtVmhkR1ZrUFNJeU1ESTBMVEF6TFRBMklERTFPakEwT2pR
eklpeHRiMlJwWm1sbFpEMGlNakF5TkMwdwpNeTB4TWlBeE56bzBPRG96TVNJc2NtVjJhWE5wYjI0
OU16ZzFYVjFzZWpRQUVBRUFBRkVIQUFEd0ozQjRkUUFES0FBQUF3QUVEMEFRCkFnNEFBYUFCSUFL
Z0RnQVBFQUFOOE1vQkFnTUVCUVlIQVEtLWtBZ0pDZ3NQREE4TkR3NFBEeEFBOEFBTkR4RVBFZzhU
RHhRUEZROFcKRHhjVEFQRUJEeGdQR1E4YUR4c1BIQThkRHg0UEh4UUE4UUFnRHlFUElnOGpEeVFQ
SlE4bUR5Y1VBUEVBS0E4cER5b1BLdzhzRHkwUApMZzh2RkFEeEFEQVBNUTh5RHpNUE5BODFEellQ
TnhRQS13VTREemtQT2c4N0R6d1BQUThfRHo4QkQtLXctd0VBNi04bldnRVFCZzhnCkVBRWdBU0FC
OEFBQ0VBSU1FQUVnRHlFZ0FUQVBRUERERHlnUC0tREdELWdLRC04UGdBLTNEdzBCOEFrQkVBWU1N
QUQtT1ItLUFRRGMKdi1nUFFBQU5RUC0tc1BCd0NnRC0tMlFmLXdFQWwxRC0tLS0tSHc9PQo6OiBt
YWluLmx1YQotLVtbcG9kX2Zvcm1hdD0icmF3IixjcmVhdGVkPSIyMDI0LTAzLTA2IDE1OjA0OjQz
Iixtb2RpZmllZD0iMjAyNC0wMy0xMiAxNzo0ODozMCIscmV2aXNpb249NTEyXV0KCgpmdW5jdGlv
biBtYWtlX2FjdG9yKGsseCx5KQoJbG9jYWwgYSA9IHsKCQlrID0gaywgeCA9IHgsIHkgPSB5LAoJ
CWEgPSAwLjQKCX0KCXJldHVybiBhZGQoYWN0b3IsIGEpCgkKZW5kCgpmdW5jdGlvbiBfaW5pdCgp
CglhY3Rvcj17fQoJCglmb3IgaT0xLDEwIGRvCgkJbG9jYWwgYSA9IG1ha2VfYWN0b3IoMSwyNDAs
MTM1KQoJCWlmIChpID09IDEpIGEuaGVhZCA9IHRydWUgaGVhZCA9IGEgYS5hID0gcm5kKCkKCQlp
ZiAoaSA_IDEpIHRoZW4KCQkJYS5wYXJlbnQgPSBhY3RvclsjYWN0b3ItMV0KCQkJYWN0b3JbI2Fj
dG9yLTFdLmNoaWxkID0gYQoJCQlhLmsgPSAyCgkJZW5kCgllbmQKCQoJZm9yIGk9MSwxIGRvCgkJ
bWFrZV9hY3RvcihybmR7MzIsMzN9LHJuZCg0NDApKzIwLHJuZCgyMzApKzIwKS5pc19mb29kID0g
dHJ1ZQoJZW5kCgkKZW5kCgpmdW5jdGlvbiBkcmF3X2FjdG9yKGEpCglsb2NhbCBiaW5kZXggPSBh
LmsKCQoJaWYgKGEuayA9PSAxKSB0aGVuCgkJbG9jYWwgYWEgPSBhLmEKCQlhYSA9IChhYSArIC4y
NSkgJSAxCgkJYmluZGV4ID0gMTYgKyAoYWEqNClcMQoJCS0tcHJpbnQoYWEuLiIgLS0_ICIuLmJp
bmRleCw0LDMwLDcpCgllbmQKCQoJc3ByKGJpbmRleCxhLngtOCxhLnktOCkKCQplbmQKCmZ1bmN0
aW9uIF9kcmF3KCkKCWNscygpCgkKCWZvciB5eT0wLDI3MCBkbwoJCWZvciBpPTEsI2FjdG9yIGRv
CgkJCWlmIChhY3RvcltpXS55XDEgPT0geXkpIGRyYXdfYWN0b3IoYWN0b3JbaV0pCgkJZW5kCgll
bmQKCS0tZm9yZWFjaChhY3RvciwgZHJhd19hY3RvcikKCQplbmQKCmZ1bmN0aW9uIG1vdmVfYWN0
b3IoYSkKCWxvY2FsIHNlZ2xlbiA9IDEwCglpZiAoYS5wYXJlbnQpIHRoZW4KCQlsb2NhbCBwID0g
YS5wYXJlbnQKCQlsb2NhbCBkeCA9IGEueCAtIHAueAoJCWxvY2FsIGR5ID0gYS55IC0gcC55CgkJ
bG9jYWwgZGQgPSBzcXJ0KGR4KmR4K2R5KmR5KQoJCWlmIChkZCA_IHNlZ2xlbikgdGhlbgoJCQls
b2NhbCBhYSA9IGF0YW4yKGR4LGR5KQoJCQlhLnggPSBwLnggKyBjb3MoYWEpKnNlZ2xlbgoJCQlh
LnkgPSBwLnkgKyBzaW4oYWEpKnNlZ2xlbgoJCQkKCQllbmQKCQkKCWVuZAoJCglpZiAoYS5pc19m
b29kKSB0aGVuCgkJbG9jYWwgZHgsZHkgPSBhLnggLSBoZWFkLngsIGEueSAtIGhlYWQueQoJCWlm
IChkeCpkeCtkeSpkeSA8IDIwMCkgdGhlbgoJCQlkZWwoYWN0b3IsYSkKCQkJbG9jYWwgbnMgPSBt
YWtlX2FjdG9yKGEuayxoZWFkLngsIGhlYWQueSkKCQkJbG9jYWwgczIgPSBoZWFkLmNoaWxkCgkJ
CWhlYWQuY2hpbGQgPSBucyBucy5wYXJlbnQgPSBoZWFkCgkJCXMyLnBhcmVudCA9IG5zIG5zLmNo
aWxkID0gczIKCQkJCgkJCW1ha2VfYWN0b3Iocm5kezMyLDMzfSxybmQoNDQwKSsyMCxybmQoMjMw
KSsyMCkuaXNfZm9vZCA9IHRydWUKCQoJCWVuZAoJZW5kCgkKZW5kCgpmdW5jdGlvbiBtb3ZlX2hl
YWQoYSkKCglsb2NhbCBkeCA9IGNvcyhhLmEpICogMgoJbG9jYWwgZHkgPSBzaW4oYS5hKSAqIDIK
CQoJYS5hKz1jb3ModCgpLzIwKSouMDAxCglhLnggKz0gZHgKCQoJaWYgKGEueCA8PSAxMCBvciBh
LnggPj0gNDcwKSB0aGVuCgkJYS54IC09IGR4CgkJZHggKj0gMQoJCWEuYSA9IGF0YW4yKC1keCxk
eSkKCQlhLmEgKz0gcm5kKDAuMDUpLXJuZCgwLjA1KQoJZW5kCgkKCWR5ID0gc2luKGEuYSkgKiAy
CglhLnkgKz0gZHkKCWlmIChhLnkgPD0gMTAgb3IgYS55ID49IDI2MCkgdGhlbgoJCWEueSAtPSBk
eSAKCQlhLmEgPSBhdGFuMihkeCwgLWR5KQoJCWEuYSArPSBybmQoMC4wNSktcm5kKDAuMDUpCgll
bmQKCQplbmQKCgpmdW5jdGlvbiBfdXBkYXRlKCkKCQoJbW92ZV9oZWFkKGFjdG9yWzFdKQoJZm9y
ZWFjaChhY3RvciwgbW92ZV9hY3RvcikKZW5kCgo6OiBbZW9jXQo=
:: screensavers/dizzy.p64
b64$cGljb3Ryb24gY2FydHJpZGdlIC8vIHd3dy5waWNvdHJvbi5uZXQKdmVyc2lvbiAyCgo6OiAu
aW5mby5wb2QKYjY0JExTMWJXM0J2WkN4amNtVmhkR1ZrUFNJeU1ESXpMVEV3TFRJeUlEQTVPakk1
T2pFM0lpeHRiMlJwWm1sbFpEMGlNakF5TkMwdwpOeTB3TmlBeE1UbzBPRG96TmlKZFhXeDZOQUFF
QUFBQUF3QUFBREJ1YVd3PQo6OiBfbWV0YS8KOjogX21ldGEvLmluZm8ucG9kCmI2NCRMUzFiVzNC
dlpDeGpjbVZoZEdWa1BTSXlNREl6TFRFd0xUSXlJREE1T2pJNE9qTXlJaXh0YjJScFptbGxaRDBp
TWpBeU5DMHcKTnkwd05pQXhNVG8wT0Rvek5pSmRYV3g2TkFBRUFBQUFBd0FBQURCdWFXdz0KOjog
X21ldGEvd29ya3NwYWNlcy5wb2QKYjY0JExTMWJXM0J2WkN4amNtVmhkR1ZrUFNJeU1ESXpMVEk0
TFRJeUlEQTVPakk0T2pNeUlpeHRiMlJwWm1sbFpEMGlNakF5TXkweQpNaTB6TUNBeU16b3lNam93
TnlJc2NtVjJhWE5wYjI0OU5EazFPVjFkYkhvMEFDMEFBQUFyQUFBQThCeDdlMk53Y205cVgyWnBi
R1U5CkltMWhhVzR1YkhWaElpeDNiM0pyYzNCaFkyVmZhVzVrWlhnOU1YMTkKOjogbWFpbi5sdWEK
LS1bW3BvZF9mb3JtYXQ9InJhdyIsY3JlYXRlZD0iMjAyMy0yOS0yMiAwOToyOTozMyIsbW9kaWZp
ZWQ9IjIwMjMtMjItMzAgMjM6MjI6MDciLHJldmlzaW9uPTI3OTVdXQotLSBkaXp6eSBieSB6ZXAK
CmZ1bmN0aW9uIGlkZW50aXR5X21hdHJpeCgpCglsb2NhbCBtID0gdXNlcmRhdGEoImY2NCIsMyw0
KQoJc2V0KG0sIDAsIDAsCgkJMSwgMCwgMCwgCgkJMCwgMSwgMCwgCgkJMCwgMCwgMSwgCgkJMCwg
MCwgMAoJKQoJcmV0dXJuIG0KZW5kCgoKLS0gcm90YXRlIHBvaW50IHgseSBhcm91bmQgb3JpZ2lu
IGJ5IGFuZ2xlIGEKZnVuY3Rpb24gcm90MmQoeCx5LGEpCglyZXR1cm4gY29zKGEpKnggLSBzaW4o
YSkqeSwgY29zKGEpKnkgKyBzaW4oYSkqeAplbmQKCi0tIGNyZWF0ZSBhIHRyYW5zZm9ybWF0aW9u
IG1hdHJpeCB0aGF0IHJvdGF0ZXMgYXJvdW5kIGEgZ2l2ZW4gYXhpcyBieSBhbmdsZQotLSBheGlz
IGlzIGEgc3RyaW5nOiAieCIsICJ5IiwgInoiCmZ1bmN0aW9uIHJvdGF0aW9uX21hdHJpeChheGlz
LCBhbmdsZSkKCQoJLS0gY29tcG9uZW50IG9mZnNldHMgZGVwZW5kIG9uIHdoaWNoIGF4aXMgdG8g
cm90YXRlIGFyb3VuZAoJbG9jYWwgZGF0ID0ge3g9ezMsNn0sIHk9ezAsNn0sIHo9ezAsM319Cgls
b2NhbCBjMCxjMSA9IGRhdFtheGlzXVsxXSwgZGF0W2F4aXNdWzJdCgkKCWxvY2FsIG0gPSBpZGVu
dGl0eV9tYXRyaXgoKQoJCgktLSByb3RhdGUgdGhlIGNvbXBvbmVudCB2ZWN0b3JzIChlYWNoIG9u
ZSBpcyBhIGNvbHVtbiBmcm9tIHJvd3MgMC4uMikKCWZvciBjb2x1bW49MCwyIGRvCgkJbVtjb2x1
bW4gKyBjMF0sIG1bY29sdW1uICsgYzFdID0gcm90MmQobVtjb2x1bW4gKyBjMF0sIG1bY29sdW1u
ICsgYzFdLCBhbmdsZSkKCWVuZAoJcmV0dXJuIG0KZW5kCgoKZnVuY3Rpb24gX2luaXQoKQoKCS0t
IG1ha2UgcG9pbnRzCglwPXt9IG4gPSA1NQoJZm9yIGk9MSwzMDAwIGRvCgkJCQktLWxvY2FsIHkg
PSBjb3MoeC8xOSkgKyBzaW4oei8zMikgLSBjb3Moei8zNSkqc2luKHgvNDcpKjQgKyAzCgkJCQkt
LSB4LCB5LCB6LCBjb2xvdXIKCQkJCS0tIG5vdGU6IHdlIGNhbiBzdG9yZSB0aGUgY29sb3VyIGhl
cmUsIGJlY2F1c2UgbWF0bXVsM2QKCQkJCS0tIG9ubHkgY2FyZXMgYWJvdXQgdGhlIGZpcnN0IDMg
dmFsdWVzIG9mIGVhY2ggcm93IQoJCQkJcFsjcCsxXSA9IHZlYygKCQkJCQljb3MoaS8yMjAuNCkq
MTQwLjcsCgkJCQkJY29zKGkvMjY0KSozMC4yLAoJCQkJCWNvcyhpLzI4NSkqMzEuMiwKCQkJCQk4
KyhpKSUxMSwKCQkJCQljb3MoaS84MCkqMjAwKzExMCkgCgllbmQKCQoJLS0gY3JlYXRlIGEgdXNl
cmRhdGEgdGhlIHNhbWUgc2l6ZSwgdXNlZCBmb3Igei1zb3J0aW5nCglvcmRlciA9IHVzZXJkYXRh
KCJmNjQiLCAyLCAjcCkKCWZvciBpPTAsI3AtMSBkbwoJCXNldChvcmRlciwgMCwgaSwgaSsxKSAt
LSBzdGFydGluZyBzY29yZQoJCXNldChvcmRlciwgMSwgaSwgaSsxKSAtLSBpbmRleAoJZW5kCgkK
ZW5kCQoKCgpmdW5jdGlvbiBfZHJhdygpCgljbHMoKQoJbG9jYWwgd3cgPSAyNDAuMAoJCgktLSBj
cmVhdGUgMyBtYXRyaWNlcyB0aGF0IG1vZGlmeSB0aGUgb3JpZW50YXRpb24gYW5kIHBvc2l0aW9u
IG9mCgktLSB0aGUgbGFuZHNjYXBlIChpbiB0aGlzIGRlbW8sIHRoZXJlIGlzIG5vIGNvbmNlcHQg
b2YgYSBjYW1lcmEpCgkKCXNwaW5fYXJvdW5kID0gcm90YXRpb25fbWF0cml4KCJ4Iix0KCkvKGNv
cyh0KCkvMTApKjIrMjUpKSAgICAgICAgCgl0aWx0ICAgICAgICA9IHJvdGF0aW9uX21hdHJpeCgi
eCIsMC4wMikgICAgICAgICAgLS0gMCB0byBzdGF5IGZsYXQKCXNoaWZ0X3ogICAgID0gaWRlbnRp
dHlfbWF0cml4KCkgc2hpZnRfelsxMV0gPSA4MCAtLSB0cnkgMjAgZm9yIGNsb3NlIHVwCgkKCS0t
IG1hdG11bDNkKCkgaXMgdXNlZCB0byBtdWx0aXBseSAzeDQgbWF0cmljZXMKCS0tIGhlcmUgdGhl
IDMgdHJhbnNmb3JtYXRpb25zIHdpbGwgYmUgYXBwbGllZCBmcm9tIGxlZnQgdG8gcmlnaHQKCQoJ
bSA9IHNwaW5fYXJvdW5kOm1hdG11bDNkKHRpbHQpCgltID0gbTptYXRtdWwzZChyb3RhdGlvbl9t
YXRyaXgoInkiLHQoKS8yMykpCgltID0gbTptYXRtdWwzZChyb3RhdGlvbl9tYXRyaXgoInoiLHQo
KS8zMCkpCgltID0gbTptYXRtdWwzZChzaGlmdF96KQoJCgktLSAodGhpcyBnaXZlcyB0aGUgc2Ft
ZSByZXN1bHQgYXMgYXBwbHlpbmcgZWFjaCBtYXRyaXggc2VwYXJhdGVseSBpbiB0aGUKCS0tIGlu
bmVyIGxvb3A6IHYgPSB2Om1hdG11bDNkKHNwaW5hcm91bmQpIHYgPSBtYXRtdWwzZCh0aWx0KSBl
dGMpCgkKCS0tLS0tLS0tIHNvcnQgLS0tLS0tLS0tCgoJLS0gKHVzaW5nIGNhbWVyYSB6IHZhbHVl
cyBmcm9tIGxhc3QgZnJhbWUhKQoJCglvcmRlcjpzb3J0KCkKCQoJLS0tLS0tLS0gZHJhdyAtLS0t
LS0tLS0KCQoJbG9jYWwgdiA9IHZlYygwLDAsMCkgLS0gcmV1c2VkIGZvciBldmVyeSB0cmFuc2Zv
cm1lZCBwb2ludAoJCglmb3IgaT0wLCNvcmRlci0xLDIgZG8KCQlsb2NhbCB2MCA9IHBbb3JkZXJb
aSsxXV0gLS0gZ3JhYiBmcm9tIHRoZSBzb3J0ZWQgbGlzdAoKCQktLSBhcHBseSB0aGUgMyB0cmFu
c2Zvcm1hdGlvbnMgdXNpbmcgYSBzaW5nbGUgbWF0cml4CgkJLS0gKG0gbWVhbnMgc3BpbiBhcm91
bmQsIHRpbHQsIGFuZCB0aGVuIHNoaWZ0IGFsb25nIHopCgkJLS0gd3JpdGUgdGhlIG91dHB1dCB0
byB2IGluc3RlYWQgb2YgY3JlYXRpbmcgYSBuZXcgdXNlcmRhdGEgCgkJLS0gKCBmYXN0ZXIgdGhh
biBlLmcuIHYgPSBtYXRtdWwzZChtLCB2MCkgKQoJCXYwOm1hdG11bDNkKG0sIHYpCgkJCgkJbG9j
YWwgc3ogPSB2LnoKCQkKCQlvcmRlcltpXSA9IC1zeiAtLSBzZXQgdGhlIHNjb3JlIGZvciBzb3J0
aW5nIG5leHQgZnJhbWUgKGRyYXcgZnVydGhlc3QgZmlyc3QpCgoJCWlmIChzeiA_IDAuMDUpIHRo
ZW4KCQkJLS0gaW4gZnJvbnQgb2Ygdmlld3BsYW5lOyBkcmF3IGl0CgkJCWxvY2FsIHd3X2Rpdl9z
eiA9IHd3IC8gc3oJCQoJCQlsb2NhbCBzeCA9IDI0MC4wICsgdi54ICogd3dfZGl2X3N6CgkJCWxv
Y2FsIHN5ID0gMTM1ICsgdi55ICogd3dfZGl2X3N6CgkJCS0tcHNldChzeCxzeSx2MC51KQoJCQlj
aXJjZmlsbChzeCwgc3ksIHYwWzRdL3N6LCB2MFszXSkKCQllbmQKCWVuZAoJCi0tW1sKCWxvY2Fs
IHN0cj1zdHJpbmcuZm9ybWF0KCJwb2ludHM6ICVkICBjcHU6ICUzLjNmICglZGZwcykiLAoJCSNw
LCBzdGF0KDEpLCBzdGF0KDcpKQoJcHJpbnQoc3RyLCAxMSwgMTEsIDApCglwcmludChzdHIsIDEw
LCAxMCwgNikKXV0KCQplbmQKCgo6OiBbZW9jXQo=
:: tooltray/tooltray.p64
b64$cGljb3Ryb24gY2FydHJpZGdlIC8vIHd3dy5waWNvdHJvbi5uZXQKdmVyc2lvbiAyCgo6OiAu
aW5mby5wb2QKYjY0JExTMWJXM0J2WkN4amNtVmhkR1ZrUFNJeU1ESTBMVEEwTFRNd0lERTVPakE1
T2pNeklpeHRiMlJwWm1sbFpEMGlNakF5TkMwdwpOeTB3TmlBeE1UbzBPRG96TmlJc2MzUnZjbVZr
UFNJeU1ESTBMVEF6TFRFd0lEQXpPalU1T2pNeUlpeDNiM0pyYzNCaFkyVnpQWHQ3CmJHOWpZWFJw
YjI0OUltMWhhVzR1YkhWaElpeDNiM0pyYzNCaFkyVmZhVzVrWlhnOU1YMHNlMnh2WTJGMGFXOXVQ
U0puWm5ndk1DNW4KWm5naUxIZHZjbXR6Y0dGalpWOXBibVJsZUQweWZTeDdiRzlqWVhScGIyNDlJ
bTFoY0M5dFlYQXdMbTFoY0NJc2QyOXlhM053WVdObApYMmx1WkdWNFBUTjlMSHRzYjJOaGRHbHZi
ajBpYzJaNEwzTm1lREF1YzJaNElpeDNiM0pyYzNCaFkyVmZhVzVrWlhnOU5IMTlYVjFzCmVqUUFC
QUFBQUFNQUFBQXdibWxzCjo6IGdmeC8KOjogZ2Z4Ly5pbmZvLnBvZApiNjQkTFMxYlczQnZaQ3hq
Y21WaGRHVmtQU0l5TURJMExUQXpMVEV3SURBek9qVTBPakE0SWl4dGIyUnBabWxsWkQwaU1qQXlO
QzB3Ck55MHdOaUF4TVRvME9Eb3pOaUlzYzNSdmNtVmtQU0l5TURJMExUQXpMVEV3SURBek9qVTBP
akE0SWwxZGJIbzBBQVFBQUFBREFBQUEKTUc1cGJBPT0KOjogZ2Z4LzAuZ2Z4CmI2NCRMUzFiVzNC
dlpDeGpjbVZoZEdWa1BTSXlNREkwTFRBekxURXdJREF6T2pVME9qQTRJaXh0YjJScFptbGxaRDBp
TWpBeU5DMHcKTXkweE1DQXdNem8xT1Rvek1pSXNjbVYyYVhOcGIyNDlNVEJkWFd4Nk5BQnRBQUFB
QlRFQUFQTVVlMXN3WFQxN1ltMXdQWEI0ZFFCRApJQkFRQlBEd0xHWnNZV2R6UFRBc2NHRnVYM2dJ
QU05NVBUQXNlbTl2YlQwNGZTd3hBUC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCi0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1fZFFiVDA0ZlgwPQo6OiBtYXAvCjo6IG1hcC8u
aW5mby5wb2QKYjY0JExTMWJXM0J2WkN4amNtVmhkR1ZrUFNJeU1ESTBMVEF6TFRFd0lEQXpPalUw
T2pBNElpeHRiMlJwWm1sbFpEMGlNakF5TkMwdwpOeTB3TmlBeE1UbzBPRG96TmlJc2MzUnZjbVZr
UFNJeU1ESTBMVEF6TFRFd0lEQXpPalUwT2pBNElsMWRiSG8wQUFRQUFBQURBQUFBCk1HNXBiQT09
Cjo6IG1hcC9tYXAwLm1hcApiNjQkTFMxYlczQnZaQ3hqY21WaGRHVmtQU0l5TURJMExUQXpMVEV3
SURBek9qVTBPakE0SWl4dGIyUnBabWxsWkQwaU1qQXlOQzB3Ck15MHhNQ0F3TXpvMU9Ub3pNaUlz
Y21WMmFYTnBiMjQ5TVRCZFhXeDZOQUJTQUFBQVR3UUFBUEFNZTFzd1hUMTdZbTF3UFhWelpYSmsK
WVhSaEtDSnBNVFlpTERFMkF3QXZJakFCQVAtLS1fX2hJaWtzY0dGdVgzZzlNQWdBMG5rOU1DeDBh
V3hsWDJnOU1UWUtBQkIzQ2dDQQplbTl2YlQweGZYMD0KOjogc2Z4Lwo6OiBzZngvLmluZm8ucG9k
CmI2NCRMUzFiVzNCdlpDeGpjbVZoZEdWa1BTSXlNREkwTFRBekxURXdJREF6T2pVME9qQTRJaXh0
YjJScFptbGxaRDBpTWpBeU5DMHcKTnkwd05pQXhNVG8wT0Rvek5pSXNjM1J2Y21Wa1BTSXlNREkw
TFRBekxURXdJREF6T2pVME9qQTRJbDFkYkhvMEFBUUFBQUFEQUFBQQpNRzVwYkE9PQo6OiBzZngv
c2Z4MC5zZngKYjY0JExTMWJXM0J2WkN4amNtVmhkR1ZrUFNJeU1ESTBMVEF6TFRFd0lEQXpPalUw
T2pBNElpeHRiMlJwWm1sbFpEMGlNakF5TkMwdwpNeTB4TUNBd016bzFPVG96TWlJc2NtVjJhWE5w
YjI0OU4xMWRiSG8wQUJBQkFBQlJCd0FBOENkd2VIVUFBeWdBQUFNQUJBOUFFQUlPCkFBR2dBU0FD
b0E0QUR4QUFEZkRLQVFJREJBVUdCd0VQLTVBSUNRb0xEd3dQRFE4T0R3OFFBUEFBRFE4UkR4SVBF
dzhVRHhVUEZnOFgKRXdEeEFROFlEeGtQR2c4YkR4d1BIUThlRHg4VUFQRUFJQThoRHlJUEl3OGtE
eVVQSmc4bkZBRHhBQ2dQS1E4cUR5c1BMQTh0RHk0UApMeFFBOFFBd0R6RVBNZzh6RHpRUE5RODJE
emNVQVA4Rk9BODVEem9QT3c4OER6MFBQZzgtQVEtLThQOEJBT3YtSjFvQkVBWVBJQkFCCklBRWdB
ZkFBQWhBQ0RCQUJJQThoSUFFd0QwRHd3dzhvRC0td3hnLTRDZy0tRDRBUDl3OE5BZkFKQVJBR0RE
QUEtemtmLXdFQTNMLTQKRDBBQURVRC0tN0R3Y0FvQS0tOWtILThCQUpkUS0tLS0teDg9Cjo6IG1h
aW4ubHVhCi0tW1twb2RfZm9ybWF0PSJyYXciLGNyZWF0ZWQ9IjIwMjQtMDMtMTAgMDM6NTQ6MDgi
LG1vZGlmaWVkPSIyMDI0LTAzLTEwIDAzOjU5OjMyIixyZXZpc2lvbj0xNF1dCi0tIHBsYWNlaG9s
ZGVyIGJhY2tncm91bmQgZm9yIHRvb2x0cmF5Ci0tIHRvIGRvOiB0b29sdHJheSB0aGVtZSBpcyB1
c2VkIGZvciAiZGVza3RvcCoiIGluIHRoYXQgY29udGV4dD8KZnVuY3Rpb24gX2RyYXcoKQoJY2xz
KDEpCmVuZAoKOjogW2VvY10K
:: screensavers/swoosh.p64
b64$cGljb3Ryb24gY2FydHJpZGdlIC8vIHd3dy5waWNvdHJvbi5uZXQKdmVyc2lvbiAyCgo6OiAu
aW5mby5wb2QKYjY0JExTMWJXM0J2WkN4amNtVmhkR1ZrUFNJeU1ESTBMVEV3TFRBeUlESXhPak01
T2pVeUlpeHRiMlJwWm1sbFpEMGlNakF5TkMwdwpOeTB3TmlBeE1UbzBPRG96TmlJc2MzUnZjbVZr
UFNJeU1ESTBMVE01TFRBeUlESXhPak01T2pVeUlsMWRiSG8wQUFRQUFBQURBQUFBCk1HNXBiQT09
Cjo6IF9tZXRhLwo6OiBfbWV0YS8uaW5mby5wb2QKYjY0JExTMWJXM0J2WkN4amNtVmhkR1ZrUFNJ
eU1ESTBMVEV3TFRBeUlESXhPak01T2pVeUlpeHRiMlJwWm1sbFpEMGlNakF5TkMwdwpOeTB3TmlB
eE1UbzBPRG96TmlJc2MzUnZjbVZrUFNJeU1ESTBMVE01TFRBeUlESXhPak01T2pVeUlsMWRiSG8w
QUFRQUFBQURBQUFBCk1HNXBiQT09Cjo6IF9tZXRhL3dvcmtzcGFjZXMucG9kCmI2NCRMUzBnY0ds
amIzUnliMjRnYjJKcVpXTjBJR1JoZEdFS2UzdGpjSEp2YWw5bWFXeGxQU0p0WVdsdUxteDFZU0lz
ZDI5eWEzTncKWVdObFgybHVaR1Y0UFRGOWZRPT0KOjogbWFpbi5sdWEKLS1bW3BvZF9mb3JtYXQ9
InJhdyIsY3JlYXRlZD0iMjAyMy00MC0zMSAxNDo0MDo0OSIscmV2aXNpb249MSxzdG9yZWQ9IjIw
MjMtNDEtMzEgMTQ6NDE6MTUiXV0KcT0wCnBva2UoMHg1NTBiLCAweGZmKQoKZnVuY3Rpb24gX2lu
aXQoKQoJLS0gc2V0IHVwIGRpc3BsYXkgcGFsZXR0ZQoJZm9yIGkwPTAsNjMgZG8KCQlsb2NhbCBp
PWkwLS02My1pMAoJCQoJCXBva2U0KDB4NTAwMCArIGkwICogNCwKCQkJKG1pZCgwLCBpICogOCwy
NTUpIDw8MTYpICsKCQkJKG1pZCgwLCBpICogMTIsMjU1KSA8PCA4KSArCgkJCShtaWQoMCwgaSAq
IDE4LDI1NSkgPDwgMCkKCQkpCgllbmQKCS0tIGNvbG91ciB0YWJsZXMKCS0tIG9ubHkgZHJhd2lu
ZyB3LyBjb2xvciA3LCBzbyBvbmx5IG5lZWQgdG8gc2V0IHRoYXQgdXAKCWZvciBpPTcsNyBkbyAt
LSBkcmF3IGNvbG9yCgkJZm9yIGo9MCw2MyBkbyAtLSB0YXJnZXQgcGl4ZWwgY29sb3IKCQkJcG9r
ZSgweDgwMDAraSo2NCtqLCBtaWQoMCwgKDYzICogMSArIGogKiAxNSkgLy8gMTYsIDYzKSkKCQll
bmQKCWVuZAplbmQKZnVuY3Rpb24gX2RyYXcoKQoJbG9jYWwgciA9IDI0CglxID0gcSArIDEvODAw
MAoJY2xzKCkKLS0JZm9yIGk9MCw2MyBkbyBjaXJjZmlsbCg4K2kqNywgOCwgMywgaSkgZW5kCi0t
CXJlY3RmaWxsKDAsMCw0NzksNyw3KQoJZm9yIGk9MCwxLDEvMjAwMCBkbwoJCWkgPSBpICsgcQoJ
CWxvY2FsIHggPSAyNDAgKyBjb3MoaSkgKiAxMjAKCQlsb2NhbCB5ID0gMTM1ICsgc2luIChpKjIu
OTQpICogNTAKCQl4ID0geCArIGNvcyhpICogMi43NykgKiAzMAoJCXkgPSB5ICsgc2luKGkgKiAx
LjQ2KSAqIDMwCgkJbG9jYWwgciA9IHQoKSAtLSsgY29zKGkqNC4zMykgKiAxMAoJCWxvY2FsIGEg
PSBpKjQgKyBxKjMKCQlsb2NhbCBkeCA9IGNvcyhhKSAqIHIKCQlsb2NhbCBkeSA9IHNpbihhKSAq
IHIKCQlsaW5lKHggLSBkeCwgeSAtIGR5LCB4ICsgZHgsIHkgKyBkeSwgNykKCQoJZW5kCglwcmlu
dChzdHJpbmcuZm9ybWF0KCJjcHU6JS4zZiIsc3RhdCgxKSksMiwyKQplbmQKOjogW2VvY10K
:: wallpapers/biplane.p64
b64$cGljb3Ryb24gY2FydHJpZGdlIC8vIHd3dy5waWNvdHJvbi5uZXQKdmVyc2lvbiAyCgo6OiAu
aW5mby5wb2QKYjY0JExTMWJXM0J2WkN4dWIzUmxjejBpSWl4aGRYUm9iM0k5SW1OaGMzUndhWGhs
YkNJc2MzUnZjbVZrUFNJeU1ESTBMVEF6TFRJegpJREU1T2pRMU9qTTBJaXhwWTI5dVBYVnpaWEpr
WVhSaEtDSjFPQ0lzTVRZc01UWXNJakF3TURBd01EQXdNREF3TURBd01EQXdNREF3Ck1EQXdNREF3
TURBd01EQXdNREV3TVRBeE1ERXdNVEF4TURFd01UQXhNREV3TVRBeE1ERXdNVEF4TURFd01UQTNN
RGN3TnpBM01EY3cKTnpBM01EY3dOekEzTURjd056QTNNRGN3TVRBeE1EY3daREJrTUdRd1pEQmtN
R1F3WkRCa01HUXdaREJrTUdRd056QXhNREV3TnpCawpNR1F3WkRCa01HUXdaREJrTUdRd1pEQmtN
R1F3WkRBM01ERXdNVEEzTUdRd1pEQmtNR1F3WkRCa01HUXdaREJrTUdRd1pEQmtNRGN3Ck1UQXhN
RGN3WkRCa01HUXdaREJrTUdRd1pEQmtNR1F3WkRCa01HUXdOekF4TURFd056QmtNR1F3WkRCa01H
UXdaREJrTUdRd1pEQmsKTUdRd1pEQTNNREV3TVRBM01HUXdaREJrTUdRd1pEQmtNR1F3WkRCa01H
UXdaREJrTURjd01UQXhNRGN3TnpBM01EY3dOekEzTURjdwpOekEzTURjd056QTNNRGN3TnpBeE1E
RXdOekEzTURZd05qQTJNRFl3TmpBMk1EWXdOakEyTURjd056QTNNREV3TVRBM01EY3dOakEyCk1E
WXdOakEyTURZd05qQTJNRFl3TnpBM01EWXdNVEF4TURjd056QTNNRGN3TnpBM01EY3dOekEzTURj
d056QTNNRFl3TVRBd01ERXcKTmpBMk1EWXdOakEyTURZd05qQTJNRFl3TmpBMk1EWXdNVEF3TURB
d01UQXhNREV3TVRBeE1ERXdNVEF4TURFd01UQXhNREV3TVRBdwpNREF3TURBd01EQXdNREF3TURB
d01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdJaWtzZEdsMGJHVTlJa0pwY0d4aGJtVWlMR055
ClpXRjBaV1E5SWpJd01qUXRNRFF0TXpBZ01UazZNRGs2TXpNaUxHMXZaR2xtYVdWa1BTSXlNREkw
TFRBM0xUQTJJREV4T2pRNE9qTTIKSWl4MlpYSnphVzl1UFNJeExqQWlMSGR2Y210emNHRmpaWE05
ZTN0c2IyTmhkR2x2YmowaWJXRnBiaTVzZFdFaUxIZHZjbXR6Y0dGagpaVjlwYm1SbGVEMHhmU3g3
Ykc5allYUnBiMjQ5SW1kbWVDOHdMbWRtZUNJc2QyOXlhM053WVdObFgybHVaR1Y0UFRKOUxIdHNi
Mk5oCmRHbHZiajBpYldGd0wyMWhjREF1YldGd0lpeDNiM0pyYzNCaFkyVmZhVzVrWlhnOU0zMHNl
Mnh2WTJGMGFXOXVQU0p6Wm5ndmMyWjQKTUM1elpuZ2lMSGR2Y210emNHRmpaVjlwYm1SbGVEMDBm
WDFkWFd4Nk5BQUVBQUFBQXdBQUFEQnVhV3c9Cjo6IGdmeC8KOjogZ2Z4Ly5pbmZvLnBvZApiNjQk
TFMxYlczQnZaQ3hqY21WaGRHVmtQU0l5TURJMExUQXpMVEEySURFd09qTTVPakk1SWl4dGIyUnBa
bWxsWkQwaU1qQXlOQzB3Ck55MHdOaUF4TVRvME9Eb3pOaUlzYzNSdmNtVmtQU0l5TURJMExUQXpM
VEEySURFd09qTTVPakk1SWwxZGJIbzBBQVFBQUFBREFBQUEKTUc1cGJBPT0KOjogZ2Z4LzAuZ2Z4
CmI2NCRMUzFiVzNCdlpDeGpjbVZoZEdWa1BTSXlNREkwTFRBekxUQTJJREV3T2pNNU9qSTVJaXh0
YjJScFptbGxaRDBpTWpBeU5DMHcKTXkwd05pQXhNVG93T1RvME5pSXNjbVYyYVhOcGIyNDlNVFZk
WFd4Nk5BQkVGZ0FBWTA0QUFQTVVlMXN3WFQxN1ltMXdQWEI0ZFFCRApJQkFRQlBEd0xHWnNZV2R6
UFRBc2NHRnVYM2dJQU9aNVBUQXNjMk5oYkdVOU1USjlMRE1BenlqZ0FRQUFEZ0VBQUFUdy13RUFI
UE1nCjFZZnctOFluWUNmdy04SW44UC1KVi1ELXlEZnctOHdYOFAtT0YtRC15SGZ3LThjbjhQLU5G
LUQtendmdy04OFlBQVFNQUFBSUFCUFEKQkFBVHppZ0FBQ0FBRjgwTUFBZ2tBQUVFQUJZWEJBQWp6
d2NNQVBFUk4tRC16UWZ3LTcxbm9CZnctN3NuUUJlUUItRC11aWR3QjVBWAo4UF80RjVBUUFFRzNG
N0FIQ0FEQkI3QVhnQmZ3LTdZWHdDZGdFQUF3OEFBSENRRHdHTFluNEJkQUYtRC10UmZ3QWdkQUIt
RC1lMmNRCk4tQWVCLUFERnlBWDhQOTVKeUFIQURjUUJ4SUE4Q2tFUi1ELWVSZEFCeEFITUFmd0ho
ZnctNUVId0Nmd0hpZnctNDRYd0FjQUItQWYKQi1ELWpTZndBQmZ3SFJmdy00d1hBQWZ3QVFmd0hS
WUFNZ2Z3QkFvQWtJd1g4QVFYTUVmd0V3d0E4QkFIOEFZSEVDY2dGLUFRTi1ELQppd2Z3QmpkUUYt
QUlOeEFYOFBfT0ItQUZ3Z0FnQnhjY0FFQ1BGLUFFMkFDeUJ3ZnctM2RuOEFrSDhBOE5BRUJ5VnlC
SENRQVFFQ29BCjhCN3ctMjFIZ0VlQVIyQVg4QkFYOEFVWDhQOXBWOEJYY0FjZ1J5QUg4QklIOEFV
SDhQOWxWNkRYWUNkQUp3QVNBQ0RnSjJzQThDUmgKUjZEM0JHQUhjQ2Z3RWdmUUZ3QTM4UDlkVjVE
M0NnQVhFQmRnRi1BVUI5QUhJQWZ3LTFwWGtQY1BFRGR3Qi1BVko3QVFBS0JIb1BjVQo4QWNuOEFz
bllRSHdDVlZYa1BjWjhBY0hBQmZ3REVkUUItRC1VRmVROXg3d0JNMEFJQThIRVFDQVRFZUE5eVRn
VndBX0FSRU9kQUdBClIxZHc5eW5RRnlBTkFCRU82QUNpUTFkdzl5N1FCMEFITUJRQjhVSXlCX0JI
Y0pjZzl5V3dONkFIRUNmdy0xQW5nRmRnMXpEM0lmQUQKRjVBM0FBZnctMDhYQUFjd1YyRDNCQkQz
SGZBWkotRC1UQmNRVjJEM0NSRDNHUEFnSi1ELVNSY3dCMEQzRHhEM0UzQUg4QndxQWZBWAoteWdu
UUFjQTl4TVE5dzNRQi1BbWgxQ0g4UDhqWjFCSEVQY09FUGNJOEFNWDhDQlhVSWVpQUVJZlZ6QVhH
QUFocHdCM0FmQWNIVGZ3CkNCZncteHRYWUNkUVJ5RDNEd0NuQUJmd0NWZndHeWZ3Q2hmdy14ZFhZ
R2RnUnhEM0VBQ0hBQklDOEFNS0ItQWZGLUFKTi1ELUUxZGcKWnlBWFVGY2NBQ0EzVUJ3QThBc0pG
LUFmWi1BQk4tRC1FVmRnbHpBWFlBY0FKeEQzRVFBSGdCNEFvQWdYOENRWGNLZnctdy13QUxRWApZ
QmNnQnhESEFOY3dCeUFBTVFmd0k0UUQ5d0VVVjFEM0EwQUhjQWNnRnhESEFIZVFJUUFSSVNFQVl4
RlhVUGNIUUVJQU5CQW40Q0VBCjRRY1g4QjhuVURmdy13NVhVTGNRWkFCQk1BY1FCOUlBRkFFbEFQ
QUtBbGZ3SGlkQU4tRC1ERmRROXdFUTF5QVhZSGNBRnlBM0lOMEMKRkFJbUFLQUJGLUFmUnlCSDhQ
OEtiQURvQVBjQUFBZGdOeUFIRUJlUUJ4QW5BQUJBQVFBbkFQQUNEUmRRcHhEbkVNY1FGMUFYUUJj
QQpKNUEzQWdnbkFQQUZHamNRUi1ELUVCY1ExekQzQUFDSFFCZFFGMUNjQUNBSGdIZ0E4QlFEQndB
WGNBY0FCOEJIOEJwbjhQOFRGeEQzCkFCRDNBUkEzY0JkZ0J4QTNBQWNBRnlFQUVCQXFBQ0VRQnlv
QVFBZnctMGdqQW5BQ0FCZUFGMkFYQUFNUUlCb0FWUmZ3QXhjQUl3Q3cKU3ZjQ0VQY0VrQWRnRnhB
dUFVQUhJQWRnY0FBbUJRY2pBUG9HVGVjUXR3QlhrQmRRRnpBWEVBY0FGeUFIWUFjUUl3RFFVTGNR
dHdBSApFQmRBWjFBWFVFZ0FJQ2RnYVFBRkl3Q1FKLUQtVW9jQWR5QUhxUUNRTUhkUUYzQVhZQ2N3
YVFBU0JpTUFvQmZRSi1ELVUxY0FOMkFqCkFCQUhJd0JVa0JkZ1p4QWhBS0FRQi1BQUotRC1WQ2NR
TVFGd0p5QjNVQmV3RjdRQUlnQVhJZ0FBVEFBUUFpSUFFUWNpQUlFWElJZEEKRjlBSGNMRUFKUEFH
YUFIeUNBUUg4UDlVRndBSGdEY2dkMEEzd0Jkd0IwQW44QUUzWEFGQXNEY3dGMEVBZ0FBSGtDY1Fk
ekJYUHdBdwpVQ2ZRUXdBQXp3QkJCNkFYRUM4RkFTSUF3QmNnWnpCM3dBZUFGMkFub0ljQUVBZGNC
UUNYQXpFQUJ5QmpCQU1tQU5SM0VJZkFGNEFICmdDZHdGeEFuSmdBeElCY3dZZ0lnVlFlY0FjRVFK
MEMzMEFlQUI2QW5VQWNpQVFRbUFFQUg4UDltendBQjJ3R29JR2ZRQjRBWHNDY2cKRnlRQUFHb0FR
RFZIOEJ6VUFBRXJBSUFnVjlBSGtBZlFKM1FFQVNjQUVCZDZBd0FDQkJBMTNnVWtIQWNwQUFETUFR
QXJBRkR3QUNjdwpKeUlBQWFJRFdQODJKMEFISmdBaUJ5QW1BQ0FDTjJ3QnRRQUhJRGNBWi1ELUxp
ZGdKZ0FtRjNBbUFCQUVuUUFRZDdZQ0FFc0VOQ3NuCmdDWUFFQ0QzQWhGSEpBQWdBUmR3QUxHQUJ3
Q0g4SFVuOEtBWGtKWUFBT0lBVWljZ0owQlhsQUFSTjFNQlVLY0FoLUIwNHdGaG5TZVEKRi1BZDJn
THdBQkFYQUVkQWQ5QUhjRGZnQnhBWE1DVUE4Z0IzOEhNbklCY1FKLUNYQjhBMzhCcmVBbkFYRVBj
QllCZFFNZ0F3SjhBSAprd0x3QndDbkFBZndFSmZ3VEVjQUJ6QTM4QndYOEdKM0FBZThCaEFhUWdM
Qkp4Q25FRWZnQjJBWE1DZWdPd0VSTUlRQkVFQVhBZkVBCkNYZHdKLUJFWi1BcEYtQmlGMUFuc0FN
QmRnSzFFTGNnTl9BSFlBZGdGNUEwQUNFUUZ6UUFJQUozSlFUUVAwZndMU2Z3WVNmd0NpZncKR2JV
Qm9CY1FaeEJIRUNkUUYzQTNBRUFuZ0FjZ05RQUJJQVhRa0lmQWx4QUg4RDBuWUVmd0pHb0FzUEFN
QndBbjhCY0hBQWRRWkFKaApSeEJISUJlZ3BBWWdFR2NXQWlFd0Iwa0I4QUlIQUpmQTl3YndFVGZ3
RTBkd0YtQW9CenNBUUJFWDhCWnRBd0RZQTVFbkVKZndBQWVBCmw1QjBBLUFNTUpmQTl4RHdEaWNR
RjhCSHNFZVFKLUFvRi1CaEYtQVRKLUFVQVFTUUZ4QW5JQ2NRaC1BQmlRSHhBd2Vud1BjWjhBMFgK
UUFlQVJ5RFhvRGZ3S1N3QVVCWUg4QlFYNmdBQXB3R1FNQmNBaDhBWEVFY0FZUUx4Q2dHbm9QY2g4
QXdYVUFkZ0otQk5CLUJpQi1BWApCLUFWQndBNUJFQVFGekNYalFUMkJSQ0hnSWV3OXlud0RRZGdG
eUEzOEE4SDhDNFhLd0FCNUFMeENtQkg4QU4zRUNjUWg3RDNNUEFOCkYzQkg4QTFYOEMwWDhHTl9B
REFCZDdCUkFNRVhNQmZ3Qnhjd1J4Q1hvUGRIQVBFRkZRY0FSLUF5Qi1CbEItQU1KMUFYOEFIM0Fo
QngKQTZCUUJ5QVg4QWVuZ1BjNFpRQndFeWZ3Tnhmd1k1WUJnQUIzOEFIM0NDQW5jUVdROEFLWE1Q
Y3o4Q01YckFnQ0lRRHdId3dIOEF2MwpCeUMzOEFqM052QWxKMkFYOEJFbjhEY0g4R1FIOEE0SDhC
UFhNTWNnRi1BQUoxQW5VUGNhOEM5a0JXRkg4QTVIOERpcEFQQUVEaWZ3CkhSY2c5d0NBRjFCM0lE
Y2c5eER3T3lBQWdCRVg4QnUzOEFRWFJRQVFFU1FKOEFZZ0YyQ1hzRWN3bHhBSElQY0E4RWNYOEJV
MzhCcnoKQWxBQ0YtQmtGeVFBTUJ3WEVNMEFrQU13bHdCSEFBZndWZTBFTUFBbmdNWUNVTUFuOEFB
SEp3QVFFbTBERVNESENUSDNDUUFXQmxEdwpWQmZ3Q1BvQW9DSW44QUJYZ0Nmd0hGY2VBVUFTRi1B
YlVRRHdDUU1YY1BjREVCY0FKeEFIOEZJbjhBbEg4Q0VuOEFkWElNNEpVakFYCjhDOG5WQUN3RUJm
d0JDZlFGd0JYRUVjRkJGSHdVUmZ3QUF3RFFBNUg4QjdwQ0NFdUYxd0pJUEFiSGdCUkJoZkFGOUFz
QkREd1VnZXAKQ1pFb0YtQkNCMEJuOENtZkFVRjM4QklIdXdrd3NCZndkd1R3QkFBSDhFeG44QVEz
OENDSDhEUm5BRWNBRjBCbUJRQXRBQkFua1FZZwo4QkxDQlJBSERnRVJBV2NGWVBCR1otQUVaNm9B
b1RrM1FDY2dKNkFuOENpdENsQVJOX0JYTVBNS0lRTUhLQUNnUWtmQTEtQWxKLUE0Ck40a0I4QUVt
Qi1BZEYwQW44QWtuMENlQUYzQVhSQUR3QUQwM3dFZndNUmZ3T1Jmd0V4ZndKWXNCSVVBWHFBanhB
ZEFYb0Vjd0YtQUUKaC1BNU43Qkg4RFFrQUJBVm9RZ2g4QnM3QlZEd0dRZWdGNjRBZ1BBRWwtQTFS
NEJuTUFJUk9zSUNZQ1VIOEJvWFFJb0I4QVVZRjVBbgpBR2Z3Qktmd01qY1F0LUE4Ri1BNko3NENF
Q1Z6QkNBZ0p5SUFRQWVnSnhCLUFmQUlBMWNRTi1BdmwtQkdGLUEySndBWDhCZ0g4Q1luCjhCaE5C
SEVYOEJjSGtFY0FzUUd3UnpBbjhJOEg4RGtuOEJXM0NwRW1OLUFWTjJBbjhCVWhBTUFBTi1BQlIw
QW44STRYOEdLRUJxTW4KQi1Bb0otQU1KNURIR0FCQUItQnBCeFlBOFFNbUp3QVh3RWRnSjdCWFFB
ZndBVWNRRnhBZEFCRm9KZ0VSSkE0R0lMQVhqd1ZnMEZjQQo5d3NBVEFEd0FJOFg4R2xIOENJSDhD
SW5VQWV3Ql9VSDhBendBRWNBOXdVQVJ3QW5BQ2Z3a0Fmd2JTZndJQWZ3SUNkd0Y2QkZDRkFYCjhB
REg0TGNBQVIwQUlHOFhMQXpBSHhlZ0oyQW5jQ2Z3QXJmZ3l3QkJrQmZ3Y0ZrTWd4NFgwRGN3Qi1B
UEZ3QndCLUJ4Ri1BWlJ4b0EKTVFJWElMWUZNUUJYRURBQUVISlhBUUNKQUJBRTJBSUFxQVRBaC1D
UkItQnpCLUFYRi1Bai1nSUFTUXNRWjM4RlFaSUg4SE11QkNJZwpWX29NSUJNMzBneFFsQWZ3ZEFj
WEFEQWJWekJWQWtRUUotRFVFd0IwR2hmd0RUZncxZzhBUkJjMzhQZ01BRk1WSi1ENkZ3d0FvUk1u
CjhQc1g4RGtIOENzUEFHRUtOeUFuOFB3a0FoRXFKd0prQ1JjUVItRDlFUUFSRnZvS1V2OEdCLUE2
TWdBUUYxZ0xJZjhHSUFBZ0t3Y3gKQUNFS0J5QUFvamduOEN3SDhCSTM4QXNRQUNBM0Z4a0ZJQTFI
YkFUd0FmOEZGLUF0TjBBWDhEQUg4QXdYOEEwMkFsRC1CQmZ3SjBFQwpBUHdCSURFWE53QVFEZ0lG
VWY4REItQWhFZ0pRUUNmd05RY1lBTkVNSi1ELUNRZndIeWNnSi1CQ0tnQlJEQWZ3LXd0X0FWTktK
M0EzCjBCRUFFQmNaQnhCTlZncVFGOEFIOEFzWDhQOE1CQVJnOEU4WFFCY2dYd1lnQ2hmT0NnQXFB
V0JRQjBBSGNKZExBQ0QtRHhFSElQQlIKZkFBWEhROEFBSkVCVVA4UEYtQVpMUUFBV0FVQkdnQmlG
LUJPRi1Ba0p3QVJHUTBBRXlVTkFCQUhKd0FoSkJjMEFHQVdKLUJQRi1BOApDeUFSWi13TkVGRzlB
UEFKOFA4YkotQU5CLUJSWi1BVlZ3QVg4UDhjQi1BTEotQlEyZ01RRVZFRElmOGc3Z0FnV3hjekFD
SC1FcHNPClVBc0g4RndISGdhUy14SVhBRGNBeC1BTUlRQkFCLUQtRVRrQVVCZ1g4RnNIX0FGZy13
NG44Q0FYNmdFUk5HUUJVZjhRRi1BaHdBRVIKTmtZQU1QOFJCeEFBSUJjSEFnWUVFQUFBeFFNTkVB
QWhOaGM3QVJRUUVBQkZNemZ3RENBQVlBbUhJRGZ3TWdFT1VmRGdWLUFaWkFBaApCeGN6QV9FMkIt
QUtSLURnRnpBWElHZndEa0FCUUFRM2dDZFFBSkFHUi1Ea0IxQkhRQmNBQVFIcEFoSEFNQUJoQTBj
UUItRGxrZ3dRCkFmNE1JQ0lITndhQVJnZndBU2Z3NDJkbUREQVg0QmNIQ2lId0pDb0dFVWR2REJE
aUdnSXlCQWZRUkFkaEpoZlFGLUJIREFrdzNWZUEKaUE4d3dBZEFZQU1RSlJnQ1lFZ1g0QWZ3M0hB
Q1lCSVhrRGN3UjhBRXNBQVg4RWtYQUVkd0ItRGJyUVJnZ0Jkd0ItQW5SZzFBOEVzbgpJRVVQd05r
WDhCazNVQWZ3TFVmd0Fnb0dRSEFYOE5nV0FoQVFjQUFRTEpRTG9QQlNOd0JIOE5nWDhCNnFCaEV0
TEFZUVV4SU9NUWZ3CjJMSUdFaTNpRHlCREJ5MENFUzdnRFFBTkFCSmpDZ0FnUWhjS0FGRUdOLUQt
UUNZSEVBSzBFRkgtUUFmd1pvY0E4QVAtUlJmd1ppZmcKRi1ELVJRZndad2NBQl9BVUFHSW44R1lI
NENjVUFDRVg0UElLY1VVSDhFeUg4QUFyQUlKSEYtQktGMkEzc0VJQVVVa0g4RWtYb1FvUQpBazBO
a0Jmd1NRZkF0LUQtVy1zQWN2RC1jeGZ3U2djSEFBQU9BSEFIOEVnMzhQOXlsZ1lBamhGd2N5ZndP
d2NRdHhJQUVRRG9BX0wtCmZ4Y3dCLUEzSi1ELWZpZndPd2NBRVR3WEFOTHdQUmZ3LTRBSDhENEg4
UF9BRGdBaWZ4Y09BRUlIOEQ4SERnQUFGUUFGRGdCU1B4ZncKLTMwSEFGSl9CLUJBQnh3QUFBNEFF
QmNqQUI5ZEZ4TU5EeFlUQlE4QkFKWVFPWDRUOEFobjhQLUtoLUQteUtmdy04VVhFQWNRUi1BTwpO
LUQtbzFFTEVDY3RDaUQtb20wQ1lTZndESGZ3LTd3TlFDZndDeGRRQkJDZkl3Q1NOLUFLRjBCSDhQ
X2VEUUN3Q1JkZ1ItRC1uQmNRCkZ6RHdFRkNBUi1ELW0tNExNRGRBTnd3SU1QRC1taWdBRUVjZkNF
SEFGOEEzaHdFa0NCY1RBQ0N3RjV3VEVIdUdCWUFIQnlBWE1EZFEKRnpBT0FSVUFJbmNBbkFJZ1FE
ZURENkdRRjlCSDhQOTd0LUFBUEFzUVlOb0xJUWVBRlFCeWZMZndBQWN3SnhNQVFuQVgwRmNUQUtF
bgpJQmRBZHdBWEVBZGdFd0JBZnBmd0F1NE1BSTBKd0FkZ0I5Qm44UF9BWi1BRE4tSVNBeE1BRUZk
SUFnQ19DR0UzSUNjd3AyQmRBQkItCjN3cWdBemN3RnhDbkFCZEFOMjhQTVlBSGNGa1FFQ2RNRURB
SFFDY1VBREdCTjBCREVBREFDUkduM1F2d0E2ZFFGLUQtZ3dkd0JfQ24KSUljd0J3Qm5jRnNBZ1Bf
RUZ5Qkh3Q2RRWWdCZ0Z6QW5JQmVRbndpdy00WUhVQWRRVndBWFVEZDBDelNnRnpDQ0R6RC1oeGNv
QURFdwpKMUJJRGdBdERVQXdGMkEzMUE4d2lRY3dRd3lCQjBBSFlDY3dOekRWREhBd0IyQjM4UF9L
dkF3QmRROGdVRGQ5RUJCUUdBRHdBOWZ3Ci00VTNJQ2NRQnpBWFVDZEFSNUFYTUJVRmdHZnctNG9I
QURjd1JBQ0JaM0FYUUFkUUo0Q1NBREtJRnlCYUFHQjNRQ2RRQjFBLURYQUgKOFBfSUJ5QVhGZ0Fn
UU5kdUFTR3dGNklBUWdjUUYxQVVBREIzUUVjWUVyRHctNGMzWUtkUXQ0Qm5NQlVOQUJvS1lQX0hC
NkNYWUU0TgpFU0RBQVFJVkFMQjlaeUFIa0Rmd0FGZGdoMElSQVVnUkFSa0FnWGhYUUhkUWwtQUlW
UkVBLXd5QUVBY2dOLUQtZEVkRUVSRkFLQUloCjhBY3RDUkVRVHcwQW5nSWdjU2RDQU1EUWgyQUg4
QVlYWUVjZ0p3QU1CaUQtY0pFRlVBY2dWMEJYQ2dJZzhBVmFBUUNXRXVHMzhQOXMKQnhCM01EZFFK
ekFYY05RTDhBTVhFQ2R3RnlBSFVDZnctMm8zTUJmUWw0RG5DSENBRnhBM1VCY2dKQUR4QS05cHQ3
QUhBRGNnQjVBbgp3Q2VRRndDM01FSVdVV2hYUUZkZ1NoS2dFQmVnTjJBM3NBY1FaOVFSQUdFRVlH
c1hRQmN3aHhvQVFCQUgwSWNWRVNCd0I0MFFVZkQtCmFnZEE4UTRnTUFmSkNsQVFGLUFTSjBVU0VO
QzRDVUQtYVJjdzd4SUI0dzV3RUFjZ0otQU5OLWNUQWY0Q2tQRC1hSGRBTnpCWEVLMFUKRUVCYkRT
RUJCeFlBQVBFQkVTZm9BREEzOEF4RUVDRUNSeFlBY1BjRUlBZVE5dzU4RVFDUEZTQm9aejRBQUln
SzhBRDNCTkFIRUxlQQpCLUQtYm1jQXB6RFVDbUJRZDlBSEFPZnZGdkVGY0FkUWQxQUg4QUUzRURj
UVo5QUhBQ2RRWjFBWEFDUHdCQllBVUlld041Qkg1UUFnCmNEZllCakFBVnhDbEQyRVhvQ2ZBTnpB
cUFEQVFKOUN6QUpFZ0p6QkhVQmVnQl9ENEFIQndGeUNYTUJmZ3dRRlJvQWNBSjZCX0NEQnkKRjZB
M0J4QUF6aFJ4Z0ZjQU4xQW5FQTBHQUNnUkFGd0FFQWtNRVNCblVPUUdVUDkySjJBM2FBWVJDaFFB
QUdZTEFDd0FrSGlYOEFNSAo4QWRIY0g0RUVIY1NBSEdWRi1BRkp5QUhFUUNTcC1ELWxpZndBaWRB
RHdBQTZnU0UtNWtIQUNmUUoyQVNBQkVYckFRaEo2RDJFeUVRCkIwNE5zUF9aRjBBM1lCZWdCM0JI
WVFNQU5BQmdnSWV3TjFDWERBQmdsamZBQnhBWEVRSUFIQUNnRUZmdy01WVhBQmV3Qng4QzhBRUEK
UnpCWDhQX2RKeEFuZ0JjZ0YyQW5vUUxBcHpjZ0YzQUhRR2NBQnlCbkxBbFEtMzZYQUhkZ0QwRUF0
LUFUOXdKQWZnY1FaNTRRSUdCWAo5Qk1oOEJKMEE1QjlKeEJYQUdkZ1J5RHFEQkFSRGdNUVp6NEhB
S1VLVWlCbllEZEE0Z3d4RHhjUWl3RVFjd3NUTVNkQVZ4a0FBRUFYCklBOEh2d0lBM2hVUmFaSVRZ
MEJIZ0RjZ1YwSU9VQXgzVUNkUTRSY0NIUUJSTnlCWGdNY2JBQUN2Q2pGUWQyQlpBeEJsR3dBVHh4
a0EKc1Nmd0NRY1FCMEFYc0FjUXVRRXlaUWNnSFFBQlh4TWc4QWhSQmdHREFDQlFWMU1YRUdVVEJU
REhnTWZoQWdBZkFEQUhVQWVaQXhFdwpFUUdoWnpjUVZ6QW5jQ2RnUnpnWkVBajRFeUVITUlVT0FH
d0FBSE1VRU9COEFQRUZCd0EzZ0JkUUY2QW5NRGNnRndDSElHZmdCekQtCkVaRHctMDluRUJjQTV3
QU9BOEIzSUZjdzl4T1FGeEIzVUVlZ0ZaRVJNSGNBZHhCM1FJZUZGakMzY1BlMENQQUNaeENYRUlj
d1J6RDMKQVFDSE1EZndEcGVYQ0pfZ0YwQW4wTmR3OXdES0I1Z2ZQS3dJREY4d0xqVjlMUGNiSGc4
ekFQLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLVVGQTlNVEo5ZlE9PQo6OiBtYXAvCjo6IG1hcC8uaW5mby5wb2QKYjY0JExT
MWJXM0J2WkN4amNtVmhkR1ZrUFNJeU1ESTBMVEF6TFRBMklERXdPak01T2pJNUlpeHRiMlJwWm1s
bFpEMGlNakF5TkMwdwpOeTB3TmlBeE1UbzBPRG96TmlJc2MzUnZjbVZrUFNJeU1ESTBMVEF6TFRB
MklERXdPak01T2pJNUlsMWRiSG8wQUFRQUFBQURBQUFBCk1HNXBiQT09Cjo6IG1hcC8wLm1hcApi
NjQkTFMxYlczQnZaQ3hqY21WaGRHVmtQU0l5TURJekxUVTBMVEF6SURBME9qVTBPakkzSWl4dGIy
UnBabWxsWkQwaU1qQXlNeTAxCk9DMHdNeUF3TkRvMU9Eb3dNU0lzY21WMmFYTnBiMjQ5TXpWZFhX
eDZOQUJwQUFBQW93Z0FBUEFUZTJ4aGVXVnlQWHRiTUYwOWUySnQKY0QxMWMyVnlaR0YwWVNnaWFU
RTJJaXd4TmdNQUx5SXdBUUQtLS0tdm9TSXBMSEJoYmw5NFBUQUlBUElHZVQwd0xITmpZV3hsUFRF
cwpkR2xzWlY5b1BURTJDZ0J2ZHoweE5uMHNTd1QtLS0tLU9GQXhObjE5ZlE9PQo6OiBtYXAvbWFw
MC5tYXAKYjY0JExTMWJXM0J2WkN4amNtVmhkR1ZrUFNJeU1ESTBMVEF6TFRBMklERXdPak01T2pJ
NUlpeHRiMlJwWm1sbFpEMGlNakF5TkMwdwpNeTB3TmlBeE1Ub3dPVG8wTmlJc2NtVjJhWE5wYjI0
OU1UUmRYV3g2TkFCZEFBQUFXQVFBQVBBVGUyeGhlV1Z5UFh0Yk1GMDllMkp0CmNEMTFjMlZ5WkdG
MFlTZ2lhVEUySWl3eE5nTUFMeUl3QVFELS0tLXZvU0lwTEhCaGJsOTRQVEFJQVBJR2VUMHdMSE5q
WVd4bFBURXMKZEdsc1pWOW9QVEUyQ2dCd2R6MHhObjE5ZlE9PQo6OiBzZngvCjo6IHNmeC8uaW5m
by5wb2QKYjY0JExTMWJXM0J2WkN4amNtVmhkR1ZrUFNJeU1ESTBMVEF6TFRBMklERXdPak01T2pJ
NUlpeHRiMlJwWm1sbFpEMGlNakF5TkMwdwpOeTB3TmlBeE1UbzBPRG96TmlJc2MzUnZjbVZrUFNJ
eU1ESTBMVEF6TFRBMklERXdPak01T2pJNUlsMWRiSG8wQUFRQUFBQURBQUFBCk1HNXBiQT09Cjo6
IHNmeC8wLnNmeApiNjQkTFMxYlczQnZaQ3hqY21WaGRHVmtQU0l5TURJekxUVTBMVEF6SURBME9q
VTBPakkzSWl4dGIyUnBabWxsWkQwaU1qQXlNeTAxCk55MHdNeUF3TkRvMU56bzBNaUlzY21WMmFY
TnBiMjQ5TXpSZFhXeDZOQUJ2QUFBQTdRWUFBTjl3ZUhVQUF5Z0FBQU1BQlBELUFRRHMKLXlmeEFS
QUdEeUFRQVNBQklBSHdBQUlRQWc0UUFTQVBJU0FCTUE5QThNTVBLQS0tOE1ZUF9Bb1Atd19BRC1j
UERRSHdDUUVRQmc0dwpBUDg1SC04QkFOelBfQTlBQUE4UVFQLS1zUEJ3Q3dELS02TWYtd0VBbDFE
LS0tLS1Idz09Cjo6IHNmeC9zZngwLnNmeApiNjQkTFMxYlczQnZaQ3hqY21WaGRHVmtQU0l5TURJ
MExUQXpMVEEySURFd09qTTVPakk1SWl4dGIyUnBabWxsWkQwaU1qQXlOQzB3Ck15MHdOaUF4TVRv
d09UbzBOaUlzY21WMmFYTnBiMjQ5TVRKZFhXeDZOQUFRQVFBQVVRY0FBUEFuY0hoMUFBTW9BQUFE
QUFRUFFCQUMKRGdBQm9BRWdBcUFPQUE4UUFBM3d5Z0VDQXdRRkJnY0JELV9RQ0FrS0N3OE1EdzBQ
RGc4UEVBRHdBQTBQRVE4U0R4TVBGQThWRHhZUApGeE1BOFFFUEdBOFpEeG9QR3c4Y0R4MFBIZzhm
RkFEeEFDQVBJUThpRHlNUEpBOGxEeVlQSnhRQThRQW9EeWtQS2c4ckR5d1BMUTh1CkR5OFVBUEVB
TUE4eER6SVBNdzgwRHpVUE5nODNGQUQtQlRnUE9RODZEenNQUEE4OUR6NFBQd0VQLS1ELUFRRHIt
eWRhQVJBR0R5QVEKQVNBQklBSHdBQUlRQWd3UUFTQVBJU0FCTUE5QThNTVBLQS0tOE1ZUF9Bb1At
d19BRC1jUERRSHdDUUVRQmd3d0FQODVILThCQU55LQpfQTlBQUExQS0tX3c4SEFLQVAtLVpCLS1B
UUNYVVAtLS0tOGYKOjogYm9uZXMubHVhCi0tW1twb2RfZm9ybWF0PSJyYXciLGNyZWF0ZWQ9IjIw
MjQtMzItMDUgMDc6MzI6MzgiLG1vZGlmaWVkPSIyMDI0LTAzLTA2IDExOjA5OjI2IixyZXZpc2lv
bj0yNDNdXQotLVtbCgoJCgpdXQoKZnVuY3Rpb24gYm9uZSh4LHksYSkKIGxvY2FsIGwgPTcKIGxv
Y2FsIGI9NjYKIAogYSs9MS8yOAogYSU9MQogbG9jYWwgcT0gZmxyKGEqNCkgLS0gMC4uMyAtLSB3
aGljaCBncm91cCBvZiA3CiBsb2NhbCBvZnM9e1swXT0KICAxLDUsIDUsNSwgNSwxLCAxLDEKIH0K
IAogLS1saW5lKHgseSx4K2NvcyhhKSpsLHkrc2luKGEpKmwsIDE0KQoKIGxvY2FsIGk9ZmxyKChh
JTAuMjUpKjI4KQogYiA9IGZscihhKjI4KQogeC09b2ZzW3EqMiswXQogeS09b2ZzW3EqMisxXQoK
IHNwcihiLHgseSkKIAplbmQKCgpmdW5jdGlvbiBkcmF3X3NrZWxseShzKQoKCWxvY2FsIGE9cy5w
b3NlCglsb2NhbCBzeD0wCglsb2NhbCBzeT0wCglsb2NhbCB4LHkKCWxvY2FsIGw9NwoJbG9jYWwg
bGw9OCAtLSBsZWcgbGVuZ3RoCgoJcGRhdD17WzBdPQoJCXs3LC02LDd9LAoJCXstOCwtNiw3fSwK
CQl7Myw2LDh9LAoJCXstNCw2LDh9Cgl9CgoJLS1jaXJjZmlsbChzLngsIHMueSwgMiw4KQoJCgkt
LSBjYWxjIGxvd2VzdCBmb290CgoJbHggPSAwCglseSA9IHN5ICsgMTAgLS0gaGlwIGJvbmUKCWxp
ID0gMAoJZm9yIGk9MiwzIGRvCgkJbG9jYWwgZD1wZGF0W2ldCgkJbG9jYWwgeD1zeCtkWzFdIAoJ
CWxvY2FsIHk9c3krZFsyXSswIC0tIGhpcAoKCQl4Kz1jb3MoYVtpKjJdKSpkWzNdIAoJCXkrPXNp
bihhW2kqMl0pKmRbM10KCQl4Kz1jb3MoYVtpKjIrMV0pKmRbM10gCgkJeSs9c2luKGFbaSoyKzFd
KSpkWzNdCgoJCWx5ID0gbWF4KGx5LHkpCgkJaWYgKGk9PTIgb3IgbHk9PXkpIHRoZW4KCQkJbHg9
eAoJCQlsaT1pCgkJZW5kCgllbmQKIAoJLS0gYWRqdXN0CglzeSAtPSAobHkgLSAyMikKCgoJaWYg
KG5vdCBzLmxseCkgcy5sbHg9MAoJaWYgKHMuY2kgIT0gbGkpIHRoZW4KCQktLSBwbGFudCBhbmNo
b3IgZm9vdCAKCQktLSAuY3ggbWVhbnMgYW5jaG9yIHJlbGF0aXZlIHRvIHN0YXJ0aW5nIHBvc2l0
aW9uIChub3QgJ2NlbnRlcicpCgkJcy5jeCA9IGx4ICsgKHMuY3ggLSBzLmxseCkKCQlzLmNpID0g
bGkKCWVuZAoJIAoJcy5sbHg9bHggLS0gbGFzdCBsb3dlc3QgeAoJc3ggLT0gKGx4IC0gcy5jeCkK
CXN4ICs9IHMueAoJc3kgKz0gcy55CiAKCgktLSBib2R5CglzcHIoNDAsc3gtOCwgc3ktOCkKCgkt
LSByZWd1bGFyIGhlYWQKCXNwcigzMixzeC0zK3MuaHgsc3ktMTQrcy5oeSkKCgktLSBidW5ueSBo
ZWFkIChlYXN0ZXIpCgktLXNwcig0MyxzeC0zK3MuaHgsc3ktMTQrcy5oeS04LDEuMjUsMikKCQoJ
Zm9yIGk9MCwzIGRvCgkJbG9jYWwgZD1wZGF0W2ldCgkJeD1zeCtkWzFdIHk9c3krZFsyXQoKCQli
b25lKHgseSxhW2kqMl0saSoyKzApCgoJCXgrPWNvcyhhW2kqMl0pKmRbM10gCgkJeSs9c2luKGFb
aSoyXSkqZFszXQoKCQlib25lKHgseSxhW2kqMisxXSxpKjIrMSkKCgllbmQKCmVuZAoKOjogbWFp
bi5sdWEKLS1bW3BvZF9mb3JtYXQ9InJhdyIsY3JlYXRlZD0iMjAyNC0wMy0wNiAxMDozOToyOSIs
bW9kaWZpZWQ9IjIwMjQtMDMtMDYgMTE6MDk6NDYiLHJldmlzaW9uPTE5XV0KCgpmdW5jdGlvbiBf
ZHJhdygpCglwYWwoKQoJY2xzKHRoZW1lImRlc2t0b3AwIikKCXBhbCgwLHRoZW1lImRlc2t0b3Aw
IikKCXBhbCg3LHRoZW1lImRlc2t0b3AxIikKCXNwcigxKQplbmQKOjogcG9zZS5sdWEKLS1bW3Bv
ZF9mb3JtYXQ9InJhdyIsY3JlYXRlZD0iMjAyNC00OS0wNSAwNzo0OTo1NyIsbW9kaWZpZWQ9IjIw
MjQtMDMtMDYgMTE6MDk6MjkiLHJldmlzaW9uPTE3OV1dCgoKZnVuY3Rpb24gZGVmcG9zZSgpCgly
ZXR1cm4ge1swXT0KCSAgMC43LDAuOSwKCSAgLTAuMywtMC40LAoJICAwLjg1LDAuNzUsCgkgIDAu
NjUsMC43NSwKCSAgMAoJIH0KZW5kCgpmdW5jdGlvbiBtYWtlcG9zZShuKQoKIG49ZmxyKG4pCiAK
Cglsb2NhbCBwZGF0PXtbMF09CgkKCSAtLSBkZWYKCSB7WzBdPQoJCSAgMC44NSwwLjc1LAoJCSAg
LTAuMywwLjc1LAoJCSAgMC44NSwwLjcsCgkJICAwLjY1LDAuNywKCQkgIDAKCQkgfSwKCQkgCgkg
LS0gMS4gYXJtcyBkb3duCgkJe1swXT0KCQkgIDAuODAsMC45MCwKCQkgIDAuNzAsMC42MCwKCQkg
IDAuOTUsMC45NSwKCQkgIDAuNTUsMC44NSwKCQkgIDAKCQkgfSwgCgkJIAoJCS0tIDIgcnVzc2lh
bgoJCS0tIChhcm1zIHdhdmUpCgkJe1swXT0KCQkgIDAuMjAsMC4zNSwKCQkgIDAuNDUsMC42MCwK
CQkgIDAuOTUsMC45NSwKCQkgIDAuNTUsMC44NSwKCQkgIDAKCQkgfSwgCgkJCgkJLS0gMyBzdG9t
cHkKCQktLSAoYXJtcyBvcGVuIC0tIGhleSBobykKCQl7WzBdPQoJCSAgMC4wLDAuMTUsCgkJICAw
LjM1LDAuMjUsCgkJICAwLjc1LDAuNzUsCgkJICAwLjQ1LDAuNjUsCgkJICAwCgkJIH0sCgkJIAoJ
CS0tIDQgYXJtcyB1cAoJCXtbMF09CgkJICAwLjI1LDAuMzUsCgkJICAwLjI1LDAuMTUsCgkJICAw
Ljc1LDAuNzUsCgkJICAwLjYsMC42LAoJCSAgMAoJCSB9LAoJCSAKCQkKCX0KCQoJbj1uJSgjcGRh
dCsxKQoKIGxvY2FsIHA9e30KIGZvciBpPTAsOCBkbwogIHBbaV09cGRhdFtuXVtpXQogZW5kCgoJ
cmV0dXJuIHAKZW5kCgoKCi0tIGNoYXNlIHBvc2UKZnVuY3Rpb24gY2hwb3NlKHAwLHAxLHEpCiBm
b3IgaT0wLDcgZG8KICBsb2NhbCBhMD1wMFtpXQogIGxvY2FsIGExPXAxW2ldCiAgYTAlPTEgYTEl
PTEKICBpZiAoYWJzKGEwLWExKT4wLjUpIHRoZW4KICAgYTArPXNnbihhMS1hMCkKICBlbmQKICBh
MD1hMCooMS1xKSthMSpxCiAgcDBbaV09YTAlMQogZW5kCiAKIC0tIGhlYWQKIHAwWzhdPXAwWzhd
KigxLXEpK3AxWzhdKnEKZW5kCgoKZnVuY3Rpb24gZmxpcF9wb3NlKHApCiBmb3Igaj0wLDEgZG8K
ICBmb3IgaT0wLDEgZG8KICAgcFtqKjQraSswXSxwW2oqNCtpKzJdPQogICBwW2oqNCtpKzJdLHBb
aio0K2krMF0KICBlbmQKIGVuZAogZm9yIGk9MCw3IGRvCiAgcFtpXT0oMC41LXBbaV0pJTEKIGVu
ZAogCi0tIHBbOF0qPS0xCiBwWzhdPTB4MC5mZmZmLXBbOF0KIAplbmQKCjo6IFtlb2NdCg==
:: wallpapers/modern_monster.p64
b64$cGljb3Ryb24gY2FydHJpZGdlIC8vIHd3dy5waWNvdHJvbi5uZXQKdmVyc2lvbiAyCgo6OiAu
aW5mby5wb2QKYjY0JExTMWJXM0J2WkN4dWIzUmxjejBpYUhSMGNITTZMeTkzZDNjdWIyTnZhbTh0
WkdWemFXZHVMbU52YlNJc1lYVjBhRzl5UFNKdgpZMjlxYnlJc2MzUnZjbVZrUFNJeU1ESTBMVEF6
TFRFeUlERTNPakkxT2pRMElpeHBZMjl1UFhWelpYSmtZWFJoS0NKMU9DSXNNVFlzCk1UWXNJakF3
TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01ERXdNVEF4TURFd01UQXhN
REV3TVRBeE1ERXcKTVRBeE1ERXdNVEF4TURFd01UQTNNRGN3TnpBM01EY3dOekEzTURjd056QTNN
RGN3TnpBM01EY3dNVEF4TURjd1pEQmtNR1F3WkRCawpNR1F3WkRCa01HUXdaREJrTUdRd056QXhN
REV3TnpCa01HUXdaREF4TURFd01UQXhNREV3TVRCa01HUXdaREEzTURFd01UQTNNR1F3ClpEQXhN
R1F3WkRCa01HUXdaREJrTURFd1pEQmtNRGN3TVRBeE1EY3daREF4TUdRd1pEQXhNREV3TVRBeE1H
UXdaREF4TUdRd056QXgKTURFd056QmtNR1F3TVRCa01HUXdaREJrTUdRd1pEQXhNR1F3WkRBM01E
RXdNVEEzTUdRd1pEQmtNREV3TVRBeE1ERXdNVEF4TUdRdwpaREJrTURjd01UQXhNRGN3TnpBM01E
Y3dOekEzTURjd056QTNNRGN3TnpBM01EY3dOekF4TURFd056QTNNRFl3TmpBMk1EWXdOakEyCk1E
WXdOakEyTURjd056QTNNREV3TVRBM01EY3dOakEyTURZd05qQTJNRFl3TmpBMk1EWXdOekEzTURZ
d01UQXhNRGN3TnpBM01EY3cKTnpBM01EY3dOekEzTURjd056QTNNRFl3TVRBd01ERXdOakEyTURZ
d05qQTJNRFl3TmpBMk1EWXdOakEyTURZd01UQXdNREF3TVRBeApNREV3TVRBeE1ERXdNVEF4TURF
d01UQXhNREV3TVRBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3
Ck1EQXdJaWtzZEdsMGJHVTlJazF2WkdWeWJpQk5iMjV6ZEdWeUlpeGpjbVZoZEdWa1BTSXlNREkw
TFRBMExUTXdJREU1T2pBNU9qTXoKSWl4dGIyUnBabWxsWkQwaU1qQXlOQzB3Tnkwd05pQXhNVG8w
T0Rvek5pSXNkbVZ5YzJsdmJqMGlNUzR3SWl4M2IzSnJjM0JoWTJWegpQWHQ3Ykc5allYUnBiMjQ5
SW0xaGFXNHViSFZoSXpNaUxIZHZjbXR6Y0dGalpWOXBibVJsZUQweGZTeDdiRzlqWVhScGIyNDlJ
bWRtCmVDOHdMbWRtZUNJc2QyOXlhM053WVdObFgybHVaR1Y0UFRKOUxIdHNiMk5oZEdsdmJqMGli
V0Z3TDIxaGNEQXViV0Z3SWl4M2IzSnIKYzNCaFkyVmZhVzVrWlhnOU0zMHNlMnh2WTJGMGFXOXVQ
U0p6Wm5ndmMyWjRNQzV6Wm5naUxIZHZjbXR6Y0dGalpWOXBibVJsZUQwMApmWDFkWFd4Nk5BQUVB
QUFBQXdBQUFEQnVhV3c9Cjo6IGdmeC8KOjogZ2Z4Ly5pbmZvLnBvZApiNjQkTFMxYlczQnZaQ3hq
Y21WaGRHVmtQU0l5TURJMExUQXpMVEEySURFME9qSTBPakE1SWl4dGIyUnBabWxsWkQwaU1qQXlO
QzB3Ck55MHdOaUF4TVRvME9Eb3pOaUlzYzNSdmNtVmtQU0l5TURJMExUQXpMVEEySURFME9qSTBP
akE1SWwxZGJIbzBBQVFBQUFBREFBQUEKTUc1cGJBPT0KOjogZ2Z4LzAuZ2Z4CmI2NCRMUzFiVzNC
dlpDeGpjbVZoZEdWa1BTSXlNREkwTFRBekxUQTRJREEzT2pBek9qSTBJaXh0YjJScFptbGxaRDBp
TWpBeU5DMHcKTXkweE1pQXhOem95TlRvME5DSXNjbVYyYVhOcGIyNDlNamMwWFYxc2VqUUFWazBB
QUE4NEFRRHpGSHRiTUYwOWUySnRjRDF3ZUhVQQpReUFRRUFUdzhDeG1iR0ZuY3owd0xIQmhibDk0
Q0FEUGVUMHdMSHB2YjIwOU9IMHNNUUFwOEJWR1JnVHc0R0h3TGdGZ0FmQXJFVEJSCjhDZ2hNQUZR
QWZBbUFSQUJJQUZnRWZBbEFSQUxBSUZSQUJId0loRVFBUUlBOEFZUkFBRWdBZkFoQVNBQklBRVFV
U0FSOEI4UkVCRTMKQUpFd0FmQWZBU0FSUUdFSkFQQXZNQUdnQVRBUjhCNEJNQkdBRVRBaDhCMFJN
QkZnRVVBUkFBSHdIUUZBZ1VBaEVBSHdHeUZBQVZBQgpJRUVRQWZBYUFRQVJRR0VnQVJBaElBSHdH
UUZTQUJCQWV3Q3dFVEFCOEJnQklDRWdBVEJ5QUxNUk1CSHdGd0VnRVFBQkVCRUFJVUFCCkVRQVpN
QThBRUFFX0FBTVBBR1FXRVFBQkFBRlBBRUZRRWZBVkx3QVJRRUlBUUJBUklBRVJBSUFCTUJGQUFR
QUJVREVBWUJVQkVBRkEKQWFvQUlGQUJRQUFDRHdBcUFSQVBBRUVBQVdBQm5BQVRBQThBQVI0QUlC
Z2hPZ0FCR2dBUkd4Z0FFSEF0QVJFZGZ3Q2djQUVBRWZBZgpBUUFoUURZQjl3RWhBU0JoWUFId0pE
RkFjZkFsQWVBQkJRRFJKZ0hBQWZBbkFTQVJZQUh3S0pvQUlmQXBUUUFQQndBWkFlTUFRUEFxCkVT
QUhBSkFyRVJBQlFCSHdLeEd0QUZBQUVmQXFJYklBRUFBZ0FBRUpBSEVSOENvQlFCRVFCd0FpQVNB
SEFLTVFJZkFwd2ZBcEFXQkIKQlFBUXNRZ0F3QUh3TEFFQU1TQUI4Q3NCZ0FVQWYzQUI4QzF4OEox
MkFnc2ZNM1lDSVNad0FYWUNGV0Z5QWk5Z0FYSUMtLThtUU9HQgo4Q3hCQURBcUFhRGtBQkFnVXdK
d0p3RVFBV0FCRUFrQWNnQUJFRUVRQVFBTEFFRUFBUUFoQmdBTEdnQURMZ0JRS0FFUVlSRDRBQUZL
CkFEQUFBWUFlQUtFbElSQ0JFQ0h3SWdFQXFBSUJCUUVRSUFFQ1VqRUFNU0FoQ3dCUUVVQVJFRUd6
QWlFQkVDY0FBV2dBTVNId0hoRUEKQUJNQVlSQUJBQkVnRWI0QkVSQkZBQUVnQUFZUEFEQVFRUURu
QVJGUURBSUFQZ0FTRUE4QUVSQXVBZ0FrQUNMd0d6Z0FBU0VDSHlBUgpBQUl3R2dFdzR3RUJ3UUlB
X1FKUklVQVJJQkVlQXlBWkFWWURFaUJhQXpNYUFTQU5BQU5GQUFVTkFDQWNNUWNBTUVCQjhOWUNF
UkRXCkFqbndKUUVMQUFJX0FRRU5BQ0FnSVNjQWMtQW1BUUFSWUJGU0FRRXlBV0FuSVlBaDhDaEZB
UkFwWUFNQUdBTWVLWHdDRHdjQVowREIKOENqUkZRUC1DRkVnSWZBbFFRQXhBQ0VBRWZBbDhRSHdK
bUVBWWZDWWdRSV9JNEFCSGdFZ0FHRTlBUWdVQUE5NUF2LS1MQnJmZVFJQQo2Z1V3NGZBbkNBQVFK
dndGWUNUeEEtQWtFZklCRUNDWEJSRW03Z0VCa3dJUU1JMEhvU2dCTUhId0tDR0FBUUNaQjVDaElB
SHdJd0ZBCllWQ1JCeUR3QkdzQ0JnWUFFQl9JQVJCaEZ3Y2c4QjRWQWlLQklBc0FrUUFSRUJGZ0VS
QVJFQTBBQVFNSE1RQUJJTnNISVBBZHZnRlIKRVJCQkVCRkdBaDhjRHdBQkVBQlJCeThSQUJNQUF3
TXlBakFRRVlBZ0FCRVJEUUF4SUJGZzBnREI4QnRCTUlFd01mQWRNVUJoQ1FnQQpmd0JQOEFFQkVB
b0FJekFRQWVBSkFBQmFBQ0tnSVFrQUFSSUJNQUFCOERzSGpKQUI4Q0lCY0FHQUJ3QVJJd01EWUhB
QjhDUUJVR0lIClR5VUJZQUVIQUVVQTRBZ0JxUUZSRVNBQk1DRVhBQkFnNFFJd0pFRWdnZ0FnSTJG
T0NkLXdJM0VBQVFDQjhDUHhBLUNYVHdKRkUyRk4KQWhfQVN3TC0td2taNEVzQ0FKMEtNQ2NCVUFz
TUlDZFJXUVl5OENjaFFBWUZFQUFDSGdDZ0pvRkFJZkFrQVJBQm9FTUJVQ0lCTUFHQQptQUJBSVFF
QTBjd0JZUEFoRVNDaFFFTUNNVkNCVUFjQUF0RUFNUjBCY0JRTElQQWRmZ3NnWVlBQUFnQk9CaG1R
Q1FBUkVOWUdGR0QtCkFUUmdFWEFYQWlWd0FRc0FNR0FCZ0FzQUlCa1Jwd3dRZ0RvSEVSZ3NBQktR
b1FzUklDVUhGb0FOQUI2Z0N3QU1Jd0FFRFFDUlFXQUIKb0ZId0Z3RXdMQUFDSFF3U01SOEFZU0F4
OEJRQlFFa0xnVkF4VUFId0ZWRVFKd0FoTUZHQ0RBTU5BQ0VCSUZNQUVERU1CeUJBVWR3TQpBY3NN
QUVnQklUQXg2Z0FDSndBbjhCOExBSkJCTUFGZ1VmQWVBWkNLQVFBSEFCQ3dKd0VCQndBeEhBR2dn
Z0JnOEJ2eEMtQWdoZ1lWCjRhY0JEd2NBTWhJbW53RVJKR0VCUVBBaUFZQVRBaEloQndCdklvRUFn
ZkNXV0FJM0lRRmdTQUlTWVZZQ0F3NEFEMVlDLS04V0VfSzAKRUNRc0FiUVFNU0h3STBrR01HQUJF
SlVRRVRBc0UxQXdFZkFiRWU0QkVCQkZDd0JEQlJFWWxBOHdFRkZ3ekE4UmdPc0tFSUNDQVVHQQpB
VUJoQ1FBaE1DRjJBaUFoTUEwQVVHQWhvQ0ZnQ1FCUmtBR0FBWkFKQUNDaGtEb0FFbkNvQ3lJQkVB
SUdFQmpmQVRBaElDR1NDeUh3CkdTRU1BSXdMQVEwQU1YQUJFTHNCRUhCWkFoRndnQXNCTkFBekd3
RndRd0FTY0o4Q0FrNEFFd0FJQUFFNUVBRHJDd0c5QUNKQkVBOEEKRkJBU0NpSWRBU3NITWhBaEVE
TUhCaE1BRm1BUkFDLXdCd1lBRTdBZUFmQUZBZkFnOFFYd0loWUhBVUlHUUNJQjhBTU1Cd0FhQURB
ZgpBWkQtQURBZUFhQV9BZ0EzQWprQUFaQUpBQktBWGdpQ0hhRWdvZkFlQVZENEFSUWdDUUF5SHdG
Z0NRQlFGM0ZnQVhBSkFEUVZNYkFKCkFER2dBWUFKQUNOQmtBa0FZeUVBQVhBUmtBc0FJWUhBQ1FB
QVpRZ1JCQW9BRWtFSUFDTVdNUWdBTUNId0JRZ0FFQzRGQUJVdkNnQkEKTG5Id0xxa1F6eTVCSUJI
d0xLSHdMSkh3am1VQ1FpWndBV1VDRldGaEFpOWdBV0VDLS04VEZONWhBaUJSTUNFSEFYSVBBR1lU
QUFVUApNVkVnQVY4UU1SQXhFQWtBSVZFUUZ3QURKUUFqWVVCN0VJQXBBYUFSOENrQmdKRUNJU2Vo
YkE5QUFBRVFJZVFHWVBBakFSQ0JZR2tGCkFDc1FFcUFsQVJBQThRVVVIZ2tBSWgwQk9RWUJPd0Vm
SEEwQUF4SmdOQWNCRFFBUkVSb0FJQkFScVFzQkdnQVJHM29DRWlBYUFBUU4KQUFDTEFURHdHeEZY
Q3hKQVBRQUVDUUJDRWRBQk1IWUFEd2tBQkFBR0VSREFtZ2N5SGtIQUpSRVF3UGNBSWg5QkJ3QkFB
UkR4QkVVVgpFZkVPQUNEeEE0Y004d054QU5Id0hwRUFnZkFoWVVDQjhDR1JBSkVGQUxDQkFJRUFB
ZkFpY1FCeEVIRUNFQUJHQVJDUnVoRVFnZjhDCjEtQW9ZVUFSOENkeDhDNWg4QzRHQUIwdkF3QUI3
d0V4TFFGZzdCUWZvX1FCT1FHaEF5RHdLYjBMQnhVQURfSUItNTRmbWpvTkRRRjgKQ0E4OERRQVFK
eXdBRUNpbUFRRUJFLUFHSnpHQU1mQWo4UVR3SUJFZzRSQVI4QndSWUtGUTFBVVFvRGtHUUJnQjhB
emVHQkZRVUFVUQpGb01CSWhIUUtnWWlNQ0VKQUVBUk1CSGdDUUF3VURFZ0NRQmhGd0V3UVJBeHhR
RVJHRWNFRWJBTEFFQkJJQUd3ekFGU0doRWdFYkNYCkFDQWNJU3dDSXdBQjRnRVJzRjRHUXZBYk1j
QUpBSDhhQWZBQUFTQmhDQUFEQVVFVU5ScnhBZ2dBRWxFWUFBQ0NHUXdLQUVCUUlmQWIKQ0FDUjhD
UUJVQ0ZnRWZBa2ZRSUF2QUVOQ1FCVUpBRXdBWEFKQUFFWkF3SUpBQ0VRQWNrUVlHQWg4Q2doY0pz
SEFMVUJCUVVBQ3c4QQpDQVVBR0ZBS0FDUXVjVEFBQkVRQVR5NWg4T2I1QVRjTzJ3d1A5UUgtdHg3
Z2N4TVB3Um9OUHhBeEFMOGFCUVU4QUhEQUFmQWxNYUF4CjJnNFF3UjBGTVFHZ0VhME9VRkF4RUJF
QUN3NVFHZ0hBRWJEdkNRTUhBQkVnd1JjZ01DRjNIQ0FCTUlVZE1SRWdRUUFkVVRCUk1CRVEKUmhN
UU1BOEFJU0J4a3hNU01RMEFFUkZlRXhJaEFRb1NNQzhBQUl3S0Fhc1lsQmNCVUJFd0VWQWhVQXNB
QVZFQ0g3QUhBQWdESlFCdwpHQUZnSVFBUlVJMEFNQm9CZ0pNR0VSekpBUUY3Q2hFZTZ3QUE4UUFE
TEJnUUlJNGNBRWtMQUFzQVFCQXg4Q1IyQ3ZFTllmQWs4UUx3CkktRUM4Q1JCQUxId0pGRWdnZkFq
WVFDUjhDUnhBQW9BQWRvUzhRRnhFSEh3SkpFUVVmQWtzUkF4OENYQkZBY0FOZ2RRY1RBQjhDc00K
RHhBdVdRc1FMUVVBUVM0aElCSDFBVFNCOEMwR0FBOEVBZ0lmbndRQ1F4X0FSQm9PRC00Qi02UVU0
ZElKQVFNQ0ptRkF0QWtEcEFzQgpLaFVmSUxRTENnVDVCVkVSQU9FQUVYRVdNUUFCRUxZSUVBQUZD
UUFIQUJMQURRQUFueFlDRFFBQ29nMUNJY0FoRUwwSkFoWUFBcGdiCkFTa0pHQnNWQUZBYUFUQWh3
QWtCQU5BYlJDQ2hJQUVMQUFGS0RRME5BQkZSQ3dBeFVmQWJDUW9BTXhJQ2J3QkVBVUJoUUFzQUwt
QUIKQ2dBakVSN0tBQUMxQ2dERkFCZ0E1UUFFRVFBR0Z3QUF2UUlGS2dBQVpnOERJQTRJQmdBd2ND
R1EtQTAyZ0NGZ1J4SUNYQklTSkdvUwpIeVdMRjBza1lBR0xGeEV4Y2dBQTJRSXg4Q01CS3hqLUJD
RmhFQUVnY2ZBZ2dRQUJFSkh3SC1FSDhKUmhBamNDRlFjaEtXSGlBUVFPCkFBOWZBdi0tSUEtQ0NC
OEN3UXdQeEFnTEFzOEtJU0dnSkJNQW13VlVJQUZBb1VCV0FVQWVBZkFHQmdBd2NIRlF2QUZTY0JF
QU1RQnMKRG5KZ0lSQVJFQ0ZBQ3dBQlJRWVFHeDhBQUk4T0FiSUtJd0V3VkJ3VkVBOEFNU0ZRSVZv
RjhBSWFVU0JCRUVFUVFmQWFVVEF4RURFZwpRYVFDTVNFZ2NWNENVaHdCVUFIUUNRQXlZQUhBQ1FB
eWNBR3dDUUFRZ0lNVGNBSHdIUkZ3QVpBSkFDQWZFZkVYQVB3YkkwRWdDUUFBCmNCd0NzQWRTSVFF
Z01aQUpBQ0h3QVFnQWd2RUU4Q0x4QS1BanpCSXhBVkFSRHh3QVNoZ2k4Q01xQWg4ak1RSUlQaVlC
VUFjQU55Y0IKUUFjQUVTZ21BMEh3S1VGZ0dTRUFEQUFrS2pFUkFFSW9VV0FCeVFZVExjc0JBbzhs
bjZId0tySHdLcUh3bGhJQ1F4X0EwQWdWRHdvQwotNmtHMmdvQjNpUWZLQklFS2dIWUNnRUZBRUVv
d2ZBbXFRRWhJQUVmSlFIRkFSRWhCZ0FDWUFFQWdoWWhBQUhMQVJBZTJBRUJZQUFCCmlBNEFCUXNq
QUNFRkN4RmdMeW9CRUJjUWdPQUJBS3NBTVJjQmtFd0FBVGNYRWJCRUFCQ2dTUmNSVUJVVEFDMENB
ZVFPRUJSeUFRQTYKS2dBNEFSRVRTUUlSWUVJbEFHa0ZnUEFUQVVBaFlCRndkQUlSRTVzQkVJQlZB
VE1VQVZBbEFBQUlGaU1CUUEwQUFuVUxCQ01jQkM0YwpBQ0lIRVVFaEFBRjlBZ01zQUFNNEJ3TWhB
R0FjTVdBQmdERzNGaEVoR2dJUlFCc0FjUEFqVVVCeDhDU3lJUU1IS2hCUTVBQUtLd0lQCkJ3QnJF
U1RDQUtEd0kwRWdBVkF4OENGeEVTTGY4Ql9SQUFFZ2dmQWU4UWp3bEdrQ09SX0FPUTBhRDJFQy0t
OEhEMXdaTHlJbklVa0wKTVNId0pPY0Y4UWNGOEIteENQQWUwUUFCQUhId0hjRkFjZkFjd1FBQm13
N3dBUnZSSUtId0d1RUFvUUFCOEJuaEFKR2lIeUR4Q1ZVUApJZkVJVUE5VUVQRURBQUVLQUFGNEFn
RUtBQUhGSXdJVUFDSVJNQW9BQXQ0R0FRb0FFNUFJQUFFS0ZDQVE4YlFCWUJrQkVQRUNRTG9nCk1C
RHhCM0VYUWZFRDhDQUdBQkFmcHdzQTNRSWg4UU10S2hCUVB3QWlIMEZYQVI4QkJ3QUNBY2NrQV9J
S0VpR0JIQkVnaWh3NDhDQ3gKR2dDQVVCRUFvZkFoQVhBUkN6QWlBWkNnQUZVakFZQWhRQWNBSUNR
eHRTQkE4Q2h4UUg0UEJBVUFKUzRSQlFBSU54c0Fxd1kta2ZDWAowUUU1QVc4UURra1pEODhCLTRv
ZjM2QUREd0dlQXdfZ0F3Z0MxZ0VCNlE0UFFSY0gwREFoMERFZ0FSQ0I4QXdCY0NIVERRQ2NGaEFB
CldCY1FnSjBzS0VHQUVRQWdFRUhmRGtCQUVmQU5IZ0FoRVJDY0drTWdBZkFRV0I4UXdIMG5VQTd4
R3ZBTFlnQWk4QW9HQUVEeEhQQU8KQVNnUUFGa3BIeElLQUFJUWNBb0FHRkFLQUJBUktnb0JIZ0FZ
RUFvQUt2RUNDQUFPSkFBUENnQUVNRUFSZ0FzQU1BOFJrRDBMY1FGdwpFZkFPRVpDSUlBNExBRFJ3
QVdBTEFDTXd3UWtBQUJnTEJRc0FBT29rTVBBT0VZMGZIVEFMQURLd0FaQUxBRkFORWNDeE1EVUFR
UXdSCjhBVHBEd01NQUNVUkVBd0FFUVY4QnhPQURBQWpNQ0VLQUNNUlFCUUFVd1lCUUJGd0NnQXBV
QUVLQVBNQUN4SHdCM0dBRWZBS0VmQUcKRVZBQkNnQXRBV0FLQUc4SFlaQVI4SXFCQWprUFVBUVNE
MzhDLS04dEhfRmRKQUVnUVNEZENSQWY1QkZBc2ZBYmdYOEM4dzRBRVJDQgo4QmlSSUFFUTRmQVdv
VEFCVUtId0ZhRkE4UUh3RmFHZ29RVUFJSUVRUFFLd2dmQVZrUUNSRUpId0ZwR1hDZ0VFQUVHUjhC
aUJPQ1JBCmdmQVpnYWdHVUJDQjhCbVJUd1ZTRUpId0drSElJeEVnQmdCakFFSHdHekZBT1FCeFFE
SHdIQ0ZBRVE4SFVoRkFJZkFkN3cwU0VlNEsKQVA4Tkl2QWRTeE1qRVNBSUFFLXdIZkVKQkFBT054
N3hCd1lrRUNLSUIwTUI4QUlCRENRd0lRR1F0UUl3SVFHd1pnWkRJZ0hBQVFjQQpBUUFURWNBUkhC
RmhqUU1oSWhFT0FEUWhBZUFIQUJBd1lCZ0JNUUFBcGhRQjFRWUFQaTR4TURHQUNRQUJ6UThBaVJB
Q0lTb2hJVUVDCkN4VXNCUUFDUlE4UEJRQUJNb0h3TFNZQUJGNFBUeXlSOEktdUFUd2ljR0h1QVJI
aDZnRXZZSkhxQWZfcEd1Qk1FeEFBTHdZU0p4UTYKRVNjcEVRRzREZ0lWSGhnZ0ZBQUNKQUF6S0hF
d1dnWUFWVFl6SURFUVZ6WXhJVEFSMlE0QTBSSWhNQUduTVVFd0FSQlItQUFnUURFcwpEaUR3SC1V
QkFNSXhVaDRCUUVGQUVDMEFBQTRCQ3dBUkhCQUJBUXNBR0JzTEFCRXd4dzRCQkNBLW9BSEFCd0FB
QUhBY01Cd1JnRG9GCkFBQW9NbEJSUVBvbkVTQ2lJMThkQVhCaGNBY0FDMEVlZ1VDQm1TUUJjZ0FR
SHc0QUZDRVFJQUFwQVRrbEFVQUhBQkF3QndBV0pnY0EKRUhBbEFRZ0hBRFFvQVNBSEFBWVVFeFFw
RlFBVU1EVVRHWEJERXhsd1dCTVRjRzBUQUZNeEE3d3hBTXdQQVhVdUVWQ3dOekR3SkhHVgpISUJ4
TUZId0l4RXdJUWNBQVBjeU1DSHdJeGdBSDVVV0Fqb0J1ZzhSSl80UUZpQVFBQThRQXYtTDRPUkI4
Q2d4SUlId0otRUE4Q2poCjNpSXd3ZkFrN1FtQmtmQWtRVkJoOENPWkh3RDhNREFSTUNIVkJBQzNE
UUlIRFRJaEFXQ0tDakFnQVhCSEFqSWZBWUQ3SnpFd0lSQlEKQm5FQllDRkFFVUFSUFNzQkRBVkJI
QUdnTVU4Z0lJQXhYU3NRRVVNVEFESUFJaEZBQ1FCQklTRVFNVklBTlNRQkFBa0FBU2N4QXdzQQpB
OThfVFNRQkFDRUpBQWNkQUFBeUFTRUJVQXNBSWlGQUZBQVZFQWtBQVIwQUpqQVJDd0FBRmdBdElD
RUpBQVVkQUFGdEJnSEhQaUltCmtkTV9GR0hZUGdPRUN5UkFFUndEQXdVQVFwQUI4Q29GQUFUQ0JR
V29QaUVBQVVRcENBY0FJWEFCckJnRkJ3QVhNS3NsRzJDNUpRQ1YKQUMtd0pna0FGVkpoOENXQkFO
TWdINU1hQWtBakFXQWFBaEpoR0FJdkFXQVlBdi1SR3Q1Q0JqSkFZUUFCQlNCZ0VRNFhBVVlJQVFr
QQpJQUFCSmpBSUZBQUFNQUlBQndBUmdlczU4UW1nRVFBeDhDQkJnQ0VBUWZBZUVRRFJBR0h3SERF
QU1XRDNFaEJCSHdvUVFFMEtrQnBoCkVDRWcwZkFac1FVQTh3SEJBQkVBd2ZBWW9RQUJBUEVBOEJm
UkJnRHdBQUVBMGZBWHNRQUJBT0h3R05FQTBTb1RJQUVBRHk4UUdrZ1QKQUtFWFlodmhBS0h3R3hj
QU53SHdHeGNBTUpId0hDRUtJV0VBOXdFaEFBRnFEd0lQQUJNZ0RRQWdBUUJYRHpOaDBBRUZBQ0FC
UUx3VwpFUl9lUTFCd0FmQWZZZndHQV9nR0FBc0FFWERxQmdFSkRocGdDd0FpVVREckJUUWRBWUFK
QUFDRURoUlFDUUFTWUJJY0FTOHdCd2tBCkFGY1RBd2tBUDVBQlFBa0FBejlRQWFBSkFDTWZZUmtB
QlFCekFHSWJjYUJ4OEJ0bUV3S2FDaF9sTUFJOEVvQWpBZ0IwQ0FZUUFBOHEKQXYta0lQOHBGeWRn
Y0JId0t3R1FHVDRRWUlJU0FiTTNNQkh3STQwS0FIQThRSUF4OENkS0FoY3BJeUN6RUVGUUFmQWxF
WEJCRUJIWApEVk1nOFFmd0k0TUVVU0FCOENZUjNRd0MzUVVSWUdFd0FCOEFFZEgwS3dBTkRuRWhB
VEFoVUJFd3ZRWWlVV0RMSXdCeVBoQWVZQkVoCjhCMEdBQ0FjTVRZZ0FHUXdEd2dBQ1RBWW9hQktE
akFhOFFUSENoQkJHQUlTME1na0Rnc0FJaDFoQndBUkFhVUFFZ0IzQUVNZ0FiQkIKQ1FBMGNERXdG
QUEwUUNGd0N3QTBJQkdnQ3dBUUFJVXRFQjRWT2hRQTFpQVBCZ0FJQWU0Z0R3WUFKQlFIUVRVZ0hD
RVNBQkFiVFFHdwpCQUh3R2pId0J4SHdHR0VhQUY4VzhSSHdqLVFCYnhOaDhnRWZnUEFCLTRNZjM0
QU9Cd0F6SGdHbkF3VC1EUkVBSEI4V0FCRUFCQjRBCklWRmcxUUdCWURId0VGRmdjVEFOQUNEd0Rn
OEtSQ0dnSVVBTkFJQVFFU0NoSUJFZ1VRMEFZU0ZRY1dBUkFBc0FNQUh3Q1FVQUZ3MEsKQUNyd0VB
Z0FJZUJobERkQURnSEFnV2tCNEE0Qm9MSGdBZkFQQVhBaE1ISFFDUUFRVU1sS2NHSEFBZkFSVVRD
bEFERVJJQkdWRGdJTApBQUNaRGhJQnZSSUFCQUFRTUM1TW9CMEJVRkZRTWZBZkVWQTBJd0NZUnhC
UUVnWXdJZ0VRbnhjRmtoSU1CZ0FoOFFRRUFCRWg0UUlFCkJnQVNZR0VTQURRS0NBa0FBR2dMQVZN
R0VSOHpDZ01KQUFGUEJqSWZrVERyRGdGU0R3SUpBQkpnRXkxaVVBRndjZkFWRmhjQnFnSXMKOEJR
TkFCR0FhUXNIRFFBeUlBRWdEUUF4a0JFZ3hDQUJTeUF5d0hFd0NRQWs4QVFnQUFNS0FEQ0I4QVEt
QUFCbUFGLXdCU0h3RmU4UwpBQUgzVFJSd0h3cy1vZkNrV1FJOEZvQkdBZ01pQkFJTkFCX0FVUUwt
LXdnTEtoTVZ3T1lqQS1JakFGa0dFeEJERlFlUkpnRjBMeGtBCkdBQVJKb0lqSVJBUkIwZndBU0po
WUdId0lYRkFjZkFna1NDUjhCNUhQRUFkc1FDeDlCOHh3ZkFiQlFBd1lSQXhCd0FoVVNBSEFKRGgK
SUlId0dfRXdjZkFXUVVRYzhRcncxaGFJSC1FRzhDQ1JBS0VGQUQyQklKRUZBQUFuQUhCeFFJSHdJ
R0ZRNHhKRHdHSHdJQk1DQUJRSwpBWThmQXc1QkR3Y0FFeEVqemdFdzhDU0IyQklqUVhCTE5pOHRB
UVVBRkFPZUFRY0pGejl4OEppZUFVZ0JUZzhCbkFFTHhpVVBtQUgtClFnbGdHaEVxWXdVR0NoVUFD
a01CQndBQ0JrTUJHUUFRRUJJQUFpY0FZVEVRWWZBb0VTd0FBS1FCRWlDTEtnQTJCQkJRUXpBd01J
RVEKVVNZQ2EwUUR3VHNnTUVGa0RRRlFGaEVRVnljUlVLd3JBU1VGRW1DSFFBQlNBUUFNUVFEckJG
SVlBY0FCMEFjQUFLa0VBREUwSWdIQQpvemdTVUFrQUVSblFQQUpPRFJNaENRQVFIYXdKSUFCUkNB
QVNBVzRBQUFRakFXb0FNR0FCa053UUVCdG1BQUZtQ2dERUZoS3dDd0F3CkdnRlFDd0FSRVJRQUVR
QTRIa1R3R3lFd0N3QXdIakVnUlQwd0lRSFFSUk1GeUNzZ0FURElBaFFpQndBQVRnQUVCd0FSSVd3
Tkl2QWkKZ3lNYkkzVWpDZ2NBRWxCN1FRQkxBZzhKQUFFQWl5Y0dDUUFBZ1FVWFVBa0FBQ1FBREFr
QUFMSUZEd2tBREJGeEJ3Q2ZJWUV3Y2ZBaApjVENCUUFKQkVuQUhBQ1lRWVJVQUR6d0MtLWdFU1NN
U0pjQVpBQUFRRURBSENnSWxXQU9URmpKQUFSQy1HQklnUng0RVlnd0FIUUlBCkFnQUVIZ0FCcGdR
VUVEWUFBUTBBSm1GQUdBQWZvQXNBQVRFUmdESElOQkFRTjBBajhCMEtBQkVDTEE1QkVCRVFjWUk4
QUJVQVF6QlIKY0JFTEFERkFNWkIySndNQ0FBQ0lBa053SWZBWkR3QUNFUUJEZ0NId0dBMEFCZ0lB
VG5BeDhCY1ZBQ0JSOERoWUZoQTdBRUpoOEJVQgo0d0FERVFBemNmQVVGUmNBdmhaRllJSHdFdzhB
Y0JBUmNLSHdENEdDQ3ZBQmtQRUE4QXNoQUNFZ1FhRGg4QXdCQURoVVVRR3d3ZkFPCk5nQmhVQUdR
c2ZBU2IxbGhZQ0VRWWZBV0ZBQ2dNQ0ZBUWZBWlFWQUJBTDBPVVIwaEFJR2duUUlBWkFvaDhRVUVB
Qmdnb2c0djhRZGoKQ2dvR0NRQVBad29NQUl3Q0VrQWdDZ2tOQUFCYUNnY05BQ1ZBQVI4dE1wQWhF
QTBBTEJPQlpRb1RnUWdBQWhJQUQyVUtDQVVGQUFsbgpDaF9tdFFKRkFVNERBclVDQXNBTUJiRUNB
eG9BRDdFQy0tOVhZdUNCOENnaEFBVWZJaUJ4RkJzQ2FBOGpJMEdoRVFDQ0JnSUpEUUVQCkhDTkFB
UmdBRVNBZkJ3RVFUakpnZ1VBWEFRRFNCZ0VKQUJJUUNRQUJXaUFBN3l6QUhRRmdJZEFoOEJvQnNK
RkFvQ3doOEF3R0FBQnkKS0JBUmNpaEFHeEh3Q0xVQklQQUM5UUFBRzFRaUlBRnpBQk1BRVFBVEVU
MGtGQkVSQUFFNEFoTVFDQUFBQWdBbDhDQU5BQk1nQ0FBQgpGUUF2OEFJSUFBVUFNbDBFQmdBTFd3
OENHQUFnOFFRcUFDSHhCSElBQUp3QUFFWS1BVUFBRVJBT0NCQUNtaTB5SGZFRTh6bENBREh3Ckla
Z1hFU1RfQVVMd0pRRndwaHNDQndBVkVlZ2JBSU1oQ1FjQUVpbmlEQjBxQndBQlVGMEJCd0FrS1RH
bE5ROEZBQUV1S3lFQURBS0oKRlFHNU5SX1lHUUk1QVdjUkFSY0NGV0VWQWdFVUFBOFRBdi1QQUtZ
UFVRQWg4Q1p4MXhFQWVsRUI0QkVSSTJBYkVTQUxBQ0VSSURJMQpFREF4QVFFV0FCRVIzQW9SY0Fz
TEFNNEdFSUVBQndIWEJnRF9DZ083QVNHZ0FVMUNFQndSSEFJb0FDQWFFWDhGRWtBTkFFRVlFV0Jo
Ck1pTUE3REJIOEFjQkFBb0FFUkFLQUJBSW1BQXdHQUhnVWxzQXlrNEJjQUFBOFFZREN3QlJBZkFj
UVNDTU9RR2dPVEFnUWFDb0FTRWMKQWM0c1F2QWRJVEFJQUFBVUl4SUFSd3d2OEFFSUFBY0E2Q1F2
OEFJSUFCY0JTeHNLQ0FBZzhRUUdBQUg4RnhBY29RQUNPazRTRzdBQwpFUkVERURFYUFSQWpGQUVK
RUJFYlpSTUJqVEVnR3pHTEF3UGxDeEtRblFzREJ3QVRFTkVMQVBRTUVTVDhBQUVIQUFvWk5RZE1T
QTk1CkFnRkFLQUZnWVJvQU0zSHdKZ1VBRDBJQ0JCX1pRZ0k1RTRCQUFoVnhQZ0lmZ0R3Qy0tOERE
OElWSFFNVURnckVGU0VsSVM0QVlDSHcKSVJFQThheGNFQjJqRndDS0cxQVpFVkFSb05GbFVCWUJn
QkdRV3drQXJ3cFFnQkZ3RVhBNUFCQVMxQ0F4RVdBUnBRc3hFUUVnWkFJZwpFQkVRSUFGUk1SQkE2
VGxCRVRBUkFHWUNFRUFOR0FBVEFCQWd6MXdSSVJFQUVBN2hDMEVoUUVFQXR3WkJZQUh3RFRrQk4y
QWhjQTBBCkloR0FEUUFSVUlvc0VvQXRDZ0lQQURpQUVaQVBBQkJ3TmlnRUVRQlJRQUVnOFFWbUFB
ME1BSEVCSUJGd0lTQUJFUUFTRExBZ0FWZ0EKQUdzREVFQjFCd0FrQUJFUVhBQUFrQU1GRXdBM0FC
R2dFd0JDWVNBaHNBOEFFV0VnQUNFUUlWb3lKQUVRTVFBUUVGY0RBdzRBQURVQQpJdkFIelFNQkRn
QWw4UWtNQURGQThRV0pHU0FMVVFvQUVWRThBRFV3OFFXTUFBa01BRE9SQUpFTkFDRXdFUTBBQUJZ
RW9Bd3hRSkVnCmtVQXg4QmJoRlFuQUN3d0pBQkpnZENFRkNRQXlIZ0Z3blNrZkhRa0FBQkpnNndJ
T0NRQkJISkZna1ZJU0VtQlNBd0JGQXg5Z0NRQUwKTUlHQWdWQkFNRUdBUWExRVg0R2dnZkNSOWdK
SUg0QWFGd0VQN2dMLS01MTEzNkh3S3NId0tRTUFBUFVDSVNmeHl3SVNRVFUzQUVKVQpBcmdIRlNr
VUFBQmtBZ091U3h3b00yY0JCZ0lCVWkwaUlTRU1EQkFRRFFDeElERWdJU0FoSURId0gwRWNBMEZC
OEI1UkNRQTdVZkFkCkNRQkFZZkFiY2JzQ1V3Qng4QnR4QWpNa0dvR21KZzRKQUFCZFBtRUJBS0h3
R3BGdUFEQ2g4QnFpSmpPeDhCc0hBR0h4Q3ZBYThRc0UKQUZBYjhRQUFjZWdIUUJFQVlTQ1FKWUFn
SVJCQllFSHdITUVXQUFJNEF5Z2VJQUVROWtRRkRRQlRFY0FSOEJ5alp4QXdUd2NUSEJZcgpFNEFM
QUJFUnFEWU1Dd0FSSWV0UUR3c0FFZ0FLTEJCUUhXZ0pDd0F3Y0JFUWRRZ0F2U0lEbGdNYUh3c0FB
RHNtQXdnakR3c0FCd0VtCkRRc0xBQzlBRVJZQUFSRlFyQVFDQ3dCaU1mQWRJYUNoRGdBVGtZTUFJ
QkFCU2loZklaQ0I4SnRwQWpjQ296a1RjV01DSDNCaEF2LS0KSnhYZXVBY0FWQ29EUmpJU0FMSUhB
TEJtQVFrQUE1MEtHQkVXQUFJb0FJRndNZkFiQVRCaEVDRUhSLUFhQWNBSkFJRlI4QnZCY0ZIdwpH
UWtGRVVCRkFBRC1GQ0h3Rm9vM0F0b0dBaVlGUVFBQjhCUV9ad01vQUFBbkoxTUI4QklSUUNnQUVW
QVZBR0VBRWZBUkFXQ1BBQkVnCnZ3SUI3aFFoRUFFaVp3RjdXUURUSWdJRUF4QUNEQUFBQlF3RURB
QVNjSHdCRVFJeEFBSGtGQkJBNFNZeUVCRmdxUWNBaXhVU0VVVUgKQVVvTkVsQzVRREVSQVFBUE1C
SXdlUUF4VWZBU2lRQUE2R2NTc0JrQkFGWUFGQk1uSXg0eEZRQUJPd0VQRndBQkx3RWdGd0FDSXpI
QQpGUUFRRU5nSUFERm9FQUMyRFFJU0FBbEFBQkx3RWdBZkFCWUFHZ1BuRmdDaExCQUNFZ0JEOEJr
QkFQTUFBbjhCQVM5R0FJWU5BR0FCCkpmQWozVWtFWEJJRGhnMEJwQTBTSXZzZkF3SWdBeEFnQUJV
QUFDY0VEd2tBQUJFaHh4WVNZTzBqQUtneEFiOWZFRENJVndEYWNnSUwKQUJJUTRWY1JVS2N4REFz
QUlXQWhhaGdBQ3dBamdIRUpBQUNaVndBZkR4QmdxQUFES0FBQ0cwOEJGQUJTQXlId0Y0RmJJQVgz
TUFEcApHeF9vS3dNNUVvQWNBd0ZxYWdVUUFBOGpBLS0tNFZETUlmQUJnWVViSUJIZ1NBQnhGZ0VR
TWNBQm9GSUJJa0d3SGlreUZHR3dueGN6CkZVSEFvaG1DVUNId0RTSFFBUUFLRWdIUkFtTVFFZkFR
TVlBZ0FCQXdLRmNRRHJZNEFUb0FFRERDUFFBUEFBRGZBRkJBWWZBT1VlbzEKWlZCQjhBOVJjRHNS
VVZBaDhBOXgxWEVBUUE0UkZsa0FFUURJU2dEbkFRUUJDVkJRTWZBTEFVUlBDaGNBQVFVTk1nb0JV
T1VCQUxKeQpDQlVBQVE4QUFOTUxBTEJ4Y0ZId0NnSFFFYURjZHdBTEFLRHdGSEh3Q1FId0JCSFFT
UTRCSHhnaEFqRmlZeEVLdlFjU1lBczJFQXRfClJpUVJjQTBBSVZBUnpWTmpzQUh3REZFd0NnQVJG
a1pQRXJEY1hBQXFhU2J3RndrQUFFdExBYVpMQU1VQkFKZ3BFQmtLQUJBd2FnUWgKWUJGdkFnQXJB
QVFIQUdFaUFYQVJnQkZWSEFCSENDRHdDRlVkQUpzQUVCcDlBQU5tWFJBWWt3NGg4QmNHQUJBV0R3
UWo4QlVHQUNDZwpNY0FURVJWRkJBQy1BeUR3RmFrX0lqR0FDUUFRWUwwWEFCbE1BVWtlTVJjQnNB
eERBZ2tBQUJzQUVCbldDQ014VUFrQUVVSDZCRUdnCkFWQnhmRkFoY0RIYkhDR0FRWEl5RUpEZGV3
RHZBaUd3Y1o4ZEFLUUNFUkd2WkFCekl3Qi1DUUY5QlFFSEFER3g4Q3QxWkJfZ293Sk4KRjRDaEFo
bGhuUUlmZ0pzQy0tOC13dVFoOENfaDhDbmg4Q2J4QVdWMUdPRzBOaUVRUVVFVEV5QXhCeWdBQVJZ
QUFTWUFBZFp5QWVZNQpjQ3JCOENkeEFIRURXUkZobFFnQmVTWUE0d0FRSHVJOUFMZ0hFUjFGQWdG
dkNCRWMtaElBMWdZU0lDa1JBQmdBQVEwQUFXWlVBX29DCkN0UllNeGdCUUEwQUFmNUxEUTBBQWtN
QUJROEFBbDhBQVE4QUFPWUZCQ0FBSVFBUmhBWTBNQkVnUmhrSlN3QUFCMUFDRFFBRmZ3QUMKT0FB
RkR3QUEtd0FCRHdBa0dnR25XVUV3OFFFd0NBQUNMVU1BbG1VaDRCRk1EUU1KQUlBZUlmQUJJZkFn
RWNNQkJSWk1Bd2NBRW5CMApKZzhKQUFsT2tRQ1I4RXdtQUlBOEF3a0FFbEE5QXlNZ0FWTURFUl9y
RWdGekFRQTJDUUVMQUJFYmN5NUJjSEh3R1R4ckFYTWRJeGdSCmwya2dGeUhsSndHRmFURkFBZEFK
QUJCQnNBUUFDUUF3WWZBQkNBQVFGOGtBRWdJMkFKQVFFZkFBa2ZBWFFmRGtVUjRndUVNUGZBSXcK
RGpBNUQzUUMtLTh5Q2pRWUlvRkExeElCY0Q0Q1l3RW04Q2ROT1FjVUFBRWtBQ0Fsb2F3Z0FwaFVB
RVJoRUhBaEM1QWlRUkNCSUJIdwpJR0VVQndEVkVnR2xIVkVnUWZBZWdRa0FNVkh3SFkwU0l5QmhD
UUJPRUlId0hBa0FJdkVLQkFDR0lTRHhCUEFjRVRBR0FCQWhsbEFRCkhUaFJBaTBBSDJFSkFCdzFB
VUF4Q3dBd01FRVFGU1lnSDRHUEJ5QUFZVFVlRm5IUElRQU9KZ2VGZUZJaEFYQXhjQllNQlM4ekVo
QXYKTXdjSkFCQWdDUUFXSGdrQUVtQkFGeGdlYlJjQi1VTUNDUUFCWnd3SENRQVNJSUlNQ1FrQUFY
QUNEd2tBQWhPQklnQUJsd0J6WUFFdwpnZkFnZ1VRZEFCUUFFeXhGREJfZ0Z3STRIb0FyUmc4UkF2
LVJnT0ZSOEM0UlVCRUFuVDhCNXc0VUphb2tBYlFxRXlOV0tTSHdJdElCCkFCQVFBY2dxQVBneEV5
RFRLZ0FJU0FIOUJBQ3RBRkloQVRCeEFDNEZJYUFCQ1FBZ0hoSFNHeElBSlFVaE1KSFlFQkVhU0VR
UlVIOEsKTkFRUlVJMEtBb2NLQTQwS0VoRVNBQ0NBQVFoSUFUVlpRQUJCVUVFN0FDSWhzRnd2QUxr
NkVCeHhHd0RlQ2lFRUlXc2xBRDR2UUI4Qgp3Q0ZLRUFJdUN6WWljYUEtRUE4R0FCWkE4UVR3SXgw
d0VpWVdBUkltRHdNSHUwTUFGQmdZRVk4bEZTdVdKUURoSUFHOUNqY3FBUkFICkFBWGdNQklnS2tn
QkpRSVpKd2NBQU10REJ3Y0FGSEVGQUM4bllUNGhBQl9hN0FGSkpuQUI3QUVpa1NBSkFDX0FBZW9C
LTVjSjV3VUIKSWhVQjNnd0J1QUFqSndGcEdDQVdFWjFfQS1JTUFBQWdOQUFCMEJ3QVZCUWhFQkd3
TWdBU0ZDY0FJaEdnbmhVUUZkMG5JaEdBMmc4UgpFTXdVUUhDaDhCWmlJQ0FoSUhXREVCUXlHcUVo
SUlFZ0lmQVNRZkFQV2c0UUR1UUlBTzhCVUJnUmtHR1FueVV3WUlHUUF6TUJpRklCCmJnSUFxUjRR
SWQ0VUFHd0FFaUJiQWd3UEFDS0JJRnNGQmdrQUF5RUFBTHdDRHc4QUFRQmJBQVFOQUJHQkdrZ1JI
N3RNQVFrQUFWRUsKSHlBSEFBUWlJUkFPQUNFUUFlMHBGZ0NmTXdZc0toQkFpU0VBbkFBU3dKZ0ZF
ckFiQmdNSEFBRWtTUWt0V1FISFhRRlNCaldBRVlBWApBQkVoRndBQmxRb1FnTWdQQmNzVUVJRGtB
QUFnSnhsZ1BDb0dCd0FTSm40S0lDYUJFd0FRa1FVQUFwUURERWRaVHkxeDhKZEZBajRWCmdFTUNG
MkUtQWhfQVBRTC04MERaTWZBeDNBMVNnZkFpTVJBaUNSQWhlaDRDMXdCUlVBRUFjVkM4RGdFLUJR
TkdOeEVRemlFVE1BMEEKRUJISFVoQXdIQzRpSUhFWUFHRVFFZkFWWVdCUlJCQWdaMWhRRUFHZzBX
Q3VFaEF3QnhRaEJnRWVGQ0F3RWQwU0VBNlpDQUV5QWhFTwpsZzRoOEE4S0FBRERHVkh3RHlFUUVW
SUNFREVORXlBYkVWY0dJUjRSUlhvWUlXc1lEQVlBQlM0S0R4Z0FDU2NSQUFJQUNXTUdBRnNBCkN3
WUFCamNBQW14VUVDSnFKUW02R0NGZ0Fhb0NGQ0VKQUFBU0FCMFFDUUFLSkFBUENRQUREb0VLSHpB
dEFCNEtDUUFBZ3dvRkRnQVEKRUhzQ0VSNHpKZ1JkZTJfaDhCNmg4Snc1QWxNQnBnd0JDd0FWY1RV
Q0gzQXpBdi1XQzZrR0VCQW9raEVuRHdFQXdnNEJLVW9BdXdZVQpFZHdWR0JBV0FBVW9BQUota2dF
LWR3RTZqQkFtam9nUkViODNFU0FHR0JFQXJUY0JKd0FBM2pFQklCZ1NJT1VTTVJvUmNCNVlBQkFU
CklDR1FRZ2tBdnhNUkVua2JFaUFVQnlJT0VRazhBR01XY2JBaDhBa2hzQkZSQmhBQUJINFJFRGdM
QVJBQVFRTVI4QU0yQmpGUUVSQXIKQ2dCWUZ5RVFJUkE4RUJBUEtBRVZBRUZRSVdBQndBQUEwQUFB
ckhNUlFGY2VJUkFScndvekFWRndFUUFBNzR3UUlNZ0NFRUNIRnhBQgpobzBIRHdBUWNKQUdNUTBS
UUNSWmdKQVI4QXdSUUJIUWhRQXdHWEhnWHhoZ0drSHdBREVnaElBUThNaGlRUEVDOENSeUFBc0dB
Q3BRCklTd3VJWEFSMjFSSllESHdJd2NBQUhGM0VuQUhBQ0pnUVFjQUVERm1BUUFRSkJBb3NSZ2tM
UUVGQUFGQmN4OHRCUUFhQWFvR0VTeXMKR0REd0xJRl9jdzlJQWowU2dEa0NBQ0VSRmhBUUFBVWdB
QTlBQXYtd1FPV1I4Q3VnQVRFaEFCSEdRQUp1QkNId0tMZ0JJZ0FCTndJTQpEUUFTRUlnQkFCY09B
UmdDTUNjQlVFd3lNQkpoMEJjS0VCSHRhUkZoZVdrUUVmR1dBZFVHRWZCZUtBTlNmeEFQb3dZUkFI
UTNFUEN2CkNrRHdBQUV3NG5kQkVHR3dVVmtGTWhkUlVDcEFJUnhSUnh3QXJRVUJrZzhXSUFrQUVs
QUtDaFFmQ1FBUkhvNEJHMEFKQUFNYkFCRlEKQ3dBQkNRQVNVQWtBQUVnQUEtRVNCbG9BTjJId0lR
Y0FBRVFBUVNHQlVBRUlDeUJnc2JNUEVKR3pGeEVEU1FjQXFFMGdBZUIyVFRBZApBZERRQmpBZEFh
Q0NFeEVkZmh3UmdCQUFBT0lQUUI0QndERjhDeEVSSUhRd0lSR2cxWmN3SkJGd0xvTWhKaEU1QVRB
b0VTQU9BRFFyClVUQ3pkd0FZTkJzdTdnRVBCUUFWRVlFV0FtX1I4Q3VSOEpnUEFpUUJsUUVUS2Vv
QkF3OENCZlVCQndBQ0R3c0MtOG9HZHhjbVFHRVEKRWxJd0FSQkJBQWtBRUFCVGVnY1NBQU1pQUZG
UWNmQWVJYXNCRUI1RkJqRVJjRkUtUkFESlB3Q0ZiZ0NrUHhJeFRBUUFQQVlCUGdJVApHSzlLQUJv
UEFFYVJBYkVGRUJlX0lFRVJBQkZBNFE0RXNYc0JrQUlUb0JFQUlTRWdEd0FBN2c0RElnQUFDUUFD
SUFBQm5wb0FrdzBECkRRQUNIQUFTUU5CY0FCb0FBaWNBRW1CSWdESmdRU0FMQURKUWNYQUpBQkZB
QndNQmx3NEFwejhBRFFBMmtBRmdEUUFCTDJvZ0YwRUwKQUNGUUVhTUtRUmdCSU1GQUFoUVkxQUlB
VnlJY0lRb0FQeGNCSUFvQUFDVVFNUW9BSS1FRkVnQ2cwQ0V3SWZBWEFRQkIwRWNpTWhvaApJUE1U
QWZ5TkJJZzdEd2NBRVFINUFnNEhBQUZKR1E4SEFCY0FMd01QQndBU1FlSHdKaEY1RVZJbUFRREJB
RDRlSDVkX0FqVVNjQWNBCkpnQnhEZ0FQZUFMLS16d2kzcEhDRmlBcDBlcVlBZFFyQU5RZ0FXSVdB
cGh6Qkpjb0NCWUFBeVlBTXpCaEFFNExBUVVBRUNaY0dBSXIKb0FDZmVnQUJvQkFSSlFjU1VPVVBF
UnFvQ2hGUXJRSUJKd0lBY1FzQlJDRmhGQUV3TVZBeHdqQlFFZ0Z3UVpDb0NqRVJBY0JXTm5IdwpF
UUhRVVVBUmZDc3cwR0V3ZEdJQUpnQWl3SEZhQUREd0VtR2tDeEVRMng4QTFnb1NZUjhVQXc4QUVC
ck1BZ0RPVVFGdEFBQVBBQ0tCCklONEdFUmxSR1JKQTFpQTBRRUZRQ3dBazhBQXJBQUFLQUFDM0pR
ME9Dd2NrQ3lBUWNkbGVFU0VCQWhBalB4VkFBZkFpRVJJTUFBSVEKQVNvUUVPQmZEQkRRSldNd0l3
SEFyeGtoSXdHN1ZnVVZFQkpnMWdJQTdDQUJDUUFTSXZrVUFJY0hGQ0FaQUFDam9CUUFGQUFBQWdB
QgpDd0FBRkF3Ql95QUJydzhlSWM4UEVZRXJCQ0lkb1FjQUpaRmdLUWNHWUFjQUxRY1FvVEFISDVN
NkFqWVNnQ3NDQUlRTkJoQUFEeklDCi0tSlEzNkh3SmtFTEJoQUF1R0lCV2dRQkVTb0JjUmNDbWdZ
Qy1SRVNBQXlNRlNBaUFBREdQeUV4SU80QUFZNWxNUlpoSUZrN1VDQmgKOEJHQkdXOVJJSUh3RHBF
SkFHQ1I4QXp4QUtDWFNQQWY4UUpnOFFMd0MtRWI4QXZ4QUNCUklPSHdDX0hRMGZBTXdmQUFzZkFP
b2ZBQwprZkFTY2ZBQ1lmQVlRZkFDTWRnS0RrOUVEd1lBTXdiLVZRVy1JQThHQUFFZ2NDRkpGU0FS
Y05vd0J5SVlEd2NBVXlJaFlBNEFFQkN6CkVBQU5SUVBYR0FFR0dqQWVZVEJqQVRBZGdTRElOZ0FM
SWhfUy1RRXZHWUQ3QVJsaDl3RWZnUFVCLTdSQjB6R2dnYjkyQWVvbkVSdDkKSTNGQVlmQWFjVkFC
WWdRUkdjc0lBMUlORVJtRkJSUlFhZzBHRHdBREhnQlFVQUVnTVVCSkVoRVhFZ0l3RUJGQS1RZ1NG
X0lFQVRjXwpBUjVTQUJ4ckVtQU5BREZ3RVlCWEFnREZJQ01EQVJVQUlmQUNQd0FBRkFBMUFnRndD
Z0FYWUFvQUFSWUxJdkFCSGdBeEdESEFVQVV3CjhCc2hqd0FCQ3dBakhqRUpBQVZTU1FsYlNRY0pB
QUdnSVFrSkFCSUFDUUFWa0FrQUVSSFJLQUVnVWdFSEFCSWlBQkFHQndBVXdRd0EKQUM4QUdiQUhB
QktBNVFVRGpnQU9jd0FPQ1FBQTdBVURDUUFBMVJNQmNnTWJZQWtBUWg0QllERUpBQkF4UmdZQkN3
QXlJa0VRQ1FBRApaanNOVDBRUEJ3QUdET0VLQ3djQUVHSEtDZ0R2YUU4bmdmQ2FZUUpGR1hCZkFo
ZHhEUUFmY0ZzQy0tOEhIX0Z5YVJZRFJCWUhGZ0FCCkpnQXdKaUV3ZENFQWVqNFFrTTRLVUIwaFlK
RkF6RU1RNE5PVk1oVVI0RVFQQVBNY1FQQUVBZERTZGlId0JnUUtFQWxTVFFDWFhRQkkKSldFS0FW
QVJzQkc0TmpIUUVZQU1QUURoQVFCeWxTQ1FJUnc5TXlBUmNCQUFBSmc5RWFBSE14TlFFZ0FBOXow
UXNBc0RJeUVnRWdBeApNQkZRRWdBaGtFRlRBQUE5QUFBUEFFTHdFV0dRQ1FBZklnY0FHSEdBa2ZB
aWtRQWhEQUFta0NFVEFCS1EweklYSWRNeUV4RTZUaEFZCjF3QUIwQVV3Z0FFQXhaSUFUQ1pCTURG
d0lRa0FRWEFoTUFHRnFCRndtSVVTSUFzQU03QVJNQWtBQUhjQUVSb2RBQUVKQURCQU1hQzQKQmlB
WFVlQW1Fb0RZTndjSkFCSndNemdRa0swX0FEOEFFS0FqRVFTS0tRS1BLUVVLQUFnVUFDcGdBZHds
SDVjOEFqd09UakFQTkFMLQo4VUhnSWZBdzdrSlJLT0h3SmJHSWdCQWQyQ2tSRWQ0QVVCc0JJT0Vn
OHdRVEdtWUVJaUFCQkFBQkRwSUdPem9SRU42TUx2QVpKZ0FSCk1GMEZFakNvTVFBcVVnQVZGUEFD
OEIxQmdLSHdIc0VBTVZBUjhCc2hBSUVfQUFBNEJ6QWhJRUU1Y0FES05sQWhzQkV3VVhNN0FuS2kK
RVNFcURoQVZRUThCbGhNQml4TVJGVll1RVJCZkFDRlFFVlk4SUJBQnUzSVJNSVpySWZBVDgyOEFz
b2tSTUdBSFEtQVRBVENzSEFEcQpEME1BRWZBU3NCd1FJQ0VNRlJNTkFBRXhoUUJNV3lGd0FWczlB
Z3NBQWZncUFnMEFFVkJSV2lEd0Vfc0NBbDZ0Z1FId0ZESGdJUUFCCkN3QUF6RHd2OEFNTUFCTWxB
U0FNQUFHT0ZERVE4UU12TnpBQThRTW1DQkFST1RrZUd3c2RBa1pZRFRBcUVpZGRDQUhaQXd4dktn
aUwKS2hBUnBTb1FNYmdxQkFVQVVySHdLZ0VBQWdBLUlmQXJDd0FBRUJHSXNRTUNBQVI3QWdNZ0hR
QUlBQkFzdlFnTzNwUVBpQUktRzRDRwpBZ0dYTUFlQ0FoX0FnQUwtLXlOUS0tLS0tLVpLQUVCd1Fm
QW5fRDhRSVFnVEFERW1FU0RVT2lId0hmeEJJWkF4WXdJQW9nRUJKNGtDCl9sb0F6d0VCT0NrekZE
RVFvUUFFRVFBakFTQVJBQWNUQUJBdzZ4TUdEd0FSUU1zSkFMZ0NBVk1DUVRDUkVBRUNFekVUWVJB
X0FBUVAKQUFCUkJ3SDFDZ0FCSWdEOUdBRW1Dd0FOQUJKeEl3QUJFQXd4RVFGUWNSUUFIQUFGRHdB
U3dQb0xBSFFIRkxBTEFES1FFYkJsQ3hFUAp1d3NTZ0NFTEVSQWZBQUN1QmhJd25rSVJJT1VGQVNS
OVFoQUJVSEdsQndIUVFoRkExQUFSa05RTU1QQVBZY2ExQUI0d0FFRVpJUEFOCkp3QVFzYVFBQWdz
QUFMazdFQUFNQUFGWWZRSG1LaElPWmdFUUExZ0FFYkNMYkVJUkFaQWhDQUFBMEFzQXhWc0JnQUFG
VERNQk1UTVAKQ1FBUEJXSU5JU0J4cGdNQUtnd2lRSEVIQUFFUUFCUnhCd0FBMDVJQTNHZ0JOazB3
Z1RDUjN5RWZuRG9DWndnUEFBUDZBUmdRTmdJSgpEd0FSUUI0QUR6WUMtNmNMckFzZlVQMGZCQUl6
SkFVVUFBT3BsWUFrTVZDQjhDSlJvRk1HUUNCQkFLSHVJQ0V4SUljUUF3a0FBUDRBCkVDSGJCUUJB
S1JBeENRQVNvQUpXQU80QkdiQUxBQkVhU21VUXdGd0hCRFlDQVowLU1oQXgwQWtBSlVBQkNRQUE0
d1VGQ3dBQlRSZ0EKdVJnUjRBa0FHbEVIQUFRZ0FBQUpBQUFOSmpBYlVlQWxIUUNaTHdFS0x5TWJF
Uk12RVJ2aUhRRlpEd0IwQVNCUU1kMFBRaUdBRVRCUQpFQUZzcEFuakZBUUdBQW44a2dEeUFBQWNK
Z09ZQmcwSEFCSW1IZ0VLekgwQUlSb05Cd0FBZEdZTHJRWVJBWVVHQndjQUZDRkZXd1VCCklnQUlB
RE1zQVhBRkFBNE9adzhTQWl3TmtSOFBDZ0wteW5ELS0tOVRNZkFCZ0U4d01CSEFVZzRRR2dkVkFJ
Y2JVaGtCZ0lHQWgyZ1IKRVBBRUFVMGdBZU1GSWxFQURRQVJZTWNGRW1CYURoSkFxd2tTRldJRkZW
RUxBQUlOWndNUEFBQW5ad01hQUFJQ0JnRVdBQ05nWVFrQQpFc0FTQUVGUU1hQXhhd1pBSUNFd29l
VUtJUEFXYlNvQVdSUUZzVGNSR0VCRUVSbEZCaUZBQVdFQVVCb0JVRUVnd0hVVUd3a0FBTllBCkVR
QU1JZ0pTTXk3d0hSRUFMLUFIQmdBQkdCNmhZdzBHQUZBZ0FmQURNU1FBRVFGRUFDRHhBcWxVRVFG
d1JsSWJBZEFCa0FjQXNxQUIKOEJyaHNBSHdGRkhRSmg0d0QwSEF5NkFBckFBUUQ3OEFFSUJsQmlG
Z0lVd1ZBTDV4STJHUUd3QVJBSkZfRUdCNkJrSFFFU0F4TWdBQQp3d0lnRUZFM0ExRHdFZ0d3RVZl
VUVSQTlBeUR3RktrR29IRVFjZkFXUVZBQkVLRUJBZjhHOFFBZ2dmQWlZVENSOENGUlFLSHdJVEZn
CmtmQ1FIUUoxRm5BTEFCUVFfZ0VISVFBUEdRTC1rRlBna2ZBcnNSZ2hVQ2ZoOENYQkwxOGhzUkF2
S2lRUk1NOUJFZ0R6YWdPX1B3SHAKaFRBbklaQk9qaEVGVlhrQl9HWUFvcEpNOFFJZ0lRWUFJUkF4
RjVVTUJBQVZIemdBRXdaTVp4SUVCQUFBYUpJUEJnQUFBS0VjQVowZwpLZkVDcFNBeVFBR1F1d1VE
aW9VSXJRVVFRTE1LQTFZT0ZDZ0hBQUNzWGdfbUJSRVpMSjQ3RHdjQURCTWhCUUF3b2ZBcHppRUVQ
R2NmCm01QUJNaUZCZ0g0QkhvRktRUV9NQWY5TUY2RWpYVEFtQVNEVlBnQmx4Z0ZzQ0FIYnJnRzJG
QUFwSXdKMEN3R2xEQURxcmdFYUFBRUwKQUJJZzRSa3dJZ0ZBaVQwQ09tb1JJR0FFSUIwUmhqNEZQ
RXNSRFprNkVnOGZFaUx3QTNPWkdEQUtBQkFDVmdFU0V4NEFFSUFoQkJndwpDZ0E0QWdHUUNnQVFF
WFlBRUFLX0FBQjJFZ0lNVEJJUUhnQVFzR2NBR0VBS0FEOEJBY0FLQUFNQnZIZ0dDZ0FBa1RzTENn
QUFHaWtBCkN3QWtNU0FMQUpJUEFSQWhnQUZnVVlBWE54R0FkN1FBSkRjaEVTQXVLUUZMTFRFUk1a
QXFCZ0dWRGxLUUFZQkJZQWtBQUJrQkVCT1kKQUI4RUNBQUpFTUQ1QUNEd0UzY1lCUW9BRUNDcEFB
VkVBRDhVQWFBMEFBUVEwR3NZSVBBVElnRWg4QklHQUFVTUFBVURBR0VSQVVCeApZSUV3VXdEcUdC
SkFFVWx3RHdFZ0lXQ0JZQWNZQU9RQU1IQnhjREV1RUEzdkFDQmhnS3d6RUF3RkZKNFJRQUZ3d2ZB
UmNYRGxPZzl4CkFpOFZnRzhDRldGckFoX0FhUUwtLXlNQW16UUJUaFVDdVVFU0lhd2JBc01FRVFB
Rk5pQUJBV0Y4Qk5VbUU5QnVEVEVBSVpDUUFqRVEKQWFDTkZCRFF0QkZCQVJBaFlPNGtBS2tOQUJJ
RkFoWUFFU0FpVnhIQTVJMENGZ0FSRUVRTUFGWUlFY0JBeXhFZ0VBQXg0Q0V3NHhJZwpFQkhScHdF
V0FCRWg4bW9EUlFBQmxDMFNNQTRBQU9HVUV3QVpBQ0FRb1ZBQUFsRWFNUEFLSWFjQUVTQk5BQUNu
RENId0Q3d0lFYkExCkZ5RUFJU2RBTW9BaFVFTU9FRkJRTnhBaG9Wd0EzeWdRMEZNREVNQUpOaUdR
SVY4REFKWlZBSjVJQU80a0lDUUJlMEFoOENUNk1pQlEKVVNjTEFBMHlJaEV3bUFvQUNsSUJPbEZC
R2dHQUVaS0JNaGtCVU9vdUFBM01FSkJxTnhJWnRWSlFHQUhnRVdBZHZRR1VBQUJDVVJDUQpqRmNT
RVhBZ0VTRnhnZ0RfSUNCQndNOERBV1FsQUo4T0FLczhBVHdYRUZEaWpZSWdRWEFSOENRaE1LZ2hJ
Q01CV0NvQ0NRQUJVeGdBCnJ3QVJJWFFUQUYxSkFXVVRFU1JKS1FGNkxRQnhvQkFRM0RZalFDRjVE
Z0oyRGdFUEFBREtBQ0R3TFhRQ0Joc0FFaTBiQUJBQVV3ODUKTFJGUUd3QUFDak1RTFN4U0E3WU9B
a0lYSDV5S0FpY1ZnSWdDSEdHRUFoX0FnZ0wtLTBzWDM0Z0FBbWNPSlBBckNRQVJLZzBDQWU0agpB
d2tBRVNqMHdBSXhaeEFtaGdZUkpBN1FRdkFpRVZBU0FRRFNDZ0kwQlNEd0hiVEdCbFVGTXh3aGtC
b0FZWEJSOEE0aG9EQUFBZHNICklCQkIxd1VBMkNCQjhCUkIwRHdXUVBBTFVZQzZBZ0RnQUFEdlpR
QTREd0hhTFNBTUVXQVBBdzBBSVEwQkRRQUJIeVl3OEF3eEJ3QkIKRUtFUUVjUVBFUTROSVVNQXdR
QkJEUUJpRUZFQWdRQmhEUUFWZ1FzQU1tRHhDUWdBRUdGcEN4QUFUd3lqRHdGd01RQWhZQ0VBVVEw
QQpFT0NjU3dEZk1rRXdnVEJCZ0J3UmNBMXRFREROQWhVVURRQWhrQ0dyVmpGZ0VVQ2VBQktBWFIx
eENoRWdNVkJCVUZzUUFjc09NZ3NoCklGWW1FaUFRQUNFUUFSMFBBTGtEQkE0QUFNc0lBWE1BSWZB
RF93Y0FPQWNTQTVjVUFRb0FJaUFSQ2dBd0JER0FqZ0FnOEFSMUlVRVUKQVlBaHVac1JGbHdBSVdD
QkNDY0Jfd2NDSFFrRlNEZ2ljSEhoTXdFb0FBTVFkUWtOQUJGdzF4Y0hEUUFCLUFFQURRQUFhVE1V
TUU1MQpNckJ4TUFrQUpQQURJQUFEQ2dBUmdUVTlBV1lBQU9RaUZSWmtBZ254RXc0WWVBXzVBbXdW
Z0xjQ0ZXR3pBaF9Bc1FMLS16aEwzZUh3Ckp3TUFBSTRDVUNYeEEtQVM5VFlTRUlrQ0VBQU1BRGtn
RWRCOUNoSFFSUWNab0tjS0FnRUlFY0RzQUFDZ2VRUXdBQkZ3ZVFjUklCb0EKQURXSEJGb0FBREZj
RVJBWUFBQUdBR0p3VVNCaElGRkVBWERRSVJBQnNER2c4R0FSSVQ0Y0lNRHhQcklBZjU4Q1h3QUJU
d0JTRWZBSgpJWkRFQmdBYUdWRWg4QTRoWUhNelFXQWg4QkhNdGdPTkIySlI4QkV4RUNFZ0FoRUFC
Z0JoRUNFUU1mQVJLd2NURUpzVUFBb0FGekFWCkFBTmVBZ1lWQUNNUkFCVUFKUUFSRlFBQjBRQUJ2
d0FFRVFBREt0VUZFUUFUTUFNRUh6QVJBQWNCd0FnbEFCRVJBQk5BcHdBVlFCRUEKQUdFQkZTRVBB
QkZnYmdFVllBOEFGVUVMQUNUd0F3b0FFWENmRlFvWEFBRHh5eUFoY01KVEFBc0FJRUFoSXBVQ0RR
QXhVWUJSQ1FBQgpwbHdTTUFvQUFJb1pBd3NBQUgxY0F3c0FMbkFCQ3dBUlFQNENIMEFMQUJJd0lD
RmdIU2dBQ3dBQVJ3RUFHQUJCRUJFQVFVYUpFbUN2CnlBZ0xBQWM3QUFHZEZSQmczRjBnRVJGeURn
RkpRaDBidkhJUEJ3QU5FZkVCQ1JBQmUxY0FxQThPUThnUE9RTkNIb0EzQXg5aE13TUQKSDRBeEEt
LS13NERvUWZBd2NmQXRvZkFTSUFMQjhCSmdBWUVBVWZBVUNBQUFFZ0ZBRWZBQW9hVW1kQUN4OEJn
UjRNRUZBRkhRNGZBWApFUjFEUUJjUndQRktWTENnOFFYd0ZCR1E4UWZ3RTFnREVqRjNBZ0FmQUFI
eFNRRVVZaEd3TGdNQU5nSkM4QlVSc0VTU1FCVVJrQkVICkVsSVVFWEFSVUVpU0lCUVJUYzBBWFNN
QWNna2dZYUFKQUtKQWdRQlJzQUh3RXZFQUNBQUFibmdSUVFrQUpCREJDUUE1MFFBeENRQWgKOFFN
SUFCQVJ0UWdXVVFzQU5HRWdBUXNBUTNFZ0FhQUxBQkd4Q1FBMVVBRXdDUUFwd1pBSkFBQ2lEU1dn
QVFzQUVRQkVBd0FHQUFKTwphQURCRGdBZUFBSEpSeHpSQ1FCUkFQRUFnQUdFcHhrQkNBQVJrREdz
QVFnQUFQOGFFREgwSXdNTEhEWVBFYUFOQUZJT01hQVJVUGNCClF3OFJ3QUVMQUNBT01RWmlBZ29U
QWhZQUpTRkFGZ0FsUVNBTEFDVmhBQXNBQUVncE1RMVJvQXNBSlBBVkNRQWdGSEh6Z1E4R0FBWUEK
VlFRQXN3QWo4QlB6QUg4QUFYRHhBUENVYlFKMUZXRnJBaF9BYVFMLTlCLWZqTjQzQk94M1VCR2dF
ZkFsZEEwUUVkSEJBMVlIQWRnRQpFUjRFQnhNUURnY0NBMklCSGdBQl9Zb1NzUHdqTUJrQnNFc09B
UEtLRU9DMUh3Q3RFeGZBQ1FBUUZoNEFBSzhDQndnQUFkSVhCd2tBCkFMb1hBUUlvRHdzQUJ3QVFx
d093R0FBT2R3SUN6UkFIdWhJQWttY0FkWDJSRWZBWUlmQUhJZkFhN0JnUUhIOTlEQVlBRUFteEh3
a0cKQUJnS202d1RBU0laQU1ZeEFGY3hJUEFPZ2VFRERBQVJDdDR4QU9veE1DSHdCRFFsUVlCUjhD
WDNWUVRrUkFQU0hBQnZEd1lIQUNRcQpNUVVBS2lzaFVBMEpXZzBSRVM4VVR5NWg4SmtTQWo0VWdB
RUNBMVVWQnhRQUR3b0MtN3dmNEJKS0RnQVJCQmdSRkFBR25FY3lKaEhBCjZNUUJFaWhoSHlFd29V
QVI0b2tnUUpIN0FRQ2xKd0VMQUFNOE1RTUxBQUI5WlNGQWtmZ1FGaGNMQUFBbVJ3QUxBQUduQVFV
TEFBQV8KdUFBTEFBR2pNQXdMQUNzUk1CWUFNVUR4QVFvQUVCVFpPUk9CVEFCQmdCRVFjUXNBRUJZ
SU5oTnhlQUFCQ3dBQUJRSXdHQkZRQ3dDUgpNZkFiOFFKQU1mQWRUZ0FCaTNVRHJ3QUpDUUFoSUNI
ZGRRQ2JJQUVYQVRBZkFVQS1NaUlCOEFZcEFPOENFUERNT2hKd1Z5Z0FrbEFpCjhDR3hud0FuQUNv
QUFRc0FGQ0ZDV1NPQUFUdFpBRndEQXdrQUFRRUNBZ2tBQVRJc0J3a0FBU29DRHdrQUZRQ01xQmFC
RlJJS0RnQUEKeFFaUEh3RlFFUklBQ1FCMkFBQlNUU0ZRZ2E5N0FJSXNINkQ4U1VRUFlBTC0teklQ
NUFnMUFlUEJZU2p4QVBBa0VaSU9DemxDSkFHUQpCd0FSY01aREtBR2dDUUFTTUowQ0duQUxBQUZo
Unc4TEFBVVJZUHNQQ1EwQUlRQVIyZ0lSRURVV0FhUUxCUTBBSkFGQURRQUFHZ0lCClpBQU5EUUFS
TUE4QUFnMEFBcDJVRVJzWUFCSkFrUWN4R3pGd2h3RUNGZ0FpY1FDX0FEQVFBWEI1eFFDWVJDRndr
U1FCQUY1cUkzQ2gKMVhvUmNDaFJFTEdBUndFRkFET2g4Q0lGQURfUjhDTUZBQUpCUU1Id0l3V1FJ
Q01SSzZWLUl3RVE4UUR3SmdRQUVRSWxDd1FIQUVEeApBUEFsUVFnUlVha0FBRDRtSDVZbEFqNGZn
UGNJQVE4ZEF2LVZkZjhxWWZBclFWQjdDUU9RQ1JBbnJTNHhKLUVFNzVZU29KNW1JUUNoCmF4SUI5
RlFSSl9zdUJMY0dFaWdoQmxBcHdmQW5JVHdKRURBaHhqQUFVU0JiY2hBZ096a0FBVjRBTFFGaE1C
R2dFVEFCZE44Q0N3QUIKelFFZ1FPRi1BUVlKQUFCRXZZRURNRUh3Ri1FR01GZ0dVU0V3OFFFUUNn
QXdBVkN4SXdBU0lPZFBFZ1lLQURVaDBCRVZBRER3QWVGLQpDaUFCMFM4UUVVSGlBVUVhRVhDQkNR
QWdIUEU0RkJFZTBXNFJJTGdwQTBFVEFPaDREd1FBQUJJbGlnSURCbEFSSi00RkM2ZENFaWtnCkF4
MHFCd0FHWXlrUktyZ0NJdkFyQndBS3R5a0RkUUVMQndBVVFRVUFJQ3F4OHpZUkFiOERBTFMwSDVy
ZUFWQWJZWk1JRDl3Qi00Z24KSjRGSnpoSW9LUVVDcDRVUk1DcGRBZTRIR0RBVUFBTWtBQkZ4YTFJ
VXdOQUZNZUh3SmVZWEFhRUpFQ0loVHhBaEtVOHc4Q0F4eXhZeApBQkVRUTRNUWdVR0R3MkVRWVJC
aDhCMXhFRUVRY2FHR0FlaUNNUTN3R1FRQThRZ084QmZ4RC1BWDhSRHdGdkVROEJYeEVmQVZVUUR4
CkNnWUFFQVBtRXhOaENBQVFVV2pCTkdId0V3Z0FBcHdZUWZFREVGSEFQUU1LQUNGQklBZ0FFaHZT
ZXdHdEJRQnRSZ01MQUJGd3J6MFUKSUFzQVR5QkI4QndqRndFSVV5MEgxZ0lYTUFjQUNxUUJBZFVC
TUJId0t4RklFaEh4QVRjeDhDZ0hBQkFoR3dJYVFVVHhJU29CYnlNUQpVRUU5STBBeFNFOVBMWEh3
bk5jQk5BRTFCeEFuWDJNR0RnQVB6d0gtazBJbTBmQW5Bd0JpNGZBbklXQkItV0pqTWJBaDhCZ1Jr
d3NRCk1iZzhBUllBOEF0d1lmQVlJV0JCVUhId0dlRXdvZkFad1NDQjhCM0JBSEh3SVVjd29ERkFV
ZkFtVVNCeDhDVUZBRUVrY1FDUnl3UVQKSXNzd1lSNmhBTUh3SFFVQWNKRWdzZkFkZ1RBRkFDZEFv
UVVBRUI1TE94QWdFSjRUSXlBRkZTVTh5QVFxQlFCUEFBTFdNQWdpTVE4RQpBQWNYSURBQUV5SkVB
QklrWjNjaEtNRmJJd0ctQlI4ckNRQWFNRUVBUVE3VEVHRnIydzdnRVE5MkFTSVRnSFFCRTJGd0FS
X0FiZ0gtCk55bmhnV3pEQUtHSkFBSUFBZGdERDVFR0lFQXFvZkFvRFlrRkF4RVNJSGI0QUdVSUtF
REJKTEVSR3I1ckFSeGFFV0JfaENUd0Z3a0EKQVBrUUFPTklFZ0NJNlRCUUVlQ0NEd0RESXlQZ0Fi
OWFFdUE2QURKQUFlQVREQVhpZUJJZ2s3NFhIUWtBR1BFSUFBTHllQUJuM1FKaQpBRkFBSWZBV0lY
cWxJVUJSSFFzUUVka0RNbEVBSVdNUEFKNExZUUFSOEE1QklBeC1BaWdsRUFEZ0JCQVNxc3dnTVhB
bUFHRWg4Qm94CkVCSGlIaEFqNFNzdkxBRUZBQUVnVUNFRkFEY3g4Q3NGQUNCQVVmWUJZbkh3S2pF
UVVXZ1NNQ2toSU1fakVCQnBkVUFwSVJDQnExY3cKRVFCeEhnVUFNSDhCRGdBQTgwUTdLQ0VRRUFB
UklBY0FBTEVGQXdjQUVVRzk4d0VIQUJBUTd2bWZLa0V3RWZBc0lmQ2dJd0l1QThJRwpGd0FxQWc3
ZEJnOGJBdi1USF9BX0JBY1JJR1NtQVN3RUFBUUFKZkFmUkFRU0VBdGpCUndBTVNId0hURUNFaENW
S0VFZGNWQUJmbUlSCkhDQkRFRUNoQVJLZ0xDZ3hHX0ZBelY0Uk1lUHlBaVNURUJSS0dBUUE2U0FC
QUVBeUFOeWdCaE1BQVVNQUFYZ2RBTnVDQW1ZSUVRNGsKRVNJQWdTQUFBVF9URVpBekFDVkFFUk1B
RVF5V0VBQmxvZ0FYSkNId0RGa01BRmNBRVNBa0FCQWc2QWt4REFGd2lRVVRFTjBBQUFJUgpBU2pJ
RVNEWDNSQWd1R3NURDE4cEFPY2hBRnNBQUtkU0FSRUFBQWNrRWdCYmZnQVJBQUFZZmdCTkNRR3RT
QlVBX1NOQjhCNWhJQWtBCkFUd0FBRzRWQW5Na0FBMEFBUWNBRWhCUkFRQXJVeU1BQVdNQUVTUGpQ
QUY0QVFHLTNSQUI0WDBSSXVOb0VTRFhBQ0Z3RWNBVUVDQzEKVGpBY0FYQ1lMd0RBSWpJZ01TQkNF
UUFhSXdPZmtqSkFJWUFKQUFCU1NRTUxBQkVRa1U0QnNnTVJJTXdxQWNsa0VTRFRUZ0ZpQUFGMApK
QkVpQ1FBU0lQRUpFakNNRWdjSkFDRkFFYUVPSy1BdkJRQVlZUTBBREFVQVJ6QUI4REFGQUVBZ0Fm
QXhCUUJQTWlId3ByMENMaFZ3CnR3SUZ4Z0lCUXdFUkg5NEVBN2NDSDNDMUF2LS1iUlRaZ3lOQUs4
RVFJVFFtQUFBdU1DS0JNRGN5SVNHaHl4bHlJYkZBSWZBaHdhbkEKR09DNUNnRV9nd1hiSlJFblNC
Z0JHeFlSWUFFREFMNzNBR0s4SVNBUlJMTWdZREZPa2xBaEVHRXdJY1VhRUNISEJnQi1VVEJCWUpI
dwpZOERCUURGd0FmQVcwVUJCY0RFdFNmQUEwYkFoOEE1eE1OSFFFZkFNY1REUi1sSkFDb0VRNGNw
Yk1BZnhDME1lc0FYeEMtQUdFZkFECmtSRGhvQjVBQVpFdzBaWWVGQUFJQUpDaEVOSHdDd0hRQVVE
Umx3Rk5BZ0VPWlFEc0J3SGVLVFh4QWxCa0FnUUNBRUJBQWRCUkdRQUIKeWdJYUFCa0FBUzBBRWdE
NEFRQXREZ0N5RFJBUnB3NEFUUWdDWWdBQUFnTTFVQUZRVXdBUklFY0RNOEJCRURZQUFPZ3VKQVR4
QndBVApVRklBQWk4Z0dGQVVBQUM2WlFJOEVpRUY4V3dDQkZJQUVRRGZGaUx3QlNvQUVqQVVBQUlH
QkRFRzRXQVRBQklnRlFBQVVRQWdCdUd3Ck9oQUlPV1FURGdnQVFBMEI4QXBRNHhBTUNBQWdNQkVx
QVRBTWtWQ0FLa0h3RGFGZ3U0TXdFTEZnajVSZ0VnRlFVWkNCQlFrWFVaMlYKTWJId0ttWHJBR3Zq
UDJId3FIRUNZQmhoemo4UGJRTC0td3daMVVpTEFnWUFJZ0FCQ3l3aUFRQU9BQk1ReUFZVElBd0FO
ZkFXUVJFQQpBTUtxQVozOHNVSHdIa0VnUVNCQjhDTWhJQWN3SWZBbWlEZ1NJallUQWNHWEFUa0JJ
Z0JCQTZJRFV4MEFqUXdTUVRVQkFRWUFOVUh3Ckl4d0FEMUliQXdITGZoRXBNWElRRUZja0VqQmFC
aUVpSVFrQUFMb1RBUWtBOEFNeDhCOHhRRUZBTWZBZVVVQWhRRkh3SFdGQ3dBRDAKbTBBYlFRRGg0
R2hRVVJEQkVGR1U0LWdBb1NCUjhCaHg0SEh3RjRIQWdmQVd1Uk9TSVFCQkFFRUFJUUJSRmxFVEVh
Z0FBQVFBRWhITApFd1FpQUFIUUUxWlJBRUVBVWRNVEUwRXJBQUY0Q3dMY0V3RWlBQWpmRXlIeEF4
MEFCQWdBRVJ3OERRRWtEUUI5UHlFd1FlOGVGVEJPCnVoRW9qd2NtOENrSEFCVVFZQmNVSzdvVEFQ
YzZBdzRrS1NzeFNCY3BLRkVGQUNBcHdWY1hEcTFYRHo4Q2tCZUFQUUlBaVIwQ09RSWYKZ0RjQy01
UlEteXdCOERSOEFCQXlqd0JDTFRGQU1UdU1BbWs3QXNNSkFHUUZJLUF1dWpzakFRQUNBUElBOEN3
aEFDRUFJZkF2SWZBeQpRZkF3dVBJUWdlRW1RQ3loOENwcVBCSXBlRUFVS0hFQk1DSHdKMEVRTUNI
d0prcWNFeVhtR2hJb01RQVFVYWdQTWxFZ1Vjd1RCUFNNCkFDRUFFQ0pyaXdHTnVTQWZvZXg1UlBF
SjhCenZGd0M4eFlBWTBTRFI4QmJ4QUpNZUZCMDBBQVB1RkFCN0ZOVWVNVUJoUURId0hFRXcKZ1RC
QkpoZ1JHQ0lZRVE4dUF2RUdGUEVUOEJMeEZmQVE4UmZ3RC1FWDhBN3hHZkFaUndZQTMzNEZDUUFB
UzQwUUpDd0RFREZYTXc2NApIZzl3QVc4UmdHNEJFV0ZxQVJfQWFBSHFFTnlfN2hFaVZ5b0RlUTBD
aWdRU0lQX3RBUTBBQUpNaEVSNG1maEZBSjBBQURoTVFNZEVJCkVnRE9EaEV3dHdJUklBWUFBaVJh
RVFFM0JCRkJSd1FpQVNBVEFDRVFBU2NGQWx3QUVSdXhDQUNPT1FCM0lTRVJJUGNFRUNEbkNRSi0K
QUFBVENnWlVCeU1BQVJvREJBOEFEMjRIQmhBdzVrUWhLaEZNQUdFcEVSQWhBQ0U3QlJEZ053VVE0
RE1GRU9BdkJmQU40REh3SGtGUQpJVkJCOEIxQlFFRkFRZkFjVVVCQlFGSHdHMUV3WVJMekltRXd6
QUJBWWZBWllSME9jaEFSSUdId0dIRWdEMmdBRVNCeDhCY05BQ0FXCmdZRWJzQUFSSUlId0ZZRXdZ
VENCVVFVeEVVQkJ2NVFBQ3dBaTRCRk5Hd0FKQURWaDhCTUpBQ01CTUdXUEFEVUZFVkVMQUJkUkNR
QUoKSHdBRFp4c0NEQUFBRmdvRFB3VmhFMEV3QVlBUlFRVUEyTWdCSVFJRkJ3QUdBaDhIMW5BUEJ3
QUpFVUNrS0M4QlVBY0FFdy1JY0FJUApnZ0s1SDRBNkpRRVBlZ0wtLXp3MURSSEFmQUlpd0JHMU9n
WEJPaURnRVVZQ0ZhRHhCQkNnV0FJQ0Jwa0JXRVFCQ0FJREdBVUE3RVVBCjlRMFE4S3NDQUIyTUJE
VUFFRkN5RGlCaDhCdEFBTFU1QWwwQUFNVTVRREJ4OEFRMUh4TUJnQUFBWWc4d0VmQUxsVG9CemdJ
Qm1UcEEKRFFFUU1aSndBS0FBUVRBQklERlhXZ0QxQUJNZzVBSVNJUGtBZ1ExUlFCSGdFVUJSSGdB
QTdRSVNJQllBTUFCUjRFb0hvQTNCNE1IdwpEY0ZRSVZBSEFEZEFRVUFIQURFd1lUQUhBQUpFQVdQ
QjhBNXhFQkg4QW9VUkVISHdFRUV3RWZNQ0VCRXlCd2NQQUFBTnN3SUNBd0FMCkFEQXdZVEFIQUNG
QVFhbjBIX0FGQUE0QVhCMENpQkFBeUFJdjhDWEdBdjlPSDRERUFnTWZZY0FDQkJfQXZnTC0wVkQt
S2tId0w5M1cKRUNxSkN3SXdCd2V1VHlBZUFadFdBcVkwQW9nME1CZ0JvTVU1QU56ckFhNmlNUllC
a09rRUVKQzdEekdRQVFDSUFSQUFEd0FBalU0QQpHZ0FTb0pCT0FRS01VUklCMEdIUWZFUVJFMFFU
Q2dnUUFPTVNGeGR5VnhFWDVSSVNHZWcwQWFscE1Ca1I4TzQwQVU0MVFCc1I4QWFfClNnRDVFaWtk
RVFZQUlBUWhWcmtlQXdZQUFIV0xDd0lBUVFBeDhBTXRFQThFQUFvZlFUd0FCWElFTWZBWk1mQUZq
aWtCWTg4QlRDbFEKSUFId0JqRlNpUmNMM3dBQjdtUWg4QklBQVJFVWdtb1JGOVlBSUJvaHZtbEJH
d0VRSVZxTkVCc2JHUkVoR1I4eWNLRndXVXNoZ0FFSgpBQUJLU3hKZzZoa0E5QzBtOEJjSkFBU0hI
eEJCVmhvaUlFRmtFRkFYVVFBUndJUUlBbklRRVdFT0FJOWg4QldCNElId2ppd0NZaENBCkNRQUJL
Z0lWWVNZQ0FkOHVEeVFDLTdCZkVCQUU4UEF4QUFzZk9ERUEtLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tdVVHMDkKT0gxOQo6OiBtYXAvCjo6IG1hcC8uaW5mby5wb2QKYjY0JExTMWJXM0J2
WkN4amNtVmhkR1ZrUFNJeU1ESTBMVEF6TFRBMklERTBPakkwT2pBNUlpeHRiMlJwWm1sbFpEMGlN
akF5TkMwdwpOeTB3TmlBeE1UbzBPRG96TmlJc2MzUnZjbVZrUFNJeU1ESTBMVEF6TFRBMklERTBP
akkwT2pBNUlsMWRiSG8wQUFRQUFBQURBQUFBCk1HNXBiQT09Cjo6IG1hcC9tYXAwLm1hcApiNjQk
TFMxYlczQnZaQ3hqY21WaGRHVmtQU0l5TURJMExUQXpMVEEySURFME9qSTBPakV3SWl4dGIyUnBa
bWxsWkQwaU1qQXlOQzB3Ck15MHhNaUF4TnpveU5UbzBOQ0lzY21WMmFYTnBiMjQ5TXpBd1hWMXNl
alFBVkFBQUFFUVFBQUR3Q0h0N1ltMXdQWFZ6WlhKa1lYUmgKS0NKcE1UWWlMRE15QXdBdklqQUJB
UC0tLS0tLS0tLS0tLS0tLS0tLS0tdWhJaWtzY0dGdVgzZzlNQWdBMG5rOU1DeDBhV3hsWDJnOQpN
VFlLQUdCM1BURTJmWDA9Cjo6IHNmeC8KOjogc2Z4Ly5pbmZvLnBvZApiNjQkTFMxYlczQnZaQ3hq
Y21WaGRHVmtQU0l5TURJMExUQXpMVEEySURFME9qSTBPakE1SWl4dGIyUnBabWxsWkQwaU1qQXlO
QzB3Ck55MHdOaUF4TVRvME9Eb3pOaUlzYzNSdmNtVmtQU0l5TURJMExUQXpMVEEySURFME9qSTBP
akE1SWwxZGJIbzBBQVFBQUFBREFBQUEKTUc1cGJBPT0KOjogc2Z4L3NmeDAuc2Z4CmI2NCRMUzFi
VzNCdlpDeGpjbVZoZEdWa1BTSXlNREkwTFRBekxUQTJJREUwT2pJME9qRXdJaXh0YjJScFptbGxa
RDBpTWpBeU5DMHcKTXkweE1pQXhOem95TlRvME5DSXNjbVYyYVhOcGIyNDlNamszWFYxc2VqUUFF
QUVBQUZFSEFBRHdKM0I0ZFFBREtBQUFBd0FFRDBBUQpBZzRBQWFBQklBS2dEZ0FQRUFBTjhNb0JB
Z01FQlFZSEFRLS1rQWdKQ2dzUERBOE5EdzRQRHhBQThBQU5EeEVQRWc4VER4UVBGUThXCkR4Y1RB
UEVCRHhnUEdROGFEeHNQSEE4ZER4NFBIeFFBOFFBZ0R5RVBJZzhqRHlRUEpROG1EeWNVQVBFQUtB
OHBEeW9QS3c4c0R5MFAKTGc4dkZBRHhBREFQTVE4eUR6TVBOQTgxRHpZUE54UUEtd1U0RHprUE9n
ODdEendQUFE4X0R6OEJELS13LXdFQTYtOG5XZ0VRQmc4ZwpFQUVnQVNBQjhBQUNFQUlNRUFFZ0R5
RWdBVEFQUVBERER5Z1AtLURHRC1nS0QtOFBnQS0zRHcwQjhBa0JFQVlNTUFELU9SLS1BUURjCnYt
Z1BRQUFOUVAtLXNQQndDZ0QtLTJRZi13RUFsMUQtLS0tLUh3PT0KOjogbWFpbi5sdWEKLS1bW3Bv
ZF9mb3JtYXQ9InJhdyIsY3JlYXRlZD0iMjAyNC0wMy0wNiAxNDoyNDoxMCIsbW9kaWZpZWQ9IjIw
MjQtMDMtMTIgMTc6MjU6NDQiLHJldmlzaW9uPTM3NF1dCi0tIE1vZGVybiBNb25zdGVyCi0tIGJ5
IG9jb2pvCgpyYXJlPXszNSw0Miw1Nn0KaGFsbG93ZWVuPXs0Niw0Nyw0OCw0OSw1MH0KeG1hcz17
NTksNjAsNjF9CmVhc3Rlcj17NjIsNjMsNjR9CgpidCA9IDAKZnJlcSA9IDEwMAoKZnVuY3Rpb24g
X2luaXQoKQoJbG9jYWwgZzAgPSB7fQoJZm9yIGk9MSw2NCBkbyBhZGQoZzAsaSkgZW5kCglmb3Jl
YWNoKHJhcmUsIGZ1bmN0aW9uKGUpIGRlbChnMCwgZSkgZW5kKQoJZm9yZWFjaChoYWxsb3dlZW4s
IGZ1bmN0aW9uKGUpIGRlbChnMCwgZSkgZW5kKQoJZm9yZWFjaCh4bWFzLCBmdW5jdGlvbihlKSBk
ZWwoZzAsIGUpIGVuZCkKCWZvcmVhY2goZWFzdGVyLCBmdW5jdGlvbihlKSBkZWwoZzAsIGUpIGVu
ZCkKCQoJbW9uID0ge30KCQoJLS0gYWRkIGZyb20gcmVndWxhciBjb2xsZWN0aW9uCglmb3IgaT0x
LDExIGRvCgkJZGVsKGcwLCBhZGQobW9uLCBybmQoZzApKSkKCWVuZAoJCgktLSByYXJlCglpZiAo
cm5kKDIwKTwxKSB0aGVuCgkJbG9jYWwgaW5kZXggPSAxK3JuZCgxMSlcMQoJCW1vbltpbmRleF0g
PSBybmQocmFyZSkKCWVuZAoJCgktLSBoYWxsb3dlZW4KCWlmIChkYXRlKCk6c3ViKDYsMTApPT0i
MjAyNC0xMC0zMSIpIHRoZW4KCQlsb2NhbCBpbmRleCA9IDErcm5kKDExKVwxCgkJbW9uW2luZGV4
XSA9IGRlbChoYWxsb3dlZW4sIHJuZChoYWxsb3dlZW4pKQoJZW5kCgkKCS0tIGVhc3RlcgoJaWYg
ZGF0ZSgpOnN1YigxLDEwKT09IjIwMjQtMDMtMDYiIHRoZW4KCQlmb3IgaT0xLDIgZG8KCQkJbG9j
YWwgaW5kZXggPSAxK3JuZCgxMSlcMQoJCQltb25baW5kZXhdID0gZGVsKGVhc3Rlciwgcm5kKGVh
c3RlcikpCgkJZW5kCgllbmQKCQoJLS0geG1hcwoJaWYgKGRhdGUoKTpzdWIoNiwxMCk9PSIyMDI0
LTEwLTMxIikgdGhlbgoJCWZvciBpPTEsMiBkbwoJCQlsb2NhbCBpbmRleCA9IDErcm5kKDExKVwx
CgkJCW1vbltpbmRleF0gPSBkZWwoeG1hcywgcm5kKHhtYXMpKQoJCWVuZAoJZW5kCgkKCWZvciBp
PTEsI21vbiBkbwoJCW1vbltpXSA9IHsKCQkJaW5kZXggPSBtb25baV0sCgkJCWJsaW5rID0gcm5k
KGZyZXEpXDEKCQl9CgllbmQKCQplbmQKCgpmdW5jdGlvbiBfZHJhdygpCgljbHModGhlbWUiZGVz
a3RvcDAiKQoJCgkKCWkgPSAxCglmb3IgeT0wLDIgZG8KCQlmb3IgeD0wLCAzLSh5JTIpIGRvCgkK
CQkJbG9jYWwgc3ggPSAyMCt4ICogMTIwICsgKHklMikqNjAKCQkJbG9jYWwgc3kgPSAzMCt5Kjcw
CgkJCQoJCQlwYWwoMSx0aGVtZSJkZXNrdG9wMSIpCgkJCQoJCQkKCQkJYnQgKz0gMS8xMjAKCQkJ
aWYgKGJ0Pj1mcmVxKSB0aGVuCgkJCQlidCA9IDAKCQkJCWZvciBpPTEsI21vbiBkbwoJCQkJCW1v
bltpXS5ibGluayA9IHJuZChmcmVxKVwxCgkJCQllbmQKCQkJZW5kCgkJCXEgPSBmbHIoYnQpCgkJ
CQoJCQlpZiBtb25baV0uYmxpbmsgPT0gcSAgdGhlbgoJCQkJc3ByKG1vbltpXS5pbmRleCoyKzEs
c3gsc3kpCgkJCWVsc2UKCQkJCXNwcihtb25baV0uaW5kZXgqMiswLHN4LHN5KQoJCQllbmQKCQkJ
CgkJCWkrPTEKCQllbmQKCWVuZAplbmQKCmZ1bmN0aW9uIF91cGRhdGUoKQoJaWYgKHJuZCgxMjAp
PDEpIGJsaW5reSA9IChybmQoMTIpXDEpKjIKZW5kCgo6OiBbZW9jXQo=
:: wallpapers/hitomezashi.p64
b64$cGljb3Ryb24gY2FydHJpZGdlIC8vIHd3dy5waWNvdHJvbi5uZXQKdmVyc2lvbiAyCgo6OiAu
aW5mby5wb2QKYjY0JExTMWJXM0J2WkN4amNtVmhkR1ZrUFNJeU1ESTBMVEEwTFRNd0lERTVPakE1
T2pNeklpeHRiMlJwWm1sbFpEMGlNakF5TkMwdwpOeTB3TmlBeE1UbzBPRG96TmlJc2MzUnZjbVZr
UFNJeU1ESXpMVE0yTFRBeklESXlPak0yT2pFeklpeDNiM0pyYzNCaFkyVnpQWHQ3CmJHOWpZWFJw
YjI0OUltMWhhVzR1YkhWaElpeDNiM0pyYzNCaFkyVmZhVzVrWlhnOU1YMHNlMnh2WTJGMGFXOXVQ
U0puWm5ndk1DNW4KWm5naUxIZHZjbXR6Y0dGalpWOXBibVJsZUQweWZTeDdiRzlqWVhScGIyNDlJ
bTFoY0M4d0xtMWhjQ0lzZDI5eWEzTndZV05sWDJsdQpaR1Y0UFROOUxIdHNiMk5oZEdsdmJqMGlj
Mlo0THpBdWMyWjRJaXgzYjNKcmMzQmhZMlZmYVc1a1pYZzlOSDE5WFYxc2VqUUFCQUFBCkFBTUFB
QUF3Ym1scwo6OiBnZngvCjo6IGdmeC8uaW5mby5wb2QKYjY0JExTMWJXM0J2WkN4amNtVmhkR1Zr
UFNJeU1ESXpMVEV3TFRBeklEQTBPalV6T2pRNUlpeHRiMlJwWm1sbFpEMGlNakF5TkMwdwpOeTB3
TmlBeE1UbzBPRG96TmlJc2MzUnZjbVZrUFNJeU1ESXpMVFV6TFRBeklEQTBPalV6T2pRNUlsMWRi
SG8wQUFRQUFBQURBQUFBCk1HNXBiQT09Cjo6IGdmeC8wLmdmeApiNjQkTFMxYlczQnZaQ3hqY21W
aGRHVmtQU0l5TURJekxUVTBMVEF6SURBME9qVTBPakkzSWl4dGIyUnBabWxsWkQwaU1qQXlNeTB6
Ck5pMHdNeUF5TWpvek5qb3hNeUlzY21WMmFYTnBiMjQ5TmpkZFhXeDZOQUJ4QUFBQUJUTUFBUE1V
ZTFzd1hUMTdZbTF3UFhCNGRRQkQKSUJBUUJQRHdMR1pzWVdkelBUQXNjR0Z1WDNnSUFPOTVQVEFz
YzJOaGJHVTlNVEo5TERNQS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQotLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tblVEMHhNbjE5Cjo6IG1hcC8KOjogbWFwLy5pbmZv
LnBvZApiNjQkTFMxYlczQnZaQ3hqY21WaGRHVmtQU0l5TURJekxURXdMVEF6SURBME9qVXpPalE1
SWl4dGIyUnBabWxsWkQwaU1qQXlOQzB3Ck55MHdOaUF4TVRvME9Eb3pOaUlzYzNSdmNtVmtQU0l5
TURJekxUVXpMVEF6SURBME9qVXpPalE1SWwxZGJIbzBBQVFBQUFBREFBQUEKTUc1cGJBPT0KOjog
bWFwLzAubWFwCmI2NCRMUzFiVzNCdlpDeGpjbVZoZEdWa1BTSXlNREl6TFRVMExUQXpJREEwT2pV
ME9qSTNJaXh0YjJScFptbGxaRDBpTWpBeU15MHoKTmkwd015QXlNam96TmpveE15SXNjbVYyYVhO
cGIyNDlOamRkWFd4Nk5BQmRBQUFBV0FRQUFQQVRlMnhoZVdWeVBYdGJNRjA5ZTJKdApjRDExYzJW
eVpHRjBZU2dpYVRFMklpd3hOZ01BTHlJd0FRRC0tLS12b1NJcExIQmhibDk0UFRBSUFQSUdlVDB3
TEhOallXeGxQVEVzCmRHbHNaVjlvUFRFMkNnQndkejB4Tm4xOWZRPT0KOjogc2Z4Lwo6OiBzZngv
LmluZm8ucG9kCmI2NCRMUzFiVzNCdlpDeGpjbVZoZEdWa1BTSXlNREl6TFRFd0xUQXpJREEwT2pV
ek9qUTVJaXh0YjJScFptbGxaRDBpTWpBeU5DMHcKTnkwd05pQXhNVG8wT0Rvek5pSXNjM1J2Y21W
a1BTSXlNREl6TFRVekxUQXpJREEwT2pVek9qUTVJbDFkYkhvMEFBUUFBQUFEQUFBQQpNRzVwYkE9
PQo6OiBzZngvMC5zZngKYjY0JExTMWJXM0J2WkN4amNtVmhkR1ZrUFNJeU1ESXpMVFUwTFRBeklE
QTBPalUwT2pJM0lpeHRiMlJwWm1sbFpEMGlNakF5TXkweQpOaTB3TXlBeU1qb3lOam95TUNJc2Nt
VjJhWE5wYjI0OU5qTmRYV3g2TkFCdkFBQUE3UVlBQU45d2VIVUFBeWdBQUFNQUJQRC1BUURzCi15
ZnhBUkFHRHlBUUFTQUJJQUh3QUFJUUFnNFFBU0FQSVNBQk1BOUE4TU1QS0EtLThNWVBfQW9QLXdf
QUQtY1BEUUh3Q1FFUUJnNHcKQVA4NUgtOEJBTnpQX0E5QUFBOFFRUC0tc1BCd0N3RC0tNk1mLXdF
QWwxRC0tLS0tSHc9PQo6OiBtYWluLmx1YQotLVtbcG9kX2Zvcm1hdD0icmF3IixjcmVhdGVkPSIy
MDIzLTU0LTAzIDA0OjU0OjI3Iixtb2RpZmllZD0iMjAyMy0zNi0wMyAyMjozNjoxMyIscmV2aXNp
b249ODldXQoKbG9jYWwgc2VlZCA9IHJuZCg2NTUzNikKCmZ1bmN0aW9uIF9pbml0KCkKCWJhY2sg
PSB1c2VyZGF0YSgidTgiLDQ4MCwyNzApCmVuZAoKZnVuY3Rpb24gZ2VuZXJhdGVfYmFjaygpCgoJ
c2V0X2RyYXdfdGFyZ2V0KGJhY2spCglzcmFuZChzZWVkKQoJY2xzKHRoZW1lImRlc2t0b3AwIikK
CWNhbWVyYSgzLDMpCgljb2xvcih0aGVtZSJkZXNrdG9wMSIpCgluPXJuZCg2NTUzNilcMQoJCglm
b3IgeT0wLDY4IGRvCgkJZm9yIHg9KG48PCh5JTgpKSYxLDEyMCwyIGRvCgkJCWxpbmUoeCo0KzEs
eSo0LHgqNCszLHkqNCkKCQllbmQgCgkJaWYgKHklMTA9PTApIG49cm5kKDY1NTM2KVwxCgllbmQK
Cglmb3IgeD0wLDEyMCBkbwoJCWZvciB5PShuPj4oeCU4KSkmMSw2OCwyIGRvCgkJCWxpbmUoeCo0
LHkqNCsxLHgqNCx5KjQrMykKCQllbmQgCgkJaWYgKHglMTA9PTApIG49cm5kKDY1NTM2KVwxCgll
bmQKCmVuZAoKZnVuY3Rpb24gX2RyYXcoKQoJCgktLSByZWdlbmVyYXRlIGlmIGRlc2t0b3AgY29s
b3VycyBjaGFuZ2UKCXRoZW1lX3N0YXRlID0gcG9ke3RoZW1lImRlc2t0b3AwIix0aGVtZSJkZXNr
dG9wMSJ9CglpZiAodGhlbWVfc3RhdGUgfj0gbGFzdF90aGVtZV9zdGF0ZSkgZ2VuZXJhdGVfYmFj
aygpCglsYXN0X3RoZW1lX3N0YXRlID0gdGhlbWVfc3RhdGUKCQoJc2V0X2RyYXdfdGFyZ2V0KCkK
CWJsaXQoYmFjaywgbmlsKQplbmQKCgoKCgoKOjogW2VvY10K
:: wallpapers/patchwork.p64
b64$cGljb3Ryb24gY2FydHJpZGdlIC8vIHd3dy5waWNvdHJvbi5uZXQKdmVyc2lvbiAyCgo6OiAu
aW5mby5wb2QKYjY0JExTMWJXM0J2WkN4amNtVmhkR1ZrUFNJeU1ESTBMVEEwTFRNd0lERTVPakE1
T2pNeklpeHRiMlJwWm1sbFpEMGlNakF5TkMwdwpOeTB3TmlBeE1UbzBPRG96TmlJc2MzUnZjbVZr
UFNJeU1ESXpMVE0wTFRBMklESXlPak0wT2pVd0lpeDNiM0pyYzNCaFkyVnpQWHQ3CmJHOWpZWFJw
YjI0OUltMWhhVzR1YkhWaElpeDNiM0pyYzNCaFkyVmZhVzVrWlhnOU1YMHNlMnh2WTJGMGFXOXVQ
U0puWm5ndk1DNW4KWm5naUxIZHZjbXR6Y0dGalpWOXBibVJsZUQweWZTeDdiRzlqWVhScGIyNDlJ
bTFoY0M4d0xtMWhjQ0lzZDI5eWEzTndZV05sWDJsdQpaR1Y0UFROOUxIdHNiMk5oZEdsdmJqMGlj
Mlo0THpBdWMyWjRJaXgzYjNKcmMzQmhZMlZmYVc1a1pYZzlOSDE5WFYxc2VqUUFCQUFBCkFBTUFB
QUF3Ym1scwo6OiBnZngvCjo6IGdmeC8uaW5mby5wb2QKYjY0JExTMWJXM0J2WkN4amNtVmhkR1Zr
UFNJeU1ESXpMVEV5TFRBMklEQXhPakV5T2pNMklpeHRiMlJwWm1sbFpEMGlNakF5TkMwdwpOeTB3
TmlBeE1UbzBPRG96TmlJc2MzUnZjbVZrUFNJeU1ESXpMVEV5TFRBMklEQXhPakV5T2pNMklsMWRi
SG8wQUFRQUFBQURBQUFBCk1HNXBiQT09Cjo6IGdmeC8wLmdmeApiNjQkTFMxYlczQnZaQ3hqY21W
aGRHVmtQU0l5TURJekxURTJMVEEySURBeE9qRTJPakl3SWl4dGIyUnBabWxsWkQwaU1qQXlNeTB6
Ck5DMHdOaUF5TWpvek5EbzFNQ0lzY21WMmFYTnBiMjQ5TVRneFhWMXNlalFBY1FBQUFBVXpBQUR6
Rkh0Yk1GMDllMkp0Y0Qxd2VIVUEKUXlBUUVBVHc4Q3htYkdGbmN6MHdMSEJoYmw5NENBRHZlVDB3
TEhOallXeGxQVEV5ZlN3ekFQLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQotLS0tLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLTUxQTlNVEo5ZlE9PQo6OiBtYXAvCjo6IG1hcC8u
aW5mby5wb2QKYjY0JExTMWJXM0J2WkN4amNtVmhkR1ZrUFNJeU1ESXpMVEV5TFRBMklEQXhPakV5
T2pNMklpeHRiMlJwWm1sbFpEMGlNakF5TkMwdwpOeTB3TmlBeE1UbzBPRG96TmlJc2MzUnZjbVZr
UFNJeU1ESXpMVEV5TFRBMklEQXhPakV5T2pNMklsMWRiSG8wQUFRQUFBQURBQUFBCk1HNXBiQT09
Cjo6IG1hcC8wLm1hcApiNjQkTFMxYlczQnZaQ3hqY21WaGRHVmtQU0l5TURJekxURTJMVEEySURB
eE9qRTJPakl3SWl4dGIyUnBabWxsWkQwaU1qQXlNeTB6Ck5DMHdOaUF5TWpvek5EbzFNQ0lzY21W
MmFYTnBiMjQ5TVRneFhWMXNlalFBWFFBQUFGZ0VBQUR3RTN0c1lYbGxjajE3V3pCZFBYdGkKYlhB
OWRYTmxjbVJoZEdFb0lta3hOaUlzTVRZREFDOGlNQUVBLS0tLTc2RWlLU3h3WVc1ZmVEMHdDQUR5
Qm5rOU1DeHpZMkZzWlQweApMSFJwYkdWZmFEMHhOZ29BY0hjOU1UWjlmWDA9Cjo6IHNmeC8KOjog
c2Z4Ly5pbmZvLnBvZApiNjQkTFMxYlczQnZaQ3hqY21WaGRHVmtQU0l5TURJekxURXlMVEEySURB
eE9qRXlPak0ySWl4dGIyUnBabWxsWkQwaU1qQXlOQzB3Ck55MHdOaUF4TVRvME9Eb3pOaUlzYzNS
dmNtVmtQU0l5TURJekxURXlMVEEySURBeE9qRXlPak0ySWwxZGJIbzBBQVFBQUFBREFBQUEKTUc1
cGJBPT0KOjogc2Z4LzAuc2Z4CmI2NCRMUzFiVzNCdlpDeGpjbVZoZEdWa1BTSXlNREl6TFRFMkxU
QTJJREF4T2pFMk9qSXdJaXh0YjJScFptbGxaRDBpTWpBeU15MHoKTkMwd05pQXlNam96TkRvME9T
SXNjbVYyYVhOcGIyNDlNVGN6WFYxc2VqUUFid0FBQU8wR0FBRGZjSGgxQUFNb0FBQURBQVR3LXdF
QQo3UDhuOFFFUUJnOGdFQUVnQVNBQjhBQUNFQUlPRUFFZ0R5RWdBVEFQUVBERER5Z1AtLURHRC1n
S0QtOFBnQS0zRHcwQjhBa0JFQVlPCk1BRC1PUi0tQVFEY3otZ1BRQUFQRUVELS03RHdjQXNBLS1f
akgtOEJBSmRRLS0tLS14OD0KOjogbWFpbi5sdWEKLS1bW3BvZF9mb3JtYXQ9InJhdyIsY3JlYXRl
ZD0iMjAyMy0xNi0wNiAwMToxNjoyMCIsbW9kaWZpZWQ9IjIwMjMtMzQtMDYgMjI6MzQ6NTAiLHJl
dmlzaW9uPTIzNV1dCgpwID0gewoyMzEzMCwyMDc2NywzMjEyNSwtMTg0MDMsLTE2MzMsMjA5Mjcs
LTE5MDA5LC0yMDE5MywtMjQzNTIsCjI1NzkzLDEsLTIwMDMzLDI1NjEsLTIwMTI5LDY5NDMsLTI2
MjUsMzE0NTUsMzg1NSwyMTg0NQp9CgpmdW5jdGlvbiBkcmF3X2JhY2soKQoJYmFjayA9IHVzZXJk
YXRhKCJ1OCIsIDQ4MCwgMjcwKQoJc2V0X2RyYXdfdGFyZ2V0KGJhY2spCgljbHModGhlbWUiZGVz
a3RvcDAiKQoJZm9yIGk9MCwgMTIgZG8KCQlsb2NhbCB4ID0gLTI0MCArIGkgKiA4MCArIHJuZCg1
MCkKCQlsb2NhbCBkeCA9IDErcm5kKDEuNSkKCQkKCQljb2xvcih0aGVtZSJkZXNrdG9wMCIgKyB0
aGVtZSJkZXNrdG9wMSIqMjU2KQoJCQoJCWZpbGxwKHJuZChwKSkKCQlmb3IgeT0wLDI2OSBkbwoJ
CQlsaW5lKHgseSw0ODAseSkKCQkJeCArPSBkeAoJCWVuZAoJCQoJCWxvY2FsIHggPSAtMjQwICsg
aSAqIDgwICsgcm5kKDUwKQoJCWxvY2FsIGR4ID0gMStybmQoMS41KQoJCQoJCWZpbGxwKHJuZChw
KSkKCQlmb3IgeT0yNjksMCwtMSBkbwoJCQlsaW5lKHgseSw0ODAseSkKCQkJeCArPSBkeAoJCWVu
ZAoJCQoJZW5kCgkKZW5kCmZ1bmN0aW9uIF9pbml0KCkKCWRyYXdfYmFjaygpCgplbmQKCmZ1bmN0
aW9uIF9kcmF3KCkKCgloYXNoX3BvZCA9IHBvZHsKCQl0aGVtZSJkZXNrdG9wMCIsCgkJdGhlbWUi
ZGVza3RvcDEiLAoJCXRoZW1lImRlc2t0b3BfcGF0dGVybiIsCQkKCQl0aGVtZSJkZXNrdG9wX3Bh
dHRlcm5fc3BhY2luZyIKCX0KCQoJLS0gcmVnZW5lcmF0ZSB3aGVuIHNldHRpbmdzIGNoYW5nZQoJ
aWYgKGhhc2hfcG9kIH49IGxhc3RfaGFzaF9wb2QpIHRoZW4KCQlkcmF3X2JhY2soKQoJZW5kCgkK
CWxhc3RfaGFzaF9wb2QgPSBoYXNoX3BvZAoJCgoJYmxpdChiYWNrKQplbmQKCgoKCgoKCgoKCgoK
CgoKCgoKCgoKCgoKCgoKCjo6IFtlb2NdCg==
:: wallpapers/robot.p64
b64$cGljb3Ryb24gY2FydHJpZGdlIC8vIHd3dy5waWNvdHJvbi5uZXQKdmVyc2lvbiAyCgo6OiAu
aW5mby5wb2QKYjY0JExTMWJXM0J2WkN4amNtVmhkR1ZrUFNJeU1ESTBMVEEwTFRNd0lERTVPakE1
T2pNeklpeHRiMlJwWm1sbFpEMGlNakF5TkMwdwpOeTB3TmlBeE1UbzBPRG96TmlJc2MzUnZjbVZr
UFNJeU1ESTBMVEF6TFRBMklERXdPalV6T2pFd0lpeDNiM0pyYzNCaFkyVnpQWHQ3CmJHOWpZWFJw
YjI0OUltMWhhVzR1YkhWaElpeDNiM0pyYzNCaFkyVmZhVzVrWlhnOU1YMHNlMnh2WTJGMGFXOXVQ
U0puWm5ndk1DNW4KWm5naUxIZHZjbXR6Y0dGalpWOXBibVJsZUQweWZTeDdiRzlqWVhScGIyNDlJ
bTFoY0M5dFlYQXdMbTFoY0NJc2QyOXlhM053WVdObApYMmx1WkdWNFBUTjlMSHRzYjJOaGRHbHZi
ajBpYzJaNEwzTm1lREF1YzJaNElpeDNiM0pyYzNCaFkyVmZhVzVrWlhnOU5IMTlYVjFzCmVqUUFC
QUFBQUFNQUFBQXdibWxzCjo6IGdmeC8KOjogZ2Z4Ly5pbmZvLnBvZApiNjQkTFMxYlczQnZaQ3hq
Y21WaGRHVmtQU0l5TURJMExUQXpMVEEySURFd09qTTVPakk1SWl4dGIyUnBabWxsWkQwaU1qQXlO
QzB3Ck55MHdOaUF4TVRvME9Eb3pOaUlzYzNSdmNtVmtQU0l5TURJMExUQXpMVEEySURFd09qTTVP
akk1SWwxZGJIbzBBQVFBQUFBREFBQUEKTUc1cGJBPT0KOjogZ2Z4LzAuZ2Z4CmI2NCRMUzFiVzNC
dlpDeGpjbVZoZEdWa1BTSXlNREkwTFRBekxUQTJJREV3T2pNNU9qSTVJaXh0YjJScFptbGxaRDBp
TWpBeU5DMHcKTXkwd05pQXhNRG8xTXpveE1DSXNjbVYyYVhOcGIyNDlNVGxkWFd4Nk5BQkVGZ0FB
WTA0QUFQTVVlMXN3WFQxN1ltMXdQWEI0ZFFCRApJQkFRQlBEd0xHWnNZV2R6UFRBc2NHRnVYM2dJ
QU9aNVBUQXNjMk5oYkdVOU1USjlMRE1BenlqZ0FRQUFEZ0VBQUFUdy13RUFIUE1nCjFZZnctOFlu
WUNmdy04SW44UC1KVi1ELXlEZnctOHdYOFAtT0YtRC15SGZ3LThjbjhQLU5GLUQtendmdy04OFlB
QVFNQUFBSUFCUFEKQkFBVHppZ0FBQ0FBRjgwTUFBZ2tBQUVFQUJZWEJBQWp6d2NNQVBFUk4tRC16
UWZ3LTcxbm9CZnctN3NuUUJlUUItRC11aWR3QjVBWAo4UF80RjVBUUFFRzNGN0FIQ0FEQkI3QVhn
QmZ3LTdZWHdDZGdFQUF3OEFBSENRRHdHTFluNEJkQUYtRC10UmZ3QWdkQUItRC1lMmNRCk4tQWVC
LUFERnlBWDhQOTVKeUFIQURjUUJ4SUE4Q2tFUi1ELWVSZEFCeEFITUFmd0hoZnctNUVId0Nmd0hp
ZnctNDRYd0FjQUItQWYKQi1ELWpTZndBQmZ3SFJmdy00d1hBQWZ3QVFmd0hSWUFNZ2Z3QkFvQWtJ
d1g4QVFYTUVmd0V3d0E4QkFIOEFZSEVDY2dGLUFRTi1ELQppd2Z3QmpkUUYtQUlOeEFYOFBfT0It
QUZ3Z0FnQnhjY0FFQ1BGLUFFMkFDeUJ3ZnctM2RuOEFrSDhBOE5BRUJ5VnlCSENRQVFFQ29BCjhC
N3ctMjFIZ0VlQVIyQVg4QkFYOEFVWDhQOXBWOEJYY0FjZ1J5QUg4QklIOEFVSDhQOWxWNkRYWUNk
QUp3QVNBQ0RnSjJzQThDUmgKUjZEM0JHQUhjQ2Z3RWdmUUZ3QTM4UDlkVjVEM0NnQVhFQmRnRi1B
VUI5QUhJQWZ3LTFwWGtQY1BFRGR3Qi1BVko3QVFBS0JIb1BjVQo4QWNuOEFzbllRSHdDVlZYa1Bj
WjhBY0hBQmZ3REVkUUItRC1VRmVROXg3d0JNMEFJQThIRVFDQVRFZUE5eVRnVndBX0FSRU9kQUdB
ClIxZHc5eW5RRnlBTkFCRU82QUNpUTFkdzl5N1FCMEFITUJRQjhVSXlCX0JIY0pjZzl5V3dONkFI
RUNmdy0xQW5nRmRnMXpEM0lmQUQKRjVBM0FBZnctMDhYQUFjd1YyRDNCQkQzSGZBWkotRC1UQmNR
VjJEM0NSRDNHUEFnSi1ELVNSY3dCMEQzRHhEM0UzQUg4QndxQWZBWAoteWduUUFjQTl4TVE5dzNR
Qi1BbWgxQ0g4UDhqWjFCSEVQY09FUGNJOEFNWDhDQlhVSWVpQUVJZlZ6QVhHQUFocHdCM0FmQWNI
VGZ3CkNCZncteHRYWUNkUVJ5RDNEd0NuQUJmd0NWZndHeWZ3Q2hmdy14ZFhZR2RnUnhEM0VBQ0hB
QklDOEFNS0ItQWZGLUFKTi1ELUUxZGcKWnlBWFVGY2NBQ0EzVUJ3QThBc0pGLUFmWi1BQk4tRC1F
VmRnbHpBWFlBY0FKeEQzRVFBSGdCNEFvQWdYOENRWGNLZnctdy13QUxRWApZQmNnQnhESEFOY3dC
eUFBTVFmd0k0UUQ5d0VVVjFEM0EwQUhjQWNnRnhESEFIZVFJUUFSSVNFQVl4RlhVUGNIUUVJQU5C
QW40Q0VBCjRRY1g4QjhuVURmdy13NVhVTGNRWkFCQk1BY1FCOUlBRkFFbEFQQUtBbGZ3SGlkQU4t
RC1ERmRROXdFUTF5QVhZSGNBRnlBM0lOMEMKRkFJbUFLQUJGLUFmUnlCSDhQOEtiQURvQVBjQUFB
ZGdOeUFIRUJlUUJ4QW5BQUJBQVFBbkFQQUNEUmRRcHhEbkVNY1FGMUFYUUJjQQpKNUEzQWdnbkFQ
QUZHamNRUi1ELUVCY1ExekQzQUFDSFFCZFFGMUNjQUNBSGdIZ0E4QlFEQndBWGNBY0FCOEJIOEJw
bjhQOFRGeEQzCkFCRDNBUkEzY0JkZ0J4QTNBQWNBRnlFQUVCQXFBQ0VRQnlvQVFBZnctMGdqQW5B
Q0FCZUFGMkFYQUFNUUlCb0FWUmZ3QXhjQUl3Q3cKU3ZjQ0VQY0VrQWRnRnhBdUFVQUhJQWRnY0FB
bUJRY2pBUG9HVGVjUXR3QlhrQmRRRnpBWEVBY0FGeUFIWUFjUUl3RFFVTGNRdHdBSApFQmRBWjFB
WFVFZ0FJQ2RnYVFBRkl3Q1FKLUQtVW9jQWR5QUhxUUNRTUhkUUYzQVhZQ2N3YVFBU0JpTUFvQmZR
Si1ELVUxY0FOMkFqCkFCQUhJd0JVa0JkZ1p4QWhBS0FRQi1BQUotRC1WQ2NRTVFGd0p5QjNVQmV3
RjdRQUlnQVhJZ0FBVEFBUUFpSUFFUWNpQUlFWElJZEEKRjlBSGNMRUFKUEFHYUFIeUNBUUg4UDlV
RndBSGdEY2dkMEEzd0Jkd0IwQW44QUUzWEFGQXNEY3dGMEVBZ0FBSGtDY1FkekJYUHdBdwpVQ2ZR
UXdBQXp3QkJCNkFYRUM4RkFTSUF3QmNnWnpCM3dBZUFGMkFub0ljQUVBZGNCUUNYQXpFQUJ5QmpC
QU1tQU5SM0VJZkFGNEFICmdDZHdGeEFuSmdBeElCY3dZZ0lnVlFlY0FjRVFKMEMzMEFlQUI2QW5V
QWNpQVFRbUFFQUg4UDltendBQjJ3R29JR2ZRQjRBWHNDY2cKRnlRQUFHb0FRRFZIOEJ6VUFBRXJB
SUFnVjlBSGtBZlFKM1FFQVNjQUVCZDZBd0FDQkJBMTNnVWtIQWNwQUFETUFRQXJBRkR3QUNjdwpK
eUlBQWFJRFdQODJKMEFISmdBaUJ5QW1BQ0FDTjJ3QnRRQUhJRGNBWi1ELUxpZGdKZ0FtRjNBbUFC
QUVuUUFRZDdZQ0FFc0VOQ3NuCmdDWUFFQ0QzQWhGSEpBQWdBUmR3QUxHQUJ3Q0g4SFVuOEtBWGtK
WUFBT0lBVWljZ0owQlhsQUFSTjFNQlVLY0FoLUIwNHdGaG5TZVEKRi1BZDJnTHdBQkFYQUVkQWQ5
QUhjRGZnQnhBWE1DVUE4Z0IzOEhNbklCY1FKLUNYQjhBMzhCcmVBbkFYRVBjQllCZFFNZ0F3SjhB
SAprd0x3QndDbkFBZndFSmZ3VEVjQUJ6QTM4QndYOEdKM0FBZThCaEFhUWdMQkp4Q25FRWZnQjJB
WE1DZWdPd0VSTUlRQkVFQVhBZkVBCkNYZHdKLUJFWi1BcEYtQmlGMUFuc0FNQmRnSzFFTGNnTl9B
SFlBZGdGNUEwQUNFUUZ6UUFJQUozSlFUUVAwZndMU2Z3WVNmd0NpZncKR2JVQm9CY1FaeEJIRUNk
UUYzQTNBRUFuZ0FjZ05RQUJJQVhRa0lmQWx4QUg4RDBuWUVmd0pHb0FzUEFNQndBbjhCY0hBQWRR
WkFKaApSeEJISUJlZ3BBWWdFR2NXQWlFd0Iwa0I4QUlIQUpmQTl3YndFVGZ3RTBkd0YtQW9CenNB
UUJFWDhCWnRBd0RZQTVFbkVKZndBQWVBCmw1QjBBLUFNTUpmQTl4RHdEaWNRRjhCSHNFZVFKLUFv
Ri1CaEYtQVRKLUFVQVFTUUZ4QW5JQ2NRaC1BQmlRSHhBd2Vud1BjWjhBMFgKUUFlQVJ5RFhvRGZ3
S1N3QVVCWUg4QlFYNmdBQXB3R1FNQmNBaDhBWEVFY0FZUUx4Q2dHbm9QY2g4QXdYVUFkZ0otQk5C
LUJpQi1BWApCLUFWQndBNUJFQVFGekNYalFUMkJSQ0hnSWV3OXlud0RRZGdGeUEzOEE4SDhDNFhL
d0FCNUFMeENtQkg4QU4zRUNjUWg3RDNNUEFOCkYzQkg4QTFYOEMwWDhHTl9BREFCZDdCUkFNRVhN
QmZ3Qnhjd1J4Q1hvUGRIQVBFRkZRY0FSLUF5Qi1CbEItQU1KMUFYOEFIM0FoQngKQTZCUUJ5QVg4
QWVuZ1BjNFpRQndFeWZ3Tnhmd1k1WUJnQUIzOEFIM0NDQW5jUVdROEFLWE1QY3o4Q01YckFnQ0lR
RHdId3dIOEF2MwpCeUMzOEFqM052QWxKMkFYOEJFbjhEY0g4R1FIOEE0SDhCUFhNTWNnRi1BQUox
QW5VUGNhOEM5a0JXRkg4QTVIOERpcEFQQUVEaWZ3CkhSY2c5d0NBRjFCM0lEY2c5eER3T3lBQWdC
RVg4QnUzOEFRWFJRQVFFU1FKOEFZZ0YyQ1hzRWN3bHhBSElQY0E4RWNYOEJVMzhCcnoKQWxBQ0Yt
QmtGeVFBTUJ3WEVNMEFrQU13bHdCSEFBZndWZTBFTUFBbmdNWUNVTUFuOEFBSEp3QVFFbTBERVNE
SENUSDNDUUFXQmxEdwpWQmZ3Q1BvQW9DSW44QUJYZ0Nmd0hGY2VBVUFTRi1BYlVRRHdDUU1YY1Bj
REVCY0FKeEFIOEZJbjhBbEg4Q0VuOEFkWElNNEpVakFYCjhDOG5WQUN3RUJmd0JDZlFGd0JYRUVj
RkJGSHdVUmZ3QUF3RFFBNUg4QjdwQ0NFdUYxd0pJUEFiSGdCUkJoZkFGOUFzQkREd1VnZXAKQ1pF
b0YtQkNCMEJuOENtZkFVRjM4QklIdXdrd3NCZndkd1R3QkFBSDhFeG44QVEzOENDSDhEUm5BRWNB
RjBCbUJRQXRBQkFua1FZZwo4QkxDQlJBSERnRVJBV2NGWVBCR1otQUVaNm9Bb1RrM1FDY2dKNkFu
OENpdENsQVJOX0JYTVBNS0lRTUhLQUNnUWtmQTEtQWxKLUE0Ck40a0I4QUVtQi1BZEYwQW44QWtu
MENlQUYzQVhSQUR3QUQwM3dFZndNUmZ3T1Jmd0V4ZndKWXNCSVVBWHFBanhBZEFYb0Vjd0YtQUUK
aC1BNU43Qkg4RFFrQUJBVm9RZ2g4QnM3QlZEd0dRZWdGNjRBZ1BBRWwtQTFSNEJuTUFJUk9zSUNZ
Q1VIOEJvWFFJb0I4QVVZRjVBbgpBR2Z3Qktmd01qY1F0LUE4Ri1BNko3NENFQ1Z6QkNBZ0p5SUFR
QWVnSnhCLUFmQUlBMWNRTi1BdmwtQkdGLUEySndBWDhCZ0g4Q1luCjhCaE5CSEVYOEJjSGtFY0Fz
UUd3UnpBbjhJOEg4RGtuOEJXM0NwRW1OLUFWTjJBbjhCVWhBTUFBTi1BQlIwQW44STRYOEdLRUJx
TW4KQi1Bb0otQU1KNURIR0FCQUItQnBCeFlBOFFNbUp3QVh3RWRnSjdCWFFBZndBVWNRRnhBZEFC
Rm9KZ0VSSkE0R0lMQVhqd1ZnMEZjQQo5d3NBVEFEd0FJOFg4R2xIOENJSDhDSW5VQWV3Ql9VSDhB
endBRWNBOXdVQVJ3QW5BQ2Z3a0Fmd2JTZndJQWZ3SUNkd0Y2QkZDRkFYCjhBREg0TGNBQVIwQUlH
OFhMQXpBSHhlZ0oyQW5jQ2Z3QXJmZ3l3QkJrQmZ3Y0ZrTWd4NFgwRGN3Qi1BUEZ3QndCLUJ4Ri1B
WlJ4b0EKTVFJWElMWUZNUUJYRURBQUVISlhBUUNKQUJBRTJBSUFxQVRBaC1DUkItQnpCLUFYRi1B
ai1nSUFTUXNRWjM4RlFaSUg4SE11QkNJZwpWX29NSUJNMzBneFFsQWZ3ZEFjWEFEQWJWekJWQWtR
UUotRFVFd0IwR2hmd0RUZncxZzhBUkJjMzhQZ01BRk1WSi1ENkZ3d0FvUk1uCjhQc1g4RGtIOENz
UEFHRUtOeUFuOFB3a0FoRXFKd0prQ1JjUVItRDlFUUFSRnZvS1V2OEdCLUE2TWdBUUYxZ0xJZjhH
SUFBZ0t3Y3gKQUNFS0J5QUFvamduOEN3SDhCSTM4QXNRQUNBM0Z4a0ZJQTFIYkFUd0FmOEZGLUF0
TjBBWDhEQUg4QXdYOEEwMkFsRC1CQmZ3SjBFQwpBUHdCSURFWE53QVFEZ0lGVWY4REItQWhFZ0pR
UUNmd05RY1lBTkVNSi1ELUNRZndIeWNnSi1CQ0tnQlJEQWZ3LXd0X0FWTktKM0EzCjBCRUFFQmNa
QnhCTlZncVFGOEFIOEFzWDhQOE1CQVJnOEU4WFFCY2dYd1lnQ2hmT0NnQXFBV0JRQjBBSGNKZExB
Q0QtRHhFSElQQlIKZkFBWEhROEFBSkVCVVA4UEYtQVpMUUFBV0FVQkdnQmlGLUJPRi1Ba0p3QVJH
UTBBRXlVTkFCQUhKd0FoSkJjMEFHQVdKLUJQRi1BOApDeUFSWi13TkVGRzlBUEFKOFA4YkotQU5C
LUJSWi1BVlZ3QVg4UDhjQi1BTEotQlEyZ01RRVZFRElmOGc3Z0FnV3hjekFDSC1FcHNPClVBc0g4
RndISGdhUy14SVhBRGNBeC1BTUlRQkFCLUQtRVRrQVVCZ1g4RnNIX0FGZy13NG44Q0FYNmdFUk5H
UUJVZjhRRi1BaHdBRVIKTmtZQU1QOFJCeEFBSUJjSEFnWUVFQUFBeFFNTkVBQWhOaGM3QVJRUUVB
QkZNemZ3RENBQVlBbUhJRGZ3TWdFT1VmRGdWLUFaWkFBaApCeGN6QV9FMkItQUtSLURnRnpBWElH
ZndEa0FCUUFRM2dDZFFBSkFHUi1Ea0IxQkhRQmNBQVFIcEFoSEFNQUJoQTBjUUItRGxrZ3dRCkFm
NE1JQ0lITndhQVJnZndBU2Z3NDJkbUREQVg0QmNIQ2lId0pDb0dFVWR2REJEaUdnSXlCQWZRUkFk
aEpoZlFGLUJIREFrdzNWZUEKaUE4d3dBZEFZQU1RSlJnQ1lFZ1g0QWZ3M0hBQ1lCSVhrRGN3UjhB
RXNBQVg4RWtYQUVkd0ItRGJyUVJnZ0Jkd0ItQW5SZzFBOEVzbgpJRVVQd05rWDhCazNVQWZ3TFVm
d0Fnb0dRSEFYOE5nV0FoQVFjQUFRTEpRTG9QQlNOd0JIOE5nWDhCNnFCaEV0TEFZUVV4SU9NUWZ3
CjJMSUdFaTNpRHlCREJ5MENFUzdnRFFBTkFCSmpDZ0FnUWhjS0FGRUdOLUQtUUNZSEVBSzBFRkgt
UUFmd1pvY0E4QVAtUlJmd1ppZmcKRi1ELVJRZndad2NBQl9BVUFHSW44R1lINENjVUFDRVg0UElL
Y1VVSDhFeUg4QUFyQUlKSEYtQktGMkEzc0VJQVVVa0g4RWtYb1FvUQpBazBOa0Jmd1NRZkF0LUQt
Vy1zQWN2RC1jeGZ3U2djSEFBQU9BSEFIOEVnMzhQOXlsZ1lBamhGd2N5ZndPd2NRdHhJQUVRRG9B
X0wtCmZ4Y3dCLUEzSi1ELWZpZndPd2NBRVR3WEFOTHdQUmZ3LTRBSDhENEg4UF9BRGdBaWZ4Y09B
RUlIOEQ4SERnQUFGUUFGRGdCU1B4ZncKLTMwSEFGSl9CLUJBQnh3QUFBNEFFQmNqQUI5ZEZ4TU5E
eFlUQlE4QkFKWVFPWDRUOEFobjhQLUtoLUQteUtmdy04VVhFQWNRUi1BTwpOLUQtbzFFTEVDY3RD
aUQtb20wQ1lTZndESGZ3LTd3TlFDZndDeGRRQkJDZkl3Q1NOLUFLRjBCSDhQX2VEUUN3Q1JkZ1It
RC1uQmNRCkZ6RHdFRkNBUi1ELW0tNExNRGRBTnd3SU1QRC1taWdBRUVjZkNFSEFGOEEzaHdFa0NC
Y1RBQ0N3RjV3VEVIdUdCWUFIQnlBWE1EZFEKRnpBT0FSVUFJbmNBbkFJZ1FEZURENkdRRjlCSDhQ
OTd0LUFBUEFzUVlOb0xJUWVBRlFCeWZMZndBQWN3SnhNQVFuQVgwRmNUQUtFbgpJQmRBZHdBWEVB
ZGdFd0JBZnBmd0F1NE1BSTBKd0FkZ0I5Qm44UF9BWi1BRE4tSVNBeE1BRUZkSUFnQ19DR0UzSUNj
d3AyQmRBQkItCjN3cWdBemN3RnhDbkFCZEFOMjhQTVlBSGNGa1FFQ2RNRURBSFFDY1VBREdCTjBC
REVBREFDUkduM1F2d0E2ZFFGLUQtZ3dkd0JfQ24KSUljd0J3Qm5jRnNBZ1BfRUZ5Qkh3Q2RRWWdC
Z0Z6QW5JQmVRbndpdy00WUhVQWRRVndBWFVEZDBDelNnRnpDQ0R6RC1oeGNvQURFdwpKMUJJRGdB
dERVQXdGMkEzMUE4d2lRY3dRd3lCQjBBSFlDY3dOekRWREhBd0IyQjM4UF9LdkF3QmRROGdVRGQ5
RUJCUUdBRHdBOWZ3Ci00VTNJQ2NRQnpBWFVDZEFSNUFYTUJVRmdHZnctNG9IQURjd1JBQ0JaM0FY
UUFkUUo0Q1NBREtJRnlCYUFHQjNRQ2RRQjFBLURYQUgKOFBfSUJ5QVhGZ0FnUU5kdUFTR3dGNklB
UWdjUUYxQVVBREIzUUVjWUVyRHctNGMzWUtkUXQ0Qm5NQlVOQUJvS1lQX0hCNkNYWUU0TgpFU0RB
QVFJVkFMQjlaeUFIa0Rmd0FGZGdoMElSQVVnUkFSa0FnWGhYUUhkUWwtQUlWUkVBLXd5QUVBY2dO
LUQtZEVkRUVSRkFLQUloCjhBY3RDUkVRVHcwQW5nSWdjU2RDQU1EUWgyQUg4QVlYWUVjZ0p3QU1C
aUQtY0pFRlVBY2dWMEJYQ2dJZzhBVmFBUUNXRXVHMzhQOXMKQnhCM01EZFFKekFYY05RTDhBTVhF
Q2R3RnlBSFVDZnctMm8zTUJmUWw0RG5DSENBRnhBM1VCY2dKQUR4QS05cHQ3QUhBRGNnQjVBbgp3
Q2VRRndDM01FSVdVV2hYUUZkZ1NoS2dFQmVnTjJBM3NBY1FaOVFSQUdFRVlHc1hRQmN3aHhvQVFC
QUgwSWNWRVNCd0I0MFFVZkQtCmFnZEE4UTRnTUFmSkNsQVFGLUFTSjBVU0VOQzRDVUQtYVJjdzd4
SUI0dzV3RUFjZ0otQU5OLWNUQWY0Q2tQRC1hSGRBTnpCWEVLMFUKRUVCYkRTRUJCeFlBQVBFQkVT
Zm9BREEzOEF4RUVDRUNSeFlBY1BjRUlBZVE5dzU4RVFDUEZTQm9aejRBQUlnSzhBRDNCTkFIRUxl
QQpCLUQtYm1jQXB6RFVDbUJRZDlBSEFPZnZGdkVGY0FkUWQxQUg4QUUzRURjUVo5QUhBQ2RRWjFB
WEFDUHdCQllBVUlld041Qkg1UUFnCmNEZllCakFBVnhDbEQyRVhvQ2ZBTnpBcUFEQVFKOUN6QUpF
Z0p6QkhVQmVnQl9ENEFIQndGeUNYTUJmZ3dRRlJvQWNBSjZCX0NEQnkKRjZBM0J4QUF6aFJ4Z0Zj
QU4xQW5FQTBHQUNnUkFGd0FFQWtNRVNCblVPUUdVUDkySjJBM2FBWVJDaFFBQUdZTEFDd0FrSGlY
OEFNSAo4QWRIY0g0RUVIY1NBSEdWRi1BRkp5QUhFUUNTcC1ELWxpZndBaWRBRHdBQTZnU0UtNWtI
QUNmUUoyQVNBQkVYckFRaEo2RDJFeUVRCkIwNE5zUF9aRjBBM1lCZWdCM0JIWVFNQU5BQmdnSWV3
TjFDWERBQmdsamZBQnhBWEVRSUFIQUNnRUZmdy01WVhBQmV3Qng4QzhBRUEKUnpCWDhQX2RKeEFu
Z0JjZ0YyQW5vUUxBcHpjZ0YzQUhRR2NBQnlCbkxBbFEtMzZYQUhkZ0QwRUF0LUFUOXdKQWZnY1Fa
NTRRSUdCWAo5Qk1oOEJKMEE1QjlKeEJYQUdkZ1J5RHFEQkFSRGdNUVp6NEhBS1VLVWlCbllEZEE0
Z3d4RHhjUWl3RVFjd3NUTVNkQVZ4a0FBRUFYCklBOEh2d0lBM2hVUmFaSVRZMEJIZ0RjZ1YwSU9V
QXgzVUNkUTRSY0NIUUJSTnlCWGdNY2JBQUN2Q2pGUWQyQlpBeEJsR3dBVHh4a0EKc1Nmd0NRY1FC
MEFYc0FjUXVRRXlaUWNnSFFBQlh4TWc4QWhSQmdHREFDQlFWMU1YRUdVVEJUREhnTWZoQWdBZkFE
QUhVQWVaQXhFdwpFUUdoWnpjUVZ6QW5jQ2RnUnpnWkVBajRFeUVITUlVT0FHd0FBSE1VRU9COEFQ
RUZCd0EzZ0JkUUY2QW5NRGNnRndDSElHZmdCekQtCkVaRHctMDluRUJjQTV3QU9BOEIzSUZjdzl4
T1FGeEIzVUVlZ0ZaRVJNSGNBZHhCM1FJZUZGakMzY1BlMENQQUNaeENYRUljd1J6RDMKQVFDSE1E
ZndEcGVYQ0pfZ0YwQW4wTmR3OXdES0I1Z2ZQS3dJREY4d0xqVjlMUGNiSGc4ekFQLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLQotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LVVGQTlNVEo5ZlE9PQo6OiBtYXAvCjo6IG1hcC8uaW5mby5wb2QKYjY0JExTMWJXM0J2WkN4amNt
VmhkR1ZrUFNJeU1ESTBMVEF6TFRBMklERXdPak01T2pJNUlpeHRiMlJwWm1sbFpEMGlNakF5TkMw
dwpOeTB3TmlBeE1UbzBPRG96TmlJc2MzUnZjbVZrUFNJeU1ESTBMVEF6TFRBMklERXdPak01T2pJ
NUlsMWRiSG8wQUFRQUFBQURBQUFBCk1HNXBiQT09Cjo6IG1hcC9tYXAwLm1hcApiNjQkTFMxYlcz
QnZaQ3hqY21WaGRHVmtQU0l5TURJMExUQXpMVEEySURFd09qTTVPakk1SWl4dGIyUnBabWxsWkQw
aU1qQXlOQzB3Ck15MHdOaUF4TURvMU16b3hNQ0lzY21WMmFYTnBiMjQ5TVRaZFhXeDZOQUJkQUFB
QVdBUUFBUEFUZTJ4aGVXVnlQWHRiTUYwOWUySnQKY0QxMWMyVnlaR0YwWVNnaWFURTJJaXd4TmdN
QUx5SXdBUUQtLS0tdm9TSXBMSEJoYmw5NFBUQUlBUElHZVQwd0xITmpZV3hsUFRFcwpkR2xzWlY5
b1BURTJDZ0J3ZHoweE5uMTlmUT09Cjo6IHNmeC8KOjogc2Z4Ly5pbmZvLnBvZApiNjQkTFMxYlcz
QnZaQ3hqY21WaGRHVmtQU0l5TURJMExUQXpMVEEySURFd09qTTVPakk1SWl4dGIyUnBabWxsWkQw
aU1qQXlOQzB3Ck55MHdOaUF4TVRvME9Eb3pOaUlzYzNSdmNtVmtQU0l5TURJMExUQXpMVEEySURF
d09qTTVPakk1SWwxZGJIbzBBQVFBQUFBREFBQUEKTUc1cGJBPT0KOjogc2Z4L3NmeDAuc2Z4CmI2
NCRMUzFiVzNCdlpDeGpjbVZoZEdWa1BTSXlNREkwTFRBekxUQTJJREV3T2pNNU9qSTVJaXh0YjJS
cFptbGxaRDBpTWpBeU5DMHcKTXkwd05pQXhNRG8xTXpveE1DSXNjbVYyYVhOcGIyNDlNVFJkWFd4
Nk5BQVFBUUFBVVFjQUFQQW5jSGgxQUFNb0FBQURBQVFQUUJBQwpEZ0FCb0FFZ0FxQU9BQThRQUEz
d3lnRUNBd1FGQmdjQkQtX1FDQWtLQ3c4TUR3MFBEZzhQRUFEd0FBMFBFUThTRHhNUEZBOFZEeFlQ
CkZ4TUE4UUVQR0E4WkR4b1BHdzhjRHgwUEhnOGZGQUR4QUNBUElROGlEeU1QSkE4bER5WVBKeFFB
OFFBb0R5a1BLZzhyRHl3UExROHUKRHk4VUFQRUFNQTh4RHpJUE13ODBEelVQTmc4M0ZBRC1CVGdQ
T1E4NkR6c1BQQTg5RHo0UFB3RVAtLUQtQVFEci15ZGFBUkFHRHlBUQpBU0FCSUFId0FBSVFBZ3dR
QVNBUElTQUJNQTlBOE1NUEtBLS04TVlQX0FvUC13X0FELWNQRFFId0NRRVFCZ3d3QVA4NUgtOEJB
TnktCl9BOUFBQTFBLS1fdzhIQUtBUC0tWkItLUFRQ1hVUC0tLS04Zgo6OiBtYWluLmx1YQotLVtb
cG9kX2Zvcm1hdD0icmF3IixjcmVhdGVkPSIyMDI0LTAzLTA2IDEwOjM5OjI5Iixtb2RpZmllZD0i
MjAyNC0wMy0wNiAxMDo1MzoxMCIscmV2aXNpb249MjJdXQpmdW5jdGlvbiBfZHJhdygpCglwYWwo
KQoJY2xzKHRoZW1lImRlc2t0b3AwIikKCXBhbCgwLHRoZW1lImRlc2t0b3AwIikKCXBhbCg3LHRo
ZW1lImRlc2t0b3AxIikKCXNwcigyKQplbmQKOjogW2VvY10K
:: wallpapers/pattern.p64
b64$cGljb3Ryb24gY2FydHJpZGdlIC8vIHd3dy5waWNvdHJvbi5uZXQKdmVyc2lvbiAyCgo6OiAu
aW5mby5wb2QKYjY0JExTMWJXM0J2WkN4amNtVmhkR1ZrUFNJeU1ESXpMVEV3TFRFM0lEQTJPakl3
T2pBd0lpeHRiMlJwWm1sbFpEMGlNakF5TkMwdwpOeTB3TmlBeE1UbzBPRG96TmlJc2MzUnZjbVZr
UFNJeU1ESXpMVFF6TFRBeklESXlPalF6T2pBd0lpeDNiM0pyYzNCaFkyVnpQWHQ3CmJHOWpZWFJw
YjI0OUltMWhhVzR1YkhWaElpeDNiM0pyYzNCaFkyVmZhVzVrWlhnOU1YMTlYVjFzZWpRQUJBQUFB
QU1BQUFBd2JtbHMKOjogZ2Z4Lwo6OiBnZngvLmluZm8ucG9kCmI2NCRMUzFiVzNCdlpDeGpjbVZo
ZEdWa1BTSXlNREl6TFRFd0xURTNJREEyT2pJd09qQXdJaXh0YjJScFptbGxaRDBpTWpBeU5DMHcK
Tnkwd05pQXhNVG8wT0Rvek5pSXNjM1J2Y21Wa1BTSXlNREl6TFRJd0xURTNJREEyT2pJd09qQXdJ
bDFkYkhvMEFBUUFBQUFEQUFBQQpNRzVwYkE9PQo6OiBnZngvMC5nZngKYjY0JExTMWJXM0J2WkN4
amNtVmhkR1ZrUFNJeU1ESXpMVFUzTFRBeklESXpPalUzT2pNeklpeHRiMlJwWm1sbFpEMGlNakF5
TXkwMQpOeTB3TXlBeU16bzFOem96TXlJc2NtVjJhWE5wYjI0OU1GMWRiSG8wQUhFQUFBQUZNd0FB
OHhSN1d6QmRQWHRpYlhBOWNIaDFBRU1nCkVCQUU4UEFzWm14aFozTTlNQ3h3WVc1ZmVBZ0E3M2s5
TUN4elkyRnNaVDB4TW4wc013RC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KLS0tLS0tLS0tLS0t
LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1fZFFQVEV5ZlgwPQo6OiBtYXAvCjo6IG1hcC8u
aW5mby5wb2QKYjY0JExTMWJXM0J2WkN4amNtVmhkR1ZrUFNJeU1ESXpMVEV3TFRFM0lEQTJPakl3
T2pBd0lpeHRiMlJwWm1sbFpEMGlNakF5TkMwdwpOeTB3TmlBeE1UbzBPRG96TmlJc2MzUnZjbVZr
UFNJeU1ESXpMVEl3TFRFM0lEQTJPakl3T2pBd0lsMWRiSG8wQUFRQUFBQURBQUFBCk1HNXBiQT09
Cjo6IG1hcC8wLm1hcApiNjQkTFMxYlczQnZaQ3hqY21WaGRHVmtQU0l5TURJekxUSXpMVEU1SURF
Mk9qSXpPakEwSWl4dGIyUnBabWxsWkQwaU1qQXlNeTAxCk5TMHpNQ0F3TkRvMU5Ub3hPQ0lzY21W
MmFYTnBiMjQ5TVRFeExITjBiM0psWkQwaU1qQXlNeTAwT0MweU55QXlNem8wT0Rvek55SmQKWFh0
c1lYbGxjajE3V3pCZFBYdGliWEE5ZFhObGNtUmhkR0VvSW1reE5pSXNNVFlzTVRZc0lqQXdNREF3
TURBd01EQXdNREF3TURBdwpNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3
TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3Ck1EQXdNREF3TURBd01EQXdNREF3
TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXcK
TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdN
REF3TURBd01EQXdNREF3TURBdwpNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdN
REF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3Ck1EQXdNREF3TURBd01EQXdN
REF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01E
QXcKTURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01E
QXdNREF3TURBd01EQXdNREF3TURBdwpNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01E
QXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3Ck1EQXdNREF3TURBd01E
QXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURB
d01EQXcKTURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURB
d01EQXdNREF3TURBd01EQXdNREF3TURBdwpNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURB
d01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3Ck1EQXdNREF3TURB
d01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3
TURBd01EQXcKTURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3
TURBd01EQXdNREF3TURBd01EQXdNREF3TURBdwpNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3
TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3Ck1EQXdNREF3
TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdN
REF3TURBd01EQXcKTURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdN
REF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBdwpNREF3TURBd01EQXdNREF3TURBd01EQXdN
REF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3Ck1EQXdN
REF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01E
QXdNREF3TURBd01EQXcKTURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01EQXdNREF3TURBd01E
QXdNREF3TURBaUtTeHdZVzVmZUQwd0xIQmhibDk1UFRBcwpjMk5oYkdVOU1TeDBhV3hsWDJnOU1U
WXNkR2xzWlY5M1BURTJmWDE5Cjo6IG1haW4ubHVhCi0tW1twb2RfZm9ybWF0PSJyYXciLGNyZWF0
ZWQ9IjIwMjMtMjMtMTkgMTY6MjM6MDQiLG1vZGlmaWVkPSIyMDIzLTQzLTAzIDIyOjQzOjAwIixy
ZXZpc2lvbj0zNjksc3RvcmVkPSIyMDIzLTAzLTI4IDAwOjAzOjI0Il1dCi0tW1sKCWRlc2t0b3Au
cDY0CgkKCWRlZmF1bHQgZGVza3RvcDogZGlzcGxheSBwYXR0ZXJuCgkoanVzdCB1c2UgdGhlbWUg
ZGF0YSAtLSBubyBzZXR0aW5ncyBvZiBvd24pCgkKXV0KCgpmdW5jdGlvbiBfaW5pdCgpCgkKCWJh
Y2sgPSB1c2VyZGF0YSgidTgiLDQ4MCwyNzApCgkKCWRyYXdfYmFjaygpCgkKZW5kCmZ1bmN0aW9u
IGRyYXdfYmFjaygpCglsb2NhbCBibXAgPSB0aGVtZSJkZXNrdG9wX3BhdHRlcm4iCgkKCWlmICh0
eXBlKGJtcCkgIT0gInVzZXJkYXRhIikgYm1wID0gdXNlcmRhdGEiW2dmeF0wMjAyNzc3N1svZ2Z4
XSIKCQoJc2V0X2RyYXdfdGFyZ2V0KGJhY2spCgktLWxvY2FsIGNjID0gc2V0dGluZ3MuY2hlY2tl
ciBhbmQgMHgxIG9yIDB4MTAwMDAKCQoJbG9jYWwgY2MgPSB0aGVtZSJkZXNrdG9wX3BhdHRlcm5f
Y2hlY2tlciIgYW5kIDB4MSBvciAweDEwMDAwCgkKCWlmIChlbnYoKS53aW5kb3dfYXR0cmlicy53
b3Jrc3BhY2UgPT0gInRvb2x0cmF5IikgdGhlbgoJCS0tIHRvIGRvOiBzZXBhcmF0ZSBzZXR0aW5n
cyBmb3IgdG9vbHRyYXk-CgkJcmVjdGZpbGwoMCwwLDQ3OSwyNjksMSkKCQlwYWwoNywyKQoJZWxz
ZQoJCXJlY3RmaWxsKDAsMCw0NzksMjY5LHRoZW1lImRlc2t0b3AwIikKCQlwYWwoNyx0aGVtZSJk
ZXNrdG9wMSIpCgllbmQKCQoJbG9jYWwgd3cgPSB0aGVtZSJkZXNrdG9wX3BhdHRlcm5fc3BhY2lu
ZyIgb3IgMAoJbG9jYWwgaGggPSB0aGVtZSJkZXNrdG9wX3BhdHRlcm5fc3BhY2luZyIgb3IgMAoJ
Cgl3dyArPSBibXA6d2lkdGgoKQoJaGggKz0gYm1wOmhlaWdodCgpCgkKCXd3ID0gbWF4KDgsIHd3
KQoJaGggPSBtYXgoOCwgaGgpCgkKCQoJZm9yIHk9LTEsMjcwL2hoIGRvCgkJZm9yIHg9LTEsNDgw
L3d3IGRvCgkJCWlmICgoMHgxMDAwMCt4K3kpJmNjID4gMCkgdGhlbgoJCQkJc3ByKGJtcCwgeCp3
dywgeSpoaCkKCQkJZW5kCgkJZW5kCgllbmQJCgkKCWNhbWVyYSgpCmVuZAoKZnVuY3Rpb24gX2Ry
YXcoKQoJCgloYXNoX3BvZCA9IHBvZHsKCQl0aGVtZSJkZXNrdG9wMCIsCgkJdGhlbWUiZGVza3Rv
cDEiLAoJCXRoZW1lImRlc2t0b3BfcGF0dGVybiIsCQkKCQl0aGVtZSJkZXNrdG9wX3BhdHRlcm5f
c3BhY2luZyIKCX0KCQoJLS0gcmVnZW5lcmF0ZSB3aGVuIHNldHRpbmdzIGNoYW5nZQoJaWYgKGhh
c2hfcG9kIH49IGxhc3RfaGFzaF9wb2QpIHRoZW4KCQlkcmF3X2JhY2soKQoJZW5kCgkKCWxhc3Rf
aGFzaF9wb2QgPSBoYXNoX3BvZAoJCgktLSBtb3N0IG9mIHRoZSB0aW1lIG9ubHkgbmVlZCB0byBi
bGl0CgktLSBsYXRlcjogY291bGQgaW1wbGVtZW50IDh4OCBmaWxsIHBhdHRlcm4gd2l0aCBmaWxs
cCAoZmFzdGVyKQoJCglibGl0KGJhY2spCgkKZW5kCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoK
Cjo6IFtlb2NdCg==
:: wallpapers/skellytown.p64
b64$cGljb3Ryb24gY2FydHJpZGdlIC8vIHd3dy5waWNvdHJvbi5uZXQKdmVyc2lvbiAyCgo6OiAu
aW5mby5wb2QKYjY0JExTMWJXM0J2WkN4amNtVmhkR1ZrUFNJeU1ESTBMVEEwTFRNd0lERTVPakE1
T2pNeklpeHRiMlJwWm1sbFpEMGlNakF5TkMwdwpOeTB3TmlBeE1UbzBPRG96TmlJc2MzUnZjbVZr
UFNJeU1ESTBMVEF6TFRBMklEQXpPalF4T2pNeklpeDNiM0pyYzNCaFkyVnpQWHQ3CmJHOWpZWFJw
YjI0OUltMWhhVzR1YkhWaEl6VXhJaXgzYjNKcmMzQmhZMlZmYVc1a1pYZzlNWDBzZTJ4dlkyRjBh
Vzl1UFNKaWIyNWwKY3k1c2RXRWpOeklpTEhkdmNtdHpjR0ZqWlY5cGJtUmxlRDB4ZlN4N2JHOWpZ
WFJwYjI0OUluQnZjMlV1YkhWaElpeDNiM0pyYzNCaApZMlZmYVc1a1pYZzlNWDBzZTJ4dlkyRjBh
Vzl1UFNKblpuZ3ZNQzVuWm5naUxIZHZjbXR6Y0dGalpWOXBibVJsZUQweWZTeDdiRzlqCllYUnBi
MjQ5SW0xaGNDOXRZWEF3TG0xaGNDSXNkMjl5YTNOd1lXTmxYMmx1WkdWNFBUTjlMSHRzYjJOaGRH
bHZiajBpYzJaNEwzTm0KZURBdWMyWjRJaXgzYjNKcmMzQmhZMlZmYVc1a1pYZzlOSDE5WFYxc2Vq
UUFCQUFBQUFNQUFBQXdibWxzCjo6IGdmeC8KOjogZ2Z4Ly5pbmZvLnBvZApiNjQkTFMxYlczQnZa
Q3hqY21WaGRHVmtQU0l5TURJMExURXdMVEExSURBM09qSTRPakl3SWl4dGIyUnBabWxsWkQwaU1q
QXlOQzB3Ck55MHdOaUF4TVRvME9Eb3pOaUlzYzNSdmNtVmtQU0l5TURJMExUSTRMVEExSURBM09q
STRPakl3SWwxZGJIbzBBQVFBQUFBREFBQUEKTUc1cGJBPT0KOjogZ2Z4LzAuZ2Z4CmI2NCRMUzFi
VzNCdlpDeGpjbVZoZEdWa1BTSXlNREkwTFRJNExUQTFJREEzT2pJNE9qSXdJaXh0YjJScFptbGxa
RDBpTWpBeU5DMHcKTXkwd05pQXdNem8wTVRvek15SXNjbVYyYVhOcGIyNDlNemsxWFYxc2VqUUFV
Z0lBQUJnMUFBRHpISHRiTUYwOWUySnRjRDF3ZUhVQQpReUFJQ0FUd0dSY2dCeEJIY0FjQUxHWnNZ
V2R6UFRBc2NHRnVYM2dJQU90NVBUQXNjMk5oYkdVOU1USjlMRHNBbnhZSEVFY2dGeUFICmdEc0FI
NThOQjBBM0VCZFFGOEE3QUI5LUJRZGdGekFYTUQwQUkzOEVCMkFYUUFkQVBRQWlmNkFIWUJkUUIy
QV9BQ1JBa0FjQUJ6NEEKRDBBQUpSWEFRQUJQVUJkUUYzTUJIeFd3UUFBZllFQUFKQ0JRRno0QUgz
QV9BQ0pmb0FkUUYzQV9BQ1loOEFNLUFBODlBQ1JQQ2dkUQpOenNBSkg4SkIzQW5NQWNnUFFBaXJ3
QUhjRWNRQnlBWDhCazdBQjZ2Z0FjZ0Z5QkhFQWZ3RmpzQUhxLUFGMUFYRURkQUItQU5Pd0FpCkFG
a0RUMkFIOEFVOUFDSUFXUU5QWUFmd0JEMEFKQkZnWWdJZm9ENEFKbjlnQjFBSEFBZVFRQUFlVllB
WFVCZFFRQUFmd0VBQUloVmcKUUFBZnNFQUFJaEp3bUFNUFBnQW9YM0FYVUFlZ1BnQWtBRHdBTC1B
RFBRQWpYemRRQi1BS093QWlqeUFITUNkd0ItQUpQUUFiWHhBUQpCUER3TXdDNG8yVkhrR2VBQndB
bkFBY0dBSzRuQUNlUVI2QUhBQWNBQUFRUFVBQVEtd01WRndBWG9FZWdSM0FIRUVjUUIxQ0g4QWhm
CkFEbHhBQmR3RnpBWGNEQUQ3M0FIVUFkd0Z5QVhnQmNnRi1BS3h3QThoQk1YUUJkZ0YwQVhZUUJm
a0FjZ0I2QmtBRHdEZXdHd041QUgKQUNlZ0p3QUhzRGNsQnktd0dDc0NoUTh6QUNCd0UwY0FSMEFY
SU1NRy14UTNBRGRnQnlBSElBZUFGd0FYa0FjUUJ4QUhvQ2ZRQjlBbgprQmNRQnhBWFlJZndJNU1B
SUE4ekFQLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t
LS0tCi05ZFFQVEV5ZlgwPQo6OiBtYXAvCjo6IG1hcC8uaW5mby5wb2QKYjY0JExTMWJXM0J2WkN4
amNtVmhkR1ZrUFNJeU1ESTBMVEV3TFRBMUlEQTNPakk0T2pJd0lpeHRiMlJwWm1sbFpEMGlNakF5
TkMwdwpOeTB3TmlBeE1UbzBPRG96TmlJc2MzUnZjbVZrUFNJeU1ESTBMVEk0TFRBMUlEQTNPakk0
T2pJd0lsMWRiSG8wQUFRQUFBQURBQUFBCk1HNXBiQT09Cjo6IG1hcC8wLm1hcApiNjQkTFMxYlcz
QnZaQ3hqY21WaGRHVmtQU0l5TURJekxUVTBMVEF6SURBME9qVTBPakkzSWl4dGIyUnBabWxsWkQw
aU1qQXlNeTAxCk9DMHdNeUF3TkRvMU9Eb3dNU0lzY21WMmFYTnBiMjQ5TXpWZFhXeDZOQUJwQUFB
QW93Z0FBUEFUZTJ4aGVXVnlQWHRiTUYwOWUySnQKY0QxMWMyVnlaR0YwWVNnaWFURTJJaXd4TmdN
QUx5SXdBUUQtLS0tdm9TSXBMSEJoYmw5NFBUQUlBUElHZVQwd0xITmpZV3hsUFRFcwpkR2xzWlY5
b1BURTJDZ0J2ZHoweE5uMHNTd1QtLS0tLU9GQXhObjE5ZlE9PQo6OiBtYXAvbWFwMC5tYXAKYjY0
JExTMWJXM0J2WkN4amNtVmhkR1ZrUFNJeU1ESTBMVEk0TFRBMUlEQTNPakk0T2pJd0lpeHRiMlJw
Wm1sbFpEMGlNakF5TkMwdwpNeTB3TmlBd016bzBNVG96TXlJc2NtVjJhWE5wYjI0OU16WTNYVjFz
ZWpRQVhRQUFBRmdFQUFEd0UzdHNZWGxsY2oxN1d6QmRQWHRpCmJYQTlkWE5sY21SaGRHRW9JbWt4
TmlJc01UWURBQzhpTUFFQS0tLS03NkVpS1N4d1lXNWZlRDB3Q0FEeUJuazlNQ3h6WTJGc1pUMHgK
TEhScGJHVmZhRDB4TmdvQWNIYzlNVFo5ZlgwPQo6OiBzZngvCjo6IHNmeC8uaW5mby5wb2QKYjY0
JExTMWJXM0J2WkN4amNtVmhkR1ZrUFNJeU1ESTBMVEV3TFRBMUlEQTNPakk0T2pJd0lpeHRiMlJw
Wm1sbFpEMGlNakF5TkMwdwpOeTB3TmlBeE1UbzBPRG96TmlJc2MzUnZjbVZrUFNJeU1ESTBMVEk0
TFRBMUlEQTNPakk0T2pJd0lsMWRiSG8wQUFRQUFBQURBQUFBCk1HNXBiQT09Cjo6IHNmeC8wLnNm
eApiNjQkTFMxYlczQnZaQ3hqY21WaGRHVmtQU0l5TURJekxUVTBMVEF6SURBME9qVTBPakkzSWl4
dGIyUnBabWxsWkQwaU1qQXlNeTAxCk55MHdNeUF3TkRvMU56bzBNaUlzY21WMmFYTnBiMjQ5TXpS
ZFhXeDZOQUJ2QUFBQTdRWUFBTjl3ZUhVQUF5Z0FBQU1BQlBELUFRRHMKLXlmeEFSQUdEeUFRQVNB
QklBSHdBQUlRQWc0UUFTQVBJU0FCTUE5QThNTVBLQS0tOE1ZUF9Bb1Atd19BRC1jUERRSHdDUUVR
Qmc0dwpBUDg1SC04QkFOelBfQTlBQUE4UVFQLS1zUEJ3Q3dELS02TWYtd0VBbDFELS0tLS1Idz09
Cjo6IHNmeC9zZngwLnNmeApiNjQkTFMxYlczQnZaQ3hqY21WaGRHVmtQU0l5TURJMExUSTRMVEEx
SURBM09qSTRPakl3SWl4dGIyUnBabWxsWkQwaU1qQXlOQzB3Ck15MHdOaUF3TXpvME1Ub3pNeUlz
Y21WMmFYTnBiMjQ5TXpZeVhWMXNlalFBRUFFQUFGRUhBQUR3SjNCNGRRQURLQUFBQXdBRUQwQVEK
QWc0QUFhQUJJQUtnRGdBUEVBQU44TW9CQWdNRUJRWUhBUS0ta0FnSkNnc1BEQThORHc0UER4QUE4
QUFORHhFUEVnOFREeFFQRlE4VwpEeGNUQVBFQkR4Z1BHUThhRHhzUEhBOGREeDRQSHhRQThRQWdE
eUVQSWc4akR5UVBKUThtRHljVUFQRUFLQThwRHlvUEt3OHNEeTBQCkxnOHZGQUR4QURBUE1ROHlE
ek1QTkE4MUR6WVBOeFFBLXdVNER6a1BPZzg3RHp3UFBROF9EejhCRC0tdy13RUE2LThuV2dFUUJn
OGcKRUFFZ0FTQUI4QUFDRUFJTUVBRWdEeUVnQVRBUFFQREREeWdQLS1ER0QtZ0tELThQZ0EtM0R3
MEI4QWtCRUFZTU1BRC1PUi0tQVFEYwp2LWdQUUFBTlFQLS1zUEJ3Q2dELS0yUWYtd0VBbDFELS0t
LS1Idz09Cjo6IGJvbmVzLmx1YQotLVtbcG9kX2Zvcm1hdD0icmF3IixjcmVhdGVkPSIyMDI0LTMy
LTA1IDA3OjMyOjM4Iixtb2RpZmllZD0iMjAyNC0wMy0wNiAwMzo0MTozMyIscmV2aXNpb249NDE3
XV0KLS1bWwoKCQoKXV0KCmZ1bmN0aW9uIGJvbmUoeCx5LGEpCiBsb2NhbCBsID03CiBsb2NhbCBi
PTY2CiAKIGErPTEvMjgKIGElPTEKIGxvY2FsIHE9IGZscihhKjQpIC0tIDAuLjMgLS0gd2hpY2gg
Z3JvdXAgb2YgNwogbG9jYWwgb2ZzPXtbMF09CiAgMSw1LCA1LDUsIDUsMSwgMSwxCiB9CiAKIC0t
bGluZSh4LHkseCtjb3MoYSkqbCx5K3NpbihhKSpsLCAxNCkKCiBsb2NhbCBpPWZscigoYSUwLjI1
KSoyOCkKIGIgPSBmbHIoYSoyOCkKIHgtPW9mc1txKjIrMF0KIHktPW9mc1txKjIrMV0KCiBzcHIo
Yix4LHkpCiAKZW5kCgoKZnVuY3Rpb24gZHJhd19za2VsbHkocykKCglsb2NhbCBhPXMucG9zZQoJ
bG9jYWwgc3g9MAoJbG9jYWwgc3k9MAoJbG9jYWwgeCx5Cglsb2NhbCBsPTcKCWxvY2FsIGxsPTgg
LS0gbGVnIGxlbmd0aAoKCXBkYXQ9e1swXT0KCQl7NywtNiw3fSwKCQl7LTgsLTYsN30sCgkJezMs
Niw4fSwKCQl7LTQsNiw4fQoJfQoKCS0tY2lyY2ZpbGwocy54LCBzLnksIDIsOCkKCQoJLS0gY2Fs
YyBsb3dlc3QgZm9vdAoKCWx4ID0gMAoJbHkgPSBzeSArIDEwIC0tIGhpcCBib25lCglsaSA9IDAK
CWZvciBpPTIsMyBkbwoJCWxvY2FsIGQ9cGRhdFtpXQoJCWxvY2FsIHg9c3grZFsxXSAKCQlsb2Nh
bCB5PXN5K2RbMl0rMCAtLSBoaXAKCgkJeCs9Y29zKGFbaSoyXSkqZFszXSAKCQl5Kz1zaW4oYVtp
KjJdKSpkWzNdCgkJeCs9Y29zKGFbaSoyKzFdKSpkWzNdIAoJCXkrPXNpbihhW2kqMisxXSkqZFsz
XQoKCQlseSA9IG1heChseSx5KQoJCWlmIChpPT0yIG9yIGx5PT15KSB0aGVuCgkJCWx4PXgKCQkJ
bGk9aQoJCWVuZAoJZW5kCiAKCS0tIGFkanVzdAoJc3kgLT0gKGx5IC0gMjIpCgoKCWlmIChub3Qg
cy5sbHgpIHMubGx4PTAKCWlmIChzLmNpICE9IGxpKSB0aGVuCgkJLS0gcGxhbnQgYW5jaG9yIGZv
b3QgCgkJLS0gLmN4IG1lYW5zIGFuY2hvciByZWxhdGl2ZSB0byBzdGFydGluZyBwb3NpdGlvbiAo
bm90ICdjZW50ZXInKQoJCXMuY3ggPSBseCArIChzLmN4IC0gcy5sbHgpCgkJcy5jaSA9IGxpCgll
bmQKCSAKCXMubGx4PWx4IC0tIGxhc3QgbG93ZXN0IHgKCXN4IC09IChseCAtIHMuY3gpCglzeCAr
PSBzLngKCXN5ICs9IHMueQogCgoJLS0gYm9keQoJc3ByKDQwLHN4LTgsIHN5LTgpCgoJLS0gaGVh
ZAoJc3ByKHMuaGVhZCxzeC03K3MuaHgsc3ktMjErcy5oeSkKCgktLSBidW5ueSBoZWFkIChlYXN0
ZXIpCgktLXNwcig0MyxzeC0zK3MuaHgsc3ktMTQrcy5oeS04LDEuMjUsMikKCQoJZm9yIGk9MCwz
IGRvCgkJbG9jYWwgZD1wZGF0W2ldCgkJeD1zeCtkWzFdIHk9c3krZFsyXQoKCQlib25lKHgseSxh
W2kqMl0saSoyKzApCgoJCXgrPWNvcyhhW2kqMl0pKmRbM10gCgkJeSs9c2luKGFbaSoyXSkqZFsz
XQoKCQlpZiAoaSB_PSBzLm1pc3NpbmdfYm9uZSkgdGhlbgoJCQlib25lKHgseSxhW2kqMisxXSxp
KjIrMSkKCQllbmQKCgllbmQKCmVuZAoKCgoKOjogbWFpbi5sdWEKLS1bW3BvZF9mb3JtYXQ9InJh
dyIsY3JlYXRlZD0iMjAyNC0yOC0wNSAwNzoyODoyMCIsbW9kaWZpZWQ9IjIwMjQtMDMtMDYgMDM6
NDE6MzMiLHJldmlzaW9uPTQ4MF1dCgppbmNsdWRlImJvbmVzLmx1YSIKaW5jbHVkZSJwb3NlLmx1
YSIKCgkKCQpmdW5jdGlvbiBfaW5pdCgpCgoJc2tlbD17fQoJCglmb3IgeT0wLDQgZG8KCWZvciB4
PTAsNS0oeSUyKSBkbwoJCglsb2NhbCBzID0gYWRkKHNrZWwsewoJCWNpPS0xLGN4PTAsCgkJeD0z
NiArIHggKiA4MCArICh5JTIpKjQwLCAKCQl5PTM2ICsgeSAqIDUwLAoJCWh4PTAsIGh5PTAsCgkJ
YiA9IGRlZnBvc2UoKSwKCQluZXh0X3Q9MCwKCQl0cD17WzBdPTAsMCwwLDAsIDAsMCwwLDAsIDB9
LAoJCWhlYWQgPSAzMgoJfSkKCQoJaWYgKHJuZCgyMCk8MSkgcy5oZWFkID0gMzMgLS0gcmFyZSBo
YXQKCWlmIChybmQoMjApPDEpIHMuaGVhZCA9IDM2IC0tIGNoaXBwZWQgc2t1bGwKCWlmIChybmQo
MTApPDEpIHMubWlzc2luZ19ib25lID0gcm5kezAsMX0gLS0gbWlzc2luZyBsb3dlciBhcm0KCQoJ
aWYgKHJuZCgxMCk8MSBhbmQgZGF0ZSgpOnN1YigxLDEwKT09IjIwMjQtMDMtMDYiKSBzLmhlYWQg
PSAzNAoJCglzLnBvc2UgPSBkZWZwb3NlKDEpCglzLnRwICAgPSBtYWtlcG9zZShybmQoNSlcMSkg
LS0gdGFyZ2V0IHBvc2UKCgllbmQgCgllbmQKCQplbmQKCgpmdW5jdGlvbiBfZHJhdygpCgljbHMo
dGhlbWUiZGVza3RvcDAiKQoJCglwYWwoNyx0aGVtZSJkZXNrdG9wMSIpCglmb3IgaT0xLCNza2Vs
IGRvCgkJZHJhd19za2VsbHkoc2tlbFtpXSkKCWVuZAoJCmVuZAoKZnVuY3Rpb24gX3VwZGF0ZSgp
CgoJCglsb2NhbCBteCwgbXksIG1iID0gbW91c2UoKQoJCglmb3IgaT0xLCNza2VsIGRvCgkJbG9j
YWwgcyA9IHNrZWxbaV0KCQljaHBvc2Uocy5wb3NlLHMudHAsIDAuMykKCQkKCQlsb2NhbCBkeCA9
IG14IC0gcy54CgkJbG9jYWwgZHkgPSBteSAtIHMueQoJCQoJCWlmIChkeCpkeCtkeSpkeSA8IDQw
MCkgdGhlbgoJCQlpZiBub3Qgcy5ob3ZlciBvciAobGFzdF9tYiA9PSAwIGFuZCBtYiA_IDApIHRo
ZW4KCQkJCS0tIGNob29zZSBuZXcgcmFuZG9tIHBvc2UKCQkJCWlmIChybmQoNCkgPiAxKSB0aGVu
CgkJCQkJcy50cCAgID0gbWFrZXBvc2Uocm5kKDUpXDEpCgkJCQkJaWYgKHJuZCgyKTwxKSBmbGlw
X3Bvc2Uocy50cCkgLS0gdmFyaWF0aW9uCgkJCQllbHNlCgkJCQkJLS0gZmxpcAoJCQkJCWZsaXBf
cG9zZShzLnRwKQoJCQkJZW5kCgkJCWVuZAoJCQlzLmhvdmVyID0gdHJ1ZQoJCWVsc2UKCQkJcy5o
b3ZlciA9IGZhbHNlCgkJZW5kCgllbmQKCQoJbGFzdF9tYiA9IG1iCmVuZAoKCgoKOjogcG9zZS5s
dWEKLS1bW3BvZF9mb3JtYXQ9InJhdyIsY3JlYXRlZD0iMjAyNC00OS0wNSAwNzo0OTo1NyIsbW9k
aWZpZWQ9IjIwMjQtMDMtMDYgMDM6NDE6MzMiLHJldmlzaW9uPTMzMl1dCgoKZnVuY3Rpb24gZGVm
cG9zZSgpCglyZXR1cm4ge1swXT0KCSAgMC43LDAuOSwKCSAgLTAuMywtMC40LAoJICAwLjg1LDAu
NzUsCgkgIDAuNjUsMC43NSwKCSAgMAoJIH0KZW5kCgpmdW5jdGlvbiBtYWtlcG9zZShuKQoKIG49
ZmxyKG4pCiAKCglsb2NhbCBwZGF0PXtbMF09CgkKCSAtLSBkZWYKCSB7WzBdPQoJCSAgMC44NSww
Ljc1LAoJCSAgLTAuMywwLjc1LAoJCSAgMC44NSwwLjcsCgkJICAwLjY1LDAuNywKCQkgIDAKCQkg
fSwKCQkgCgkgLS0gMS4gYXJtcyBkb3duCgkJe1swXT0KCQkgIDAuODAsMC45MCwKCQkgIDAuNzAs
MC42MCwKCQkgIDAuOTUsMC45NSwKCQkgIDAuNTUsMC44NSwKCQkgIDAKCQkgfSwgCgkJIAoJCS0t
IDIgcnVzc2lhbgoJCS0tIChhcm1zIHdhdmUpCgkJe1swXT0KCQkgIDAuMjAsMC4zNSwKCQkgIDAu
NDUsMC42MCwKCQkgIDAuOTUsMC45NSwKCQkgIDAuNTUsMC44NSwKCQkgIDAKCQkgfSwgCgkJCgkJ
LS0gMyBzdG9tcHkKCQktLSAoYXJtcyBvcGVuIC0tIGhleSBobykKCQl7WzBdPQoJCSAgMC4wLDAu
MTUsCgkJICAwLjM1LDAuMjUsCgkJICAwLjc1LDAuNzUsCgkJICAwLjQ1LDAuNjUsCgkJICAwCgkJ
IH0sCgkJIAoJCS0tIDQgYXJtcyB1cAoJCXtbMF09CgkJICAwLjI1LDAuMzUsCgkJICAwLjI1LDAu
MTUsCgkJICAwLjc1LDAuNzUsCgkJICAwLjYsMC42LAoJCSAgMAoJCSB9LAoJCSAKCQkKCX0KCQoJ
bj1uJSgjcGRhdCsxKQoKIGxvY2FsIHA9e30KIGZvciBpPTAsOCBkbwogIHBbaV09cGRhdFtuXVtp
XQogZW5kCgoJcmV0dXJuIHAKZW5kCgoKCi0tIGNoYXNlIHBvc2UKZnVuY3Rpb24gY2hwb3NlKHAw
LHAxLHEpCiBmb3IgaT0wLDcgZG8KICBsb2NhbCBhMD1wMFtpXQogIGxvY2FsIGExPXAxW2ldCiAg
YTAlPTEgYTElPTEKICBpZiAoYWJzKGEwLWExKT4wLjUpIHRoZW4KICAgYTArPXNnbihhMS1hMCkK
ICBlbmQKICBhMD1hMCooMS1xKSthMSpxCiAgcDBbaV09YTAlMQogZW5kCiAKIC0tIGhlYWQKIHAw
WzhdPXAwWzhdKigxLXEpK3AxWzhdKnEKZW5kCgoKZnVuY3Rpb24gZmxpcF9wb3NlKHApCiBmb3Ig
aj0wLDEgZG8KICBmb3IgaT0wLDEgZG8KICAgcFtqKjQraSswXSxwW2oqNCtpKzJdPQogICBwW2oq
NCtpKzJdLHBbaio0K2krMF0KICBlbmQKIGVuZAogZm9yIGk9MCw3IGRvCiAgcFtpXT0oMC41LXBb
aV0pJTEKIGVuZAogCi0tIHBbOF0qPS0xCiBwWzhdPTB4MC5mZmZmLXBbOF0KIAplbmQKCgoKCjo6
IFtlb2NdCg==
:: [eoc]
